import {
  markdown
} from "./chunk-DRPDE4QF.js";
import {
  __awaiter,
  __generator,
  addPackageJSONIfNeeded,
  dequal,
  extractErrorDetails,
  normalizePath
} from "./chunk-Z3SMBXMB.js";
import {
  html
} from "./chunk-UBIKR5W5.js";
import {
  css
} from "./chunk-C4MAMX6I.js";
import {
  javascript
} from "./chunk-UQ3M6DPP.js";
import {
  autocompletion,
  closeBrackets,
  closeBracketsKeymap,
  completionKeymap
} from "./chunk-DTEIZH2F.js";
import {
  Annotation,
  ChangeDesc,
  ChangeSet,
  CharCategory,
  Compartment,
  Decoration,
  Direction,
  EditorSelection,
  EditorState,
  EditorView,
  Facet,
  GutterMarker,
  HighlightStyle,
  IndentContext,
  LanguageDescription,
  LanguageSupport,
  NodeProp,
  Prec,
  RangeSet,
  RangeSetBuilder,
  StateEffect,
  StateField,
  StreamLanguage,
  StyleModule,
  Text as Text2,
  Transaction,
  ViewPlugin,
  WidgetType,
  bracketMatching,
  codePointAt,
  codePointSize,
  combineConfig,
  countColumn,
  crosshairCursor,
  defaultHighlightStyle,
  drawSelection,
  dropCursor,
  findClusterBreak,
  foldGutter,
  foldKeymap,
  fromCodePoint,
  getIndentUnit,
  getIndentation,
  getPanel,
  gutter,
  highlightActiveLine,
  highlightActiveLineGutter,
  highlightSpecialChars,
  highlightTree,
  highlightingFor,
  hoverTooltip,
  indentOnInput,
  indentString,
  indentUnit,
  keymap,
  language,
  lineNumbers,
  logException,
  matchBrackets,
  rectangularSelection,
  runScopeHandlers,
  showPanel,
  showTooltip,
  syntaxHighlighting,
  syntaxTree,
  tags
} from "./chunk-NSPZCAGU.js";
import {
  require_react_dom
} from "./chunk-JBJ6LC6B.js";
import {
  require_react
} from "./chunk-ODB75UNA.js";
import {
  __commonJS,
  __export,
  __publicField,
  __toESM
} from "./chunk-DWA4UIM3.js";

// node_modules/react/cjs/react-jsx-runtime.development.js
var require_react_jsx_runtime_development = __commonJS({
  "node_modules/react/cjs/react-jsx-runtime.development.js"(exports) {
    "use strict";
    if (true) {
      (function() {
        "use strict";
        var React48 = require_react();
        var REACT_ELEMENT_TYPE = Symbol.for("react.element");
        var REACT_PORTAL_TYPE = Symbol.for("react.portal");
        var REACT_FRAGMENT_TYPE = Symbol.for("react.fragment");
        var REACT_STRICT_MODE_TYPE = Symbol.for("react.strict_mode");
        var REACT_PROFILER_TYPE = Symbol.for("react.profiler");
        var REACT_PROVIDER_TYPE = Symbol.for("react.provider");
        var REACT_CONTEXT_TYPE = Symbol.for("react.context");
        var REACT_FORWARD_REF_TYPE = Symbol.for("react.forward_ref");
        var REACT_SUSPENSE_TYPE = Symbol.for("react.suspense");
        var REACT_SUSPENSE_LIST_TYPE = Symbol.for("react.suspense_list");
        var REACT_MEMO_TYPE = Symbol.for("react.memo");
        var REACT_LAZY_TYPE = Symbol.for("react.lazy");
        var REACT_OFFSCREEN_TYPE = Symbol.for("react.offscreen");
        var MAYBE_ITERATOR_SYMBOL = Symbol.iterator;
        var FAUX_ITERATOR_SYMBOL = "@@iterator";
        function getIteratorFn(maybeIterable) {
          if (maybeIterable === null || typeof maybeIterable !== "object") {
            return null;
          }
          var maybeIterator = MAYBE_ITERATOR_SYMBOL && maybeIterable[MAYBE_ITERATOR_SYMBOL] || maybeIterable[FAUX_ITERATOR_SYMBOL];
          if (typeof maybeIterator === "function") {
            return maybeIterator;
          }
          return null;
        }
        var ReactSharedInternals = React48.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED;
        function error(format) {
          {
            {
              for (var _len2 = arguments.length, args = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {
                args[_key2 - 1] = arguments[_key2];
              }
              printWarning("error", format, args);
            }
          }
        }
        function printWarning(level, format, args) {
          {
            var ReactDebugCurrentFrame2 = ReactSharedInternals.ReactDebugCurrentFrame;
            var stack = ReactDebugCurrentFrame2.getStackAddendum();
            if (stack !== "") {
              format += "%s";
              args = args.concat([stack]);
            }
            var argsWithFormat = args.map(function(item) {
              return String(item);
            });
            argsWithFormat.unshift("Warning: " + format);
            Function.prototype.apply.call(console[level], console, argsWithFormat);
          }
        }
        var enableScopeAPI = false;
        var enableCacheElement = false;
        var enableTransitionTracing = false;
        var enableLegacyHidden = false;
        var enableDebugTracing = false;
        var REACT_MODULE_REFERENCE;
        {
          REACT_MODULE_REFERENCE = Symbol.for("react.module.reference");
        }
        function isValidElementType(type2) {
          if (typeof type2 === "string" || typeof type2 === "function") {
            return true;
          }
          if (type2 === REACT_FRAGMENT_TYPE || type2 === REACT_PROFILER_TYPE || enableDebugTracing || type2 === REACT_STRICT_MODE_TYPE || type2 === REACT_SUSPENSE_TYPE || type2 === REACT_SUSPENSE_LIST_TYPE || enableLegacyHidden || type2 === REACT_OFFSCREEN_TYPE || enableScopeAPI || enableCacheElement || enableTransitionTracing) {
            return true;
          }
          if (typeof type2 === "object" && type2 !== null) {
            if (type2.$$typeof === REACT_LAZY_TYPE || type2.$$typeof === REACT_MEMO_TYPE || type2.$$typeof === REACT_PROVIDER_TYPE || type2.$$typeof === REACT_CONTEXT_TYPE || type2.$$typeof === REACT_FORWARD_REF_TYPE || // This needs to include all possible module reference object
            // types supported by any Flight configuration anywhere since
            // we don't know which Flight build this will end up being used
            // with.
            type2.$$typeof === REACT_MODULE_REFERENCE || type2.getModuleId !== void 0) {
              return true;
            }
          }
          return false;
        }
        function getWrappedName(outerType, innerType, wrapperName) {
          var displayName = outerType.displayName;
          if (displayName) {
            return displayName;
          }
          var functionName = innerType.displayName || innerType.name || "";
          return functionName !== "" ? wrapperName + "(" + functionName + ")" : wrapperName;
        }
        function getContextName(type2) {
          return type2.displayName || "Context";
        }
        function getComponentNameFromType(type2) {
          if (type2 == null) {
            return null;
          }
          {
            if (typeof type2.tag === "number") {
              error("Received an unexpected object in getComponentNameFromType(). This is likely a bug in React. Please file an issue.");
            }
          }
          if (typeof type2 === "function") {
            return type2.displayName || type2.name || null;
          }
          if (typeof type2 === "string") {
            return type2;
          }
          switch (type2) {
            case REACT_FRAGMENT_TYPE:
              return "Fragment";
            case REACT_PORTAL_TYPE:
              return "Portal";
            case REACT_PROFILER_TYPE:
              return "Profiler";
            case REACT_STRICT_MODE_TYPE:
              return "StrictMode";
            case REACT_SUSPENSE_TYPE:
              return "Suspense";
            case REACT_SUSPENSE_LIST_TYPE:
              return "SuspenseList";
          }
          if (typeof type2 === "object") {
            switch (type2.$$typeof) {
              case REACT_CONTEXT_TYPE:
                var context = type2;
                return getContextName(context) + ".Consumer";
              case REACT_PROVIDER_TYPE:
                var provider = type2;
                return getContextName(provider._context) + ".Provider";
              case REACT_FORWARD_REF_TYPE:
                return getWrappedName(type2, type2.render, "ForwardRef");
              case REACT_MEMO_TYPE:
                var outerName = type2.displayName || null;
                if (outerName !== null) {
                  return outerName;
                }
                return getComponentNameFromType(type2.type) || "Memo";
              case REACT_LAZY_TYPE: {
                var lazyComponent = type2;
                var payload = lazyComponent._payload;
                var init = lazyComponent._init;
                try {
                  return getComponentNameFromType(init(payload));
                } catch (x3) {
                  return null;
                }
              }
            }
          }
          return null;
        }
        var assign = Object.assign;
        var disabledDepth = 0;
        var prevLog;
        var prevInfo;
        var prevWarn;
        var prevError;
        var prevGroup;
        var prevGroupCollapsed;
        var prevGroupEnd;
        function disabledLog() {
        }
        disabledLog.__reactDisabledLog = true;
        function disableLogs() {
          {
            if (disabledDepth === 0) {
              prevLog = console.log;
              prevInfo = console.info;
              prevWarn = console.warn;
              prevError = console.error;
              prevGroup = console.group;
              prevGroupCollapsed = console.groupCollapsed;
              prevGroupEnd = console.groupEnd;
              var props = {
                configurable: true,
                enumerable: true,
                value: disabledLog,
                writable: true
              };
              Object.defineProperties(console, {
                info: props,
                log: props,
                warn: props,
                error: props,
                group: props,
                groupCollapsed: props,
                groupEnd: props
              });
            }
            disabledDepth++;
          }
        }
        function reenableLogs() {
          {
            disabledDepth--;
            if (disabledDepth === 0) {
              var props = {
                configurable: true,
                enumerable: true,
                writable: true
              };
              Object.defineProperties(console, {
                log: assign({}, props, {
                  value: prevLog
                }),
                info: assign({}, props, {
                  value: prevInfo
                }),
                warn: assign({}, props, {
                  value: prevWarn
                }),
                error: assign({}, props, {
                  value: prevError
                }),
                group: assign({}, props, {
                  value: prevGroup
                }),
                groupCollapsed: assign({}, props, {
                  value: prevGroupCollapsed
                }),
                groupEnd: assign({}, props, {
                  value: prevGroupEnd
                })
              });
            }
            if (disabledDepth < 0) {
              error("disabledDepth fell below zero. This is a bug in React. Please file an issue.");
            }
          }
        }
        var ReactCurrentDispatcher = ReactSharedInternals.ReactCurrentDispatcher;
        var prefix;
        function describeBuiltInComponentFrame(name2, source, ownerFn) {
          {
            if (prefix === void 0) {
              try {
                throw Error();
              } catch (x3) {
                var match = x3.stack.trim().match(/\n( *(at )?)/);
                prefix = match && match[1] || "";
              }
            }
            return "\n" + prefix + name2;
          }
        }
        var reentry = false;
        var componentFrameCache;
        {
          var PossiblyWeakMap = typeof WeakMap === "function" ? WeakMap : Map;
          componentFrameCache = new PossiblyWeakMap();
        }
        function describeNativeComponentFrame(fn, construct) {
          if (!fn || reentry) {
            return "";
          }
          {
            var frame = componentFrameCache.get(fn);
            if (frame !== void 0) {
              return frame;
            }
          }
          var control;
          reentry = true;
          var previousPrepareStackTrace = Error.prepareStackTrace;
          Error.prepareStackTrace = void 0;
          var previousDispatcher;
          {
            previousDispatcher = ReactCurrentDispatcher.current;
            ReactCurrentDispatcher.current = null;
            disableLogs();
          }
          try {
            if (construct) {
              var Fake = function() {
                throw Error();
              };
              Object.defineProperty(Fake.prototype, "props", {
                set: function() {
                  throw Error();
                }
              });
              if (typeof Reflect === "object" && Reflect.construct) {
                try {
                  Reflect.construct(Fake, []);
                } catch (x3) {
                  control = x3;
                }
                Reflect.construct(fn, [], Fake);
              } else {
                try {
                  Fake.call();
                } catch (x3) {
                  control = x3;
                }
                fn.call(Fake.prototype);
              }
            } else {
              try {
                throw Error();
              } catch (x3) {
                control = x3;
              }
              fn();
            }
          } catch (sample) {
            if (sample && control && typeof sample.stack === "string") {
              var sampleLines = sample.stack.split("\n");
              var controlLines = control.stack.split("\n");
              var s2 = sampleLines.length - 1;
              var c2 = controlLines.length - 1;
              while (s2 >= 1 && c2 >= 0 && sampleLines[s2] !== controlLines[c2]) {
                c2--;
              }
              for (; s2 >= 1 && c2 >= 0; s2--, c2--) {
                if (sampleLines[s2] !== controlLines[c2]) {
                  if (s2 !== 1 || c2 !== 1) {
                    do {
                      s2--;
                      c2--;
                      if (c2 < 0 || sampleLines[s2] !== controlLines[c2]) {
                        var _frame = "\n" + sampleLines[s2].replace(" at new ", " at ");
                        if (fn.displayName && _frame.includes("<anonymous>")) {
                          _frame = _frame.replace("<anonymous>", fn.displayName);
                        }
                        {
                          if (typeof fn === "function") {
                            componentFrameCache.set(fn, _frame);
                          }
                        }
                        return _frame;
                      }
                    } while (s2 >= 1 && c2 >= 0);
                  }
                  break;
                }
              }
            }
          } finally {
            reentry = false;
            {
              ReactCurrentDispatcher.current = previousDispatcher;
              reenableLogs();
            }
            Error.prepareStackTrace = previousPrepareStackTrace;
          }
          var name2 = fn ? fn.displayName || fn.name : "";
          var syntheticFrame = name2 ? describeBuiltInComponentFrame(name2) : "";
          {
            if (typeof fn === "function") {
              componentFrameCache.set(fn, syntheticFrame);
            }
          }
          return syntheticFrame;
        }
        function describeFunctionComponentFrame(fn, source, ownerFn) {
          {
            return describeNativeComponentFrame(fn, false);
          }
        }
        function shouldConstruct(Component3) {
          var prototype = Component3.prototype;
          return !!(prototype && prototype.isReactComponent);
        }
        function describeUnknownElementTypeFrameInDEV(type2, source, ownerFn) {
          if (type2 == null) {
            return "";
          }
          if (typeof type2 === "function") {
            {
              return describeNativeComponentFrame(type2, shouldConstruct(type2));
            }
          }
          if (typeof type2 === "string") {
            return describeBuiltInComponentFrame(type2);
          }
          switch (type2) {
            case REACT_SUSPENSE_TYPE:
              return describeBuiltInComponentFrame("Suspense");
            case REACT_SUSPENSE_LIST_TYPE:
              return describeBuiltInComponentFrame("SuspenseList");
          }
          if (typeof type2 === "object") {
            switch (type2.$$typeof) {
              case REACT_FORWARD_REF_TYPE:
                return describeFunctionComponentFrame(type2.render);
              case REACT_MEMO_TYPE:
                return describeUnknownElementTypeFrameInDEV(type2.type, source, ownerFn);
              case REACT_LAZY_TYPE: {
                var lazyComponent = type2;
                var payload = lazyComponent._payload;
                var init = lazyComponent._init;
                try {
                  return describeUnknownElementTypeFrameInDEV(init(payload), source, ownerFn);
                } catch (x3) {
                }
              }
            }
          }
          return "";
        }
        var hasOwnProperty4 = Object.prototype.hasOwnProperty;
        var loggedTypeFailures = {};
        var ReactDebugCurrentFrame = ReactSharedInternals.ReactDebugCurrentFrame;
        function setCurrentlyValidatingElement(element2) {
          {
            if (element2) {
              var owner = element2._owner;
              var stack = describeUnknownElementTypeFrameInDEV(element2.type, element2._source, owner ? owner.type : null);
              ReactDebugCurrentFrame.setExtraStackFrame(stack);
            } else {
              ReactDebugCurrentFrame.setExtraStackFrame(null);
            }
          }
        }
        function checkPropTypes(typeSpecs, values2, location2, componentName, element2) {
          {
            var has = Function.call.bind(hasOwnProperty4);
            for (var typeSpecName in typeSpecs) {
              if (has(typeSpecs, typeSpecName)) {
                var error$1 = void 0;
                try {
                  if (typeof typeSpecs[typeSpecName] !== "function") {
                    var err = Error((componentName || "React class") + ": " + location2 + " type `" + typeSpecName + "` is invalid; it must be a function, usually from the `prop-types` package, but received `" + typeof typeSpecs[typeSpecName] + "`.This often happens because of typos such as `PropTypes.function` instead of `PropTypes.func`.");
                    err.name = "Invariant Violation";
                    throw err;
                  }
                  error$1 = typeSpecs[typeSpecName](values2, typeSpecName, componentName, location2, null, "SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED");
                } catch (ex) {
                  error$1 = ex;
                }
                if (error$1 && !(error$1 instanceof Error)) {
                  setCurrentlyValidatingElement(element2);
                  error("%s: type specification of %s `%s` is invalid; the type checker function must return `null` or an `Error` but returned a %s. You may have forgotten to pass an argument to the type checker creator (arrayOf, instanceOf, objectOf, oneOf, oneOfType, and shape all require an argument).", componentName || "React class", location2, typeSpecName, typeof error$1);
                  setCurrentlyValidatingElement(null);
                }
                if (error$1 instanceof Error && !(error$1.message in loggedTypeFailures)) {
                  loggedTypeFailures[error$1.message] = true;
                  setCurrentlyValidatingElement(element2);
                  error("Failed %s type: %s", location2, error$1.message);
                  setCurrentlyValidatingElement(null);
                }
              }
            }
          }
        }
        var isArrayImpl = Array.isArray;
        function isArray2(a2) {
          return isArrayImpl(a2);
        }
        function typeName(value2) {
          {
            var hasToStringTag = typeof Symbol === "function" && Symbol.toStringTag;
            var type2 = hasToStringTag && value2[Symbol.toStringTag] || value2.constructor.name || "Object";
            return type2;
          }
        }
        function willCoercionThrow(value2) {
          {
            try {
              testStringCoercion(value2);
              return false;
            } catch (e2) {
              return true;
            }
          }
        }
        function testStringCoercion(value2) {
          return "" + value2;
        }
        function checkKeyStringCoercion(value2) {
          {
            if (willCoercionThrow(value2)) {
              error("The provided key is an unsupported type %s. This value must be coerced to a string before before using it here.", typeName(value2));
              return testStringCoercion(value2);
            }
          }
        }
        var ReactCurrentOwner = ReactSharedInternals.ReactCurrentOwner;
        var RESERVED_PROPS = {
          key: true,
          ref: true,
          __self: true,
          __source: true
        };
        var specialPropKeyWarningShown;
        var specialPropRefWarningShown;
        var didWarnAboutStringRefs;
        {
          didWarnAboutStringRefs = {};
        }
        function hasValidRef(config) {
          {
            if (hasOwnProperty4.call(config, "ref")) {
              var getter = Object.getOwnPropertyDescriptor(config, "ref").get;
              if (getter && getter.isReactWarning) {
                return false;
              }
            }
          }
          return config.ref !== void 0;
        }
        function hasValidKey(config) {
          {
            if (hasOwnProperty4.call(config, "key")) {
              var getter = Object.getOwnPropertyDescriptor(config, "key").get;
              if (getter && getter.isReactWarning) {
                return false;
              }
            }
          }
          return config.key !== void 0;
        }
        function warnIfStringRefCannotBeAutoConverted(config, self2) {
          {
            if (typeof config.ref === "string" && ReactCurrentOwner.current && self2 && ReactCurrentOwner.current.stateNode !== self2) {
              var componentName = getComponentNameFromType(ReactCurrentOwner.current.type);
              if (!didWarnAboutStringRefs[componentName]) {
                error('Component "%s" contains the string ref "%s". Support for string refs will be removed in a future major release. This case cannot be automatically converted to an arrow function. We ask you to manually fix this case by using useRef() or createRef() instead. Learn more about using refs safely here: https://reactjs.org/link/strict-mode-string-ref', getComponentNameFromType(ReactCurrentOwner.current.type), config.ref);
                didWarnAboutStringRefs[componentName] = true;
              }
            }
          }
        }
        function defineKeyPropWarningGetter(props, displayName) {
          {
            var warnAboutAccessingKey = function() {
              if (!specialPropKeyWarningShown) {
                specialPropKeyWarningShown = true;
                error("%s: `key` is not a prop. Trying to access it will result in `undefined` being returned. If you need to access the same value within the child component, you should pass it as a different prop. (https://reactjs.org/link/special-props)", displayName);
              }
            };
            warnAboutAccessingKey.isReactWarning = true;
            Object.defineProperty(props, "key", {
              get: warnAboutAccessingKey,
              configurable: true
            });
          }
        }
        function defineRefPropWarningGetter(props, displayName) {
          {
            var warnAboutAccessingRef = function() {
              if (!specialPropRefWarningShown) {
                specialPropRefWarningShown = true;
                error("%s: `ref` is not a prop. Trying to access it will result in `undefined` being returned. If you need to access the same value within the child component, you should pass it as a different prop. (https://reactjs.org/link/special-props)", displayName);
              }
            };
            warnAboutAccessingRef.isReactWarning = true;
            Object.defineProperty(props, "ref", {
              get: warnAboutAccessingRef,
              configurable: true
            });
          }
        }
        var ReactElement = function(type2, key2, ref2, self2, source, owner, props) {
          var element2 = {
            // This tag allows us to uniquely identify this as a React Element
            $$typeof: REACT_ELEMENT_TYPE,
            // Built-in properties that belong on the element
            type: type2,
            key: key2,
            ref: ref2,
            props,
            // Record the component responsible for creating this element.
            _owner: owner
          };
          {
            element2._store = {};
            Object.defineProperty(element2._store, "validated", {
              configurable: false,
              enumerable: false,
              writable: true,
              value: false
            });
            Object.defineProperty(element2, "_self", {
              configurable: false,
              enumerable: false,
              writable: false,
              value: self2
            });
            Object.defineProperty(element2, "_source", {
              configurable: false,
              enumerable: false,
              writable: false,
              value: source
            });
            if (Object.freeze) {
              Object.freeze(element2.props);
              Object.freeze(element2);
            }
          }
          return element2;
        };
        function jsxDEV(type2, config, maybeKey, source, self2) {
          {
            var propName;
            var props = {};
            var key2 = null;
            var ref2 = null;
            if (maybeKey !== void 0) {
              {
                checkKeyStringCoercion(maybeKey);
              }
              key2 = "" + maybeKey;
            }
            if (hasValidKey(config)) {
              {
                checkKeyStringCoercion(config.key);
              }
              key2 = "" + config.key;
            }
            if (hasValidRef(config)) {
              ref2 = config.ref;
              warnIfStringRefCannotBeAutoConverted(config, self2);
            }
            for (propName in config) {
              if (hasOwnProperty4.call(config, propName) && !RESERVED_PROPS.hasOwnProperty(propName)) {
                props[propName] = config[propName];
              }
            }
            if (type2 && type2.defaultProps) {
              var defaultProps2 = type2.defaultProps;
              for (propName in defaultProps2) {
                if (props[propName] === void 0) {
                  props[propName] = defaultProps2[propName];
                }
              }
            }
            if (key2 || ref2) {
              var displayName = typeof type2 === "function" ? type2.displayName || type2.name || "Unknown" : type2;
              if (key2) {
                defineKeyPropWarningGetter(props, displayName);
              }
              if (ref2) {
                defineRefPropWarningGetter(props, displayName);
              }
            }
            return ReactElement(type2, key2, ref2, self2, source, ReactCurrentOwner.current, props);
          }
        }
        var ReactCurrentOwner$1 = ReactSharedInternals.ReactCurrentOwner;
        var ReactDebugCurrentFrame$1 = ReactSharedInternals.ReactDebugCurrentFrame;
        function setCurrentlyValidatingElement$1(element2) {
          {
            if (element2) {
              var owner = element2._owner;
              var stack = describeUnknownElementTypeFrameInDEV(element2.type, element2._source, owner ? owner.type : null);
              ReactDebugCurrentFrame$1.setExtraStackFrame(stack);
            } else {
              ReactDebugCurrentFrame$1.setExtraStackFrame(null);
            }
          }
        }
        var propTypesMisspellWarningShown;
        {
          propTypesMisspellWarningShown = false;
        }
        function isValidElement3(object) {
          {
            return typeof object === "object" && object !== null && object.$$typeof === REACT_ELEMENT_TYPE;
          }
        }
        function getDeclarationErrorAddendum() {
          {
            if (ReactCurrentOwner$1.current) {
              var name2 = getComponentNameFromType(ReactCurrentOwner$1.current.type);
              if (name2) {
                return "\n\nCheck the render method of `" + name2 + "`.";
              }
            }
            return "";
          }
        }
        function getSourceInfoErrorAddendum(source) {
          {
            if (source !== void 0) {
              var fileName = source.fileName.replace(/^.*[\\\/]/, "");
              var lineNumber = source.lineNumber;
              return "\n\nCheck your code at " + fileName + ":" + lineNumber + ".";
            }
            return "";
          }
        }
        var ownerHasKeyUseWarning = {};
        function getCurrentComponentErrorInfo(parentType) {
          {
            var info = getDeclarationErrorAddendum();
            if (!info) {
              var parentName = typeof parentType === "string" ? parentType : parentType.displayName || parentType.name;
              if (parentName) {
                info = "\n\nCheck the top-level render call using <" + parentName + ">.";
              }
            }
            return info;
          }
        }
        function validateExplicitKey(element2, parentType) {
          {
            if (!element2._store || element2._store.validated || element2.key != null) {
              return;
            }
            element2._store.validated = true;
            var currentComponentErrorInfo = getCurrentComponentErrorInfo(parentType);
            if (ownerHasKeyUseWarning[currentComponentErrorInfo]) {
              return;
            }
            ownerHasKeyUseWarning[currentComponentErrorInfo] = true;
            var childOwner = "";
            if (element2 && element2._owner && element2._owner !== ReactCurrentOwner$1.current) {
              childOwner = " It was passed a child from " + getComponentNameFromType(element2._owner.type) + ".";
            }
            setCurrentlyValidatingElement$1(element2);
            error('Each child in a list should have a unique "key" prop.%s%s See https://reactjs.org/link/warning-keys for more information.', currentComponentErrorInfo, childOwner);
            setCurrentlyValidatingElement$1(null);
          }
        }
        function validateChildKeys(node2, parentType) {
          {
            if (typeof node2 !== "object") {
              return;
            }
            if (isArray2(node2)) {
              for (var i3 = 0; i3 < node2.length; i3++) {
                var child = node2[i3];
                if (isValidElement3(child)) {
                  validateExplicitKey(child, parentType);
                }
              }
            } else if (isValidElement3(node2)) {
              if (node2._store) {
                node2._store.validated = true;
              }
            } else if (node2) {
              var iteratorFn = getIteratorFn(node2);
              if (typeof iteratorFn === "function") {
                if (iteratorFn !== node2.entries) {
                  var iterator = iteratorFn.call(node2);
                  var step;
                  while (!(step = iterator.next()).done) {
                    if (isValidElement3(step.value)) {
                      validateExplicitKey(step.value, parentType);
                    }
                  }
                }
              }
            }
          }
        }
        function validatePropTypes2(element2) {
          {
            var type2 = element2.type;
            if (type2 === null || type2 === void 0 || typeof type2 === "string") {
              return;
            }
            var propTypes2;
            if (typeof type2 === "function") {
              propTypes2 = type2.propTypes;
            } else if (typeof type2 === "object" && (type2.$$typeof === REACT_FORWARD_REF_TYPE || // Note: Memo only checks outer props here.
            // Inner props are checked in the reconciler.
            type2.$$typeof === REACT_MEMO_TYPE)) {
              propTypes2 = type2.propTypes;
            } else {
              return;
            }
            if (propTypes2) {
              var name2 = getComponentNameFromType(type2);
              checkPropTypes(propTypes2, element2.props, "prop", name2, element2);
            } else if (type2.PropTypes !== void 0 && !propTypesMisspellWarningShown) {
              propTypesMisspellWarningShown = true;
              var _name = getComponentNameFromType(type2);
              error("Component %s declared `PropTypes` instead of `propTypes`. Did you misspell the property assignment?", _name || "Unknown");
            }
            if (typeof type2.getDefaultProps === "function" && !type2.getDefaultProps.isReactClassApproved) {
              error("getDefaultProps is only used on classic React.createClass definitions. Use a static property named `defaultProps` instead.");
            }
          }
        }
        function validateFragmentProps(fragment) {
          {
            var keys = Object.keys(fragment.props);
            for (var i3 = 0; i3 < keys.length; i3++) {
              var key2 = keys[i3];
              if (key2 !== "children" && key2 !== "key") {
                setCurrentlyValidatingElement$1(fragment);
                error("Invalid prop `%s` supplied to `React.Fragment`. React.Fragment can only have `key` and `children` props.", key2);
                setCurrentlyValidatingElement$1(null);
                break;
              }
            }
            if (fragment.ref !== null) {
              setCurrentlyValidatingElement$1(fragment);
              error("Invalid attribute `ref` supplied to `React.Fragment`.");
              setCurrentlyValidatingElement$1(null);
            }
          }
        }
        var didWarnAboutKeySpread = {};
        function jsxWithValidation(type2, props, key2, isStaticChildren, source, self2) {
          {
            var validType = isValidElementType(type2);
            if (!validType) {
              var info = "";
              if (type2 === void 0 || typeof type2 === "object" && type2 !== null && Object.keys(type2).length === 0) {
                info += " You likely forgot to export your component from the file it's defined in, or you might have mixed up default and named imports.";
              }
              var sourceInfo = getSourceInfoErrorAddendum(source);
              if (sourceInfo) {
                info += sourceInfo;
              } else {
                info += getDeclarationErrorAddendum();
              }
              var typeString;
              if (type2 === null) {
                typeString = "null";
              } else if (isArray2(type2)) {
                typeString = "array";
              } else if (type2 !== void 0 && type2.$$typeof === REACT_ELEMENT_TYPE) {
                typeString = "<" + (getComponentNameFromType(type2.type) || "Unknown") + " />";
                info = " Did you accidentally export a JSX literal instead of a component?";
              } else {
                typeString = typeof type2;
              }
              error("React.jsx: type is invalid -- expected a string (for built-in components) or a class/function (for composite components) but got: %s.%s", typeString, info);
            }
            var element2 = jsxDEV(type2, props, key2, source, self2);
            if (element2 == null) {
              return element2;
            }
            if (validType) {
              var children = props.children;
              if (children !== void 0) {
                if (isStaticChildren) {
                  if (isArray2(children)) {
                    for (var i3 = 0; i3 < children.length; i3++) {
                      validateChildKeys(children[i3], type2);
                    }
                    if (Object.freeze) {
                      Object.freeze(children);
                    }
                  } else {
                    error("React.jsx: Static children should always be an array. You are likely explicitly calling React.jsxs or React.jsxDEV. Use the Babel transform instead.");
                  }
                } else {
                  validateChildKeys(children, type2);
                }
              }
            }
            {
              if (hasOwnProperty4.call(props, "key")) {
                var componentName = getComponentNameFromType(type2);
                var keys = Object.keys(props).filter(function(k3) {
                  return k3 !== "key";
                });
                var beforeExample = keys.length > 0 ? "{key: someKey, " + keys.join(": ..., ") + ": ...}" : "{key: someKey}";
                if (!didWarnAboutKeySpread[componentName + beforeExample]) {
                  var afterExample = keys.length > 0 ? "{" + keys.join(": ..., ") + ": ...}" : "{}";
                  error('A props object containing a "key" prop is being spread into JSX:\n  let props = %s;\n  <%s {...props} />\nReact keys must be passed directly to JSX without using spread:\n  let props = %s;\n  <%s key={someKey} {...props} />', beforeExample, componentName, afterExample, componentName);
                  didWarnAboutKeySpread[componentName + beforeExample] = true;
                }
              }
            }
            if (type2 === REACT_FRAGMENT_TYPE) {
              validateFragmentProps(element2);
            } else {
              validatePropTypes2(element2);
            }
            return element2;
          }
        }
        function jsxWithValidationStatic(type2, props, key2) {
          {
            return jsxWithValidation(type2, props, key2, true);
          }
        }
        function jsxWithValidationDynamic(type2, props, key2) {
          {
            return jsxWithValidation(type2, props, key2, false);
          }
        }
        var jsx27 = jsxWithValidationDynamic;
        var jsxs7 = jsxWithValidationStatic;
        exports.Fragment = REACT_FRAGMENT_TYPE;
        exports.jsx = jsx27;
        exports.jsxs = jsxs7;
      })();
    }
  }
});

// node_modules/react/jsx-runtime.js
var require_jsx_runtime = __commonJS({
  "node_modules/react/jsx-runtime.js"(exports, module) {
    "use strict";
    if (false) {
      module.exports = null;
    } else {
      module.exports = require_react_jsx_runtime_development();
    }
  }
});

// node_modules/ms/index.js
var require_ms = __commonJS({
  "node_modules/ms/index.js"(exports, module) {
    var s2 = 1e3;
    var m2 = s2 * 60;
    var h2 = m2 * 60;
    var d3 = h2 * 24;
    var w3 = d3 * 7;
    var y2 = d3 * 365.25;
    module.exports = function(val, options) {
      options = options || {};
      var type2 = typeof val;
      if (type2 === "string" && val.length > 0) {
        return parse5(val);
      } else if (type2 === "number" && isFinite(val)) {
        return options.long ? fmtLong(val) : fmtShort(val);
      }
      throw new Error(
        "val is not a non-empty string or a valid number. val=" + JSON.stringify(val)
      );
    };
    function parse5(str2) {
      str2 = String(str2);
      if (str2.length > 100) {
        return;
      }
      var match = /^(-?(?:\d+)?\.?\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|weeks?|w|years?|yrs?|y)?$/i.exec(
        str2
      );
      if (!match) {
        return;
      }
      var n3 = parseFloat(match[1]);
      var type2 = (match[2] || "ms").toLowerCase();
      switch (type2) {
        case "years":
        case "year":
        case "yrs":
        case "yr":
        case "y":
          return n3 * y2;
        case "weeks":
        case "week":
        case "w":
          return n3 * w3;
        case "days":
        case "day":
        case "d":
          return n3 * d3;
        case "hours":
        case "hour":
        case "hrs":
        case "hr":
        case "h":
          return n3 * h2;
        case "minutes":
        case "minute":
        case "mins":
        case "min":
        case "m":
          return n3 * m2;
        case "seconds":
        case "second":
        case "secs":
        case "sec":
        case "s":
          return n3 * s2;
        case "milliseconds":
        case "millisecond":
        case "msecs":
        case "msec":
        case "ms":
          return n3;
        default:
          return void 0;
      }
    }
    function fmtShort(ms) {
      var msAbs = Math.abs(ms);
      if (msAbs >= d3) {
        return Math.round(ms / d3) + "d";
      }
      if (msAbs >= h2) {
        return Math.round(ms / h2) + "h";
      }
      if (msAbs >= m2) {
        return Math.round(ms / m2) + "m";
      }
      if (msAbs >= s2) {
        return Math.round(ms / s2) + "s";
      }
      return ms + "ms";
    }
    function fmtLong(ms) {
      var msAbs = Math.abs(ms);
      if (msAbs >= d3) {
        return plural(ms, msAbs, d3, "day");
      }
      if (msAbs >= h2) {
        return plural(ms, msAbs, h2, "hour");
      }
      if (msAbs >= m2) {
        return plural(ms, msAbs, m2, "minute");
      }
      if (msAbs >= s2) {
        return plural(ms, msAbs, s2, "second");
      }
      return ms + " ms";
    }
    function plural(ms, msAbs, n3, name2) {
      var isPlural = msAbs >= n3 * 1.5;
      return Math.round(ms / n3) + " " + name2 + (isPlural ? "s" : "");
    }
  }
});

// node_modules/debug/src/common.js
var require_common = __commonJS({
  "node_modules/debug/src/common.js"(exports, module) {
    function setup(env2) {
      createDebug2.debug = createDebug2;
      createDebug2.default = createDebug2;
      createDebug2.coerce = coerce;
      createDebug2.disable = disable2;
      createDebug2.enable = enable;
      createDebug2.enabled = enabled;
      createDebug2.humanize = require_ms();
      createDebug2.destroy = destroy;
      Object.keys(env2).forEach((key2) => {
        createDebug2[key2] = env2[key2];
      });
      createDebug2.names = [];
      createDebug2.skips = [];
      createDebug2.formatters = {};
      function selectColor(namespace) {
        let hash = 0;
        for (let i3 = 0; i3 < namespace.length; i3++) {
          hash = (hash << 5) - hash + namespace.charCodeAt(i3);
          hash |= 0;
        }
        return createDebug2.colors[Math.abs(hash) % createDebug2.colors.length];
      }
      createDebug2.selectColor = selectColor;
      function createDebug2(namespace) {
        let prevTime;
        let enableOverride = null;
        let namespacesCache;
        let enabledCache;
        function debug2(...args) {
          if (!debug2.enabled) {
            return;
          }
          const self2 = debug2;
          const curr = Number(/* @__PURE__ */ new Date());
          const ms = curr - (prevTime || curr);
          self2.diff = ms;
          self2.prev = prevTime;
          self2.curr = curr;
          prevTime = curr;
          args[0] = createDebug2.coerce(args[0]);
          if (typeof args[0] !== "string") {
            args.unshift("%O");
          }
          let index3 = 0;
          args[0] = args[0].replace(/%([a-zA-Z%])/g, (match, format) => {
            if (match === "%%") {
              return "%";
            }
            index3++;
            const formatter2 = createDebug2.formatters[format];
            if (typeof formatter2 === "function") {
              const val = args[index3];
              match = formatter2.call(self2, val);
              args.splice(index3, 1);
              index3--;
            }
            return match;
          });
          createDebug2.formatArgs.call(self2, args);
          const logFn = self2.log || createDebug2.log;
          logFn.apply(self2, args);
        }
        debug2.namespace = namespace;
        debug2.useColors = createDebug2.useColors();
        debug2.color = createDebug2.selectColor(namespace);
        debug2.extend = extend4;
        debug2.destroy = createDebug2.destroy;
        Object.defineProperty(debug2, "enabled", {
          enumerable: true,
          configurable: false,
          get: () => {
            if (enableOverride !== null) {
              return enableOverride;
            }
            if (namespacesCache !== createDebug2.namespaces) {
              namespacesCache = createDebug2.namespaces;
              enabledCache = createDebug2.enabled(namespace);
            }
            return enabledCache;
          },
          set: (v3) => {
            enableOverride = v3;
          }
        });
        if (typeof createDebug2.init === "function") {
          createDebug2.init(debug2);
        }
        return debug2;
      }
      function extend4(namespace, delimiter) {
        const newDebug = createDebug2(this.namespace + (typeof delimiter === "undefined" ? ":" : delimiter) + namespace);
        newDebug.log = this.log;
        return newDebug;
      }
      function enable(namespaces) {
        createDebug2.save(namespaces);
        createDebug2.namespaces = namespaces;
        createDebug2.names = [];
        createDebug2.skips = [];
        const split = (typeof namespaces === "string" ? namespaces : "").trim().replace(" ", ",").split(",").filter(Boolean);
        for (const ns of split) {
          if (ns[0] === "-") {
            createDebug2.skips.push(ns.slice(1));
          } else {
            createDebug2.names.push(ns);
          }
        }
      }
      function matchesTemplate(search2, template) {
        let searchIndex = 0;
        let templateIndex = 0;
        let starIndex = -1;
        let matchIndex = 0;
        while (searchIndex < search2.length) {
          if (templateIndex < template.length && (template[templateIndex] === search2[searchIndex] || template[templateIndex] === "*")) {
            if (template[templateIndex] === "*") {
              starIndex = templateIndex;
              matchIndex = searchIndex;
              templateIndex++;
            } else {
              searchIndex++;
              templateIndex++;
            }
          } else if (starIndex !== -1) {
            templateIndex = starIndex + 1;
            matchIndex++;
            searchIndex = matchIndex;
          } else {
            return false;
          }
        }
        while (templateIndex < template.length && template[templateIndex] === "*") {
          templateIndex++;
        }
        return templateIndex === template.length;
      }
      function disable2() {
        const namespaces = [
          ...createDebug2.names,
          ...createDebug2.skips.map((namespace) => "-" + namespace)
        ].join(",");
        createDebug2.enable("");
        return namespaces;
      }
      function enabled(name2) {
        for (const skip of createDebug2.skips) {
          if (matchesTemplate(name2, skip)) {
            return false;
          }
        }
        for (const ns of createDebug2.names) {
          if (matchesTemplate(name2, ns)) {
            return true;
          }
        }
        return false;
      }
      function coerce(val) {
        if (val instanceof Error) {
          return val.stack || val.message;
        }
        return val;
      }
      function destroy() {
        console.warn("Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.");
      }
      createDebug2.enable(createDebug2.load());
      return createDebug2;
    }
    module.exports = setup;
  }
});

// node_modules/debug/src/browser.js
var require_browser = __commonJS({
  "node_modules/debug/src/browser.js"(exports, module) {
    exports.formatArgs = formatArgs;
    exports.save = save;
    exports.load = load2;
    exports.useColors = useColors;
    exports.storage = localstorage();
    exports.destroy = /* @__PURE__ */ (() => {
      let warned = false;
      return () => {
        if (!warned) {
          warned = true;
          console.warn("Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.");
        }
      };
    })();
    exports.colors = [
      "#0000CC",
      "#0000FF",
      "#0033CC",
      "#0033FF",
      "#0066CC",
      "#0066FF",
      "#0099CC",
      "#0099FF",
      "#00CC00",
      "#00CC33",
      "#00CC66",
      "#00CC99",
      "#00CCCC",
      "#00CCFF",
      "#3300CC",
      "#3300FF",
      "#3333CC",
      "#3333FF",
      "#3366CC",
      "#3366FF",
      "#3399CC",
      "#3399FF",
      "#33CC00",
      "#33CC33",
      "#33CC66",
      "#33CC99",
      "#33CCCC",
      "#33CCFF",
      "#6600CC",
      "#6600FF",
      "#6633CC",
      "#6633FF",
      "#66CC00",
      "#66CC33",
      "#9900CC",
      "#9900FF",
      "#9933CC",
      "#9933FF",
      "#99CC00",
      "#99CC33",
      "#CC0000",
      "#CC0033",
      "#CC0066",
      "#CC0099",
      "#CC00CC",
      "#CC00FF",
      "#CC3300",
      "#CC3333",
      "#CC3366",
      "#CC3399",
      "#CC33CC",
      "#CC33FF",
      "#CC6600",
      "#CC6633",
      "#CC9900",
      "#CC9933",
      "#CCCC00",
      "#CCCC33",
      "#FF0000",
      "#FF0033",
      "#FF0066",
      "#FF0099",
      "#FF00CC",
      "#FF00FF",
      "#FF3300",
      "#FF3333",
      "#FF3366",
      "#FF3399",
      "#FF33CC",
      "#FF33FF",
      "#FF6600",
      "#FF6633",
      "#FF9900",
      "#FF9933",
      "#FFCC00",
      "#FFCC33"
    ];
    function useColors() {
      if (typeof window !== "undefined" && window.process && (window.process.type === "renderer" || window.process.__nwjs)) {
        return true;
      }
      if (typeof navigator !== "undefined" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/(edge|trident)\/(\d+)/)) {
        return false;
      }
      let m2;
      return typeof document !== "undefined" && document.documentElement && document.documentElement.style && document.documentElement.style.WebkitAppearance || // Is firebug? http://stackoverflow.com/a/398120/376773
      typeof window !== "undefined" && window.console && (window.console.firebug || window.console.exception && window.console.table) || // Is firefox >= v31?
      // https://developer.mozilla.org/en-US/docs/Tools/Web_Console#Styling_messages
      typeof navigator !== "undefined" && navigator.userAgent && (m2 = navigator.userAgent.toLowerCase().match(/firefox\/(\d+)/)) && parseInt(m2[1], 10) >= 31 || // Double check webkit in userAgent just in case we are in a worker
      typeof navigator !== "undefined" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/applewebkit\/(\d+)/);
    }
    function formatArgs(args) {
      args[0] = (this.useColors ? "%c" : "") + this.namespace + (this.useColors ? " %c" : " ") + args[0] + (this.useColors ? "%c " : " ") + "+" + module.exports.humanize(this.diff);
      if (!this.useColors) {
        return;
      }
      const c2 = "color: " + this.color;
      args.splice(1, 0, c2, "color: inherit");
      let index3 = 0;
      let lastC = 0;
      args[0].replace(/%[a-zA-Z%]/g, (match) => {
        if (match === "%%") {
          return;
        }
        index3++;
        if (match === "%c") {
          lastC = index3;
        }
      });
      args.splice(lastC, 0, c2);
    }
    exports.log = console.debug || console.log || (() => {
    });
    function save(namespaces) {
      try {
        if (namespaces) {
          exports.storage.setItem("debug", namespaces);
        } else {
          exports.storage.removeItem("debug");
        }
      } catch (error) {
      }
    }
    function load2() {
      let r2;
      try {
        r2 = exports.storage.getItem("debug");
      } catch (error) {
      }
      if (!r2 && typeof process !== "undefined" && "env" in process) {
        r2 = process.env.DEBUG;
      }
      return r2;
    }
    function localstorage() {
      try {
        return localStorage;
      } catch (error) {
      }
    }
    module.exports = require_common()(exports);
    var { formatters } = module.exports;
    formatters.j = function(v3) {
      try {
        return JSON.stringify(v3);
      } catch (error) {
        return "[UnexpectedJSONParseError]: " + error.message;
      }
    };
  }
});

// node_modules/classnames/index.js
var require_classnames = __commonJS({
  "node_modules/classnames/index.js"(exports, module) {
    (function() {
      "use strict";
      var hasOwn2 = {}.hasOwnProperty;
      function classNames14() {
        var classes = "";
        for (var i3 = 0; i3 < arguments.length; i3++) {
          var arg = arguments[i3];
          if (arg) {
            classes = appendClass(classes, parseValue(arg));
          }
        }
        return classes;
      }
      function parseValue(arg) {
        if (typeof arg === "string" || typeof arg === "number") {
          return arg;
        }
        if (typeof arg !== "object") {
          return "";
        }
        if (Array.isArray(arg)) {
          return classNames14.apply(null, arg);
        }
        if (arg.toString !== Object.prototype.toString && !arg.toString.toString().includes("[native code]")) {
          return arg.toString();
        }
        var classes = "";
        for (var key2 in arg) {
          if (hasOwn2.call(arg, key2) && arg[key2]) {
            classes = appendClass(classes, key2);
          }
        }
        return classes;
      }
      function appendClass(value2, newClass) {
        if (!newClass) {
          return value2;
        }
        if (value2) {
          return value2 + " " + newClass;
        }
        return value2 + newClass;
      }
      if (typeof module !== "undefined" && module.exports) {
        classNames14.default = classNames14;
        module.exports = classNames14;
      } else if (typeof define === "function" && typeof define.amd === "object" && define.amd) {
        define("classnames", [], function() {
          return classNames14;
        });
      } else {
        window.classNames = classNames14;
      }
    })();
  }
});

// node_modules/prop-types/node_modules/react-is/cjs/react-is.development.js
var require_react_is_development = __commonJS({
  "node_modules/prop-types/node_modules/react-is/cjs/react-is.development.js"(exports) {
    "use strict";
    if (true) {
      (function() {
        "use strict";
        var hasSymbol = typeof Symbol === "function" && Symbol.for;
        var REACT_ELEMENT_TYPE = hasSymbol ? Symbol.for("react.element") : 60103;
        var REACT_PORTAL_TYPE = hasSymbol ? Symbol.for("react.portal") : 60106;
        var REACT_FRAGMENT_TYPE = hasSymbol ? Symbol.for("react.fragment") : 60107;
        var REACT_STRICT_MODE_TYPE = hasSymbol ? Symbol.for("react.strict_mode") : 60108;
        var REACT_PROFILER_TYPE = hasSymbol ? Symbol.for("react.profiler") : 60114;
        var REACT_PROVIDER_TYPE = hasSymbol ? Symbol.for("react.provider") : 60109;
        var REACT_CONTEXT_TYPE = hasSymbol ? Symbol.for("react.context") : 60110;
        var REACT_ASYNC_MODE_TYPE = hasSymbol ? Symbol.for("react.async_mode") : 60111;
        var REACT_CONCURRENT_MODE_TYPE = hasSymbol ? Symbol.for("react.concurrent_mode") : 60111;
        var REACT_FORWARD_REF_TYPE = hasSymbol ? Symbol.for("react.forward_ref") : 60112;
        var REACT_SUSPENSE_TYPE = hasSymbol ? Symbol.for("react.suspense") : 60113;
        var REACT_SUSPENSE_LIST_TYPE = hasSymbol ? Symbol.for("react.suspense_list") : 60120;
        var REACT_MEMO_TYPE = hasSymbol ? Symbol.for("react.memo") : 60115;
        var REACT_LAZY_TYPE = hasSymbol ? Symbol.for("react.lazy") : 60116;
        var REACT_BLOCK_TYPE = hasSymbol ? Symbol.for("react.block") : 60121;
        var REACT_FUNDAMENTAL_TYPE = hasSymbol ? Symbol.for("react.fundamental") : 60117;
        var REACT_RESPONDER_TYPE = hasSymbol ? Symbol.for("react.responder") : 60118;
        var REACT_SCOPE_TYPE = hasSymbol ? Symbol.for("react.scope") : 60119;
        function isValidElementType(type2) {
          return typeof type2 === "string" || typeof type2 === "function" || // Note: its typeof might be other than 'symbol' or 'number' if it's a polyfill.
          type2 === REACT_FRAGMENT_TYPE || type2 === REACT_CONCURRENT_MODE_TYPE || type2 === REACT_PROFILER_TYPE || type2 === REACT_STRICT_MODE_TYPE || type2 === REACT_SUSPENSE_TYPE || type2 === REACT_SUSPENSE_LIST_TYPE || typeof type2 === "object" && type2 !== null && (type2.$$typeof === REACT_LAZY_TYPE || type2.$$typeof === REACT_MEMO_TYPE || type2.$$typeof === REACT_PROVIDER_TYPE || type2.$$typeof === REACT_CONTEXT_TYPE || type2.$$typeof === REACT_FORWARD_REF_TYPE || type2.$$typeof === REACT_FUNDAMENTAL_TYPE || type2.$$typeof === REACT_RESPONDER_TYPE || type2.$$typeof === REACT_SCOPE_TYPE || type2.$$typeof === REACT_BLOCK_TYPE);
        }
        function typeOf(object) {
          if (typeof object === "object" && object !== null) {
            var $$typeof = object.$$typeof;
            switch ($$typeof) {
              case REACT_ELEMENT_TYPE:
                var type2 = object.type;
                switch (type2) {
                  case REACT_ASYNC_MODE_TYPE:
                  case REACT_CONCURRENT_MODE_TYPE:
                  case REACT_FRAGMENT_TYPE:
                  case REACT_PROFILER_TYPE:
                  case REACT_STRICT_MODE_TYPE:
                  case REACT_SUSPENSE_TYPE:
                    return type2;
                  default:
                    var $$typeofType = type2 && type2.$$typeof;
                    switch ($$typeofType) {
                      case REACT_CONTEXT_TYPE:
                      case REACT_FORWARD_REF_TYPE:
                      case REACT_LAZY_TYPE:
                      case REACT_MEMO_TYPE:
                      case REACT_PROVIDER_TYPE:
                        return $$typeofType;
                      default:
                        return $$typeof;
                    }
                }
              case REACT_PORTAL_TYPE:
                return $$typeof;
            }
          }
          return void 0;
        }
        var AsyncMode = REACT_ASYNC_MODE_TYPE;
        var ConcurrentMode = REACT_CONCURRENT_MODE_TYPE;
        var ContextConsumer = REACT_CONTEXT_TYPE;
        var ContextProvider = REACT_PROVIDER_TYPE;
        var Element2 = REACT_ELEMENT_TYPE;
        var ForwardRef = REACT_FORWARD_REF_TYPE;
        var Fragment11 = REACT_FRAGMENT_TYPE;
        var Lazy = REACT_LAZY_TYPE;
        var Memo = REACT_MEMO_TYPE;
        var Portal6 = REACT_PORTAL_TYPE;
        var Profiler = REACT_PROFILER_TYPE;
        var StrictMode = REACT_STRICT_MODE_TYPE;
        var Suspense2 = REACT_SUSPENSE_TYPE;
        var hasWarnedAboutDeprecatedIsAsyncMode = false;
        function isAsyncMode(object) {
          {
            if (!hasWarnedAboutDeprecatedIsAsyncMode) {
              hasWarnedAboutDeprecatedIsAsyncMode = true;
              console["warn"]("The ReactIs.isAsyncMode() alias has been deprecated, and will be removed in React 17+. Update your code to use ReactIs.isConcurrentMode() instead. It has the exact same API.");
            }
          }
          return isConcurrentMode(object) || typeOf(object) === REACT_ASYNC_MODE_TYPE;
        }
        function isConcurrentMode(object) {
          return typeOf(object) === REACT_CONCURRENT_MODE_TYPE;
        }
        function isContextConsumer(object) {
          return typeOf(object) === REACT_CONTEXT_TYPE;
        }
        function isContextProvider(object) {
          return typeOf(object) === REACT_PROVIDER_TYPE;
        }
        function isElement2(object) {
          return typeof object === "object" && object !== null && object.$$typeof === REACT_ELEMENT_TYPE;
        }
        function isForwardRef2(object) {
          return typeOf(object) === REACT_FORWARD_REF_TYPE;
        }
        function isFragment(object) {
          return typeOf(object) === REACT_FRAGMENT_TYPE;
        }
        function isLazy(object) {
          return typeOf(object) === REACT_LAZY_TYPE;
        }
        function isMemo(object) {
          return typeOf(object) === REACT_MEMO_TYPE;
        }
        function isPortal(object) {
          return typeOf(object) === REACT_PORTAL_TYPE;
        }
        function isProfiler(object) {
          return typeOf(object) === REACT_PROFILER_TYPE;
        }
        function isStrictMode(object) {
          return typeOf(object) === REACT_STRICT_MODE_TYPE;
        }
        function isSuspense(object) {
          return typeOf(object) === REACT_SUSPENSE_TYPE;
        }
        exports.AsyncMode = AsyncMode;
        exports.ConcurrentMode = ConcurrentMode;
        exports.ContextConsumer = ContextConsumer;
        exports.ContextProvider = ContextProvider;
        exports.Element = Element2;
        exports.ForwardRef = ForwardRef;
        exports.Fragment = Fragment11;
        exports.Lazy = Lazy;
        exports.Memo = Memo;
        exports.Portal = Portal6;
        exports.Profiler = Profiler;
        exports.StrictMode = StrictMode;
        exports.Suspense = Suspense2;
        exports.isAsyncMode = isAsyncMode;
        exports.isConcurrentMode = isConcurrentMode;
        exports.isContextConsumer = isContextConsumer;
        exports.isContextProvider = isContextProvider;
        exports.isElement = isElement2;
        exports.isForwardRef = isForwardRef2;
        exports.isFragment = isFragment;
        exports.isLazy = isLazy;
        exports.isMemo = isMemo;
        exports.isPortal = isPortal;
        exports.isProfiler = isProfiler;
        exports.isStrictMode = isStrictMode;
        exports.isSuspense = isSuspense;
        exports.isValidElementType = isValidElementType;
        exports.typeOf = typeOf;
      })();
    }
  }
});

// node_modules/prop-types/node_modules/react-is/index.js
var require_react_is = __commonJS({
  "node_modules/prop-types/node_modules/react-is/index.js"(exports, module) {
    "use strict";
    if (false) {
      module.exports = null;
    } else {
      module.exports = require_react_is_development();
    }
  }
});

// node_modules/object-assign/index.js
var require_object_assign = __commonJS({
  "node_modules/object-assign/index.js"(exports, module) {
    "use strict";
    var getOwnPropertySymbols = Object.getOwnPropertySymbols;
    var hasOwnProperty4 = Object.prototype.hasOwnProperty;
    var propIsEnumerable = Object.prototype.propertyIsEnumerable;
    function toObject(val) {
      if (val === null || val === void 0) {
        throw new TypeError("Object.assign cannot be called with null or undefined");
      }
      return Object(val);
    }
    function shouldUseNative() {
      try {
        if (!Object.assign) {
          return false;
        }
        var test1 = new String("abc");
        test1[5] = "de";
        if (Object.getOwnPropertyNames(test1)[0] === "5") {
          return false;
        }
        var test2 = {};
        for (var i3 = 0; i3 < 10; i3++) {
          test2["_" + String.fromCharCode(i3)] = i3;
        }
        var order2 = Object.getOwnPropertyNames(test2).map(function(n3) {
          return test2[n3];
        });
        if (order2.join("") !== "0123456789") {
          return false;
        }
        var test3 = {};
        "abcdefghijklmnopqrst".split("").forEach(function(letter) {
          test3[letter] = letter;
        });
        if (Object.keys(Object.assign({}, test3)).join("") !== "abcdefghijklmnopqrst") {
          return false;
        }
        return true;
      } catch (err) {
        return false;
      }
    }
    module.exports = shouldUseNative() ? Object.assign : function(target, source) {
      var from;
      var to = toObject(target);
      var symbols;
      for (var s2 = 1; s2 < arguments.length; s2++) {
        from = Object(arguments[s2]);
        for (var key2 in from) {
          if (hasOwnProperty4.call(from, key2)) {
            to[key2] = from[key2];
          }
        }
        if (getOwnPropertySymbols) {
          symbols = getOwnPropertySymbols(from);
          for (var i3 = 0; i3 < symbols.length; i3++) {
            if (propIsEnumerable.call(from, symbols[i3])) {
              to[symbols[i3]] = from[symbols[i3]];
            }
          }
        }
      }
      return to;
    };
  }
});

// node_modules/prop-types/lib/ReactPropTypesSecret.js
var require_ReactPropTypesSecret = __commonJS({
  "node_modules/prop-types/lib/ReactPropTypesSecret.js"(exports, module) {
    "use strict";
    var ReactPropTypesSecret = "SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED";
    module.exports = ReactPropTypesSecret;
  }
});

// node_modules/prop-types/lib/has.js
var require_has = __commonJS({
  "node_modules/prop-types/lib/has.js"(exports, module) {
    module.exports = Function.call.bind(Object.prototype.hasOwnProperty);
  }
});

// node_modules/prop-types/checkPropTypes.js
var require_checkPropTypes = __commonJS({
  "node_modules/prop-types/checkPropTypes.js"(exports, module) {
    "use strict";
    var printWarning = function() {
    };
    if (true) {
      ReactPropTypesSecret = require_ReactPropTypesSecret();
      loggedTypeFailures = {};
      has = require_has();
      printWarning = function(text4) {
        var message = "Warning: " + text4;
        if (typeof console !== "undefined") {
          console.error(message);
        }
        try {
          throw new Error(message);
        } catch (x3) {
        }
      };
    }
    var ReactPropTypesSecret;
    var loggedTypeFailures;
    var has;
    function checkPropTypes(typeSpecs, values2, location2, componentName, getStack) {
      if (true) {
        for (var typeSpecName in typeSpecs) {
          if (has(typeSpecs, typeSpecName)) {
            var error;
            try {
              if (typeof typeSpecs[typeSpecName] !== "function") {
                var err = Error(
                  (componentName || "React class") + ": " + location2 + " type `" + typeSpecName + "` is invalid; it must be a function, usually from the `prop-types` package, but received `" + typeof typeSpecs[typeSpecName] + "`.This often happens because of typos such as `PropTypes.function` instead of `PropTypes.func`."
                );
                err.name = "Invariant Violation";
                throw err;
              }
              error = typeSpecs[typeSpecName](values2, typeSpecName, componentName, location2, null, ReactPropTypesSecret);
            } catch (ex) {
              error = ex;
            }
            if (error && !(error instanceof Error)) {
              printWarning(
                (componentName || "React class") + ": type specification of " + location2 + " `" + typeSpecName + "` is invalid; the type checker function must return `null` or an `Error` but returned a " + typeof error + ". You may have forgotten to pass an argument to the type checker creator (arrayOf, instanceOf, objectOf, oneOf, oneOfType, and shape all require an argument)."
              );
            }
            if (error instanceof Error && !(error.message in loggedTypeFailures)) {
              loggedTypeFailures[error.message] = true;
              var stack = getStack ? getStack() : "";
              printWarning(
                "Failed " + location2 + " type: " + error.message + (stack != null ? stack : "")
              );
            }
          }
        }
      }
    }
    checkPropTypes.resetWarningCache = function() {
      if (true) {
        loggedTypeFailures = {};
      }
    };
    module.exports = checkPropTypes;
  }
});

// node_modules/prop-types/factoryWithTypeCheckers.js
var require_factoryWithTypeCheckers = __commonJS({
  "node_modules/prop-types/factoryWithTypeCheckers.js"(exports, module) {
    "use strict";
    var ReactIs = require_react_is();
    var assign = require_object_assign();
    var ReactPropTypesSecret = require_ReactPropTypesSecret();
    var has = require_has();
    var checkPropTypes = require_checkPropTypes();
    var printWarning = function() {
    };
    if (true) {
      printWarning = function(text4) {
        var message = "Warning: " + text4;
        if (typeof console !== "undefined") {
          console.error(message);
        }
        try {
          throw new Error(message);
        } catch (x3) {
        }
      };
    }
    function emptyFunctionThatReturnsNull() {
      return null;
    }
    module.exports = function(isValidElement3, throwOnDirectAccess) {
      var ITERATOR_SYMBOL = typeof Symbol === "function" && Symbol.iterator;
      var FAUX_ITERATOR_SYMBOL = "@@iterator";
      function getIteratorFn(maybeIterable) {
        var iteratorFn = maybeIterable && (ITERATOR_SYMBOL && maybeIterable[ITERATOR_SYMBOL] || maybeIterable[FAUX_ITERATOR_SYMBOL]);
        if (typeof iteratorFn === "function") {
          return iteratorFn;
        }
      }
      var ANONYMOUS = "<<anonymous>>";
      var ReactPropTypes = {
        array: createPrimitiveTypeChecker("array"),
        bigint: createPrimitiveTypeChecker("bigint"),
        bool: createPrimitiveTypeChecker("boolean"),
        func: createPrimitiveTypeChecker("function"),
        number: createPrimitiveTypeChecker("number"),
        object: createPrimitiveTypeChecker("object"),
        string: createPrimitiveTypeChecker("string"),
        symbol: createPrimitiveTypeChecker("symbol"),
        any: createAnyTypeChecker(),
        arrayOf: createArrayOfTypeChecker,
        element: createElementTypeChecker(),
        elementType: createElementTypeTypeChecker(),
        instanceOf: createInstanceTypeChecker,
        node: createNodeChecker(),
        objectOf: createObjectOfTypeChecker,
        oneOf: createEnumTypeChecker,
        oneOfType: createUnionTypeChecker,
        shape: createShapeTypeChecker,
        exact: createStrictShapeTypeChecker
      };
      function is2(x3, y2) {
        if (x3 === y2) {
          return x3 !== 0 || 1 / x3 === 1 / y2;
        } else {
          return x3 !== x3 && y2 !== y2;
        }
      }
      function PropTypeError(message, data2) {
        this.message = message;
        this.data = data2 && typeof data2 === "object" ? data2 : {};
        this.stack = "";
      }
      PropTypeError.prototype = Error.prototype;
      function createChainableTypeChecker(validate) {
        if (true) {
          var manualPropTypeCallCache = {};
          var manualPropTypeWarningCount = 0;
        }
        function checkType(isRequired, props, propName, componentName, location2, propFullName, secret) {
          componentName = componentName || ANONYMOUS;
          propFullName = propFullName || propName;
          if (secret !== ReactPropTypesSecret) {
            if (throwOnDirectAccess) {
              var err = new Error(
                "Calling PropTypes validators directly is not supported by the `prop-types` package. Use `PropTypes.checkPropTypes()` to call them. Read more at http://fb.me/use-check-prop-types"
              );
              err.name = "Invariant Violation";
              throw err;
            } else if (typeof console !== "undefined") {
              var cacheKey = componentName + ":" + propName;
              if (!manualPropTypeCallCache[cacheKey] && // Avoid spamming the console because they are often not actionable except for lib authors
              manualPropTypeWarningCount < 3) {
                printWarning(
                  "You are manually calling a React.PropTypes validation function for the `" + propFullName + "` prop on `" + componentName + "`. This is deprecated and will throw in the standalone `prop-types` package. You may be seeing this warning due to a third-party PropTypes library. See https://fb.me/react-warning-dont-call-proptypes for details."
                );
                manualPropTypeCallCache[cacheKey] = true;
                manualPropTypeWarningCount++;
              }
            }
          }
          if (props[propName] == null) {
            if (isRequired) {
              if (props[propName] === null) {
                return new PropTypeError("The " + location2 + " `" + propFullName + "` is marked as required " + ("in `" + componentName + "`, but its value is `null`."));
              }
              return new PropTypeError("The " + location2 + " `" + propFullName + "` is marked as required in " + ("`" + componentName + "`, but its value is `undefined`."));
            }
            return null;
          } else {
            return validate(props, propName, componentName, location2, propFullName);
          }
        }
        var chainedCheckType = checkType.bind(null, false);
        chainedCheckType.isRequired = checkType.bind(null, true);
        return chainedCheckType;
      }
      function createPrimitiveTypeChecker(expectedType) {
        function validate(props, propName, componentName, location2, propFullName, secret) {
          var propValue = props[propName];
          var propType = getPropType(propValue);
          if (propType !== expectedType) {
            var preciseType = getPreciseType(propValue);
            return new PropTypeError(
              "Invalid " + location2 + " `" + propFullName + "` of type " + ("`" + preciseType + "` supplied to `" + componentName + "`, expected ") + ("`" + expectedType + "`."),
              { expectedType }
            );
          }
          return null;
        }
        return createChainableTypeChecker(validate);
      }
      function createAnyTypeChecker() {
        return createChainableTypeChecker(emptyFunctionThatReturnsNull);
      }
      function createArrayOfTypeChecker(typeChecker) {
        function validate(props, propName, componentName, location2, propFullName) {
          if (typeof typeChecker !== "function") {
            return new PropTypeError("Property `" + propFullName + "` of component `" + componentName + "` has invalid PropType notation inside arrayOf.");
          }
          var propValue = props[propName];
          if (!Array.isArray(propValue)) {
            var propType = getPropType(propValue);
            return new PropTypeError("Invalid " + location2 + " `" + propFullName + "` of type " + ("`" + propType + "` supplied to `" + componentName + "`, expected an array."));
          }
          for (var i3 = 0; i3 < propValue.length; i3++) {
            var error = typeChecker(propValue, i3, componentName, location2, propFullName + "[" + i3 + "]", ReactPropTypesSecret);
            if (error instanceof Error) {
              return error;
            }
          }
          return null;
        }
        return createChainableTypeChecker(validate);
      }
      function createElementTypeChecker() {
        function validate(props, propName, componentName, location2, propFullName) {
          var propValue = props[propName];
          if (!isValidElement3(propValue)) {
            var propType = getPropType(propValue);
            return new PropTypeError("Invalid " + location2 + " `" + propFullName + "` of type " + ("`" + propType + "` supplied to `" + componentName + "`, expected a single ReactElement."));
          }
          return null;
        }
        return createChainableTypeChecker(validate);
      }
      function createElementTypeTypeChecker() {
        function validate(props, propName, componentName, location2, propFullName) {
          var propValue = props[propName];
          if (!ReactIs.isValidElementType(propValue)) {
            var propType = getPropType(propValue);
            return new PropTypeError("Invalid " + location2 + " `" + propFullName + "` of type " + ("`" + propType + "` supplied to `" + componentName + "`, expected a single ReactElement type."));
          }
          return null;
        }
        return createChainableTypeChecker(validate);
      }
      function createInstanceTypeChecker(expectedClass) {
        function validate(props, propName, componentName, location2, propFullName) {
          if (!(props[propName] instanceof expectedClass)) {
            var expectedClassName = expectedClass.name || ANONYMOUS;
            var actualClassName = getClassName(props[propName]);
            return new PropTypeError("Invalid " + location2 + " `" + propFullName + "` of type " + ("`" + actualClassName + "` supplied to `" + componentName + "`, expected ") + ("instance of `" + expectedClassName + "`."));
          }
          return null;
        }
        return createChainableTypeChecker(validate);
      }
      function createEnumTypeChecker(expectedValues) {
        if (!Array.isArray(expectedValues)) {
          if (true) {
            if (arguments.length > 1) {
              printWarning(
                "Invalid arguments supplied to oneOf, expected an array, got " + arguments.length + " arguments. A common mistake is to write oneOf(x, y, z) instead of oneOf([x, y, z])."
              );
            } else {
              printWarning("Invalid argument supplied to oneOf, expected an array.");
            }
          }
          return emptyFunctionThatReturnsNull;
        }
        function validate(props, propName, componentName, location2, propFullName) {
          var propValue = props[propName];
          for (var i3 = 0; i3 < expectedValues.length; i3++) {
            if (is2(propValue, expectedValues[i3])) {
              return null;
            }
          }
          var valuesString = JSON.stringify(expectedValues, function replacer(key2, value2) {
            var type2 = getPreciseType(value2);
            if (type2 === "symbol") {
              return String(value2);
            }
            return value2;
          });
          return new PropTypeError("Invalid " + location2 + " `" + propFullName + "` of value `" + String(propValue) + "` " + ("supplied to `" + componentName + "`, expected one of " + valuesString + "."));
        }
        return createChainableTypeChecker(validate);
      }
      function createObjectOfTypeChecker(typeChecker) {
        function validate(props, propName, componentName, location2, propFullName) {
          if (typeof typeChecker !== "function") {
            return new PropTypeError("Property `" + propFullName + "` of component `" + componentName + "` has invalid PropType notation inside objectOf.");
          }
          var propValue = props[propName];
          var propType = getPropType(propValue);
          if (propType !== "object") {
            return new PropTypeError("Invalid " + location2 + " `" + propFullName + "` of type " + ("`" + propType + "` supplied to `" + componentName + "`, expected an object."));
          }
          for (var key2 in propValue) {
            if (has(propValue, key2)) {
              var error = typeChecker(propValue, key2, componentName, location2, propFullName + "." + key2, ReactPropTypesSecret);
              if (error instanceof Error) {
                return error;
              }
            }
          }
          return null;
        }
        return createChainableTypeChecker(validate);
      }
      function createUnionTypeChecker(arrayOfTypeCheckers) {
        if (!Array.isArray(arrayOfTypeCheckers)) {
          true ? printWarning("Invalid argument supplied to oneOfType, expected an instance of array.") : void 0;
          return emptyFunctionThatReturnsNull;
        }
        for (var i3 = 0; i3 < arrayOfTypeCheckers.length; i3++) {
          var checker = arrayOfTypeCheckers[i3];
          if (typeof checker !== "function") {
            printWarning(
              "Invalid argument supplied to oneOfType. Expected an array of check functions, but received " + getPostfixForTypeWarning(checker) + " at index " + i3 + "."
            );
            return emptyFunctionThatReturnsNull;
          }
        }
        function validate(props, propName, componentName, location2, propFullName) {
          var expectedTypes = [];
          for (var i4 = 0; i4 < arrayOfTypeCheckers.length; i4++) {
            var checker2 = arrayOfTypeCheckers[i4];
            var checkerResult = checker2(props, propName, componentName, location2, propFullName, ReactPropTypesSecret);
            if (checkerResult == null) {
              return null;
            }
            if (checkerResult.data && has(checkerResult.data, "expectedType")) {
              expectedTypes.push(checkerResult.data.expectedType);
            }
          }
          var expectedTypesMessage = expectedTypes.length > 0 ? ", expected one of type [" + expectedTypes.join(", ") + "]" : "";
          return new PropTypeError("Invalid " + location2 + " `" + propFullName + "` supplied to " + ("`" + componentName + "`" + expectedTypesMessage + "."));
        }
        return createChainableTypeChecker(validate);
      }
      function createNodeChecker() {
        function validate(props, propName, componentName, location2, propFullName) {
          if (!isNode3(props[propName])) {
            return new PropTypeError("Invalid " + location2 + " `" + propFullName + "` supplied to " + ("`" + componentName + "`, expected a ReactNode."));
          }
          return null;
        }
        return createChainableTypeChecker(validate);
      }
      function invalidValidatorError(componentName, location2, propFullName, key2, type2) {
        return new PropTypeError(
          (componentName || "React class") + ": " + location2 + " type `" + propFullName + "." + key2 + "` is invalid; it must be a function, usually from the `prop-types` package, but received `" + type2 + "`."
        );
      }
      function createShapeTypeChecker(shapeTypes) {
        function validate(props, propName, componentName, location2, propFullName) {
          var propValue = props[propName];
          var propType = getPropType(propValue);
          if (propType !== "object") {
            return new PropTypeError("Invalid " + location2 + " `" + propFullName + "` of type `" + propType + "` " + ("supplied to `" + componentName + "`, expected `object`."));
          }
          for (var key2 in shapeTypes) {
            var checker = shapeTypes[key2];
            if (typeof checker !== "function") {
              return invalidValidatorError(componentName, location2, propFullName, key2, getPreciseType(checker));
            }
            var error = checker(propValue, key2, componentName, location2, propFullName + "." + key2, ReactPropTypesSecret);
            if (error) {
              return error;
            }
          }
          return null;
        }
        return createChainableTypeChecker(validate);
      }
      function createStrictShapeTypeChecker(shapeTypes) {
        function validate(props, propName, componentName, location2, propFullName) {
          var propValue = props[propName];
          var propType = getPropType(propValue);
          if (propType !== "object") {
            return new PropTypeError("Invalid " + location2 + " `" + propFullName + "` of type `" + propType + "` " + ("supplied to `" + componentName + "`, expected `object`."));
          }
          var allKeys = assign({}, props[propName], shapeTypes);
          for (var key2 in allKeys) {
            var checker = shapeTypes[key2];
            if (has(shapeTypes, key2) && typeof checker !== "function") {
              return invalidValidatorError(componentName, location2, propFullName, key2, getPreciseType(checker));
            }
            if (!checker) {
              return new PropTypeError(
                "Invalid " + location2 + " `" + propFullName + "` key `" + key2 + "` supplied to `" + componentName + "`.\nBad object: " + JSON.stringify(props[propName], null, "  ") + "\nValid keys: " + JSON.stringify(Object.keys(shapeTypes), null, "  ")
              );
            }
            var error = checker(propValue, key2, componentName, location2, propFullName + "." + key2, ReactPropTypesSecret);
            if (error) {
              return error;
            }
          }
          return null;
        }
        return createChainableTypeChecker(validate);
      }
      function isNode3(propValue) {
        switch (typeof propValue) {
          case "number":
          case "string":
          case "undefined":
            return true;
          case "boolean":
            return !propValue;
          case "object":
            if (Array.isArray(propValue)) {
              return propValue.every(isNode3);
            }
            if (propValue === null || isValidElement3(propValue)) {
              return true;
            }
            var iteratorFn = getIteratorFn(propValue);
            if (iteratorFn) {
              var iterator = iteratorFn.call(propValue);
              var step;
              if (iteratorFn !== propValue.entries) {
                while (!(step = iterator.next()).done) {
                  if (!isNode3(step.value)) {
                    return false;
                  }
                }
              } else {
                while (!(step = iterator.next()).done) {
                  var entry = step.value;
                  if (entry) {
                    if (!isNode3(entry[1])) {
                      return false;
                    }
                  }
                }
              }
            } else {
              return false;
            }
            return true;
          default:
            return false;
        }
      }
      function isSymbol(propType, propValue) {
        if (propType === "symbol") {
          return true;
        }
        if (!propValue) {
          return false;
        }
        if (propValue["@@toStringTag"] === "Symbol") {
          return true;
        }
        if (typeof Symbol === "function" && propValue instanceof Symbol) {
          return true;
        }
        return false;
      }
      function getPropType(propValue) {
        var propType = typeof propValue;
        if (Array.isArray(propValue)) {
          return "array";
        }
        if (propValue instanceof RegExp) {
          return "object";
        }
        if (isSymbol(propType, propValue)) {
          return "symbol";
        }
        return propType;
      }
      function getPreciseType(propValue) {
        if (typeof propValue === "undefined" || propValue === null) {
          return "" + propValue;
        }
        var propType = getPropType(propValue);
        if (propType === "object") {
          if (propValue instanceof Date) {
            return "date";
          } else if (propValue instanceof RegExp) {
            return "regexp";
          }
        }
        return propType;
      }
      function getPostfixForTypeWarning(value2) {
        var type2 = getPreciseType(value2);
        switch (type2) {
          case "array":
          case "object":
            return "an " + type2;
          case "boolean":
          case "date":
          case "regexp":
            return "a " + type2;
          default:
            return type2;
        }
      }
      function getClassName(propValue) {
        if (!propValue.constructor || !propValue.constructor.name) {
          return ANONYMOUS;
        }
        return propValue.constructor.name;
      }
      ReactPropTypes.checkPropTypes = checkPropTypes;
      ReactPropTypes.resetWarningCache = checkPropTypes.resetWarningCache;
      ReactPropTypes.PropTypes = ReactPropTypes;
      return ReactPropTypes;
    };
  }
});

// node_modules/prop-types/index.js
var require_prop_types = __commonJS({
  "node_modules/prop-types/index.js"(exports, module) {
    if (true) {
      ReactIs = require_react_is();
      throwOnDirectAccess = true;
      module.exports = require_factoryWithTypeCheckers()(ReactIs.isElement, throwOnDirectAccess);
    } else {
      module.exports = null();
    }
    var ReactIs;
    var throwOnDirectAccess;
  }
});

// node_modules/react-is/cjs/react-is.development.js
var require_react_is_development2 = __commonJS({
  "node_modules/react-is/cjs/react-is.development.js"(exports) {
    "use strict";
    if (true) {
      (function() {
        "use strict";
        var REACT_ELEMENT_TYPE = 60103;
        var REACT_PORTAL_TYPE = 60106;
        var REACT_FRAGMENT_TYPE = 60107;
        var REACT_STRICT_MODE_TYPE = 60108;
        var REACT_PROFILER_TYPE = 60114;
        var REACT_PROVIDER_TYPE = 60109;
        var REACT_CONTEXT_TYPE = 60110;
        var REACT_FORWARD_REF_TYPE = 60112;
        var REACT_SUSPENSE_TYPE = 60113;
        var REACT_SUSPENSE_LIST_TYPE = 60120;
        var REACT_MEMO_TYPE = 60115;
        var REACT_LAZY_TYPE = 60116;
        var REACT_BLOCK_TYPE = 60121;
        var REACT_SERVER_BLOCK_TYPE = 60122;
        var REACT_FUNDAMENTAL_TYPE = 60117;
        var REACT_SCOPE_TYPE = 60119;
        var REACT_OPAQUE_ID_TYPE = 60128;
        var REACT_DEBUG_TRACING_MODE_TYPE = 60129;
        var REACT_OFFSCREEN_TYPE = 60130;
        var REACT_LEGACY_HIDDEN_TYPE = 60131;
        if (typeof Symbol === "function" && Symbol.for) {
          var symbolFor = Symbol.for;
          REACT_ELEMENT_TYPE = symbolFor("react.element");
          REACT_PORTAL_TYPE = symbolFor("react.portal");
          REACT_FRAGMENT_TYPE = symbolFor("react.fragment");
          REACT_STRICT_MODE_TYPE = symbolFor("react.strict_mode");
          REACT_PROFILER_TYPE = symbolFor("react.profiler");
          REACT_PROVIDER_TYPE = symbolFor("react.provider");
          REACT_CONTEXT_TYPE = symbolFor("react.context");
          REACT_FORWARD_REF_TYPE = symbolFor("react.forward_ref");
          REACT_SUSPENSE_TYPE = symbolFor("react.suspense");
          REACT_SUSPENSE_LIST_TYPE = symbolFor("react.suspense_list");
          REACT_MEMO_TYPE = symbolFor("react.memo");
          REACT_LAZY_TYPE = symbolFor("react.lazy");
          REACT_BLOCK_TYPE = symbolFor("react.block");
          REACT_SERVER_BLOCK_TYPE = symbolFor("react.server.block");
          REACT_FUNDAMENTAL_TYPE = symbolFor("react.fundamental");
          REACT_SCOPE_TYPE = symbolFor("react.scope");
          REACT_OPAQUE_ID_TYPE = symbolFor("react.opaque.id");
          REACT_DEBUG_TRACING_MODE_TYPE = symbolFor("react.debug_trace_mode");
          REACT_OFFSCREEN_TYPE = symbolFor("react.offscreen");
          REACT_LEGACY_HIDDEN_TYPE = symbolFor("react.legacy_hidden");
        }
        var enableScopeAPI = false;
        function isValidElementType(type2) {
          if (typeof type2 === "string" || typeof type2 === "function") {
            return true;
          }
          if (type2 === REACT_FRAGMENT_TYPE || type2 === REACT_PROFILER_TYPE || type2 === REACT_DEBUG_TRACING_MODE_TYPE || type2 === REACT_STRICT_MODE_TYPE || type2 === REACT_SUSPENSE_TYPE || type2 === REACT_SUSPENSE_LIST_TYPE || type2 === REACT_LEGACY_HIDDEN_TYPE || enableScopeAPI) {
            return true;
          }
          if (typeof type2 === "object" && type2 !== null) {
            if (type2.$$typeof === REACT_LAZY_TYPE || type2.$$typeof === REACT_MEMO_TYPE || type2.$$typeof === REACT_PROVIDER_TYPE || type2.$$typeof === REACT_CONTEXT_TYPE || type2.$$typeof === REACT_FORWARD_REF_TYPE || type2.$$typeof === REACT_FUNDAMENTAL_TYPE || type2.$$typeof === REACT_BLOCK_TYPE || type2[0] === REACT_SERVER_BLOCK_TYPE) {
              return true;
            }
          }
          return false;
        }
        function typeOf(object) {
          if (typeof object === "object" && object !== null) {
            var $$typeof = object.$$typeof;
            switch ($$typeof) {
              case REACT_ELEMENT_TYPE:
                var type2 = object.type;
                switch (type2) {
                  case REACT_FRAGMENT_TYPE:
                  case REACT_PROFILER_TYPE:
                  case REACT_STRICT_MODE_TYPE:
                  case REACT_SUSPENSE_TYPE:
                  case REACT_SUSPENSE_LIST_TYPE:
                    return type2;
                  default:
                    var $$typeofType = type2 && type2.$$typeof;
                    switch ($$typeofType) {
                      case REACT_CONTEXT_TYPE:
                      case REACT_FORWARD_REF_TYPE:
                      case REACT_LAZY_TYPE:
                      case REACT_MEMO_TYPE:
                      case REACT_PROVIDER_TYPE:
                        return $$typeofType;
                      default:
                        return $$typeof;
                    }
                }
              case REACT_PORTAL_TYPE:
                return $$typeof;
            }
          }
          return void 0;
        }
        var ContextConsumer = REACT_CONTEXT_TYPE;
        var ContextProvider = REACT_PROVIDER_TYPE;
        var Element2 = REACT_ELEMENT_TYPE;
        var ForwardRef = REACT_FORWARD_REF_TYPE;
        var Fragment11 = REACT_FRAGMENT_TYPE;
        var Lazy = REACT_LAZY_TYPE;
        var Memo = REACT_MEMO_TYPE;
        var Portal6 = REACT_PORTAL_TYPE;
        var Profiler = REACT_PROFILER_TYPE;
        var StrictMode = REACT_STRICT_MODE_TYPE;
        var Suspense2 = REACT_SUSPENSE_TYPE;
        var hasWarnedAboutDeprecatedIsAsyncMode = false;
        var hasWarnedAboutDeprecatedIsConcurrentMode = false;
        function isAsyncMode(object) {
          {
            if (!hasWarnedAboutDeprecatedIsAsyncMode) {
              hasWarnedAboutDeprecatedIsAsyncMode = true;
              console["warn"]("The ReactIs.isAsyncMode() alias has been deprecated, and will be removed in React 18+.");
            }
          }
          return false;
        }
        function isConcurrentMode(object) {
          {
            if (!hasWarnedAboutDeprecatedIsConcurrentMode) {
              hasWarnedAboutDeprecatedIsConcurrentMode = true;
              console["warn"]("The ReactIs.isConcurrentMode() alias has been deprecated, and will be removed in React 18+.");
            }
          }
          return false;
        }
        function isContextConsumer(object) {
          return typeOf(object) === REACT_CONTEXT_TYPE;
        }
        function isContextProvider(object) {
          return typeOf(object) === REACT_PROVIDER_TYPE;
        }
        function isElement2(object) {
          return typeof object === "object" && object !== null && object.$$typeof === REACT_ELEMENT_TYPE;
        }
        function isForwardRef2(object) {
          return typeOf(object) === REACT_FORWARD_REF_TYPE;
        }
        function isFragment(object) {
          return typeOf(object) === REACT_FRAGMENT_TYPE;
        }
        function isLazy(object) {
          return typeOf(object) === REACT_LAZY_TYPE;
        }
        function isMemo(object) {
          return typeOf(object) === REACT_MEMO_TYPE;
        }
        function isPortal(object) {
          return typeOf(object) === REACT_PORTAL_TYPE;
        }
        function isProfiler(object) {
          return typeOf(object) === REACT_PROFILER_TYPE;
        }
        function isStrictMode(object) {
          return typeOf(object) === REACT_STRICT_MODE_TYPE;
        }
        function isSuspense(object) {
          return typeOf(object) === REACT_SUSPENSE_TYPE;
        }
        exports.ContextConsumer = ContextConsumer;
        exports.ContextProvider = ContextProvider;
        exports.Element = Element2;
        exports.ForwardRef = ForwardRef;
        exports.Fragment = Fragment11;
        exports.Lazy = Lazy;
        exports.Memo = Memo;
        exports.Portal = Portal6;
        exports.Profiler = Profiler;
        exports.StrictMode = StrictMode;
        exports.Suspense = Suspense2;
        exports.isAsyncMode = isAsyncMode;
        exports.isConcurrentMode = isConcurrentMode;
        exports.isContextConsumer = isContextConsumer;
        exports.isContextProvider = isContextProvider;
        exports.isElement = isElement2;
        exports.isForwardRef = isForwardRef2;
        exports.isFragment = isFragment;
        exports.isLazy = isLazy;
        exports.isMemo = isMemo;
        exports.isPortal = isPortal;
        exports.isProfiler = isProfiler;
        exports.isStrictMode = isStrictMode;
        exports.isSuspense = isSuspense;
        exports.isValidElementType = isValidElementType;
        exports.typeOf = typeOf;
      })();
    }
  }
});

// node_modules/react-is/index.js
var require_react_is2 = __commonJS({
  "node_modules/react-is/index.js"(exports, module) {
    "use strict";
    if (false) {
      module.exports = null;
    } else {
      module.exports = require_react_is_development2();
    }
  }
});

// node_modules/format/format.js
var require_format = __commonJS({
  "node_modules/format/format.js"(exports, module) {
    (function() {
      var namespace;
      if (typeof module !== "undefined") {
        namespace = module.exports = format;
      } else {
        namespace = function() {
          return this || (1, eval)("this");
        }();
      }
      namespace.format = format;
      namespace.vsprintf = vsprintf;
      if (typeof console !== "undefined" && typeof console.log === "function") {
        namespace.printf = printf;
      }
      function printf() {
        console.log(format.apply(null, arguments));
      }
      function vsprintf(fmt, replacements) {
        return format.apply(null, [fmt].concat(replacements));
      }
      function format(fmt) {
        var argIndex = 1, args = [].slice.call(arguments), i3 = 0, n3 = fmt.length, result = "", c2, escaped = false, arg, tmp, leadingZero = false, precision, nextArg = function() {
          return args[argIndex++];
        }, slurpNumber = function() {
          var digits = "";
          while (/\d/.test(fmt[i3])) {
            digits += fmt[i3++];
            c2 = fmt[i3];
          }
          return digits.length > 0 ? parseInt(digits) : null;
        };
        for (; i3 < n3; ++i3) {
          c2 = fmt[i3];
          if (escaped) {
            escaped = false;
            if (c2 == ".") {
              leadingZero = false;
              c2 = fmt[++i3];
            } else if (c2 == "0" && fmt[i3 + 1] == ".") {
              leadingZero = true;
              i3 += 2;
              c2 = fmt[i3];
            } else {
              leadingZero = true;
            }
            precision = slurpNumber();
            switch (c2) {
              case "b":
                result += parseInt(nextArg(), 10).toString(2);
                break;
              case "c":
                arg = nextArg();
                if (typeof arg === "string" || arg instanceof String)
                  result += arg;
                else
                  result += String.fromCharCode(parseInt(arg, 10));
                break;
              case "d":
                result += parseInt(nextArg(), 10);
                break;
              case "f":
                tmp = String(parseFloat(nextArg()).toFixed(precision || 6));
                result += leadingZero ? tmp : tmp.replace(/^0/, "");
                break;
              case "j":
                result += JSON.stringify(nextArg());
                break;
              case "o":
                result += "0" + parseInt(nextArg(), 10).toString(8);
                break;
              case "s":
                result += nextArg();
                break;
              case "x":
                result += "0x" + parseInt(nextArg(), 10).toString(16);
                break;
              case "X":
                result += "0x" + parseInt(nextArg(), 10).toString(16).toUpperCase();
                break;
              default:
                result += c2;
                break;
            }
          } else if (c2 === "%") {
            escaped = true;
          } else {
            result += c2;
          }
        }
        return result;
      }
    })();
  }
});

// node_modules/acorn-jsx/xhtml.js
var require_xhtml = __commonJS({
  "node_modules/acorn-jsx/xhtml.js"(exports, module) {
    module.exports = {
      quot: '"',
      amp: "&",
      apos: "'",
      lt: "<",
      gt: ">",
      nbsp: " ",
      iexcl: "¡",
      cent: "¢",
      pound: "£",
      curren: "¤",
      yen: "¥",
      brvbar: "¦",
      sect: "§",
      uml: "¨",
      copy: "©",
      ordf: "ª",
      laquo: "«",
      not: "¬",
      shy: "­",
      reg: "®",
      macr: "¯",
      deg: "°",
      plusmn: "±",
      sup2: "²",
      sup3: "³",
      acute: "´",
      micro: "µ",
      para: "¶",
      middot: "·",
      cedil: "¸",
      sup1: "¹",
      ordm: "º",
      raquo: "»",
      frac14: "¼",
      frac12: "½",
      frac34: "¾",
      iquest: "¿",
      Agrave: "À",
      Aacute: "Á",
      Acirc: "Â",
      Atilde: "Ã",
      Auml: "Ä",
      Aring: "Å",
      AElig: "Æ",
      Ccedil: "Ç",
      Egrave: "È",
      Eacute: "É",
      Ecirc: "Ê",
      Euml: "Ë",
      Igrave: "Ì",
      Iacute: "Í",
      Icirc: "Î",
      Iuml: "Ï",
      ETH: "Ð",
      Ntilde: "Ñ",
      Ograve: "Ò",
      Oacute: "Ó",
      Ocirc: "Ô",
      Otilde: "Õ",
      Ouml: "Ö",
      times: "×",
      Oslash: "Ø",
      Ugrave: "Ù",
      Uacute: "Ú",
      Ucirc: "Û",
      Uuml: "Ü",
      Yacute: "Ý",
      THORN: "Þ",
      szlig: "ß",
      agrave: "à",
      aacute: "á",
      acirc: "â",
      atilde: "ã",
      auml: "ä",
      aring: "å",
      aelig: "æ",
      ccedil: "ç",
      egrave: "è",
      eacute: "é",
      ecirc: "ê",
      euml: "ë",
      igrave: "ì",
      iacute: "í",
      icirc: "î",
      iuml: "ï",
      eth: "ð",
      ntilde: "ñ",
      ograve: "ò",
      oacute: "ó",
      ocirc: "ô",
      otilde: "õ",
      ouml: "ö",
      divide: "÷",
      oslash: "ø",
      ugrave: "ù",
      uacute: "ú",
      ucirc: "û",
      uuml: "ü",
      yacute: "ý",
      thorn: "þ",
      yuml: "ÿ",
      OElig: "Œ",
      oelig: "œ",
      Scaron: "Š",
      scaron: "š",
      Yuml: "Ÿ",
      fnof: "ƒ",
      circ: "ˆ",
      tilde: "˜",
      Alpha: "Α",
      Beta: "Β",
      Gamma: "Γ",
      Delta: "Δ",
      Epsilon: "Ε",
      Zeta: "Ζ",
      Eta: "Η",
      Theta: "Θ",
      Iota: "Ι",
      Kappa: "Κ",
      Lambda: "Λ",
      Mu: "Μ",
      Nu: "Ν",
      Xi: "Ξ",
      Omicron: "Ο",
      Pi: "Π",
      Rho: "Ρ",
      Sigma: "Σ",
      Tau: "Τ",
      Upsilon: "Υ",
      Phi: "Φ",
      Chi: "Χ",
      Psi: "Ψ",
      Omega: "Ω",
      alpha: "α",
      beta: "β",
      gamma: "γ",
      delta: "δ",
      epsilon: "ε",
      zeta: "ζ",
      eta: "η",
      theta: "θ",
      iota: "ι",
      kappa: "κ",
      lambda: "λ",
      mu: "μ",
      nu: "ν",
      xi: "ξ",
      omicron: "ο",
      pi: "π",
      rho: "ρ",
      sigmaf: "ς",
      sigma: "σ",
      tau: "τ",
      upsilon: "υ",
      phi: "φ",
      chi: "χ",
      psi: "ψ",
      omega: "ω",
      thetasym: "ϑ",
      upsih: "ϒ",
      piv: "ϖ",
      ensp: " ",
      emsp: " ",
      thinsp: " ",
      zwnj: "‌",
      zwj: "‍",
      lrm: "‎",
      rlm: "‏",
      ndash: "–",
      mdash: "—",
      lsquo: "‘",
      rsquo: "’",
      sbquo: "‚",
      ldquo: "“",
      rdquo: "”",
      bdquo: "„",
      dagger: "†",
      Dagger: "‡",
      bull: "•",
      hellip: "…",
      permil: "‰",
      prime: "′",
      Prime: "″",
      lsaquo: "‹",
      rsaquo: "›",
      oline: "‾",
      frasl: "⁄",
      euro: "€",
      image: "ℑ",
      weierp: "℘",
      real: "ℜ",
      trade: "™",
      alefsym: "ℵ",
      larr: "←",
      uarr: "↑",
      rarr: "→",
      darr: "↓",
      harr: "↔",
      crarr: "↵",
      lArr: "⇐",
      uArr: "⇑",
      rArr: "⇒",
      dArr: "⇓",
      hArr: "⇔",
      forall: "∀",
      part: "∂",
      exist: "∃",
      empty: "∅",
      nabla: "∇",
      isin: "∈",
      notin: "∉",
      ni: "∋",
      prod: "∏",
      sum: "∑",
      minus: "−",
      lowast: "∗",
      radic: "√",
      prop: "∝",
      infin: "∞",
      ang: "∠",
      and: "∧",
      or: "∨",
      cap: "∩",
      cup: "∪",
      "int": "∫",
      there4: "∴",
      sim: "∼",
      cong: "≅",
      asymp: "≈",
      ne: "≠",
      equiv: "≡",
      le: "≤",
      ge: "≥",
      sub: "⊂",
      sup: "⊃",
      nsub: "⊄",
      sube: "⊆",
      supe: "⊇",
      oplus: "⊕",
      otimes: "⊗",
      perp: "⊥",
      sdot: "⋅",
      lceil: "⌈",
      rceil: "⌉",
      lfloor: "⌊",
      rfloor: "⌋",
      lang: "〈",
      rang: "〉",
      loz: "◊",
      spades: "♠",
      clubs: "♣",
      hearts: "♥",
      diams: "♦"
    };
  }
});

// node_modules/acorn/dist/acorn.js
var require_acorn = __commonJS({
  "node_modules/acorn/dist/acorn.js"(exports, module) {
    (function(global2, factory) {
      typeof exports === "object" && typeof module !== "undefined" ? factory(exports) : typeof define === "function" && define.amd ? define(["exports"], factory) : (global2 = typeof globalThis !== "undefined" ? globalThis : global2 || self, factory(global2.acorn = {}));
    })(exports, function(exports2) {
      "use strict";
      var astralIdentifierCodes2 = [509, 0, 227, 0, 150, 4, 294, 9, 1368, 2, 2, 1, 6, 3, 41, 2, 5, 0, 166, 1, 574, 3, 9, 9, 7, 9, 32, 4, 318, 1, 80, 3, 71, 10, 50, 3, 123, 2, 54, 14, 32, 10, 3, 1, 11, 3, 46, 10, 8, 0, 46, 9, 7, 2, 37, 13, 2, 9, 6, 1, 45, 0, 13, 2, 49, 13, 9, 3, 2, 11, 83, 11, 7, 0, 3, 0, 158, 11, 6, 9, 7, 3, 56, 1, 2, 6, 3, 1, 3, 2, 10, 0, 11, 1, 3, 6, 4, 4, 68, 8, 2, 0, 3, 0, 2, 3, 2, 4, 2, 0, 15, 1, 83, 17, 10, 9, 5, 0, 82, 19, 13, 9, 214, 6, 3, 8, 28, 1, 83, 16, 16, 9, 82, 12, 9, 9, 7, 19, 58, 14, 5, 9, 243, 14, 166, 9, 71, 5, 2, 1, 3, 3, 2, 0, 2, 1, 13, 9, 120, 6, 3, 6, 4, 0, 29, 9, 41, 6, 2, 3, 9, 0, 10, 10, 47, 15, 343, 9, 54, 7, 2, 7, 17, 9, 57, 21, 2, 13, 123, 5, 4, 0, 2, 1, 2, 6, 2, 0, 9, 9, 49, 4, 2, 1, 2, 4, 9, 9, 330, 3, 10, 1, 2, 0, 49, 6, 4, 4, 14, 10, 5350, 0, 7, 14, 11465, 27, 2343, 9, 87, 9, 39, 4, 60, 6, 26, 9, 535, 9, 470, 0, 2, 54, 8, 3, 82, 0, 12, 1, 19628, 1, 4178, 9, 519, 45, 3, 22, 543, 4, 4, 5, 9, 7, 3, 6, 31, 3, 149, 2, 1418, 49, 513, 54, 5, 49, 9, 0, 15, 0, 23, 4, 2, 14, 1361, 6, 2, 16, 3, 6, 2, 1, 2, 4, 101, 0, 161, 6, 10, 9, 357, 0, 62, 13, 499, 13, 245, 1, 2, 9, 726, 6, 110, 6, 6, 9, 4759, 9, 787719, 239];
      var astralIdentifierStartCodes2 = [0, 11, 2, 25, 2, 18, 2, 1, 2, 14, 3, 13, 35, 122, 70, 52, 268, 28, 4, 48, 48, 31, 14, 29, 6, 37, 11, 29, 3, 35, 5, 7, 2, 4, 43, 157, 19, 35, 5, 35, 5, 39, 9, 51, 13, 10, 2, 14, 2, 6, 2, 1, 2, 10, 2, 14, 2, 6, 2, 1, 4, 51, 13, 310, 10, 21, 11, 7, 25, 5, 2, 41, 2, 8, 70, 5, 3, 0, 2, 43, 2, 1, 4, 0, 3, 22, 11, 22, 10, 30, 66, 18, 2, 1, 11, 21, 11, 25, 71, 55, 7, 1, 65, 0, 16, 3, 2, 2, 2, 28, 43, 28, 4, 28, 36, 7, 2, 27, 28, 53, 11, 21, 11, 18, 14, 17, 111, 72, 56, 50, 14, 50, 14, 35, 39, 27, 10, 22, 251, 41, 7, 1, 17, 2, 60, 28, 11, 0, 9, 21, 43, 17, 47, 20, 28, 22, 13, 52, 58, 1, 3, 0, 14, 44, 33, 24, 27, 35, 30, 0, 3, 0, 9, 34, 4, 0, 13, 47, 15, 3, 22, 0, 2, 0, 36, 17, 2, 24, 20, 1, 64, 6, 2, 0, 2, 3, 2, 14, 2, 9, 8, 46, 39, 7, 3, 1, 3, 21, 2, 6, 2, 1, 2, 4, 4, 0, 19, 0, 13, 4, 31, 9, 2, 0, 3, 0, 2, 37, 2, 0, 26, 0, 2, 0, 45, 52, 19, 3, 21, 2, 31, 47, 21, 1, 2, 0, 185, 46, 42, 3, 37, 47, 21, 0, 60, 42, 14, 0, 72, 26, 38, 6, 186, 43, 117, 63, 32, 7, 3, 0, 3, 7, 2, 1, 2, 23, 16, 0, 2, 0, 95, 7, 3, 38, 17, 0, 2, 0, 29, 0, 11, 39, 8, 0, 22, 0, 12, 45, 20, 0, 19, 72, 200, 32, 32, 8, 2, 36, 18, 0, 50, 29, 113, 6, 2, 1, 2, 37, 22, 0, 26, 5, 2, 1, 2, 31, 15, 0, 328, 18, 16, 0, 2, 12, 2, 33, 125, 0, 80, 921, 103, 110, 18, 195, 2637, 96, 16, 1071, 18, 5, 26, 3994, 6, 582, 6842, 29, 1763, 568, 8, 30, 18, 78, 18, 29, 19, 47, 17, 3, 32, 20, 6, 18, 433, 44, 212, 63, 129, 74, 6, 0, 67, 12, 65, 1, 2, 0, 29, 6135, 9, 1237, 42, 9, 8936, 3, 2, 6, 2, 1, 2, 290, 16, 0, 30, 2, 3, 0, 15, 3, 9, 395, 2309, 106, 6, 12, 4, 8, 8, 9, 5991, 84, 2, 70, 2, 1, 3, 0, 3, 1, 3, 3, 2, 11, 2, 0, 2, 6, 2, 64, 2, 3, 3, 7, 2, 6, 2, 27, 2, 3, 2, 4, 2, 0, 4, 6, 2, 339, 3, 24, 2, 24, 2, 30, 2, 24, 2, 30, 2, 24, 2, 30, 2, 24, 2, 30, 2, 24, 2, 7, 1845, 30, 7, 5, 262, 61, 147, 44, 11, 6, 17, 0, 322, 29, 19, 43, 485, 27, 229, 29, 3, 0, 496, 6, 2, 3, 2, 1, 2, 14, 2, 196, 60, 67, 8, 0, 1205, 3, 2, 26, 2, 1, 2, 0, 3, 0, 2, 9, 2, 3, 2, 0, 2, 0, 7, 0, 5, 0, 2, 0, 2, 0, 2, 2, 2, 1, 2, 0, 3, 0, 2, 0, 2, 0, 2, 0, 2, 0, 2, 1, 2, 0, 3, 3, 2, 6, 2, 3, 2, 3, 2, 0, 2, 9, 2, 16, 6, 2, 2, 4, 2, 16, 4421, 42719, 33, 4153, 7, 221, 3, 5761, 15, 7472, 16, 621, 2467, 541, 1507, 4938, 6, 4191];
      var nonASCIIidentifierChars2 = "‌‍·̀-ͯ·҃-֑҇-ׇֽֿׁׂׅׄؐ-ًؚ-٩ٰۖ-ۜ۟-۪ۤۧۨ-ۭ۰-۹ܑܰ-݊ަ-ް߀-߉߫-߽߳ࠖ-࠙ࠛ-ࠣࠥ-ࠧࠩ-࡙࠭-࡛ࢗ-࢟࣊-ࣣ࣡-ःऺ-़ा-ॏ॑-ॗॢॣ०-९ঁ-ঃ়া-ৄেৈো-্ৗৢৣ০-৯৾ਁ-ਃ਼ਾ-ੂੇੈੋ-੍ੑ੦-ੱੵઁ-ઃ઼ા-ૅે-ૉો-્ૢૣ૦-૯ૺ-૿ଁ-ଃ଼ା-ୄେୈୋ-୍୕-ୗୢୣ୦-୯ஂா-ூெ-ைொ-்ௗ௦-௯ఀ-ఄ఼ా-ౄె-ైొ-్ౕౖౢౣ౦-౯ಁ-ಃ಼ಾ-ೄೆ-ೈೊ-್ೕೖೢೣ೦-೯ೳഀ-ഃ഻഼ാ-ൄെ-ൈൊ-്ൗൢൣ൦-൯ඁ-ඃ්ා-ුූෘ-ෟ෦-෯ෲෳัิ-ฺ็-๎๐-๙ັິ-ຼ່-໎໐-໙༘༙༠-༩༹༵༷༾༿ཱ-྄྆྇ྍ-ྗྙ-ྼ࿆ါ-ှ၀-၉ၖ-ၙၞ-ၠၢ-ၤၧ-ၭၱ-ၴႂ-ႍႏ-ႝ፝-፟፩-፱ᜒ-᜕ᜲ-᜴ᝒᝓᝲᝳ឴-៓៝០-៩᠋-᠍᠏-᠙ᢩᤠ-ᤫᤰ-᤻᥆-᥏᧐-᧚ᨗ-ᨛᩕ-ᩞ᩠-᩿᩼-᪉᪐-᪙᪰-᪽ᪿ-ᫎᬀ-ᬄ᬴-᭄᭐-᭙᭫-᭳ᮀ-ᮂᮡ-ᮭ᮰-᮹᯦-᯳ᰤ-᰷᱀-᱉᱐-᱙᳐-᳔᳒-᳨᳭᳴᳷-᳹᷀-᷿‌‍‿⁀⁔⃐-⃥⃜⃡-⃰⳯-⵿⳱ⷠ-〪ⷿ-゙゚〯・꘠-꘩꙯ꙴ-꙽ꚞꚟ꛰꛱ꠂ꠆ꠋꠣ-ꠧ꠬ꢀꢁꢴ-ꣅ꣐-꣙꣠-꣱ꣿ-꤉ꤦ-꤭ꥇ-꥓ꦀ-ꦃ꦳-꧀꧐-꧙ꧥ꧰-꧹ꨩ-ꨶꩃꩌꩍ꩐-꩙ꩻ-ꩽꪰꪲ-ꪴꪷꪸꪾ꪿꫁ꫫ-ꫯꫵ꫶ꯣ-ꯪ꯬꯭꯰-꯹ﬞ︀-️︠-︯︳︴﹍-﹏０-９＿･";
      var nonASCIIidentifierStartChars2 = "ªµºÀ-ÖØ-öø-ˁˆ-ˑˠ-ˤˬˮͰ-ʹͶͷͺ-ͽͿΆΈ-ΊΌΎ-ΡΣ-ϵϷ-ҁҊ-ԯԱ-Ֆՙՠ-ֈא-תׯ-ײؠ-يٮٯٱ-ۓەۥۦۮۯۺ-ۼۿܐܒ-ܯݍ-ޥޱߊ-ߪߴߵߺࠀ-ࠕࠚࠤࠨࡀ-ࡘࡠ-ࡪࡰ-ࢇࢉ-ࢎࢠ-ࣉऄ-हऽॐक़-ॡॱ-ঀঅ-ঌএঐও-নপ-রলশ-হঽৎড়ঢ়য়-ৡৰৱৼਅ-ਊਏਐਓ-ਨਪ-ਰਲਲ਼ਵਸ਼ਸਹਖ਼-ੜਫ਼ੲ-ੴઅ-ઍએ-ઑઓ-નપ-રલળવ-હઽૐૠૡૹଅ-ଌଏଐଓ-ନପ-ରଲଳଵ-ହଽଡ଼ଢ଼ୟ-ୡୱஃஅ-ஊஎ-ஐஒ-கஙசஜஞடணதந-பம-ஹௐఅ-ఌఎ-ఐఒ-నప-హఽౘ-ౚౝౠౡಀಅ-ಌಎ-ಐಒ-ನಪ-ಳವ-ಹಽೝೞೠೡೱೲഄ-ഌഎ-ഐഒ-ഺഽൎൔ-ൖൟ-ൡൺ-ൿඅ-ඖක-නඳ-රලව-ෆก-ะาำเ-ๆກຂຄຆ-ຊຌ-ຣລວ-ະາຳຽເ-ໄໆໜ-ໟༀཀ-ཇཉ-ཬྈ-ྌက-ဪဿၐ-ၕၚ-ၝၡၥၦၮ-ၰၵ-ႁႎႠ-ჅჇჍა-ჺჼ-ቈቊ-ቍቐ-ቖቘቚ-ቝበ-ኈኊ-ኍነ-ኰኲ-ኵኸ-ኾዀዂ-ዅወ-ዖዘ-ጐጒ-ጕጘ-ፚᎀ-ᎏᎠ-Ᏽᏸ-ᏽᐁ-ᙬᙯ-ᙿᚁ-ᚚᚠ-ᛪᛮ-ᛸᜀ-ᜑᜟ-ᜱᝀ-ᝑᝠ-ᝬᝮ-ᝰក-ឳៗៜᠠ-ᡸᢀ-ᢨᢪᢰ-ᣵᤀ-ᤞᥐ-ᥭᥰ-ᥴᦀ-ᦫᦰ-ᧉᨀ-ᨖᨠ-ᩔᪧᬅ-ᬳᭅ-ᭌᮃ-ᮠᮮᮯᮺ-ᯥᰀ-ᰣᱍ-ᱏᱚ-ᱽᲀ-ᲊᲐ-ᲺᲽ-Ჿᳩ-ᳬᳮ-ᳳᳵᳶᳺᴀ-ᶿḀ-ἕἘ-Ἕἠ-ὅὈ-Ὅὐ-ὗὙὛὝὟ-ώᾀ-ᾴᾶ-ᾼιῂ-ῄῆ-ῌῐ-ΐῖ-Ίῠ-Ῥῲ-ῴῶ-ῼⁱⁿₐ-ₜℂℇℊ-ℓℕ℘-ℝℤΩℨK-ℹℼ-ℿⅅ-ⅉⅎⅠ-ↈⰀ-ⳤⳫ-ⳮⳲⳳⴀ-ⴥⴧⴭⴰ-ⵧⵯⶀ-ⶖⶠ-ⶦⶨ-ⶮⶰ-ⶶⶸ-ⶾⷀ-ⷆⷈ-ⷎⷐ-ⷖⷘ-ⷞ々-〇〡-〩〱-〵〸-〼ぁ-ゖ゛-ゟァ-ヺー-ヿㄅ-ㄯㄱ-ㆎㆠ-ㆿㇰ-ㇿ㐀-䶿一-ꒌꓐ-ꓽꔀ-ꘌꘐ-ꘟꘪꘫꙀ-ꙮꙿ-ꚝꚠ-ꛯꜗ-ꜟꜢ-ꞈꞋ-ꟍꟐꟑꟓꟕ-Ƛꟲ-ꠁꠃ-ꠅꠇ-ꠊꠌ-ꠢꡀ-ꡳꢂ-ꢳꣲ-ꣷꣻꣽꣾꤊ-ꤥꤰ-ꥆꥠ-ꥼꦄ-ꦲꧏꧠ-ꧤꧦ-ꧯꧺ-ꧾꨀ-ꨨꩀ-ꩂꩄ-ꩋꩠ-ꩶꩺꩾ-ꪯꪱꪵꪶꪹ-ꪽꫀꫂꫛ-ꫝꫠ-ꫪꫲ-ꫴꬁ-ꬆꬉ-ꬎꬑ-ꬖꬠ-ꬦꬨ-ꬮꬰ-ꭚꭜ-ꭩꭰ-ꯢ가-힣ힰ-ퟆퟋ-ퟻ豈-舘並-龎ﬀ-ﬆﬓ-ﬗיִײַ-ﬨשׁ-זּטּ-לּמּנּסּףּפּצּ-ﮱﯓ-ﴽﵐ-ﶏﶒ-ﷇﷰ-ﷻﹰ-ﹴﹶ-ﻼＡ-Ｚａ-ｚｦ-ﾾￂ-ￇￊ-ￏￒ-ￗￚ-ￜ";
      var reservedWords2 = {
        3: "abstract boolean byte char class double enum export extends final float goto implements import int interface long native package private protected public short static super synchronized throws transient volatile",
        5: "class enum extends super const export import",
        6: "enum",
        strict: "implements interface let package private protected public static yield",
        strictBind: "eval arguments"
      };
      var ecma5AndLessKeywords2 = "break case catch continue debugger default do else finally for function if return switch throw try var while with null true false instanceof typeof void delete new in this";
      var keywords$12 = {
        5: ecma5AndLessKeywords2,
        "5module": ecma5AndLessKeywords2 + " export import",
        6: ecma5AndLessKeywords2 + " const class extends export import super"
      };
      var keywordRelationalOperator2 = /^in(stanceof)?$/;
      var nonASCIIidentifierStart2 = new RegExp("[" + nonASCIIidentifierStartChars2 + "]");
      var nonASCIIidentifier2 = new RegExp("[" + nonASCIIidentifierStartChars2 + nonASCIIidentifierChars2 + "]");
      function isInAstralSet2(code3, set3) {
        var pos = 65536;
        for (var i4 = 0; i4 < set3.length; i4 += 2) {
          pos += set3[i4];
          if (pos > code3) {
            return false;
          }
          pos += set3[i4 + 1];
          if (pos >= code3) {
            return true;
          }
        }
        return false;
      }
      function isIdentifierStart2(code3, astral) {
        if (code3 < 65) {
          return code3 === 36;
        }
        if (code3 < 91) {
          return true;
        }
        if (code3 < 97) {
          return code3 === 95;
        }
        if (code3 < 123) {
          return true;
        }
        if (code3 <= 65535) {
          return code3 >= 170 && nonASCIIidentifierStart2.test(String.fromCharCode(code3));
        }
        if (astral === false) {
          return false;
        }
        return isInAstralSet2(code3, astralIdentifierStartCodes2);
      }
      function isIdentifierChar2(code3, astral) {
        if (code3 < 48) {
          return code3 === 36;
        }
        if (code3 < 58) {
          return true;
        }
        if (code3 < 65) {
          return false;
        }
        if (code3 < 91) {
          return true;
        }
        if (code3 < 97) {
          return code3 === 95;
        }
        if (code3 < 123) {
          return true;
        }
        if (code3 <= 65535) {
          return code3 >= 170 && nonASCIIidentifier2.test(String.fromCharCode(code3));
        }
        if (astral === false) {
          return false;
        }
        return isInAstralSet2(code3, astralIdentifierStartCodes2) || isInAstralSet2(code3, astralIdentifierCodes2);
      }
      var TokenType3 = function TokenType4(label4, conf) {
        if (conf === void 0) conf = {};
        this.label = label4;
        this.keyword = conf.keyword;
        this.beforeExpr = !!conf.beforeExpr;
        this.startsExpr = !!conf.startsExpr;
        this.isLoop = !!conf.isLoop;
        this.isAssign = !!conf.isAssign;
        this.prefix = !!conf.prefix;
        this.postfix = !!conf.postfix;
        this.binop = conf.binop || null;
        this.updateContext = null;
      };
      function binop2(name2, prec) {
        return new TokenType3(name2, { beforeExpr: true, binop: prec });
      }
      var beforeExpr2 = { beforeExpr: true }, startsExpr2 = { startsExpr: true };
      var keywords2 = {};
      function kw2(name2, options) {
        if (options === void 0) options = {};
        options.keyword = name2;
        return keywords2[name2] = new TokenType3(name2, options);
      }
      var types$12 = {
        num: new TokenType3("num", startsExpr2),
        regexp: new TokenType3("regexp", startsExpr2),
        string: new TokenType3("string", startsExpr2),
        name: new TokenType3("name", startsExpr2),
        privateId: new TokenType3("privateId", startsExpr2),
        eof: new TokenType3("eof"),
        // Punctuation token types.
        bracketL: new TokenType3("[", { beforeExpr: true, startsExpr: true }),
        bracketR: new TokenType3("]"),
        braceL: new TokenType3("{", { beforeExpr: true, startsExpr: true }),
        braceR: new TokenType3("}"),
        parenL: new TokenType3("(", { beforeExpr: true, startsExpr: true }),
        parenR: new TokenType3(")"),
        comma: new TokenType3(",", beforeExpr2),
        semi: new TokenType3(";", beforeExpr2),
        colon: new TokenType3(":", beforeExpr2),
        dot: new TokenType3("."),
        question: new TokenType3("?", beforeExpr2),
        questionDot: new TokenType3("?."),
        arrow: new TokenType3("=>", beforeExpr2),
        template: new TokenType3("template"),
        invalidTemplate: new TokenType3("invalidTemplate"),
        ellipsis: new TokenType3("...", beforeExpr2),
        backQuote: new TokenType3("`", startsExpr2),
        dollarBraceL: new TokenType3("${", { beforeExpr: true, startsExpr: true }),
        // Operators. These carry several kinds of properties to help the
        // parser use them properly (the presence of these properties is
        // what categorizes them as operators).
        //
        // `binop`, when present, specifies that this operator is a binary
        // operator, and will refer to its precedence.
        //
        // `prefix` and `postfix` mark the operator as a prefix or postfix
        // unary operator.
        //
        // `isAssign` marks all of `=`, `+=`, `-=` etcetera, which act as
        // binary operators with a very low precedence, that should result
        // in AssignmentExpression nodes.
        eq: new TokenType3("=", { beforeExpr: true, isAssign: true }),
        assign: new TokenType3("_=", { beforeExpr: true, isAssign: true }),
        incDec: new TokenType3("++/--", { prefix: true, postfix: true, startsExpr: true }),
        prefix: new TokenType3("!/~", { beforeExpr: true, prefix: true, startsExpr: true }),
        logicalOR: binop2("||", 1),
        logicalAND: binop2("&&", 2),
        bitwiseOR: binop2("|", 3),
        bitwiseXOR: binop2("^", 4),
        bitwiseAND: binop2("&", 5),
        equality: binop2("==/!=/===/!==", 6),
        relational: binop2("</>/<=/>=", 7),
        bitShift: binop2("<</>>/>>>", 8),
        plusMin: new TokenType3("+/-", { beforeExpr: true, binop: 9, prefix: true, startsExpr: true }),
        modulo: binop2("%", 10),
        star: binop2("*", 10),
        slash: binop2("/", 10),
        starstar: new TokenType3("**", { beforeExpr: true }),
        coalesce: binop2("??", 1),
        // Keyword token types.
        _break: kw2("break"),
        _case: kw2("case", beforeExpr2),
        _catch: kw2("catch"),
        _continue: kw2("continue"),
        _debugger: kw2("debugger"),
        _default: kw2("default", beforeExpr2),
        _do: kw2("do", { isLoop: true, beforeExpr: true }),
        _else: kw2("else", beforeExpr2),
        _finally: kw2("finally"),
        _for: kw2("for", { isLoop: true }),
        _function: kw2("function", startsExpr2),
        _if: kw2("if"),
        _return: kw2("return", beforeExpr2),
        _switch: kw2("switch"),
        _throw: kw2("throw", beforeExpr2),
        _try: kw2("try"),
        _var: kw2("var"),
        _const: kw2("const"),
        _while: kw2("while", { isLoop: true }),
        _with: kw2("with"),
        _new: kw2("new", { beforeExpr: true, startsExpr: true }),
        _this: kw2("this", startsExpr2),
        _super: kw2("super", startsExpr2),
        _class: kw2("class", startsExpr2),
        _extends: kw2("extends", beforeExpr2),
        _export: kw2("export"),
        _import: kw2("import", startsExpr2),
        _null: kw2("null", startsExpr2),
        _true: kw2("true", startsExpr2),
        _false: kw2("false", startsExpr2),
        _in: kw2("in", { beforeExpr: true, binop: 7 }),
        _instanceof: kw2("instanceof", { beforeExpr: true, binop: 7 }),
        _typeof: kw2("typeof", { beforeExpr: true, prefix: true, startsExpr: true }),
        _void: kw2("void", { beforeExpr: true, prefix: true, startsExpr: true }),
        _delete: kw2("delete", { beforeExpr: true, prefix: true, startsExpr: true })
      };
      var lineBreak2 = /\r\n?|\n|\u2028|\u2029/;
      var lineBreakG2 = new RegExp(lineBreak2.source, "g");
      function isNewLine2(code3) {
        return code3 === 10 || code3 === 13 || code3 === 8232 || code3 === 8233;
      }
      function nextLineBreak2(code3, from, end) {
        if (end === void 0) end = code3.length;
        for (var i4 = from; i4 < end; i4++) {
          var next = code3.charCodeAt(i4);
          if (isNewLine2(next)) {
            return i4 < end - 1 && next === 13 && code3.charCodeAt(i4 + 1) === 10 ? i4 + 2 : i4 + 1;
          }
        }
        return -1;
      }
      var nonASCIIwhitespace2 = /[\u1680\u2000-\u200a\u202f\u205f\u3000\ufeff]/;
      var skipWhiteSpace2 = /(?:\s|\/\/.*|\/\*[^]*?\*\/)*/g;
      var ref2 = Object.prototype;
      var hasOwnProperty4 = ref2.hasOwnProperty;
      var toString4 = ref2.toString;
      var hasOwn2 = Object.hasOwn || function(obj, propName) {
        return hasOwnProperty4.call(obj, propName);
      };
      var isArray2 = Array.isArray || function(obj) {
        return toString4.call(obj) === "[object Array]";
      };
      var regexpCache2 = /* @__PURE__ */ Object.create(null);
      function wordsRegexp2(words) {
        return regexpCache2[words] || (regexpCache2[words] = new RegExp("^(?:" + words.replace(/ /g, "|") + ")$"));
      }
      function codePointToString2(code3) {
        if (code3 <= 65535) {
          return String.fromCharCode(code3);
        }
        code3 -= 65536;
        return String.fromCharCode((code3 >> 10) + 55296, (code3 & 1023) + 56320);
      }
      var loneSurrogate2 = /(?:[\uD800-\uDBFF](?![\uDC00-\uDFFF])|(?:[^\uD800-\uDBFF]|^)[\uDC00-\uDFFF])/;
      var Position3 = function Position4(line, col) {
        this.line = line;
        this.column = col;
      };
      Position3.prototype.offset = function offset5(n3) {
        return new Position3(this.line, this.column + n3);
      };
      var SourceLocation3 = function SourceLocation4(p2, start2, end) {
        this.start = start2;
        this.end = end;
        if (p2.sourceFile !== null) {
          this.source = p2.sourceFile;
        }
      };
      function getLineInfo2(input, offset5) {
        for (var line = 1, cur = 0; ; ) {
          var nextBreak = nextLineBreak2(input, cur, offset5);
          if (nextBreak < 0) {
            return new Position3(line, offset5 - cur);
          }
          ++line;
          cur = nextBreak;
        }
      }
      var defaultOptions3 = {
        // `ecmaVersion` indicates the ECMAScript version to parse. Must be
        // either 3, 5, 6 (or 2015), 7 (2016), 8 (2017), 9 (2018), 10
        // (2019), 11 (2020), 12 (2021), 13 (2022), 14 (2023), or `"latest"`
        // (the latest version the library supports). This influences
        // support for strict mode, the set of reserved words, and support
        // for new syntax features.
        ecmaVersion: null,
        // `sourceType` indicates the mode the code should be parsed in.
        // Can be either `"script"` or `"module"`. This influences global
        // strict mode and parsing of `import` and `export` declarations.
        sourceType: "script",
        // `onInsertedSemicolon` can be a callback that will be called when
        // a semicolon is automatically inserted. It will be passed the
        // position of the inserted semicolon as an offset, and if
        // `locations` is enabled, it is given the location as a `{line,
        // column}` object as second argument.
        onInsertedSemicolon: null,
        // `onTrailingComma` is similar to `onInsertedSemicolon`, but for
        // trailing commas.
        onTrailingComma: null,
        // By default, reserved words are only enforced if ecmaVersion >= 5.
        // Set `allowReserved` to a boolean value to explicitly turn this on
        // an off. When this option has the value "never", reserved words
        // and keywords can also not be used as property names.
        allowReserved: null,
        // When enabled, a return at the top level is not considered an
        // error.
        allowReturnOutsideFunction: false,
        // When enabled, import/export statements are not constrained to
        // appearing at the top of the program, and an import.meta expression
        // in a script isn't considered an error.
        allowImportExportEverywhere: false,
        // By default, await identifiers are allowed to appear at the top-level scope only if ecmaVersion >= 2022.
        // When enabled, await identifiers are allowed to appear at the top-level scope,
        // but they are still not allowed in non-async functions.
        allowAwaitOutsideFunction: null,
        // When enabled, super identifiers are not constrained to
        // appearing in methods and do not raise an error when they appear elsewhere.
        allowSuperOutsideMethod: null,
        // When enabled, hashbang directive in the beginning of file is
        // allowed and treated as a line comment. Enabled by default when
        // `ecmaVersion` >= 2023.
        allowHashBang: false,
        // By default, the parser will verify that private properties are
        // only used in places where they are valid and have been declared.
        // Set this to false to turn such checks off.
        checkPrivateFields: true,
        // When `locations` is on, `loc` properties holding objects with
        // `start` and `end` properties in `{line, column}` form (with
        // line being 1-based and column 0-based) will be attached to the
        // nodes.
        locations: false,
        // A function can be passed as `onToken` option, which will
        // cause Acorn to call that function with object in the same
        // format as tokens returned from `tokenizer().getToken()`. Note
        // that you are not allowed to call the parser from the
        // callback—that will corrupt its internal state.
        onToken: null,
        // A function can be passed as `onComment` option, which will
        // cause Acorn to call that function with `(block, text, start,
        // end)` parameters whenever a comment is skipped. `block` is a
        // boolean indicating whether this is a block (`/* */`) comment,
        // `text` is the content of the comment, and `start` and `end` are
        // character offsets that denote the start and end of the comment.
        // When the `locations` option is on, two more parameters are
        // passed, the full `{line, column}` locations of the start and
        // end of the comments. Note that you are not allowed to call the
        // parser from the callback—that will corrupt its internal state.
        // When this option has an array as value, objects representing the
        // comments are pushed to it.
        onComment: null,
        // Nodes have their start and end characters offsets recorded in
        // `start` and `end` properties (directly on the node, rather than
        // the `loc` object, which holds line/column data. To also add a
        // [semi-standardized][range] `range` property holding a `[start,
        // end]` array with the same numbers, set the `ranges` option to
        // `true`.
        //
        // [range]: https://bugzilla.mozilla.org/show_bug.cgi?id=745678
        ranges: false,
        // It is possible to parse multiple files into a single AST by
        // passing the tree produced by parsing the first file as
        // `program` option in subsequent parses. This will add the
        // toplevel forms of the parsed file to the `Program` (top) node
        // of an existing parse tree.
        program: null,
        // When `locations` is on, you can pass this to record the source
        // file in every node's `loc` object.
        sourceFile: null,
        // This value, if given, is stored in every node, whether
        // `locations` is on or off.
        directSourceFile: null,
        // When enabled, parenthesized expressions are represented by
        // (non-standard) ParenthesizedExpression nodes
        preserveParens: false
      };
      var warnedAboutEcmaVersion2 = false;
      function getOptions2(opts) {
        var options = {};
        for (var opt in defaultOptions3) {
          options[opt] = opts && hasOwn2(opts, opt) ? opts[opt] : defaultOptions3[opt];
        }
        if (options.ecmaVersion === "latest") {
          options.ecmaVersion = 1e8;
        } else if (options.ecmaVersion == null) {
          if (!warnedAboutEcmaVersion2 && typeof console === "object" && console.warn) {
            warnedAboutEcmaVersion2 = true;
            console.warn("Since Acorn 8.0.0, options.ecmaVersion is required.\nDefaulting to 2020, but this will stop working in the future.");
          }
          options.ecmaVersion = 11;
        } else if (options.ecmaVersion >= 2015) {
          options.ecmaVersion -= 2009;
        }
        if (options.allowReserved == null) {
          options.allowReserved = options.ecmaVersion < 5;
        }
        if (!opts || opts.allowHashBang == null) {
          options.allowHashBang = options.ecmaVersion >= 14;
        }
        if (isArray2(options.onToken)) {
          var tokens = options.onToken;
          options.onToken = function(token) {
            return tokens.push(token);
          };
        }
        if (isArray2(options.onComment)) {
          options.onComment = pushComment2(options, options.onComment);
        }
        return options;
      }
      function pushComment2(options, array) {
        return function(block, text4, start2, end, startLoc, endLoc) {
          var comment2 = {
            type: block ? "Block" : "Line",
            value: text4,
            start: start2,
            end
          };
          if (options.locations) {
            comment2.loc = new SourceLocation3(this, startLoc, endLoc);
          }
          if (options.ranges) {
            comment2.range = [start2, end];
          }
          array.push(comment2);
        };
      }
      var SCOPE_TOP2 = 1, SCOPE_FUNCTION2 = 2, SCOPE_ASYNC2 = 4, SCOPE_GENERATOR2 = 8, SCOPE_ARROW2 = 16, SCOPE_SIMPLE_CATCH2 = 32, SCOPE_SUPER2 = 64, SCOPE_DIRECT_SUPER2 = 128, SCOPE_CLASS_STATIC_BLOCK2 = 256, SCOPE_VAR2 = SCOPE_TOP2 | SCOPE_FUNCTION2 | SCOPE_CLASS_STATIC_BLOCK2;
      function functionFlags2(async, generator) {
        return SCOPE_FUNCTION2 | (async ? SCOPE_ASYNC2 : 0) | (generator ? SCOPE_GENERATOR2 : 0);
      }
      var BIND_NONE2 = 0, BIND_VAR2 = 1, BIND_LEXICAL2 = 2, BIND_FUNCTION2 = 3, BIND_SIMPLE_CATCH2 = 4, BIND_OUTSIDE2 = 5;
      var Parser3 = function Parser4(options, input, startPos) {
        this.options = options = getOptions2(options);
        this.sourceFile = options.sourceFile;
        this.keywords = wordsRegexp2(keywords$12[options.ecmaVersion >= 6 ? 6 : options.sourceType === "module" ? "5module" : 5]);
        var reserved = "";
        if (options.allowReserved !== true) {
          reserved = reservedWords2[options.ecmaVersion >= 6 ? 6 : options.ecmaVersion === 5 ? 5 : 3];
          if (options.sourceType === "module") {
            reserved += " await";
          }
        }
        this.reservedWords = wordsRegexp2(reserved);
        var reservedStrict = (reserved ? reserved + " " : "") + reservedWords2.strict;
        this.reservedWordsStrict = wordsRegexp2(reservedStrict);
        this.reservedWordsStrictBind = wordsRegexp2(reservedStrict + " " + reservedWords2.strictBind);
        this.input = String(input);
        this.containsEsc = false;
        if (startPos) {
          this.pos = startPos;
          this.lineStart = this.input.lastIndexOf("\n", startPos - 1) + 1;
          this.curLine = this.input.slice(0, this.lineStart).split(lineBreak2).length;
        } else {
          this.pos = this.lineStart = 0;
          this.curLine = 1;
        }
        this.type = types$12.eof;
        this.value = null;
        this.start = this.end = this.pos;
        this.startLoc = this.endLoc = this.curPosition();
        this.lastTokEndLoc = this.lastTokStartLoc = null;
        this.lastTokStart = this.lastTokEnd = this.pos;
        this.context = this.initialContext();
        this.exprAllowed = true;
        this.inModule = options.sourceType === "module";
        this.strict = this.inModule || this.strictDirective(this.pos);
        this.potentialArrowAt = -1;
        this.potentialArrowInForAwait = false;
        this.yieldPos = this.awaitPos = this.awaitIdentPos = 0;
        this.labels = [];
        this.undefinedExports = /* @__PURE__ */ Object.create(null);
        if (this.pos === 0 && options.allowHashBang && this.input.slice(0, 2) === "#!") {
          this.skipLineComment(2);
        }
        this.scopeStack = [];
        this.enterScope(SCOPE_TOP2);
        this.regexpState = null;
        this.privateNameStack = [];
      };
      var prototypeAccessors2 = { inFunction: { configurable: true }, inGenerator: { configurable: true }, inAsync: { configurable: true }, canAwait: { configurable: true }, allowSuper: { configurable: true }, allowDirectSuper: { configurable: true }, treatFunctionsAsVar: { configurable: true }, allowNewDotTarget: { configurable: true }, inClassStaticBlock: { configurable: true } };
      Parser3.prototype.parse = function parse6() {
        var node2 = this.options.program || this.startNode();
        this.nextToken();
        return this.parseTopLevel(node2);
      };
      prototypeAccessors2.inFunction.get = function() {
        return (this.currentVarScope().flags & SCOPE_FUNCTION2) > 0;
      };
      prototypeAccessors2.inGenerator.get = function() {
        return (this.currentVarScope().flags & SCOPE_GENERATOR2) > 0 && !this.currentVarScope().inClassFieldInit;
      };
      prototypeAccessors2.inAsync.get = function() {
        return (this.currentVarScope().flags & SCOPE_ASYNC2) > 0 && !this.currentVarScope().inClassFieldInit;
      };
      prototypeAccessors2.canAwait.get = function() {
        for (var i4 = this.scopeStack.length - 1; i4 >= 0; i4--) {
          var scope = this.scopeStack[i4];
          if (scope.inClassFieldInit || scope.flags & SCOPE_CLASS_STATIC_BLOCK2) {
            return false;
          }
          if (scope.flags & SCOPE_FUNCTION2) {
            return (scope.flags & SCOPE_ASYNC2) > 0;
          }
        }
        return this.inModule && this.options.ecmaVersion >= 13 || this.options.allowAwaitOutsideFunction;
      };
      prototypeAccessors2.allowSuper.get = function() {
        var ref3 = this.currentThisScope();
        var flags = ref3.flags;
        var inClassFieldInit = ref3.inClassFieldInit;
        return (flags & SCOPE_SUPER2) > 0 || inClassFieldInit || this.options.allowSuperOutsideMethod;
      };
      prototypeAccessors2.allowDirectSuper.get = function() {
        return (this.currentThisScope().flags & SCOPE_DIRECT_SUPER2) > 0;
      };
      prototypeAccessors2.treatFunctionsAsVar.get = function() {
        return this.treatFunctionsAsVarInScope(this.currentScope());
      };
      prototypeAccessors2.allowNewDotTarget.get = function() {
        var ref3 = this.currentThisScope();
        var flags = ref3.flags;
        var inClassFieldInit = ref3.inClassFieldInit;
        return (flags & (SCOPE_FUNCTION2 | SCOPE_CLASS_STATIC_BLOCK2)) > 0 || inClassFieldInit;
      };
      prototypeAccessors2.inClassStaticBlock.get = function() {
        return (this.currentVarScope().flags & SCOPE_CLASS_STATIC_BLOCK2) > 0;
      };
      Parser3.extend = function extend4() {
        var plugins = [], len = arguments.length;
        while (len--) plugins[len] = arguments[len];
        var cls = this;
        for (var i4 = 0; i4 < plugins.length; i4++) {
          cls = plugins[i4](cls);
        }
        return cls;
      };
      Parser3.parse = function parse6(input, options) {
        return new this(options, input).parse();
      };
      Parser3.parseExpressionAt = function parseExpressionAt3(input, pos, options) {
        var parser = new this(options, input, pos);
        parser.nextToken();
        return parser.parseExpression();
      };
      Parser3.tokenizer = function tokenizer3(input, options) {
        return new this(options, input);
      };
      Object.defineProperties(Parser3.prototype, prototypeAccessors2);
      var pp$92 = Parser3.prototype;
      var literal2 = /^(?:'((?:\\[^]|[^'\\])*?)'|"((?:\\[^]|[^"\\])*?)")/;
      pp$92.strictDirective = function(start2) {
        if (this.options.ecmaVersion < 5) {
          return false;
        }
        for (; ; ) {
          skipWhiteSpace2.lastIndex = start2;
          start2 += skipWhiteSpace2.exec(this.input)[0].length;
          var match = literal2.exec(this.input.slice(start2));
          if (!match) {
            return false;
          }
          if ((match[1] || match[2]) === "use strict") {
            skipWhiteSpace2.lastIndex = start2 + match[0].length;
            var spaceAfter = skipWhiteSpace2.exec(this.input), end = spaceAfter.index + spaceAfter[0].length;
            var next = this.input.charAt(end);
            return next === ";" || next === "}" || lineBreak2.test(spaceAfter[0]) && !(/[(`.[+\-/*%<>=,?^&]/.test(next) || next === "!" && this.input.charAt(end + 1) === "=");
          }
          start2 += match[0].length;
          skipWhiteSpace2.lastIndex = start2;
          start2 += skipWhiteSpace2.exec(this.input)[0].length;
          if (this.input[start2] === ";") {
            start2++;
          }
        }
      };
      pp$92.eat = function(type2) {
        if (this.type === type2) {
          this.next();
          return true;
        } else {
          return false;
        }
      };
      pp$92.isContextual = function(name2) {
        return this.type === types$12.name && this.value === name2 && !this.containsEsc;
      };
      pp$92.eatContextual = function(name2) {
        if (!this.isContextual(name2)) {
          return false;
        }
        this.next();
        return true;
      };
      pp$92.expectContextual = function(name2) {
        if (!this.eatContextual(name2)) {
          this.unexpected();
        }
      };
      pp$92.canInsertSemicolon = function() {
        return this.type === types$12.eof || this.type === types$12.braceR || lineBreak2.test(this.input.slice(this.lastTokEnd, this.start));
      };
      pp$92.insertSemicolon = function() {
        if (this.canInsertSemicolon()) {
          if (this.options.onInsertedSemicolon) {
            this.options.onInsertedSemicolon(this.lastTokEnd, this.lastTokEndLoc);
          }
          return true;
        }
      };
      pp$92.semicolon = function() {
        if (!this.eat(types$12.semi) && !this.insertSemicolon()) {
          this.unexpected();
        }
      };
      pp$92.afterTrailingComma = function(tokType, notNext) {
        if (this.type === tokType) {
          if (this.options.onTrailingComma) {
            this.options.onTrailingComma(this.lastTokStart, this.lastTokStartLoc);
          }
          if (!notNext) {
            this.next();
          }
          return true;
        }
      };
      pp$92.expect = function(type2) {
        this.eat(type2) || this.unexpected();
      };
      pp$92.unexpected = function(pos) {
        this.raise(pos != null ? pos : this.start, "Unexpected token");
      };
      var DestructuringErrors3 = function DestructuringErrors4() {
        this.shorthandAssign = this.trailingComma = this.parenthesizedAssign = this.parenthesizedBind = this.doubleProto = -1;
      };
      pp$92.checkPatternErrors = function(refDestructuringErrors, isAssign) {
        if (!refDestructuringErrors) {
          return;
        }
        if (refDestructuringErrors.trailingComma > -1) {
          this.raiseRecoverable(refDestructuringErrors.trailingComma, "Comma is not permitted after the rest element");
        }
        var parens = isAssign ? refDestructuringErrors.parenthesizedAssign : refDestructuringErrors.parenthesizedBind;
        if (parens > -1) {
          this.raiseRecoverable(parens, isAssign ? "Assigning to rvalue" : "Parenthesized pattern");
        }
      };
      pp$92.checkExpressionErrors = function(refDestructuringErrors, andThrow) {
        if (!refDestructuringErrors) {
          return false;
        }
        var shorthandAssign = refDestructuringErrors.shorthandAssign;
        var doubleProto = refDestructuringErrors.doubleProto;
        if (!andThrow) {
          return shorthandAssign >= 0 || doubleProto >= 0;
        }
        if (shorthandAssign >= 0) {
          this.raise(shorthandAssign, "Shorthand property assignments are valid only in destructuring patterns");
        }
        if (doubleProto >= 0) {
          this.raiseRecoverable(doubleProto, "Redefinition of __proto__ property");
        }
      };
      pp$92.checkYieldAwaitInDefaultParams = function() {
        if (this.yieldPos && (!this.awaitPos || this.yieldPos < this.awaitPos)) {
          this.raise(this.yieldPos, "Yield expression cannot be a default value");
        }
        if (this.awaitPos) {
          this.raise(this.awaitPos, "Await expression cannot be a default value");
        }
      };
      pp$92.isSimpleAssignTarget = function(expr) {
        if (expr.type === "ParenthesizedExpression") {
          return this.isSimpleAssignTarget(expr.expression);
        }
        return expr.type === "Identifier" || expr.type === "MemberExpression";
      };
      var pp$82 = Parser3.prototype;
      pp$82.parseTopLevel = function(node2) {
        var exports3 = /* @__PURE__ */ Object.create(null);
        if (!node2.body) {
          node2.body = [];
        }
        while (this.type !== types$12.eof) {
          var stmt = this.parseStatement(null, true, exports3);
          node2.body.push(stmt);
        }
        if (this.inModule) {
          for (var i4 = 0, list5 = Object.keys(this.undefinedExports); i4 < list5.length; i4 += 1) {
            var name2 = list5[i4];
            this.raiseRecoverable(this.undefinedExports[name2].start, "Export '" + name2 + "' is not defined");
          }
        }
        this.adaptDirectivePrologue(node2.body);
        this.next();
        node2.sourceType = this.options.sourceType;
        return this.finishNode(node2, "Program");
      };
      var loopLabel2 = { kind: "loop" }, switchLabel2 = { kind: "switch" };
      pp$82.isLet = function(context) {
        if (this.options.ecmaVersion < 6 || !this.isContextual("let")) {
          return false;
        }
        skipWhiteSpace2.lastIndex = this.pos;
        var skip = skipWhiteSpace2.exec(this.input);
        var next = this.pos + skip[0].length, nextCh = this.input.charCodeAt(next);
        if (nextCh === 91 || nextCh === 92) {
          return true;
        }
        if (context) {
          return false;
        }
        if (nextCh === 123 || nextCh > 55295 && nextCh < 56320) {
          return true;
        }
        if (isIdentifierStart2(nextCh, true)) {
          var pos = next + 1;
          while (isIdentifierChar2(nextCh = this.input.charCodeAt(pos), true)) {
            ++pos;
          }
          if (nextCh === 92 || nextCh > 55295 && nextCh < 56320) {
            return true;
          }
          var ident = this.input.slice(next, pos);
          if (!keywordRelationalOperator2.test(ident)) {
            return true;
          }
        }
        return false;
      };
      pp$82.isAsyncFunction = function() {
        if (this.options.ecmaVersion < 8 || !this.isContextual("async")) {
          return false;
        }
        skipWhiteSpace2.lastIndex = this.pos;
        var skip = skipWhiteSpace2.exec(this.input);
        var next = this.pos + skip[0].length, after;
        return !lineBreak2.test(this.input.slice(this.pos, next)) && this.input.slice(next, next + 8) === "function" && (next + 8 === this.input.length || !(isIdentifierChar2(after = this.input.charCodeAt(next + 8)) || after > 55295 && after < 56320));
      };
      pp$82.parseStatement = function(context, topLevel, exports3) {
        var starttype = this.type, node2 = this.startNode(), kind;
        if (this.isLet(context)) {
          starttype = types$12._var;
          kind = "let";
        }
        switch (starttype) {
          case types$12._break:
          case types$12._continue:
            return this.parseBreakContinueStatement(node2, starttype.keyword);
          case types$12._debugger:
            return this.parseDebuggerStatement(node2);
          case types$12._do:
            return this.parseDoStatement(node2);
          case types$12._for:
            return this.parseForStatement(node2);
          case types$12._function:
            if (context && (this.strict || context !== "if" && context !== "label") && this.options.ecmaVersion >= 6) {
              this.unexpected();
            }
            return this.parseFunctionStatement(node2, false, !context);
          case types$12._class:
            if (context) {
              this.unexpected();
            }
            return this.parseClass(node2, true);
          case types$12._if:
            return this.parseIfStatement(node2);
          case types$12._return:
            return this.parseReturnStatement(node2);
          case types$12._switch:
            return this.parseSwitchStatement(node2);
          case types$12._throw:
            return this.parseThrowStatement(node2);
          case types$12._try:
            return this.parseTryStatement(node2);
          case types$12._const:
          case types$12._var:
            kind = kind || this.value;
            if (context && kind !== "var") {
              this.unexpected();
            }
            return this.parseVarStatement(node2, kind);
          case types$12._while:
            return this.parseWhileStatement(node2);
          case types$12._with:
            return this.parseWithStatement(node2);
          case types$12.braceL:
            return this.parseBlock(true, node2);
          case types$12.semi:
            return this.parseEmptyStatement(node2);
          case types$12._export:
          case types$12._import:
            if (this.options.ecmaVersion > 10 && starttype === types$12._import) {
              skipWhiteSpace2.lastIndex = this.pos;
              var skip = skipWhiteSpace2.exec(this.input);
              var next = this.pos + skip[0].length, nextCh = this.input.charCodeAt(next);
              if (nextCh === 40 || nextCh === 46) {
                return this.parseExpressionStatement(node2, this.parseExpression());
              }
            }
            if (!this.options.allowImportExportEverywhere) {
              if (!topLevel) {
                this.raise(this.start, "'import' and 'export' may only appear at the top level");
              }
              if (!this.inModule) {
                this.raise(this.start, "'import' and 'export' may appear only with 'sourceType: module'");
              }
            }
            return starttype === types$12._import ? this.parseImport(node2) : this.parseExport(node2, exports3);
          default:
            if (this.isAsyncFunction()) {
              if (context) {
                this.unexpected();
              }
              this.next();
              return this.parseFunctionStatement(node2, true, !context);
            }
            var maybeName = this.value, expr = this.parseExpression();
            if (starttype === types$12.name && expr.type === "Identifier" && this.eat(types$12.colon)) {
              return this.parseLabeledStatement(node2, maybeName, expr, context);
            } else {
              return this.parseExpressionStatement(node2, expr);
            }
        }
      };
      pp$82.parseBreakContinueStatement = function(node2, keyword) {
        var isBreak = keyword === "break";
        this.next();
        if (this.eat(types$12.semi) || this.insertSemicolon()) {
          node2.label = null;
        } else if (this.type !== types$12.name) {
          this.unexpected();
        } else {
          node2.label = this.parseIdent();
          this.semicolon();
        }
        var i4 = 0;
        for (; i4 < this.labels.length; ++i4) {
          var lab = this.labels[i4];
          if (node2.label == null || lab.name === node2.label.name) {
            if (lab.kind != null && (isBreak || lab.kind === "loop")) {
              break;
            }
            if (node2.label && isBreak) {
              break;
            }
          }
        }
        if (i4 === this.labels.length) {
          this.raise(node2.start, "Unsyntactic " + keyword);
        }
        return this.finishNode(node2, isBreak ? "BreakStatement" : "ContinueStatement");
      };
      pp$82.parseDebuggerStatement = function(node2) {
        this.next();
        this.semicolon();
        return this.finishNode(node2, "DebuggerStatement");
      };
      pp$82.parseDoStatement = function(node2) {
        this.next();
        this.labels.push(loopLabel2);
        node2.body = this.parseStatement("do");
        this.labels.pop();
        this.expect(types$12._while);
        node2.test = this.parseParenExpression();
        if (this.options.ecmaVersion >= 6) {
          this.eat(types$12.semi);
        } else {
          this.semicolon();
        }
        return this.finishNode(node2, "DoWhileStatement");
      };
      pp$82.parseForStatement = function(node2) {
        this.next();
        var awaitAt = this.options.ecmaVersion >= 9 && this.canAwait && this.eatContextual("await") ? this.lastTokStart : -1;
        this.labels.push(loopLabel2);
        this.enterScope(0);
        this.expect(types$12.parenL);
        if (this.type === types$12.semi) {
          if (awaitAt > -1) {
            this.unexpected(awaitAt);
          }
          return this.parseFor(node2, null);
        }
        var isLet = this.isLet();
        if (this.type === types$12._var || this.type === types$12._const || isLet) {
          var init$1 = this.startNode(), kind = isLet ? "let" : this.value;
          this.next();
          this.parseVar(init$1, true, kind);
          this.finishNode(init$1, "VariableDeclaration");
          if ((this.type === types$12._in || this.options.ecmaVersion >= 6 && this.isContextual("of")) && init$1.declarations.length === 1) {
            if (this.options.ecmaVersion >= 9) {
              if (this.type === types$12._in) {
                if (awaitAt > -1) {
                  this.unexpected(awaitAt);
                }
              } else {
                node2.await = awaitAt > -1;
              }
            }
            return this.parseForIn(node2, init$1);
          }
          if (awaitAt > -1) {
            this.unexpected(awaitAt);
          }
          return this.parseFor(node2, init$1);
        }
        var startsWithLet = this.isContextual("let"), isForOf = false;
        var containsEsc = this.containsEsc;
        var refDestructuringErrors = new DestructuringErrors3();
        var initPos = this.start;
        var init = awaitAt > -1 ? this.parseExprSubscripts(refDestructuringErrors, "await") : this.parseExpression(true, refDestructuringErrors);
        if (this.type === types$12._in || (isForOf = this.options.ecmaVersion >= 6 && this.isContextual("of"))) {
          if (awaitAt > -1) {
            if (this.type === types$12._in) {
              this.unexpected(awaitAt);
            }
            node2.await = true;
          } else if (isForOf && this.options.ecmaVersion >= 8) {
            if (init.start === initPos && !containsEsc && init.type === "Identifier" && init.name === "async") {
              this.unexpected();
            } else if (this.options.ecmaVersion >= 9) {
              node2.await = false;
            }
          }
          if (startsWithLet && isForOf) {
            this.raise(init.start, "The left-hand side of a for-of loop may not start with 'let'.");
          }
          this.toAssignable(init, false, refDestructuringErrors);
          this.checkLValPattern(init);
          return this.parseForIn(node2, init);
        } else {
          this.checkExpressionErrors(refDestructuringErrors, true);
        }
        if (awaitAt > -1) {
          this.unexpected(awaitAt);
        }
        return this.parseFor(node2, init);
      };
      pp$82.parseFunctionStatement = function(node2, isAsync, declarationPosition) {
        this.next();
        return this.parseFunction(node2, FUNC_STATEMENT2 | (declarationPosition ? 0 : FUNC_HANGING_STATEMENT2), false, isAsync);
      };
      pp$82.parseIfStatement = function(node2) {
        this.next();
        node2.test = this.parseParenExpression();
        node2.consequent = this.parseStatement("if");
        node2.alternate = this.eat(types$12._else) ? this.parseStatement("if") : null;
        return this.finishNode(node2, "IfStatement");
      };
      pp$82.parseReturnStatement = function(node2) {
        if (!this.inFunction && !this.options.allowReturnOutsideFunction) {
          this.raise(this.start, "'return' outside of function");
        }
        this.next();
        if (this.eat(types$12.semi) || this.insertSemicolon()) {
          node2.argument = null;
        } else {
          node2.argument = this.parseExpression();
          this.semicolon();
        }
        return this.finishNode(node2, "ReturnStatement");
      };
      pp$82.parseSwitchStatement = function(node2) {
        this.next();
        node2.discriminant = this.parseParenExpression();
        node2.cases = [];
        this.expect(types$12.braceL);
        this.labels.push(switchLabel2);
        this.enterScope(0);
        var cur;
        for (var sawDefault = false; this.type !== types$12.braceR; ) {
          if (this.type === types$12._case || this.type === types$12._default) {
            var isCase = this.type === types$12._case;
            if (cur) {
              this.finishNode(cur, "SwitchCase");
            }
            node2.cases.push(cur = this.startNode());
            cur.consequent = [];
            this.next();
            if (isCase) {
              cur.test = this.parseExpression();
            } else {
              if (sawDefault) {
                this.raiseRecoverable(this.lastTokStart, "Multiple default clauses");
              }
              sawDefault = true;
              cur.test = null;
            }
            this.expect(types$12.colon);
          } else {
            if (!cur) {
              this.unexpected();
            }
            cur.consequent.push(this.parseStatement(null));
          }
        }
        this.exitScope();
        if (cur) {
          this.finishNode(cur, "SwitchCase");
        }
        this.next();
        this.labels.pop();
        return this.finishNode(node2, "SwitchStatement");
      };
      pp$82.parseThrowStatement = function(node2) {
        this.next();
        if (lineBreak2.test(this.input.slice(this.lastTokEnd, this.start))) {
          this.raise(this.lastTokEnd, "Illegal newline after throw");
        }
        node2.argument = this.parseExpression();
        this.semicolon();
        return this.finishNode(node2, "ThrowStatement");
      };
      var empty$12 = [];
      pp$82.parseCatchClauseParam = function() {
        var param = this.parseBindingAtom();
        var simple = param.type === "Identifier";
        this.enterScope(simple ? SCOPE_SIMPLE_CATCH2 : 0);
        this.checkLValPattern(param, simple ? BIND_SIMPLE_CATCH2 : BIND_LEXICAL2);
        this.expect(types$12.parenR);
        return param;
      };
      pp$82.parseTryStatement = function(node2) {
        this.next();
        node2.block = this.parseBlock();
        node2.handler = null;
        if (this.type === types$12._catch) {
          var clause = this.startNode();
          this.next();
          if (this.eat(types$12.parenL)) {
            clause.param = this.parseCatchClauseParam();
          } else {
            if (this.options.ecmaVersion < 10) {
              this.unexpected();
            }
            clause.param = null;
            this.enterScope(0);
          }
          clause.body = this.parseBlock(false);
          this.exitScope();
          node2.handler = this.finishNode(clause, "CatchClause");
        }
        node2.finalizer = this.eat(types$12._finally) ? this.parseBlock() : null;
        if (!node2.handler && !node2.finalizer) {
          this.raise(node2.start, "Missing catch or finally clause");
        }
        return this.finishNode(node2, "TryStatement");
      };
      pp$82.parseVarStatement = function(node2, kind, allowMissingInitializer) {
        this.next();
        this.parseVar(node2, false, kind, allowMissingInitializer);
        this.semicolon();
        return this.finishNode(node2, "VariableDeclaration");
      };
      pp$82.parseWhileStatement = function(node2) {
        this.next();
        node2.test = this.parseParenExpression();
        this.labels.push(loopLabel2);
        node2.body = this.parseStatement("while");
        this.labels.pop();
        return this.finishNode(node2, "WhileStatement");
      };
      pp$82.parseWithStatement = function(node2) {
        if (this.strict) {
          this.raise(this.start, "'with' in strict mode");
        }
        this.next();
        node2.object = this.parseParenExpression();
        node2.body = this.parseStatement("with");
        return this.finishNode(node2, "WithStatement");
      };
      pp$82.parseEmptyStatement = function(node2) {
        this.next();
        return this.finishNode(node2, "EmptyStatement");
      };
      pp$82.parseLabeledStatement = function(node2, maybeName, expr, context) {
        for (var i$1 = 0, list5 = this.labels; i$1 < list5.length; i$1 += 1) {
          var label4 = list5[i$1];
          if (label4.name === maybeName) {
            this.raise(expr.start, "Label '" + maybeName + "' is already declared");
          }
        }
        var kind = this.type.isLoop ? "loop" : this.type === types$12._switch ? "switch" : null;
        for (var i4 = this.labels.length - 1; i4 >= 0; i4--) {
          var label$1 = this.labels[i4];
          if (label$1.statementStart === node2.start) {
            label$1.statementStart = this.start;
            label$1.kind = kind;
          } else {
            break;
          }
        }
        this.labels.push({ name: maybeName, kind, statementStart: this.start });
        node2.body = this.parseStatement(context ? context.indexOf("label") === -1 ? context + "label" : context : "label");
        this.labels.pop();
        node2.label = expr;
        return this.finishNode(node2, "LabeledStatement");
      };
      pp$82.parseExpressionStatement = function(node2, expr) {
        node2.expression = expr;
        this.semicolon();
        return this.finishNode(node2, "ExpressionStatement");
      };
      pp$82.parseBlock = function(createNewLexicalScope, node2, exitStrict) {
        if (createNewLexicalScope === void 0) createNewLexicalScope = true;
        if (node2 === void 0) node2 = this.startNode();
        node2.body = [];
        this.expect(types$12.braceL);
        if (createNewLexicalScope) {
          this.enterScope(0);
        }
        while (this.type !== types$12.braceR) {
          var stmt = this.parseStatement(null);
          node2.body.push(stmt);
        }
        if (exitStrict) {
          this.strict = false;
        }
        this.next();
        if (createNewLexicalScope) {
          this.exitScope();
        }
        return this.finishNode(node2, "BlockStatement");
      };
      pp$82.parseFor = function(node2, init) {
        node2.init = init;
        this.expect(types$12.semi);
        node2.test = this.type === types$12.semi ? null : this.parseExpression();
        this.expect(types$12.semi);
        node2.update = this.type === types$12.parenR ? null : this.parseExpression();
        this.expect(types$12.parenR);
        node2.body = this.parseStatement("for");
        this.exitScope();
        this.labels.pop();
        return this.finishNode(node2, "ForStatement");
      };
      pp$82.parseForIn = function(node2, init) {
        var isForIn = this.type === types$12._in;
        this.next();
        if (init.type === "VariableDeclaration" && init.declarations[0].init != null && (!isForIn || this.options.ecmaVersion < 8 || this.strict || init.kind !== "var" || init.declarations[0].id.type !== "Identifier")) {
          this.raise(
            init.start,
            (isForIn ? "for-in" : "for-of") + " loop variable declaration may not have an initializer"
          );
        }
        node2.left = init;
        node2.right = isForIn ? this.parseExpression() : this.parseMaybeAssign();
        this.expect(types$12.parenR);
        node2.body = this.parseStatement("for");
        this.exitScope();
        this.labels.pop();
        return this.finishNode(node2, isForIn ? "ForInStatement" : "ForOfStatement");
      };
      pp$82.parseVar = function(node2, isFor, kind, allowMissingInitializer) {
        node2.declarations = [];
        node2.kind = kind;
        for (; ; ) {
          var decl = this.startNode();
          this.parseVarId(decl, kind);
          if (this.eat(types$12.eq)) {
            decl.init = this.parseMaybeAssign(isFor);
          } else if (!allowMissingInitializer && kind === "const" && !(this.type === types$12._in || this.options.ecmaVersion >= 6 && this.isContextual("of"))) {
            this.unexpected();
          } else if (!allowMissingInitializer && decl.id.type !== "Identifier" && !(isFor && (this.type === types$12._in || this.isContextual("of")))) {
            this.raise(this.lastTokEnd, "Complex binding patterns require an initialization value");
          } else {
            decl.init = null;
          }
          node2.declarations.push(this.finishNode(decl, "VariableDeclarator"));
          if (!this.eat(types$12.comma)) {
            break;
          }
        }
        return node2;
      };
      pp$82.parseVarId = function(decl, kind) {
        decl.id = this.parseBindingAtom();
        this.checkLValPattern(decl.id, kind === "var" ? BIND_VAR2 : BIND_LEXICAL2, false);
      };
      var FUNC_STATEMENT2 = 1, FUNC_HANGING_STATEMENT2 = 2, FUNC_NULLABLE_ID2 = 4;
      pp$82.parseFunction = function(node2, statement, allowExpressionBody, isAsync, forInit) {
        this.initFunction(node2);
        if (this.options.ecmaVersion >= 9 || this.options.ecmaVersion >= 6 && !isAsync) {
          if (this.type === types$12.star && statement & FUNC_HANGING_STATEMENT2) {
            this.unexpected();
          }
          node2.generator = this.eat(types$12.star);
        }
        if (this.options.ecmaVersion >= 8) {
          node2.async = !!isAsync;
        }
        if (statement & FUNC_STATEMENT2) {
          node2.id = statement & FUNC_NULLABLE_ID2 && this.type !== types$12.name ? null : this.parseIdent();
          if (node2.id && !(statement & FUNC_HANGING_STATEMENT2)) {
            this.checkLValSimple(node2.id, this.strict || node2.generator || node2.async ? this.treatFunctionsAsVar ? BIND_VAR2 : BIND_LEXICAL2 : BIND_FUNCTION2);
          }
        }
        var oldYieldPos = this.yieldPos, oldAwaitPos = this.awaitPos, oldAwaitIdentPos = this.awaitIdentPos;
        this.yieldPos = 0;
        this.awaitPos = 0;
        this.awaitIdentPos = 0;
        this.enterScope(functionFlags2(node2.async, node2.generator));
        if (!(statement & FUNC_STATEMENT2)) {
          node2.id = this.type === types$12.name ? this.parseIdent() : null;
        }
        this.parseFunctionParams(node2);
        this.parseFunctionBody(node2, allowExpressionBody, false, forInit);
        this.yieldPos = oldYieldPos;
        this.awaitPos = oldAwaitPos;
        this.awaitIdentPos = oldAwaitIdentPos;
        return this.finishNode(node2, statement & FUNC_STATEMENT2 ? "FunctionDeclaration" : "FunctionExpression");
      };
      pp$82.parseFunctionParams = function(node2) {
        this.expect(types$12.parenL);
        node2.params = this.parseBindingList(types$12.parenR, false, this.options.ecmaVersion >= 8);
        this.checkYieldAwaitInDefaultParams();
      };
      pp$82.parseClass = function(node2, isStatement) {
        this.next();
        var oldStrict = this.strict;
        this.strict = true;
        this.parseClassId(node2, isStatement);
        this.parseClassSuper(node2);
        var privateNameMap = this.enterClassBody();
        var classBody = this.startNode();
        var hadConstructor = false;
        classBody.body = [];
        this.expect(types$12.braceL);
        while (this.type !== types$12.braceR) {
          var element2 = this.parseClassElement(node2.superClass !== null);
          if (element2) {
            classBody.body.push(element2);
            if (element2.type === "MethodDefinition" && element2.kind === "constructor") {
              if (hadConstructor) {
                this.raiseRecoverable(element2.start, "Duplicate constructor in the same class");
              }
              hadConstructor = true;
            } else if (element2.key && element2.key.type === "PrivateIdentifier" && isPrivateNameConflicted2(privateNameMap, element2)) {
              this.raiseRecoverable(element2.key.start, "Identifier '#" + element2.key.name + "' has already been declared");
            }
          }
        }
        this.strict = oldStrict;
        this.next();
        node2.body = this.finishNode(classBody, "ClassBody");
        this.exitClassBody();
        return this.finishNode(node2, isStatement ? "ClassDeclaration" : "ClassExpression");
      };
      pp$82.parseClassElement = function(constructorAllowsSuper) {
        if (this.eat(types$12.semi)) {
          return null;
        }
        var ecmaVersion2 = this.options.ecmaVersion;
        var node2 = this.startNode();
        var keyName = "";
        var isGenerator = false;
        var isAsync = false;
        var kind = "method";
        var isStatic = false;
        if (this.eatContextual("static")) {
          if (ecmaVersion2 >= 13 && this.eat(types$12.braceL)) {
            this.parseClassStaticBlock(node2);
            return node2;
          }
          if (this.isClassElementNameStart() || this.type === types$12.star) {
            isStatic = true;
          } else {
            keyName = "static";
          }
        }
        node2.static = isStatic;
        if (!keyName && ecmaVersion2 >= 8 && this.eatContextual("async")) {
          if ((this.isClassElementNameStart() || this.type === types$12.star) && !this.canInsertSemicolon()) {
            isAsync = true;
          } else {
            keyName = "async";
          }
        }
        if (!keyName && (ecmaVersion2 >= 9 || !isAsync) && this.eat(types$12.star)) {
          isGenerator = true;
        }
        if (!keyName && !isAsync && !isGenerator) {
          var lastValue = this.value;
          if (this.eatContextual("get") || this.eatContextual("set")) {
            if (this.isClassElementNameStart()) {
              kind = lastValue;
            } else {
              keyName = lastValue;
            }
          }
        }
        if (keyName) {
          node2.computed = false;
          node2.key = this.startNodeAt(this.lastTokStart, this.lastTokStartLoc);
          node2.key.name = keyName;
          this.finishNode(node2.key, "Identifier");
        } else {
          this.parseClassElementName(node2);
        }
        if (ecmaVersion2 < 13 || this.type === types$12.parenL || kind !== "method" || isGenerator || isAsync) {
          var isConstructor = !node2.static && checkKeyName2(node2, "constructor");
          var allowsDirectSuper = isConstructor && constructorAllowsSuper;
          if (isConstructor && kind !== "method") {
            this.raise(node2.key.start, "Constructor can't have get/set modifier");
          }
          node2.kind = isConstructor ? "constructor" : kind;
          this.parseClassMethod(node2, isGenerator, isAsync, allowsDirectSuper);
        } else {
          this.parseClassField(node2);
        }
        return node2;
      };
      pp$82.isClassElementNameStart = function() {
        return this.type === types$12.name || this.type === types$12.privateId || this.type === types$12.num || this.type === types$12.string || this.type === types$12.bracketL || this.type.keyword;
      };
      pp$82.parseClassElementName = function(element2) {
        if (this.type === types$12.privateId) {
          if (this.value === "constructor") {
            this.raise(this.start, "Classes can't have an element named '#constructor'");
          }
          element2.computed = false;
          element2.key = this.parsePrivateIdent();
        } else {
          this.parsePropertyName(element2);
        }
      };
      pp$82.parseClassMethod = function(method, isGenerator, isAsync, allowsDirectSuper) {
        var key2 = method.key;
        if (method.kind === "constructor") {
          if (isGenerator) {
            this.raise(key2.start, "Constructor can't be a generator");
          }
          if (isAsync) {
            this.raise(key2.start, "Constructor can't be an async method");
          }
        } else if (method.static && checkKeyName2(method, "prototype")) {
          this.raise(key2.start, "Classes may not have a static property named prototype");
        }
        var value2 = method.value = this.parseMethod(isGenerator, isAsync, allowsDirectSuper);
        if (method.kind === "get" && value2.params.length !== 0) {
          this.raiseRecoverable(value2.start, "getter should have no params");
        }
        if (method.kind === "set" && value2.params.length !== 1) {
          this.raiseRecoverable(value2.start, "setter should have exactly one param");
        }
        if (method.kind === "set" && value2.params[0].type === "RestElement") {
          this.raiseRecoverable(value2.params[0].start, "Setter cannot use rest params");
        }
        return this.finishNode(method, "MethodDefinition");
      };
      pp$82.parseClassField = function(field) {
        if (checkKeyName2(field, "constructor")) {
          this.raise(field.key.start, "Classes can't have a field named 'constructor'");
        } else if (field.static && checkKeyName2(field, "prototype")) {
          this.raise(field.key.start, "Classes can't have a static field named 'prototype'");
        }
        if (this.eat(types$12.eq)) {
          var scope = this.currentThisScope();
          var inClassFieldInit = scope.inClassFieldInit;
          scope.inClassFieldInit = true;
          field.value = this.parseMaybeAssign();
          scope.inClassFieldInit = inClassFieldInit;
        } else {
          field.value = null;
        }
        this.semicolon();
        return this.finishNode(field, "PropertyDefinition");
      };
      pp$82.parseClassStaticBlock = function(node2) {
        node2.body = [];
        var oldLabels = this.labels;
        this.labels = [];
        this.enterScope(SCOPE_CLASS_STATIC_BLOCK2 | SCOPE_SUPER2);
        while (this.type !== types$12.braceR) {
          var stmt = this.parseStatement(null);
          node2.body.push(stmt);
        }
        this.next();
        this.exitScope();
        this.labels = oldLabels;
        return this.finishNode(node2, "StaticBlock");
      };
      pp$82.parseClassId = function(node2, isStatement) {
        if (this.type === types$12.name) {
          node2.id = this.parseIdent();
          if (isStatement) {
            this.checkLValSimple(node2.id, BIND_LEXICAL2, false);
          }
        } else {
          if (isStatement === true) {
            this.unexpected();
          }
          node2.id = null;
        }
      };
      pp$82.parseClassSuper = function(node2) {
        node2.superClass = this.eat(types$12._extends) ? this.parseExprSubscripts(null, false) : null;
      };
      pp$82.enterClassBody = function() {
        var element2 = { declared: /* @__PURE__ */ Object.create(null), used: [] };
        this.privateNameStack.push(element2);
        return element2.declared;
      };
      pp$82.exitClassBody = function() {
        var ref3 = this.privateNameStack.pop();
        var declared = ref3.declared;
        var used = ref3.used;
        if (!this.options.checkPrivateFields) {
          return;
        }
        var len = this.privateNameStack.length;
        var parent = len === 0 ? null : this.privateNameStack[len - 1];
        for (var i4 = 0; i4 < used.length; ++i4) {
          var id = used[i4];
          if (!hasOwn2(declared, id.name)) {
            if (parent) {
              parent.used.push(id);
            } else {
              this.raiseRecoverable(id.start, "Private field '#" + id.name + "' must be declared in an enclosing class");
            }
          }
        }
      };
      function isPrivateNameConflicted2(privateNameMap, element2) {
        var name2 = element2.key.name;
        var curr = privateNameMap[name2];
        var next = "true";
        if (element2.type === "MethodDefinition" && (element2.kind === "get" || element2.kind === "set")) {
          next = (element2.static ? "s" : "i") + element2.kind;
        }
        if (curr === "iget" && next === "iset" || curr === "iset" && next === "iget" || curr === "sget" && next === "sset" || curr === "sset" && next === "sget") {
          privateNameMap[name2] = "true";
          return false;
        } else if (!curr) {
          privateNameMap[name2] = next;
          return false;
        } else {
          return true;
        }
      }
      function checkKeyName2(node2, name2) {
        var computed = node2.computed;
        var key2 = node2.key;
        return !computed && (key2.type === "Identifier" && key2.name === name2 || key2.type === "Literal" && key2.value === name2);
      }
      pp$82.parseExportAllDeclaration = function(node2, exports3) {
        if (this.options.ecmaVersion >= 11) {
          if (this.eatContextual("as")) {
            node2.exported = this.parseModuleExportName();
            this.checkExport(exports3, node2.exported, this.lastTokStart);
          } else {
            node2.exported = null;
          }
        }
        this.expectContextual("from");
        if (this.type !== types$12.string) {
          this.unexpected();
        }
        node2.source = this.parseExprAtom();
        if (this.options.ecmaVersion >= 16) {
          node2.attributes = this.parseWithClause();
        }
        this.semicolon();
        return this.finishNode(node2, "ExportAllDeclaration");
      };
      pp$82.parseExport = function(node2, exports3) {
        this.next();
        if (this.eat(types$12.star)) {
          return this.parseExportAllDeclaration(node2, exports3);
        }
        if (this.eat(types$12._default)) {
          this.checkExport(exports3, "default", this.lastTokStart);
          node2.declaration = this.parseExportDefaultDeclaration();
          return this.finishNode(node2, "ExportDefaultDeclaration");
        }
        if (this.shouldParseExportStatement()) {
          node2.declaration = this.parseExportDeclaration(node2);
          if (node2.declaration.type === "VariableDeclaration") {
            this.checkVariableExport(exports3, node2.declaration.declarations);
          } else {
            this.checkExport(exports3, node2.declaration.id, node2.declaration.id.start);
          }
          node2.specifiers = [];
          node2.source = null;
        } else {
          node2.declaration = null;
          node2.specifiers = this.parseExportSpecifiers(exports3);
          if (this.eatContextual("from")) {
            if (this.type !== types$12.string) {
              this.unexpected();
            }
            node2.source = this.parseExprAtom();
            if (this.options.ecmaVersion >= 16) {
              node2.attributes = this.parseWithClause();
            }
          } else {
            for (var i4 = 0, list5 = node2.specifiers; i4 < list5.length; i4 += 1) {
              var spec = list5[i4];
              this.checkUnreserved(spec.local);
              this.checkLocalExport(spec.local);
              if (spec.local.type === "Literal") {
                this.raise(spec.local.start, "A string literal cannot be used as an exported binding without `from`.");
              }
            }
            node2.source = null;
          }
          this.semicolon();
        }
        return this.finishNode(node2, "ExportNamedDeclaration");
      };
      pp$82.parseExportDeclaration = function(node2) {
        return this.parseStatement(null);
      };
      pp$82.parseExportDefaultDeclaration = function() {
        var isAsync;
        if (this.type === types$12._function || (isAsync = this.isAsyncFunction())) {
          var fNode = this.startNode();
          this.next();
          if (isAsync) {
            this.next();
          }
          return this.parseFunction(fNode, FUNC_STATEMENT2 | FUNC_NULLABLE_ID2, false, isAsync);
        } else if (this.type === types$12._class) {
          var cNode = this.startNode();
          return this.parseClass(cNode, "nullableID");
        } else {
          var declaration = this.parseMaybeAssign();
          this.semicolon();
          return declaration;
        }
      };
      pp$82.checkExport = function(exports3, name2, pos) {
        if (!exports3) {
          return;
        }
        if (typeof name2 !== "string") {
          name2 = name2.type === "Identifier" ? name2.name : name2.value;
        }
        if (hasOwn2(exports3, name2)) {
          this.raiseRecoverable(pos, "Duplicate export '" + name2 + "'");
        }
        exports3[name2] = true;
      };
      pp$82.checkPatternExport = function(exports3, pat) {
        var type2 = pat.type;
        if (type2 === "Identifier") {
          this.checkExport(exports3, pat, pat.start);
        } else if (type2 === "ObjectPattern") {
          for (var i4 = 0, list5 = pat.properties; i4 < list5.length; i4 += 1) {
            var prop2 = list5[i4];
            this.checkPatternExport(exports3, prop2);
          }
        } else if (type2 === "ArrayPattern") {
          for (var i$1 = 0, list$1 = pat.elements; i$1 < list$1.length; i$1 += 1) {
            var elt = list$1[i$1];
            if (elt) {
              this.checkPatternExport(exports3, elt);
            }
          }
        } else if (type2 === "Property") {
          this.checkPatternExport(exports3, pat.value);
        } else if (type2 === "AssignmentPattern") {
          this.checkPatternExport(exports3, pat.left);
        } else if (type2 === "RestElement") {
          this.checkPatternExport(exports3, pat.argument);
        }
      };
      pp$82.checkVariableExport = function(exports3, decls) {
        if (!exports3) {
          return;
        }
        for (var i4 = 0, list5 = decls; i4 < list5.length; i4 += 1) {
          var decl = list5[i4];
          this.checkPatternExport(exports3, decl.id);
        }
      };
      pp$82.shouldParseExportStatement = function() {
        return this.type.keyword === "var" || this.type.keyword === "const" || this.type.keyword === "class" || this.type.keyword === "function" || this.isLet() || this.isAsyncFunction();
      };
      pp$82.parseExportSpecifier = function(exports3) {
        var node2 = this.startNode();
        node2.local = this.parseModuleExportName();
        node2.exported = this.eatContextual("as") ? this.parseModuleExportName() : node2.local;
        this.checkExport(
          exports3,
          node2.exported,
          node2.exported.start
        );
        return this.finishNode(node2, "ExportSpecifier");
      };
      pp$82.parseExportSpecifiers = function(exports3) {
        var nodes = [], first = true;
        this.expect(types$12.braceL);
        while (!this.eat(types$12.braceR)) {
          if (!first) {
            this.expect(types$12.comma);
            if (this.afterTrailingComma(types$12.braceR)) {
              break;
            }
          } else {
            first = false;
          }
          nodes.push(this.parseExportSpecifier(exports3));
        }
        return nodes;
      };
      pp$82.parseImport = function(node2) {
        this.next();
        if (this.type === types$12.string) {
          node2.specifiers = empty$12;
          node2.source = this.parseExprAtom();
        } else {
          node2.specifiers = this.parseImportSpecifiers();
          this.expectContextual("from");
          node2.source = this.type === types$12.string ? this.parseExprAtom() : this.unexpected();
        }
        if (this.options.ecmaVersion >= 16) {
          node2.attributes = this.parseWithClause();
        }
        this.semicolon();
        return this.finishNode(node2, "ImportDeclaration");
      };
      pp$82.parseImportSpecifier = function() {
        var node2 = this.startNode();
        node2.imported = this.parseModuleExportName();
        if (this.eatContextual("as")) {
          node2.local = this.parseIdent();
        } else {
          this.checkUnreserved(node2.imported);
          node2.local = node2.imported;
        }
        this.checkLValSimple(node2.local, BIND_LEXICAL2);
        return this.finishNode(node2, "ImportSpecifier");
      };
      pp$82.parseImportDefaultSpecifier = function() {
        var node2 = this.startNode();
        node2.local = this.parseIdent();
        this.checkLValSimple(node2.local, BIND_LEXICAL2);
        return this.finishNode(node2, "ImportDefaultSpecifier");
      };
      pp$82.parseImportNamespaceSpecifier = function() {
        var node2 = this.startNode();
        this.next();
        this.expectContextual("as");
        node2.local = this.parseIdent();
        this.checkLValSimple(node2.local, BIND_LEXICAL2);
        return this.finishNode(node2, "ImportNamespaceSpecifier");
      };
      pp$82.parseImportSpecifiers = function() {
        var nodes = [], first = true;
        if (this.type === types$12.name) {
          nodes.push(this.parseImportDefaultSpecifier());
          if (!this.eat(types$12.comma)) {
            return nodes;
          }
        }
        if (this.type === types$12.star) {
          nodes.push(this.parseImportNamespaceSpecifier());
          return nodes;
        }
        this.expect(types$12.braceL);
        while (!this.eat(types$12.braceR)) {
          if (!first) {
            this.expect(types$12.comma);
            if (this.afterTrailingComma(types$12.braceR)) {
              break;
            }
          } else {
            first = false;
          }
          nodes.push(this.parseImportSpecifier());
        }
        return nodes;
      };
      pp$82.parseWithClause = function() {
        var nodes = [];
        if (!this.eat(types$12._with)) {
          return nodes;
        }
        this.expect(types$12.braceL);
        var attributeKeys = {};
        var first = true;
        while (!this.eat(types$12.braceR)) {
          if (!first) {
            this.expect(types$12.comma);
            if (this.afterTrailingComma(types$12.braceR)) {
              break;
            }
          } else {
            first = false;
          }
          var attr = this.parseImportAttribute();
          var keyName = attr.key.type === "Identifier" ? attr.key.name : attr.key.value;
          if (hasOwn2(attributeKeys, keyName)) {
            this.raiseRecoverable(attr.key.start, "Duplicate attribute key '" + keyName + "'");
          }
          attributeKeys[keyName] = true;
          nodes.push(attr);
        }
        return nodes;
      };
      pp$82.parseImportAttribute = function() {
        var node2 = this.startNode();
        node2.key = this.type === types$12.string ? this.parseExprAtom() : this.parseIdent(this.options.allowReserved !== "never");
        this.expect(types$12.colon);
        if (this.type !== types$12.string) {
          this.unexpected();
        }
        node2.value = this.parseExprAtom();
        return this.finishNode(node2, "ImportAttribute");
      };
      pp$82.parseModuleExportName = function() {
        if (this.options.ecmaVersion >= 13 && this.type === types$12.string) {
          var stringLiteral = this.parseLiteral(this.value);
          if (loneSurrogate2.test(stringLiteral.value)) {
            this.raise(stringLiteral.start, "An export name cannot include a lone surrogate.");
          }
          return stringLiteral;
        }
        return this.parseIdent(true);
      };
      pp$82.adaptDirectivePrologue = function(statements) {
        for (var i4 = 0; i4 < statements.length && this.isDirectiveCandidate(statements[i4]); ++i4) {
          statements[i4].directive = statements[i4].expression.raw.slice(1, -1);
        }
      };
      pp$82.isDirectiveCandidate = function(statement) {
        return this.options.ecmaVersion >= 5 && statement.type === "ExpressionStatement" && statement.expression.type === "Literal" && typeof statement.expression.value === "string" && // Reject parenthesized strings.
        (this.input[statement.start] === '"' || this.input[statement.start] === "'");
      };
      var pp$72 = Parser3.prototype;
      pp$72.toAssignable = function(node2, isBinding, refDestructuringErrors) {
        if (this.options.ecmaVersion >= 6 && node2) {
          switch (node2.type) {
            case "Identifier":
              if (this.inAsync && node2.name === "await") {
                this.raise(node2.start, "Cannot use 'await' as identifier inside an async function");
              }
              break;
            case "ObjectPattern":
            case "ArrayPattern":
            case "AssignmentPattern":
            case "RestElement":
              break;
            case "ObjectExpression":
              node2.type = "ObjectPattern";
              if (refDestructuringErrors) {
                this.checkPatternErrors(refDestructuringErrors, true);
              }
              for (var i4 = 0, list5 = node2.properties; i4 < list5.length; i4 += 1) {
                var prop2 = list5[i4];
                this.toAssignable(prop2, isBinding);
                if (prop2.type === "RestElement" && (prop2.argument.type === "ArrayPattern" || prop2.argument.type === "ObjectPattern")) {
                  this.raise(prop2.argument.start, "Unexpected token");
                }
              }
              break;
            case "Property":
              if (node2.kind !== "init") {
                this.raise(node2.key.start, "Object pattern can't contain getter or setter");
              }
              this.toAssignable(node2.value, isBinding);
              break;
            case "ArrayExpression":
              node2.type = "ArrayPattern";
              if (refDestructuringErrors) {
                this.checkPatternErrors(refDestructuringErrors, true);
              }
              this.toAssignableList(node2.elements, isBinding);
              break;
            case "SpreadElement":
              node2.type = "RestElement";
              this.toAssignable(node2.argument, isBinding);
              if (node2.argument.type === "AssignmentPattern") {
                this.raise(node2.argument.start, "Rest elements cannot have a default value");
              }
              break;
            case "AssignmentExpression":
              if (node2.operator !== "=") {
                this.raise(node2.left.end, "Only '=' operator can be used for specifying default value.");
              }
              node2.type = "AssignmentPattern";
              delete node2.operator;
              this.toAssignable(node2.left, isBinding);
              break;
            case "ParenthesizedExpression":
              this.toAssignable(node2.expression, isBinding, refDestructuringErrors);
              break;
            case "ChainExpression":
              this.raiseRecoverable(node2.start, "Optional chaining cannot appear in left-hand side");
              break;
            case "MemberExpression":
              if (!isBinding) {
                break;
              }
            default:
              this.raise(node2.start, "Assigning to rvalue");
          }
        } else if (refDestructuringErrors) {
          this.checkPatternErrors(refDestructuringErrors, true);
        }
        return node2;
      };
      pp$72.toAssignableList = function(exprList, isBinding) {
        var end = exprList.length;
        for (var i4 = 0; i4 < end; i4++) {
          var elt = exprList[i4];
          if (elt) {
            this.toAssignable(elt, isBinding);
          }
        }
        if (end) {
          var last = exprList[end - 1];
          if (this.options.ecmaVersion === 6 && isBinding && last && last.type === "RestElement" && last.argument.type !== "Identifier") {
            this.unexpected(last.argument.start);
          }
        }
        return exprList;
      };
      pp$72.parseSpread = function(refDestructuringErrors) {
        var node2 = this.startNode();
        this.next();
        node2.argument = this.parseMaybeAssign(false, refDestructuringErrors);
        return this.finishNode(node2, "SpreadElement");
      };
      pp$72.parseRestBinding = function() {
        var node2 = this.startNode();
        this.next();
        if (this.options.ecmaVersion === 6 && this.type !== types$12.name) {
          this.unexpected();
        }
        node2.argument = this.parseBindingAtom();
        return this.finishNode(node2, "RestElement");
      };
      pp$72.parseBindingAtom = function() {
        if (this.options.ecmaVersion >= 6) {
          switch (this.type) {
            case types$12.bracketL:
              var node2 = this.startNode();
              this.next();
              node2.elements = this.parseBindingList(types$12.bracketR, true, true);
              return this.finishNode(node2, "ArrayPattern");
            case types$12.braceL:
              return this.parseObj(true);
          }
        }
        return this.parseIdent();
      };
      pp$72.parseBindingList = function(close2, allowEmpty, allowTrailingComma, allowModifiers) {
        var elts = [], first = true;
        while (!this.eat(close2)) {
          if (first) {
            first = false;
          } else {
            this.expect(types$12.comma);
          }
          if (allowEmpty && this.type === types$12.comma) {
            elts.push(null);
          } else if (allowTrailingComma && this.afterTrailingComma(close2)) {
            break;
          } else if (this.type === types$12.ellipsis) {
            var rest = this.parseRestBinding();
            this.parseBindingListItem(rest);
            elts.push(rest);
            if (this.type === types$12.comma) {
              this.raiseRecoverable(this.start, "Comma is not permitted after the rest element");
            }
            this.expect(close2);
            break;
          } else {
            elts.push(this.parseAssignableListItem(allowModifiers));
          }
        }
        return elts;
      };
      pp$72.parseAssignableListItem = function(allowModifiers) {
        var elem = this.parseMaybeDefault(this.start, this.startLoc);
        this.parseBindingListItem(elem);
        return elem;
      };
      pp$72.parseBindingListItem = function(param) {
        return param;
      };
      pp$72.parseMaybeDefault = function(startPos, startLoc, left) {
        left = left || this.parseBindingAtom();
        if (this.options.ecmaVersion < 6 || !this.eat(types$12.eq)) {
          return left;
        }
        var node2 = this.startNodeAt(startPos, startLoc);
        node2.left = left;
        node2.right = this.parseMaybeAssign();
        return this.finishNode(node2, "AssignmentPattern");
      };
      pp$72.checkLValSimple = function(expr, bindingType, checkClashes) {
        if (bindingType === void 0) bindingType = BIND_NONE2;
        var isBind = bindingType !== BIND_NONE2;
        switch (expr.type) {
          case "Identifier":
            if (this.strict && this.reservedWordsStrictBind.test(expr.name)) {
              this.raiseRecoverable(expr.start, (isBind ? "Binding " : "Assigning to ") + expr.name + " in strict mode");
            }
            if (isBind) {
              if (bindingType === BIND_LEXICAL2 && expr.name === "let") {
                this.raiseRecoverable(expr.start, "let is disallowed as a lexically bound name");
              }
              if (checkClashes) {
                if (hasOwn2(checkClashes, expr.name)) {
                  this.raiseRecoverable(expr.start, "Argument name clash");
                }
                checkClashes[expr.name] = true;
              }
              if (bindingType !== BIND_OUTSIDE2) {
                this.declareName(expr.name, bindingType, expr.start);
              }
            }
            break;
          case "ChainExpression":
            this.raiseRecoverable(expr.start, "Optional chaining cannot appear in left-hand side");
            break;
          case "MemberExpression":
            if (isBind) {
              this.raiseRecoverable(expr.start, "Binding member expression");
            }
            break;
          case "ParenthesizedExpression":
            if (isBind) {
              this.raiseRecoverable(expr.start, "Binding parenthesized expression");
            }
            return this.checkLValSimple(expr.expression, bindingType, checkClashes);
          default:
            this.raise(expr.start, (isBind ? "Binding" : "Assigning to") + " rvalue");
        }
      };
      pp$72.checkLValPattern = function(expr, bindingType, checkClashes) {
        if (bindingType === void 0) bindingType = BIND_NONE2;
        switch (expr.type) {
          case "ObjectPattern":
            for (var i4 = 0, list5 = expr.properties; i4 < list5.length; i4 += 1) {
              var prop2 = list5[i4];
              this.checkLValInnerPattern(prop2, bindingType, checkClashes);
            }
            break;
          case "ArrayPattern":
            for (var i$1 = 0, list$1 = expr.elements; i$1 < list$1.length; i$1 += 1) {
              var elem = list$1[i$1];
              if (elem) {
                this.checkLValInnerPattern(elem, bindingType, checkClashes);
              }
            }
            break;
          default:
            this.checkLValSimple(expr, bindingType, checkClashes);
        }
      };
      pp$72.checkLValInnerPattern = function(expr, bindingType, checkClashes) {
        if (bindingType === void 0) bindingType = BIND_NONE2;
        switch (expr.type) {
          case "Property":
            this.checkLValInnerPattern(expr.value, bindingType, checkClashes);
            break;
          case "AssignmentPattern":
            this.checkLValPattern(expr.left, bindingType, checkClashes);
            break;
          case "RestElement":
            this.checkLValPattern(expr.argument, bindingType, checkClashes);
            break;
          default:
            this.checkLValPattern(expr, bindingType, checkClashes);
        }
      };
      var TokContext3 = function TokContext4(token, isExpr, preserveSpace, override, generator) {
        this.token = token;
        this.isExpr = !!isExpr;
        this.preserveSpace = !!preserveSpace;
        this.override = override;
        this.generator = !!generator;
      };
      var types4 = {
        b_stat: new TokContext3("{", false),
        b_expr: new TokContext3("{", true),
        b_tmpl: new TokContext3("${", false),
        p_stat: new TokContext3("(", false),
        p_expr: new TokContext3("(", true),
        q_tmpl: new TokContext3("`", true, true, function(p2) {
          return p2.tryReadTemplateToken();
        }),
        f_stat: new TokContext3("function", false),
        f_expr: new TokContext3("function", true),
        f_expr_gen: new TokContext3("function", true, false, null, true),
        f_gen: new TokContext3("function", false, false, null, true)
      };
      var pp$62 = Parser3.prototype;
      pp$62.initialContext = function() {
        return [types4.b_stat];
      };
      pp$62.curContext = function() {
        return this.context[this.context.length - 1];
      };
      pp$62.braceIsBlock = function(prevType) {
        var parent = this.curContext();
        if (parent === types4.f_expr || parent === types4.f_stat) {
          return true;
        }
        if (prevType === types$12.colon && (parent === types4.b_stat || parent === types4.b_expr)) {
          return !parent.isExpr;
        }
        if (prevType === types$12._return || prevType === types$12.name && this.exprAllowed) {
          return lineBreak2.test(this.input.slice(this.lastTokEnd, this.start));
        }
        if (prevType === types$12._else || prevType === types$12.semi || prevType === types$12.eof || prevType === types$12.parenR || prevType === types$12.arrow) {
          return true;
        }
        if (prevType === types$12.braceL) {
          return parent === types4.b_stat;
        }
        if (prevType === types$12._var || prevType === types$12._const || prevType === types$12.name) {
          return false;
        }
        return !this.exprAllowed;
      };
      pp$62.inGeneratorContext = function() {
        for (var i4 = this.context.length - 1; i4 >= 1; i4--) {
          var context = this.context[i4];
          if (context.token === "function") {
            return context.generator;
          }
        }
        return false;
      };
      pp$62.updateContext = function(prevType) {
        var update, type2 = this.type;
        if (type2.keyword && prevType === types$12.dot) {
          this.exprAllowed = false;
        } else if (update = type2.updateContext) {
          update.call(this, prevType);
        } else {
          this.exprAllowed = type2.beforeExpr;
        }
      };
      pp$62.overrideContext = function(tokenCtx) {
        if (this.curContext() !== tokenCtx) {
          this.context[this.context.length - 1] = tokenCtx;
        }
      };
      types$12.parenR.updateContext = types$12.braceR.updateContext = function() {
        if (this.context.length === 1) {
          this.exprAllowed = true;
          return;
        }
        var out = this.context.pop();
        if (out === types4.b_stat && this.curContext().token === "function") {
          out = this.context.pop();
        }
        this.exprAllowed = !out.isExpr;
      };
      types$12.braceL.updateContext = function(prevType) {
        this.context.push(this.braceIsBlock(prevType) ? types4.b_stat : types4.b_expr);
        this.exprAllowed = true;
      };
      types$12.dollarBraceL.updateContext = function() {
        this.context.push(types4.b_tmpl);
        this.exprAllowed = true;
      };
      types$12.parenL.updateContext = function(prevType) {
        var statementParens = prevType === types$12._if || prevType === types$12._for || prevType === types$12._with || prevType === types$12._while;
        this.context.push(statementParens ? types4.p_stat : types4.p_expr);
        this.exprAllowed = true;
      };
      types$12.incDec.updateContext = function() {
      };
      types$12._function.updateContext = types$12._class.updateContext = function(prevType) {
        if (prevType.beforeExpr && prevType !== types$12._else && !(prevType === types$12.semi && this.curContext() !== types4.p_stat) && !(prevType === types$12._return && lineBreak2.test(this.input.slice(this.lastTokEnd, this.start))) && !((prevType === types$12.colon || prevType === types$12.braceL) && this.curContext() === types4.b_stat)) {
          this.context.push(types4.f_expr);
        } else {
          this.context.push(types4.f_stat);
        }
        this.exprAllowed = false;
      };
      types$12.colon.updateContext = function() {
        if (this.curContext().token === "function") {
          this.context.pop();
        }
        this.exprAllowed = true;
      };
      types$12.backQuote.updateContext = function() {
        if (this.curContext() === types4.q_tmpl) {
          this.context.pop();
        } else {
          this.context.push(types4.q_tmpl);
        }
        this.exprAllowed = false;
      };
      types$12.star.updateContext = function(prevType) {
        if (prevType === types$12._function) {
          var index3 = this.context.length - 1;
          if (this.context[index3] === types4.f_expr) {
            this.context[index3] = types4.f_expr_gen;
          } else {
            this.context[index3] = types4.f_gen;
          }
        }
        this.exprAllowed = true;
      };
      types$12.name.updateContext = function(prevType) {
        var allowed = false;
        if (this.options.ecmaVersion >= 6 && prevType !== types$12.dot) {
          if (this.value === "of" && !this.exprAllowed || this.value === "yield" && this.inGeneratorContext()) {
            allowed = true;
          }
        }
        this.exprAllowed = allowed;
      };
      var pp$52 = Parser3.prototype;
      pp$52.checkPropClash = function(prop2, propHash, refDestructuringErrors) {
        if (this.options.ecmaVersion >= 9 && prop2.type === "SpreadElement") {
          return;
        }
        if (this.options.ecmaVersion >= 6 && (prop2.computed || prop2.method || prop2.shorthand)) {
          return;
        }
        var key2 = prop2.key;
        var name2;
        switch (key2.type) {
          case "Identifier":
            name2 = key2.name;
            break;
          case "Literal":
            name2 = String(key2.value);
            break;
          default:
            return;
        }
        var kind = prop2.kind;
        if (this.options.ecmaVersion >= 6) {
          if (name2 === "__proto__" && kind === "init") {
            if (propHash.proto) {
              if (refDestructuringErrors) {
                if (refDestructuringErrors.doubleProto < 0) {
                  refDestructuringErrors.doubleProto = key2.start;
                }
              } else {
                this.raiseRecoverable(key2.start, "Redefinition of __proto__ property");
              }
            }
            propHash.proto = true;
          }
          return;
        }
        name2 = "$" + name2;
        var other = propHash[name2];
        if (other) {
          var redefinition;
          if (kind === "init") {
            redefinition = this.strict && other.init || other.get || other.set;
          } else {
            redefinition = other.init || other[kind];
          }
          if (redefinition) {
            this.raiseRecoverable(key2.start, "Redefinition of property");
          }
        } else {
          other = propHash[name2] = {
            init: false,
            get: false,
            set: false
          };
        }
        other[kind] = true;
      };
      pp$52.parseExpression = function(forInit, refDestructuringErrors) {
        var startPos = this.start, startLoc = this.startLoc;
        var expr = this.parseMaybeAssign(forInit, refDestructuringErrors);
        if (this.type === types$12.comma) {
          var node2 = this.startNodeAt(startPos, startLoc);
          node2.expressions = [expr];
          while (this.eat(types$12.comma)) {
            node2.expressions.push(this.parseMaybeAssign(forInit, refDestructuringErrors));
          }
          return this.finishNode(node2, "SequenceExpression");
        }
        return expr;
      };
      pp$52.parseMaybeAssign = function(forInit, refDestructuringErrors, afterLeftParse) {
        if (this.isContextual("yield")) {
          if (this.inGenerator) {
            return this.parseYield(forInit);
          } else {
            this.exprAllowed = false;
          }
        }
        var ownDestructuringErrors = false, oldParenAssign = -1, oldTrailingComma = -1, oldDoubleProto = -1;
        if (refDestructuringErrors) {
          oldParenAssign = refDestructuringErrors.parenthesizedAssign;
          oldTrailingComma = refDestructuringErrors.trailingComma;
          oldDoubleProto = refDestructuringErrors.doubleProto;
          refDestructuringErrors.parenthesizedAssign = refDestructuringErrors.trailingComma = -1;
        } else {
          refDestructuringErrors = new DestructuringErrors3();
          ownDestructuringErrors = true;
        }
        var startPos = this.start, startLoc = this.startLoc;
        if (this.type === types$12.parenL || this.type === types$12.name) {
          this.potentialArrowAt = this.start;
          this.potentialArrowInForAwait = forInit === "await";
        }
        var left = this.parseMaybeConditional(forInit, refDestructuringErrors);
        if (afterLeftParse) {
          left = afterLeftParse.call(this, left, startPos, startLoc);
        }
        if (this.type.isAssign) {
          var node2 = this.startNodeAt(startPos, startLoc);
          node2.operator = this.value;
          if (this.type === types$12.eq) {
            left = this.toAssignable(left, false, refDestructuringErrors);
          }
          if (!ownDestructuringErrors) {
            refDestructuringErrors.parenthesizedAssign = refDestructuringErrors.trailingComma = refDestructuringErrors.doubleProto = -1;
          }
          if (refDestructuringErrors.shorthandAssign >= left.start) {
            refDestructuringErrors.shorthandAssign = -1;
          }
          if (this.type === types$12.eq) {
            this.checkLValPattern(left);
          } else {
            this.checkLValSimple(left);
          }
          node2.left = left;
          this.next();
          node2.right = this.parseMaybeAssign(forInit);
          if (oldDoubleProto > -1) {
            refDestructuringErrors.doubleProto = oldDoubleProto;
          }
          return this.finishNode(node2, "AssignmentExpression");
        } else {
          if (ownDestructuringErrors) {
            this.checkExpressionErrors(refDestructuringErrors, true);
          }
        }
        if (oldParenAssign > -1) {
          refDestructuringErrors.parenthesizedAssign = oldParenAssign;
        }
        if (oldTrailingComma > -1) {
          refDestructuringErrors.trailingComma = oldTrailingComma;
        }
        return left;
      };
      pp$52.parseMaybeConditional = function(forInit, refDestructuringErrors) {
        var startPos = this.start, startLoc = this.startLoc;
        var expr = this.parseExprOps(forInit, refDestructuringErrors);
        if (this.checkExpressionErrors(refDestructuringErrors)) {
          return expr;
        }
        if (this.eat(types$12.question)) {
          var node2 = this.startNodeAt(startPos, startLoc);
          node2.test = expr;
          node2.consequent = this.parseMaybeAssign();
          this.expect(types$12.colon);
          node2.alternate = this.parseMaybeAssign(forInit);
          return this.finishNode(node2, "ConditionalExpression");
        }
        return expr;
      };
      pp$52.parseExprOps = function(forInit, refDestructuringErrors) {
        var startPos = this.start, startLoc = this.startLoc;
        var expr = this.parseMaybeUnary(refDestructuringErrors, false, false, forInit);
        if (this.checkExpressionErrors(refDestructuringErrors)) {
          return expr;
        }
        return expr.start === startPos && expr.type === "ArrowFunctionExpression" ? expr : this.parseExprOp(expr, startPos, startLoc, -1, forInit);
      };
      pp$52.parseExprOp = function(left, leftStartPos, leftStartLoc, minPrec, forInit) {
        var prec = this.type.binop;
        if (prec != null && (!forInit || this.type !== types$12._in)) {
          if (prec > minPrec) {
            var logical = this.type === types$12.logicalOR || this.type === types$12.logicalAND;
            var coalesce = this.type === types$12.coalesce;
            if (coalesce) {
              prec = types$12.logicalAND.binop;
            }
            var op = this.value;
            this.next();
            var startPos = this.start, startLoc = this.startLoc;
            var right = this.parseExprOp(this.parseMaybeUnary(null, false, false, forInit), startPos, startLoc, prec, forInit);
            var node2 = this.buildBinary(leftStartPos, leftStartLoc, left, right, op, logical || coalesce);
            if (logical && this.type === types$12.coalesce || coalesce && (this.type === types$12.logicalOR || this.type === types$12.logicalAND)) {
              this.raiseRecoverable(this.start, "Logical expressions and coalesce expressions cannot be mixed. Wrap either by parentheses");
            }
            return this.parseExprOp(node2, leftStartPos, leftStartLoc, minPrec, forInit);
          }
        }
        return left;
      };
      pp$52.buildBinary = function(startPos, startLoc, left, right, op, logical) {
        if (right.type === "PrivateIdentifier") {
          this.raise(right.start, "Private identifier can only be left side of binary expression");
        }
        var node2 = this.startNodeAt(startPos, startLoc);
        node2.left = left;
        node2.operator = op;
        node2.right = right;
        return this.finishNode(node2, logical ? "LogicalExpression" : "BinaryExpression");
      };
      pp$52.parseMaybeUnary = function(refDestructuringErrors, sawUnary, incDec, forInit) {
        var startPos = this.start, startLoc = this.startLoc, expr;
        if (this.isContextual("await") && this.canAwait) {
          expr = this.parseAwait(forInit);
          sawUnary = true;
        } else if (this.type.prefix) {
          var node2 = this.startNode(), update = this.type === types$12.incDec;
          node2.operator = this.value;
          node2.prefix = true;
          this.next();
          node2.argument = this.parseMaybeUnary(null, true, update, forInit);
          this.checkExpressionErrors(refDestructuringErrors, true);
          if (update) {
            this.checkLValSimple(node2.argument);
          } else if (this.strict && node2.operator === "delete" && isLocalVariableAccess2(node2.argument)) {
            this.raiseRecoverable(node2.start, "Deleting local variable in strict mode");
          } else if (node2.operator === "delete" && isPrivateFieldAccess2(node2.argument)) {
            this.raiseRecoverable(node2.start, "Private fields can not be deleted");
          } else {
            sawUnary = true;
          }
          expr = this.finishNode(node2, update ? "UpdateExpression" : "UnaryExpression");
        } else if (!sawUnary && this.type === types$12.privateId) {
          if ((forInit || this.privateNameStack.length === 0) && this.options.checkPrivateFields) {
            this.unexpected();
          }
          expr = this.parsePrivateIdent();
          if (this.type !== types$12._in) {
            this.unexpected();
          }
        } else {
          expr = this.parseExprSubscripts(refDestructuringErrors, forInit);
          if (this.checkExpressionErrors(refDestructuringErrors)) {
            return expr;
          }
          while (this.type.postfix && !this.canInsertSemicolon()) {
            var node$1 = this.startNodeAt(startPos, startLoc);
            node$1.operator = this.value;
            node$1.prefix = false;
            node$1.argument = expr;
            this.checkLValSimple(expr);
            this.next();
            expr = this.finishNode(node$1, "UpdateExpression");
          }
        }
        if (!incDec && this.eat(types$12.starstar)) {
          if (sawUnary) {
            this.unexpected(this.lastTokStart);
          } else {
            return this.buildBinary(startPos, startLoc, expr, this.parseMaybeUnary(null, false, false, forInit), "**", false);
          }
        } else {
          return expr;
        }
      };
      function isLocalVariableAccess2(node2) {
        return node2.type === "Identifier" || node2.type === "ParenthesizedExpression" && isLocalVariableAccess2(node2.expression);
      }
      function isPrivateFieldAccess2(node2) {
        return node2.type === "MemberExpression" && node2.property.type === "PrivateIdentifier" || node2.type === "ChainExpression" && isPrivateFieldAccess2(node2.expression) || node2.type === "ParenthesizedExpression" && isPrivateFieldAccess2(node2.expression);
      }
      pp$52.parseExprSubscripts = function(refDestructuringErrors, forInit) {
        var startPos = this.start, startLoc = this.startLoc;
        var expr = this.parseExprAtom(refDestructuringErrors, forInit);
        if (expr.type === "ArrowFunctionExpression" && this.input.slice(this.lastTokStart, this.lastTokEnd) !== ")") {
          return expr;
        }
        var result = this.parseSubscripts(expr, startPos, startLoc, false, forInit);
        if (refDestructuringErrors && result.type === "MemberExpression") {
          if (refDestructuringErrors.parenthesizedAssign >= result.start) {
            refDestructuringErrors.parenthesizedAssign = -1;
          }
          if (refDestructuringErrors.parenthesizedBind >= result.start) {
            refDestructuringErrors.parenthesizedBind = -1;
          }
          if (refDestructuringErrors.trailingComma >= result.start) {
            refDestructuringErrors.trailingComma = -1;
          }
        }
        return result;
      };
      pp$52.parseSubscripts = function(base, startPos, startLoc, noCalls, forInit) {
        var maybeAsyncArrow = this.options.ecmaVersion >= 8 && base.type === "Identifier" && base.name === "async" && this.lastTokEnd === base.end && !this.canInsertSemicolon() && base.end - base.start === 5 && this.potentialArrowAt === base.start;
        var optionalChained = false;
        while (true) {
          var element2 = this.parseSubscript(base, startPos, startLoc, noCalls, maybeAsyncArrow, optionalChained, forInit);
          if (element2.optional) {
            optionalChained = true;
          }
          if (element2 === base || element2.type === "ArrowFunctionExpression") {
            if (optionalChained) {
              var chainNode = this.startNodeAt(startPos, startLoc);
              chainNode.expression = element2;
              element2 = this.finishNode(chainNode, "ChainExpression");
            }
            return element2;
          }
          base = element2;
        }
      };
      pp$52.shouldParseAsyncArrow = function() {
        return !this.canInsertSemicolon() && this.eat(types$12.arrow);
      };
      pp$52.parseSubscriptAsyncArrow = function(startPos, startLoc, exprList, forInit) {
        return this.parseArrowExpression(this.startNodeAt(startPos, startLoc), exprList, true, forInit);
      };
      pp$52.parseSubscript = function(base, startPos, startLoc, noCalls, maybeAsyncArrow, optionalChained, forInit) {
        var optionalSupported = this.options.ecmaVersion >= 11;
        var optional = optionalSupported && this.eat(types$12.questionDot);
        if (noCalls && optional) {
          this.raise(this.lastTokStart, "Optional chaining cannot appear in the callee of new expressions");
        }
        var computed = this.eat(types$12.bracketL);
        if (computed || optional && this.type !== types$12.parenL && this.type !== types$12.backQuote || this.eat(types$12.dot)) {
          var node2 = this.startNodeAt(startPos, startLoc);
          node2.object = base;
          if (computed) {
            node2.property = this.parseExpression();
            this.expect(types$12.bracketR);
          } else if (this.type === types$12.privateId && base.type !== "Super") {
            node2.property = this.parsePrivateIdent();
          } else {
            node2.property = this.parseIdent(this.options.allowReserved !== "never");
          }
          node2.computed = !!computed;
          if (optionalSupported) {
            node2.optional = optional;
          }
          base = this.finishNode(node2, "MemberExpression");
        } else if (!noCalls && this.eat(types$12.parenL)) {
          var refDestructuringErrors = new DestructuringErrors3(), oldYieldPos = this.yieldPos, oldAwaitPos = this.awaitPos, oldAwaitIdentPos = this.awaitIdentPos;
          this.yieldPos = 0;
          this.awaitPos = 0;
          this.awaitIdentPos = 0;
          var exprList = this.parseExprList(types$12.parenR, this.options.ecmaVersion >= 8, false, refDestructuringErrors);
          if (maybeAsyncArrow && !optional && this.shouldParseAsyncArrow()) {
            this.checkPatternErrors(refDestructuringErrors, false);
            this.checkYieldAwaitInDefaultParams();
            if (this.awaitIdentPos > 0) {
              this.raise(this.awaitIdentPos, "Cannot use 'await' as identifier inside an async function");
            }
            this.yieldPos = oldYieldPos;
            this.awaitPos = oldAwaitPos;
            this.awaitIdentPos = oldAwaitIdentPos;
            return this.parseSubscriptAsyncArrow(startPos, startLoc, exprList, forInit);
          }
          this.checkExpressionErrors(refDestructuringErrors, true);
          this.yieldPos = oldYieldPos || this.yieldPos;
          this.awaitPos = oldAwaitPos || this.awaitPos;
          this.awaitIdentPos = oldAwaitIdentPos || this.awaitIdentPos;
          var node$1 = this.startNodeAt(startPos, startLoc);
          node$1.callee = base;
          node$1.arguments = exprList;
          if (optionalSupported) {
            node$1.optional = optional;
          }
          base = this.finishNode(node$1, "CallExpression");
        } else if (this.type === types$12.backQuote) {
          if (optional || optionalChained) {
            this.raise(this.start, "Optional chaining cannot appear in the tag of tagged template expressions");
          }
          var node$2 = this.startNodeAt(startPos, startLoc);
          node$2.tag = base;
          node$2.quasi = this.parseTemplate({ isTagged: true });
          base = this.finishNode(node$2, "TaggedTemplateExpression");
        }
        return base;
      };
      pp$52.parseExprAtom = function(refDestructuringErrors, forInit, forNew) {
        if (this.type === types$12.slash) {
          this.readRegexp();
        }
        var node2, canBeArrow = this.potentialArrowAt === this.start;
        switch (this.type) {
          case types$12._super:
            if (!this.allowSuper) {
              this.raise(this.start, "'super' keyword outside a method");
            }
            node2 = this.startNode();
            this.next();
            if (this.type === types$12.parenL && !this.allowDirectSuper) {
              this.raise(node2.start, "super() call outside constructor of a subclass");
            }
            if (this.type !== types$12.dot && this.type !== types$12.bracketL && this.type !== types$12.parenL) {
              this.unexpected();
            }
            return this.finishNode(node2, "Super");
          case types$12._this:
            node2 = this.startNode();
            this.next();
            return this.finishNode(node2, "ThisExpression");
          case types$12.name:
            var startPos = this.start, startLoc = this.startLoc, containsEsc = this.containsEsc;
            var id = this.parseIdent(false);
            if (this.options.ecmaVersion >= 8 && !containsEsc && id.name === "async" && !this.canInsertSemicolon() && this.eat(types$12._function)) {
              this.overrideContext(types4.f_expr);
              return this.parseFunction(this.startNodeAt(startPos, startLoc), 0, false, true, forInit);
            }
            if (canBeArrow && !this.canInsertSemicolon()) {
              if (this.eat(types$12.arrow)) {
                return this.parseArrowExpression(this.startNodeAt(startPos, startLoc), [id], false, forInit);
              }
              if (this.options.ecmaVersion >= 8 && id.name === "async" && this.type === types$12.name && !containsEsc && (!this.potentialArrowInForAwait || this.value !== "of" || this.containsEsc)) {
                id = this.parseIdent(false);
                if (this.canInsertSemicolon() || !this.eat(types$12.arrow)) {
                  this.unexpected();
                }
                return this.parseArrowExpression(this.startNodeAt(startPos, startLoc), [id], true, forInit);
              }
            }
            return id;
          case types$12.regexp:
            var value2 = this.value;
            node2 = this.parseLiteral(value2.value);
            node2.regex = { pattern: value2.pattern, flags: value2.flags };
            return node2;
          case types$12.num:
          case types$12.string:
            return this.parseLiteral(this.value);
          case types$12._null:
          case types$12._true:
          case types$12._false:
            node2 = this.startNode();
            node2.value = this.type === types$12._null ? null : this.type === types$12._true;
            node2.raw = this.type.keyword;
            this.next();
            return this.finishNode(node2, "Literal");
          case types$12.parenL:
            var start2 = this.start, expr = this.parseParenAndDistinguishExpression(canBeArrow, forInit);
            if (refDestructuringErrors) {
              if (refDestructuringErrors.parenthesizedAssign < 0 && !this.isSimpleAssignTarget(expr)) {
                refDestructuringErrors.parenthesizedAssign = start2;
              }
              if (refDestructuringErrors.parenthesizedBind < 0) {
                refDestructuringErrors.parenthesizedBind = start2;
              }
            }
            return expr;
          case types$12.bracketL:
            node2 = this.startNode();
            this.next();
            node2.elements = this.parseExprList(types$12.bracketR, true, true, refDestructuringErrors);
            return this.finishNode(node2, "ArrayExpression");
          case types$12.braceL:
            this.overrideContext(types4.b_expr);
            return this.parseObj(false, refDestructuringErrors);
          case types$12._function:
            node2 = this.startNode();
            this.next();
            return this.parseFunction(node2, 0);
          case types$12._class:
            return this.parseClass(this.startNode(), false);
          case types$12._new:
            return this.parseNew();
          case types$12.backQuote:
            return this.parseTemplate();
          case types$12._import:
            if (this.options.ecmaVersion >= 11) {
              return this.parseExprImport(forNew);
            } else {
              return this.unexpected();
            }
          default:
            return this.parseExprAtomDefault();
        }
      };
      pp$52.parseExprAtomDefault = function() {
        this.unexpected();
      };
      pp$52.parseExprImport = function(forNew) {
        var node2 = this.startNode();
        if (this.containsEsc) {
          this.raiseRecoverable(this.start, "Escape sequence in keyword import");
        }
        this.next();
        if (this.type === types$12.parenL && !forNew) {
          return this.parseDynamicImport(node2);
        } else if (this.type === types$12.dot) {
          var meta = this.startNodeAt(node2.start, node2.loc && node2.loc.start);
          meta.name = "import";
          node2.meta = this.finishNode(meta, "Identifier");
          return this.parseImportMeta(node2);
        } else {
          this.unexpected();
        }
      };
      pp$52.parseDynamicImport = function(node2) {
        this.next();
        node2.source = this.parseMaybeAssign();
        if (this.options.ecmaVersion >= 16) {
          if (!this.eat(types$12.parenR)) {
            this.expect(types$12.comma);
            if (!this.afterTrailingComma(types$12.parenR)) {
              node2.options = this.parseMaybeAssign();
              if (!this.eat(types$12.parenR)) {
                this.expect(types$12.comma);
                if (!this.afterTrailingComma(types$12.parenR)) {
                  this.unexpected();
                }
              }
            } else {
              node2.options = null;
            }
          } else {
            node2.options = null;
          }
        } else {
          if (!this.eat(types$12.parenR)) {
            var errorPos = this.start;
            if (this.eat(types$12.comma) && this.eat(types$12.parenR)) {
              this.raiseRecoverable(errorPos, "Trailing comma is not allowed in import()");
            } else {
              this.unexpected(errorPos);
            }
          }
        }
        return this.finishNode(node2, "ImportExpression");
      };
      pp$52.parseImportMeta = function(node2) {
        this.next();
        var containsEsc = this.containsEsc;
        node2.property = this.parseIdent(true);
        if (node2.property.name !== "meta") {
          this.raiseRecoverable(node2.property.start, "The only valid meta property for import is 'import.meta'");
        }
        if (containsEsc) {
          this.raiseRecoverable(node2.start, "'import.meta' must not contain escaped characters");
        }
        if (this.options.sourceType !== "module" && !this.options.allowImportExportEverywhere) {
          this.raiseRecoverable(node2.start, "Cannot use 'import.meta' outside a module");
        }
        return this.finishNode(node2, "MetaProperty");
      };
      pp$52.parseLiteral = function(value2) {
        var node2 = this.startNode();
        node2.value = value2;
        node2.raw = this.input.slice(this.start, this.end);
        if (node2.raw.charCodeAt(node2.raw.length - 1) === 110) {
          node2.bigint = node2.raw.slice(0, -1).replace(/_/g, "");
        }
        this.next();
        return this.finishNode(node2, "Literal");
      };
      pp$52.parseParenExpression = function() {
        this.expect(types$12.parenL);
        var val = this.parseExpression();
        this.expect(types$12.parenR);
        return val;
      };
      pp$52.shouldParseArrow = function(exprList) {
        return !this.canInsertSemicolon();
      };
      pp$52.parseParenAndDistinguishExpression = function(canBeArrow, forInit) {
        var startPos = this.start, startLoc = this.startLoc, val, allowTrailingComma = this.options.ecmaVersion >= 8;
        if (this.options.ecmaVersion >= 6) {
          this.next();
          var innerStartPos = this.start, innerStartLoc = this.startLoc;
          var exprList = [], first = true, lastIsComma = false;
          var refDestructuringErrors = new DestructuringErrors3(), oldYieldPos = this.yieldPos, oldAwaitPos = this.awaitPos, spreadStart;
          this.yieldPos = 0;
          this.awaitPos = 0;
          while (this.type !== types$12.parenR) {
            first ? first = false : this.expect(types$12.comma);
            if (allowTrailingComma && this.afterTrailingComma(types$12.parenR, true)) {
              lastIsComma = true;
              break;
            } else if (this.type === types$12.ellipsis) {
              spreadStart = this.start;
              exprList.push(this.parseParenItem(this.parseRestBinding()));
              if (this.type === types$12.comma) {
                this.raiseRecoverable(
                  this.start,
                  "Comma is not permitted after the rest element"
                );
              }
              break;
            } else {
              exprList.push(this.parseMaybeAssign(false, refDestructuringErrors, this.parseParenItem));
            }
          }
          var innerEndPos = this.lastTokEnd, innerEndLoc = this.lastTokEndLoc;
          this.expect(types$12.parenR);
          if (canBeArrow && this.shouldParseArrow(exprList) && this.eat(types$12.arrow)) {
            this.checkPatternErrors(refDestructuringErrors, false);
            this.checkYieldAwaitInDefaultParams();
            this.yieldPos = oldYieldPos;
            this.awaitPos = oldAwaitPos;
            return this.parseParenArrowList(startPos, startLoc, exprList, forInit);
          }
          if (!exprList.length || lastIsComma) {
            this.unexpected(this.lastTokStart);
          }
          if (spreadStart) {
            this.unexpected(spreadStart);
          }
          this.checkExpressionErrors(refDestructuringErrors, true);
          this.yieldPos = oldYieldPos || this.yieldPos;
          this.awaitPos = oldAwaitPos || this.awaitPos;
          if (exprList.length > 1) {
            val = this.startNodeAt(innerStartPos, innerStartLoc);
            val.expressions = exprList;
            this.finishNodeAt(val, "SequenceExpression", innerEndPos, innerEndLoc);
          } else {
            val = exprList[0];
          }
        } else {
          val = this.parseParenExpression();
        }
        if (this.options.preserveParens) {
          var par = this.startNodeAt(startPos, startLoc);
          par.expression = val;
          return this.finishNode(par, "ParenthesizedExpression");
        } else {
          return val;
        }
      };
      pp$52.parseParenItem = function(item) {
        return item;
      };
      pp$52.parseParenArrowList = function(startPos, startLoc, exprList, forInit) {
        return this.parseArrowExpression(this.startNodeAt(startPos, startLoc), exprList, false, forInit);
      };
      var empty5 = [];
      pp$52.parseNew = function() {
        if (this.containsEsc) {
          this.raiseRecoverable(this.start, "Escape sequence in keyword new");
        }
        var node2 = this.startNode();
        this.next();
        if (this.options.ecmaVersion >= 6 && this.type === types$12.dot) {
          var meta = this.startNodeAt(node2.start, node2.loc && node2.loc.start);
          meta.name = "new";
          node2.meta = this.finishNode(meta, "Identifier");
          this.next();
          var containsEsc = this.containsEsc;
          node2.property = this.parseIdent(true);
          if (node2.property.name !== "target") {
            this.raiseRecoverable(node2.property.start, "The only valid meta property for new is 'new.target'");
          }
          if (containsEsc) {
            this.raiseRecoverable(node2.start, "'new.target' must not contain escaped characters");
          }
          if (!this.allowNewDotTarget) {
            this.raiseRecoverable(node2.start, "'new.target' can only be used in functions and class static block");
          }
          return this.finishNode(node2, "MetaProperty");
        }
        var startPos = this.start, startLoc = this.startLoc;
        node2.callee = this.parseSubscripts(this.parseExprAtom(null, false, true), startPos, startLoc, true, false);
        if (this.eat(types$12.parenL)) {
          node2.arguments = this.parseExprList(types$12.parenR, this.options.ecmaVersion >= 8, false);
        } else {
          node2.arguments = empty5;
        }
        return this.finishNode(node2, "NewExpression");
      };
      pp$52.parseTemplateElement = function(ref3) {
        var isTagged = ref3.isTagged;
        var elem = this.startNode();
        if (this.type === types$12.invalidTemplate) {
          if (!isTagged) {
            this.raiseRecoverable(this.start, "Bad escape sequence in untagged template literal");
          }
          elem.value = {
            raw: this.value.replace(/\r\n?/g, "\n"),
            cooked: null
          };
        } else {
          elem.value = {
            raw: this.input.slice(this.start, this.end).replace(/\r\n?/g, "\n"),
            cooked: this.value
          };
        }
        this.next();
        elem.tail = this.type === types$12.backQuote;
        return this.finishNode(elem, "TemplateElement");
      };
      pp$52.parseTemplate = function(ref3) {
        if (ref3 === void 0) ref3 = {};
        var isTagged = ref3.isTagged;
        if (isTagged === void 0) isTagged = false;
        var node2 = this.startNode();
        this.next();
        node2.expressions = [];
        var curElt = this.parseTemplateElement({ isTagged });
        node2.quasis = [curElt];
        while (!curElt.tail) {
          if (this.type === types$12.eof) {
            this.raise(this.pos, "Unterminated template literal");
          }
          this.expect(types$12.dollarBraceL);
          node2.expressions.push(this.parseExpression());
          this.expect(types$12.braceR);
          node2.quasis.push(curElt = this.parseTemplateElement({ isTagged }));
        }
        this.next();
        return this.finishNode(node2, "TemplateLiteral");
      };
      pp$52.isAsyncProp = function(prop2) {
        return !prop2.computed && prop2.key.type === "Identifier" && prop2.key.name === "async" && (this.type === types$12.name || this.type === types$12.num || this.type === types$12.string || this.type === types$12.bracketL || this.type.keyword || this.options.ecmaVersion >= 9 && this.type === types$12.star) && !lineBreak2.test(this.input.slice(this.lastTokEnd, this.start));
      };
      pp$52.parseObj = function(isPattern, refDestructuringErrors) {
        var node2 = this.startNode(), first = true, propHash = {};
        node2.properties = [];
        this.next();
        while (!this.eat(types$12.braceR)) {
          if (!first) {
            this.expect(types$12.comma);
            if (this.options.ecmaVersion >= 5 && this.afterTrailingComma(types$12.braceR)) {
              break;
            }
          } else {
            first = false;
          }
          var prop2 = this.parseProperty(isPattern, refDestructuringErrors);
          if (!isPattern) {
            this.checkPropClash(prop2, propHash, refDestructuringErrors);
          }
          node2.properties.push(prop2);
        }
        return this.finishNode(node2, isPattern ? "ObjectPattern" : "ObjectExpression");
      };
      pp$52.parseProperty = function(isPattern, refDestructuringErrors) {
        var prop2 = this.startNode(), isGenerator, isAsync, startPos, startLoc;
        if (this.options.ecmaVersion >= 9 && this.eat(types$12.ellipsis)) {
          if (isPattern) {
            prop2.argument = this.parseIdent(false);
            if (this.type === types$12.comma) {
              this.raiseRecoverable(this.start, "Comma is not permitted after the rest element");
            }
            return this.finishNode(prop2, "RestElement");
          }
          prop2.argument = this.parseMaybeAssign(false, refDestructuringErrors);
          if (this.type === types$12.comma && refDestructuringErrors && refDestructuringErrors.trailingComma < 0) {
            refDestructuringErrors.trailingComma = this.start;
          }
          return this.finishNode(prop2, "SpreadElement");
        }
        if (this.options.ecmaVersion >= 6) {
          prop2.method = false;
          prop2.shorthand = false;
          if (isPattern || refDestructuringErrors) {
            startPos = this.start;
            startLoc = this.startLoc;
          }
          if (!isPattern) {
            isGenerator = this.eat(types$12.star);
          }
        }
        var containsEsc = this.containsEsc;
        this.parsePropertyName(prop2);
        if (!isPattern && !containsEsc && this.options.ecmaVersion >= 8 && !isGenerator && this.isAsyncProp(prop2)) {
          isAsync = true;
          isGenerator = this.options.ecmaVersion >= 9 && this.eat(types$12.star);
          this.parsePropertyName(prop2);
        } else {
          isAsync = false;
        }
        this.parsePropertyValue(prop2, isPattern, isGenerator, isAsync, startPos, startLoc, refDestructuringErrors, containsEsc);
        return this.finishNode(prop2, "Property");
      };
      pp$52.parseGetterSetter = function(prop2) {
        prop2.kind = prop2.key.name;
        this.parsePropertyName(prop2);
        prop2.value = this.parseMethod(false);
        var paramCount = prop2.kind === "get" ? 0 : 1;
        if (prop2.value.params.length !== paramCount) {
          var start2 = prop2.value.start;
          if (prop2.kind === "get") {
            this.raiseRecoverable(start2, "getter should have no params");
          } else {
            this.raiseRecoverable(start2, "setter should have exactly one param");
          }
        } else {
          if (prop2.kind === "set" && prop2.value.params[0].type === "RestElement") {
            this.raiseRecoverable(prop2.value.params[0].start, "Setter cannot use rest params");
          }
        }
      };
      pp$52.parsePropertyValue = function(prop2, isPattern, isGenerator, isAsync, startPos, startLoc, refDestructuringErrors, containsEsc) {
        if ((isGenerator || isAsync) && this.type === types$12.colon) {
          this.unexpected();
        }
        if (this.eat(types$12.colon)) {
          prop2.value = isPattern ? this.parseMaybeDefault(this.start, this.startLoc) : this.parseMaybeAssign(false, refDestructuringErrors);
          prop2.kind = "init";
        } else if (this.options.ecmaVersion >= 6 && this.type === types$12.parenL) {
          if (isPattern) {
            this.unexpected();
          }
          prop2.kind = "init";
          prop2.method = true;
          prop2.value = this.parseMethod(isGenerator, isAsync);
        } else if (!isPattern && !containsEsc && this.options.ecmaVersion >= 5 && !prop2.computed && prop2.key.type === "Identifier" && (prop2.key.name === "get" || prop2.key.name === "set") && (this.type !== types$12.comma && this.type !== types$12.braceR && this.type !== types$12.eq)) {
          if (isGenerator || isAsync) {
            this.unexpected();
          }
          this.parseGetterSetter(prop2);
        } else if (this.options.ecmaVersion >= 6 && !prop2.computed && prop2.key.type === "Identifier") {
          if (isGenerator || isAsync) {
            this.unexpected();
          }
          this.checkUnreserved(prop2.key);
          if (prop2.key.name === "await" && !this.awaitIdentPos) {
            this.awaitIdentPos = startPos;
          }
          prop2.kind = "init";
          if (isPattern) {
            prop2.value = this.parseMaybeDefault(startPos, startLoc, this.copyNode(prop2.key));
          } else if (this.type === types$12.eq && refDestructuringErrors) {
            if (refDestructuringErrors.shorthandAssign < 0) {
              refDestructuringErrors.shorthandAssign = this.start;
            }
            prop2.value = this.parseMaybeDefault(startPos, startLoc, this.copyNode(prop2.key));
          } else {
            prop2.value = this.copyNode(prop2.key);
          }
          prop2.shorthand = true;
        } else {
          this.unexpected();
        }
      };
      pp$52.parsePropertyName = function(prop2) {
        if (this.options.ecmaVersion >= 6) {
          if (this.eat(types$12.bracketL)) {
            prop2.computed = true;
            prop2.key = this.parseMaybeAssign();
            this.expect(types$12.bracketR);
            return prop2.key;
          } else {
            prop2.computed = false;
          }
        }
        return prop2.key = this.type === types$12.num || this.type === types$12.string ? this.parseExprAtom() : this.parseIdent(this.options.allowReserved !== "never");
      };
      pp$52.initFunction = function(node2) {
        node2.id = null;
        if (this.options.ecmaVersion >= 6) {
          node2.generator = node2.expression = false;
        }
        if (this.options.ecmaVersion >= 8) {
          node2.async = false;
        }
      };
      pp$52.parseMethod = function(isGenerator, isAsync, allowDirectSuper) {
        var node2 = this.startNode(), oldYieldPos = this.yieldPos, oldAwaitPos = this.awaitPos, oldAwaitIdentPos = this.awaitIdentPos;
        this.initFunction(node2);
        if (this.options.ecmaVersion >= 6) {
          node2.generator = isGenerator;
        }
        if (this.options.ecmaVersion >= 8) {
          node2.async = !!isAsync;
        }
        this.yieldPos = 0;
        this.awaitPos = 0;
        this.awaitIdentPos = 0;
        this.enterScope(functionFlags2(isAsync, node2.generator) | SCOPE_SUPER2 | (allowDirectSuper ? SCOPE_DIRECT_SUPER2 : 0));
        this.expect(types$12.parenL);
        node2.params = this.parseBindingList(types$12.parenR, false, this.options.ecmaVersion >= 8);
        this.checkYieldAwaitInDefaultParams();
        this.parseFunctionBody(node2, false, true, false);
        this.yieldPos = oldYieldPos;
        this.awaitPos = oldAwaitPos;
        this.awaitIdentPos = oldAwaitIdentPos;
        return this.finishNode(node2, "FunctionExpression");
      };
      pp$52.parseArrowExpression = function(node2, params, isAsync, forInit) {
        var oldYieldPos = this.yieldPos, oldAwaitPos = this.awaitPos, oldAwaitIdentPos = this.awaitIdentPos;
        this.enterScope(functionFlags2(isAsync, false) | SCOPE_ARROW2);
        this.initFunction(node2);
        if (this.options.ecmaVersion >= 8) {
          node2.async = !!isAsync;
        }
        this.yieldPos = 0;
        this.awaitPos = 0;
        this.awaitIdentPos = 0;
        node2.params = this.toAssignableList(params, true);
        this.parseFunctionBody(node2, true, false, forInit);
        this.yieldPos = oldYieldPos;
        this.awaitPos = oldAwaitPos;
        this.awaitIdentPos = oldAwaitIdentPos;
        return this.finishNode(node2, "ArrowFunctionExpression");
      };
      pp$52.parseFunctionBody = function(node2, isArrowFunction, isMethod, forInit) {
        var isExpression = isArrowFunction && this.type !== types$12.braceL;
        var oldStrict = this.strict, useStrict = false;
        if (isExpression) {
          node2.body = this.parseMaybeAssign(forInit);
          node2.expression = true;
          this.checkParams(node2, false);
        } else {
          var nonSimple = this.options.ecmaVersion >= 7 && !this.isSimpleParamList(node2.params);
          if (!oldStrict || nonSimple) {
            useStrict = this.strictDirective(this.end);
            if (useStrict && nonSimple) {
              this.raiseRecoverable(node2.start, "Illegal 'use strict' directive in function with non-simple parameter list");
            }
          }
          var oldLabels = this.labels;
          this.labels = [];
          if (useStrict) {
            this.strict = true;
          }
          this.checkParams(node2, !oldStrict && !useStrict && !isArrowFunction && !isMethod && this.isSimpleParamList(node2.params));
          if (this.strict && node2.id) {
            this.checkLValSimple(node2.id, BIND_OUTSIDE2);
          }
          node2.body = this.parseBlock(false, void 0, useStrict && !oldStrict);
          node2.expression = false;
          this.adaptDirectivePrologue(node2.body.body);
          this.labels = oldLabels;
        }
        this.exitScope();
      };
      pp$52.isSimpleParamList = function(params) {
        for (var i4 = 0, list5 = params; i4 < list5.length; i4 += 1) {
          var param = list5[i4];
          if (param.type !== "Identifier") {
            return false;
          }
        }
        return true;
      };
      pp$52.checkParams = function(node2, allowDuplicates) {
        var nameHash = /* @__PURE__ */ Object.create(null);
        for (var i4 = 0, list5 = node2.params; i4 < list5.length; i4 += 1) {
          var param = list5[i4];
          this.checkLValInnerPattern(param, BIND_VAR2, allowDuplicates ? null : nameHash);
        }
      };
      pp$52.parseExprList = function(close2, allowTrailingComma, allowEmpty, refDestructuringErrors) {
        var elts = [], first = true;
        while (!this.eat(close2)) {
          if (!first) {
            this.expect(types$12.comma);
            if (allowTrailingComma && this.afterTrailingComma(close2)) {
              break;
            }
          } else {
            first = false;
          }
          var elt = void 0;
          if (allowEmpty && this.type === types$12.comma) {
            elt = null;
          } else if (this.type === types$12.ellipsis) {
            elt = this.parseSpread(refDestructuringErrors);
            if (refDestructuringErrors && this.type === types$12.comma && refDestructuringErrors.trailingComma < 0) {
              refDestructuringErrors.trailingComma = this.start;
            }
          } else {
            elt = this.parseMaybeAssign(false, refDestructuringErrors);
          }
          elts.push(elt);
        }
        return elts;
      };
      pp$52.checkUnreserved = function(ref3) {
        var start2 = ref3.start;
        var end = ref3.end;
        var name2 = ref3.name;
        if (this.inGenerator && name2 === "yield") {
          this.raiseRecoverable(start2, "Cannot use 'yield' as identifier inside a generator");
        }
        if (this.inAsync && name2 === "await") {
          this.raiseRecoverable(start2, "Cannot use 'await' as identifier inside an async function");
        }
        if (this.currentThisScope().inClassFieldInit && name2 === "arguments") {
          this.raiseRecoverable(start2, "Cannot use 'arguments' in class field initializer");
        }
        if (this.inClassStaticBlock && (name2 === "arguments" || name2 === "await")) {
          this.raise(start2, "Cannot use " + name2 + " in class static initialization block");
        }
        if (this.keywords.test(name2)) {
          this.raise(start2, "Unexpected keyword '" + name2 + "'");
        }
        if (this.options.ecmaVersion < 6 && this.input.slice(start2, end).indexOf("\\") !== -1) {
          return;
        }
        var re = this.strict ? this.reservedWordsStrict : this.reservedWords;
        if (re.test(name2)) {
          if (!this.inAsync && name2 === "await") {
            this.raiseRecoverable(start2, "Cannot use keyword 'await' outside an async function");
          }
          this.raiseRecoverable(start2, "The keyword '" + name2 + "' is reserved");
        }
      };
      pp$52.parseIdent = function(liberal) {
        var node2 = this.parseIdentNode();
        this.next(!!liberal);
        this.finishNode(node2, "Identifier");
        if (!liberal) {
          this.checkUnreserved(node2);
          if (node2.name === "await" && !this.awaitIdentPos) {
            this.awaitIdentPos = node2.start;
          }
        }
        return node2;
      };
      pp$52.parseIdentNode = function() {
        var node2 = this.startNode();
        if (this.type === types$12.name) {
          node2.name = this.value;
        } else if (this.type.keyword) {
          node2.name = this.type.keyword;
          if ((node2.name === "class" || node2.name === "function") && (this.lastTokEnd !== this.lastTokStart + 1 || this.input.charCodeAt(this.lastTokStart) !== 46)) {
            this.context.pop();
          }
          this.type = types$12.name;
        } else {
          this.unexpected();
        }
        return node2;
      };
      pp$52.parsePrivateIdent = function() {
        var node2 = this.startNode();
        if (this.type === types$12.privateId) {
          node2.name = this.value;
        } else {
          this.unexpected();
        }
        this.next();
        this.finishNode(node2, "PrivateIdentifier");
        if (this.options.checkPrivateFields) {
          if (this.privateNameStack.length === 0) {
            this.raise(node2.start, "Private field '#" + node2.name + "' must be declared in an enclosing class");
          } else {
            this.privateNameStack[this.privateNameStack.length - 1].used.push(node2);
          }
        }
        return node2;
      };
      pp$52.parseYield = function(forInit) {
        if (!this.yieldPos) {
          this.yieldPos = this.start;
        }
        var node2 = this.startNode();
        this.next();
        if (this.type === types$12.semi || this.canInsertSemicolon() || this.type !== types$12.star && !this.type.startsExpr) {
          node2.delegate = false;
          node2.argument = null;
        } else {
          node2.delegate = this.eat(types$12.star);
          node2.argument = this.parseMaybeAssign(forInit);
        }
        return this.finishNode(node2, "YieldExpression");
      };
      pp$52.parseAwait = function(forInit) {
        if (!this.awaitPos) {
          this.awaitPos = this.start;
        }
        var node2 = this.startNode();
        this.next();
        node2.argument = this.parseMaybeUnary(null, true, false, forInit);
        return this.finishNode(node2, "AwaitExpression");
      };
      var pp$42 = Parser3.prototype;
      pp$42.raise = function(pos, message) {
        var loc = getLineInfo2(this.input, pos);
        message += " (" + loc.line + ":" + loc.column + ")";
        var err = new SyntaxError(message);
        err.pos = pos;
        err.loc = loc;
        err.raisedAt = this.pos;
        throw err;
      };
      pp$42.raiseRecoverable = pp$42.raise;
      pp$42.curPosition = function() {
        if (this.options.locations) {
          return new Position3(this.curLine, this.pos - this.lineStart);
        }
      };
      var pp$32 = Parser3.prototype;
      var Scope3 = function Scope4(flags) {
        this.flags = flags;
        this.var = [];
        this.lexical = [];
        this.functions = [];
        this.inClassFieldInit = false;
      };
      pp$32.enterScope = function(flags) {
        this.scopeStack.push(new Scope3(flags));
      };
      pp$32.exitScope = function() {
        this.scopeStack.pop();
      };
      pp$32.treatFunctionsAsVarInScope = function(scope) {
        return scope.flags & SCOPE_FUNCTION2 || !this.inModule && scope.flags & SCOPE_TOP2;
      };
      pp$32.declareName = function(name2, bindingType, pos) {
        var redeclared = false;
        if (bindingType === BIND_LEXICAL2) {
          var scope = this.currentScope();
          redeclared = scope.lexical.indexOf(name2) > -1 || scope.functions.indexOf(name2) > -1 || scope.var.indexOf(name2) > -1;
          scope.lexical.push(name2);
          if (this.inModule && scope.flags & SCOPE_TOP2) {
            delete this.undefinedExports[name2];
          }
        } else if (bindingType === BIND_SIMPLE_CATCH2) {
          var scope$1 = this.currentScope();
          scope$1.lexical.push(name2);
        } else if (bindingType === BIND_FUNCTION2) {
          var scope$2 = this.currentScope();
          if (this.treatFunctionsAsVar) {
            redeclared = scope$2.lexical.indexOf(name2) > -1;
          } else {
            redeclared = scope$2.lexical.indexOf(name2) > -1 || scope$2.var.indexOf(name2) > -1;
          }
          scope$2.functions.push(name2);
        } else {
          for (var i4 = this.scopeStack.length - 1; i4 >= 0; --i4) {
            var scope$3 = this.scopeStack[i4];
            if (scope$3.lexical.indexOf(name2) > -1 && !(scope$3.flags & SCOPE_SIMPLE_CATCH2 && scope$3.lexical[0] === name2) || !this.treatFunctionsAsVarInScope(scope$3) && scope$3.functions.indexOf(name2) > -1) {
              redeclared = true;
              break;
            }
            scope$3.var.push(name2);
            if (this.inModule && scope$3.flags & SCOPE_TOP2) {
              delete this.undefinedExports[name2];
            }
            if (scope$3.flags & SCOPE_VAR2) {
              break;
            }
          }
        }
        if (redeclared) {
          this.raiseRecoverable(pos, "Identifier '" + name2 + "' has already been declared");
        }
      };
      pp$32.checkLocalExport = function(id) {
        if (this.scopeStack[0].lexical.indexOf(id.name) === -1 && this.scopeStack[0].var.indexOf(id.name) === -1) {
          this.undefinedExports[id.name] = id;
        }
      };
      pp$32.currentScope = function() {
        return this.scopeStack[this.scopeStack.length - 1];
      };
      pp$32.currentVarScope = function() {
        for (var i4 = this.scopeStack.length - 1; ; i4--) {
          var scope = this.scopeStack[i4];
          if (scope.flags & SCOPE_VAR2) {
            return scope;
          }
        }
      };
      pp$32.currentThisScope = function() {
        for (var i4 = this.scopeStack.length - 1; ; i4--) {
          var scope = this.scopeStack[i4];
          if (scope.flags & SCOPE_VAR2 && !(scope.flags & SCOPE_ARROW2)) {
            return scope;
          }
        }
      };
      var Node4 = function Node5(parser, pos, loc) {
        this.type = "";
        this.start = pos;
        this.end = 0;
        if (parser.options.locations) {
          this.loc = new SourceLocation3(parser, loc);
        }
        if (parser.options.directSourceFile) {
          this.sourceFile = parser.options.directSourceFile;
        }
        if (parser.options.ranges) {
          this.range = [pos, 0];
        }
      };
      var pp$22 = Parser3.prototype;
      pp$22.startNode = function() {
        return new Node4(this, this.start, this.startLoc);
      };
      pp$22.startNodeAt = function(pos, loc) {
        return new Node4(this, pos, loc);
      };
      function finishNodeAt2(node2, type2, pos, loc) {
        node2.type = type2;
        node2.end = pos;
        if (this.options.locations) {
          node2.loc.end = loc;
        }
        if (this.options.ranges) {
          node2.range[1] = pos;
        }
        return node2;
      }
      pp$22.finishNode = function(node2, type2) {
        return finishNodeAt2.call(this, node2, type2, this.lastTokEnd, this.lastTokEndLoc);
      };
      pp$22.finishNodeAt = function(node2, type2, pos, loc) {
        return finishNodeAt2.call(this, node2, type2, pos, loc);
      };
      pp$22.copyNode = function(node2) {
        var newNode = new Node4(this, node2.start, this.startLoc);
        for (var prop2 in node2) {
          newNode[prop2] = node2[prop2];
        }
        return newNode;
      };
      var scriptValuesAddedInUnicode2 = "Gara Garay Gukh Gurung_Khema Hrkt Katakana_Or_Hiragana Kawi Kirat_Rai Krai Nag_Mundari Nagm Ol_Onal Onao Sunu Sunuwar Todhri Todr Tulu_Tigalari Tutg Unknown Zzzz";
      var ecma9BinaryProperties2 = "ASCII ASCII_Hex_Digit AHex Alphabetic Alpha Any Assigned Bidi_Control Bidi_C Bidi_Mirrored Bidi_M Case_Ignorable CI Cased Changes_When_Casefolded CWCF Changes_When_Casemapped CWCM Changes_When_Lowercased CWL Changes_When_NFKC_Casefolded CWKCF Changes_When_Titlecased CWT Changes_When_Uppercased CWU Dash Default_Ignorable_Code_Point DI Deprecated Dep Diacritic Dia Emoji Emoji_Component Emoji_Modifier Emoji_Modifier_Base Emoji_Presentation Extender Ext Grapheme_Base Gr_Base Grapheme_Extend Gr_Ext Hex_Digit Hex IDS_Binary_Operator IDSB IDS_Trinary_Operator IDST ID_Continue IDC ID_Start IDS Ideographic Ideo Join_Control Join_C Logical_Order_Exception LOE Lowercase Lower Math Noncharacter_Code_Point NChar Pattern_Syntax Pat_Syn Pattern_White_Space Pat_WS Quotation_Mark QMark Radical Regional_Indicator RI Sentence_Terminal STerm Soft_Dotted SD Terminal_Punctuation Term Unified_Ideograph UIdeo Uppercase Upper Variation_Selector VS White_Space space XID_Continue XIDC XID_Start XIDS";
      var ecma10BinaryProperties2 = ecma9BinaryProperties2 + " Extended_Pictographic";
      var ecma11BinaryProperties2 = ecma10BinaryProperties2;
      var ecma12BinaryProperties2 = ecma11BinaryProperties2 + " EBase EComp EMod EPres ExtPict";
      var ecma13BinaryProperties2 = ecma12BinaryProperties2;
      var ecma14BinaryProperties2 = ecma13BinaryProperties2;
      var unicodeBinaryProperties2 = {
        9: ecma9BinaryProperties2,
        10: ecma10BinaryProperties2,
        11: ecma11BinaryProperties2,
        12: ecma12BinaryProperties2,
        13: ecma13BinaryProperties2,
        14: ecma14BinaryProperties2
      };
      var ecma14BinaryPropertiesOfStrings2 = "Basic_Emoji Emoji_Keycap_Sequence RGI_Emoji_Modifier_Sequence RGI_Emoji_Flag_Sequence RGI_Emoji_Tag_Sequence RGI_Emoji_ZWJ_Sequence RGI_Emoji";
      var unicodeBinaryPropertiesOfStrings2 = {
        9: "",
        10: "",
        11: "",
        12: "",
        13: "",
        14: ecma14BinaryPropertiesOfStrings2
      };
      var unicodeGeneralCategoryValues2 = "Cased_Letter LC Close_Punctuation Pe Connector_Punctuation Pc Control Cc cntrl Currency_Symbol Sc Dash_Punctuation Pd Decimal_Number Nd digit Enclosing_Mark Me Final_Punctuation Pf Format Cf Initial_Punctuation Pi Letter L Letter_Number Nl Line_Separator Zl Lowercase_Letter Ll Mark M Combining_Mark Math_Symbol Sm Modifier_Letter Lm Modifier_Symbol Sk Nonspacing_Mark Mn Number N Open_Punctuation Ps Other C Other_Letter Lo Other_Number No Other_Punctuation Po Other_Symbol So Paragraph_Separator Zp Private_Use Co Punctuation P punct Separator Z Space_Separator Zs Spacing_Mark Mc Surrogate Cs Symbol S Titlecase_Letter Lt Unassigned Cn Uppercase_Letter Lu";
      var ecma9ScriptValues2 = "Adlam Adlm Ahom Anatolian_Hieroglyphs Hluw Arabic Arab Armenian Armn Avestan Avst Balinese Bali Bamum Bamu Bassa_Vah Bass Batak Batk Bengali Beng Bhaiksuki Bhks Bopomofo Bopo Brahmi Brah Braille Brai Buginese Bugi Buhid Buhd Canadian_Aboriginal Cans Carian Cari Caucasian_Albanian Aghb Chakma Cakm Cham Cham Cherokee Cher Common Zyyy Coptic Copt Qaac Cuneiform Xsux Cypriot Cprt Cyrillic Cyrl Deseret Dsrt Devanagari Deva Duployan Dupl Egyptian_Hieroglyphs Egyp Elbasan Elba Ethiopic Ethi Georgian Geor Glagolitic Glag Gothic Goth Grantha Gran Greek Grek Gujarati Gujr Gurmukhi Guru Han Hani Hangul Hang Hanunoo Hano Hatran Hatr Hebrew Hebr Hiragana Hira Imperial_Aramaic Armi Inherited Zinh Qaai Inscriptional_Pahlavi Phli Inscriptional_Parthian Prti Javanese Java Kaithi Kthi Kannada Knda Katakana Kana Kayah_Li Kali Kharoshthi Khar Khmer Khmr Khojki Khoj Khudawadi Sind Lao Laoo Latin Latn Lepcha Lepc Limbu Limb Linear_A Lina Linear_B Linb Lisu Lisu Lycian Lyci Lydian Lydi Mahajani Mahj Malayalam Mlym Mandaic Mand Manichaean Mani Marchen Marc Masaram_Gondi Gonm Meetei_Mayek Mtei Mende_Kikakui Mend Meroitic_Cursive Merc Meroitic_Hieroglyphs Mero Miao Plrd Modi Mongolian Mong Mro Mroo Multani Mult Myanmar Mymr Nabataean Nbat New_Tai_Lue Talu Newa Newa Nko Nkoo Nushu Nshu Ogham Ogam Ol_Chiki Olck Old_Hungarian Hung Old_Italic Ital Old_North_Arabian Narb Old_Permic Perm Old_Persian Xpeo Old_South_Arabian Sarb Old_Turkic Orkh Oriya Orya Osage Osge Osmanya Osma Pahawh_Hmong Hmng Palmyrene Palm Pau_Cin_Hau Pauc Phags_Pa Phag Phoenician Phnx Psalter_Pahlavi Phlp Rejang Rjng Runic Runr Samaritan Samr Saurashtra Saur Sharada Shrd Shavian Shaw Siddham Sidd SignWriting Sgnw Sinhala Sinh Sora_Sompeng Sora Soyombo Soyo Sundanese Sund Syloti_Nagri Sylo Syriac Syrc Tagalog Tglg Tagbanwa Tagb Tai_Le Tale Tai_Tham Lana Tai_Viet Tavt Takri Takr Tamil Taml Tangut Tang Telugu Telu Thaana Thaa Thai Thai Tibetan Tibt Tifinagh Tfng Tirhuta Tirh Ugaritic Ugar Vai Vaii Warang_Citi Wara Yi Yiii Zanabazar_Square Zanb";
      var ecma10ScriptValues2 = ecma9ScriptValues2 + " Dogra Dogr Gunjala_Gondi Gong Hanifi_Rohingya Rohg Makasar Maka Medefaidrin Medf Old_Sogdian Sogo Sogdian Sogd";
      var ecma11ScriptValues2 = ecma10ScriptValues2 + " Elymaic Elym Nandinagari Nand Nyiakeng_Puachue_Hmong Hmnp Wancho Wcho";
      var ecma12ScriptValues2 = ecma11ScriptValues2 + " Chorasmian Chrs Diak Dives_Akuru Khitan_Small_Script Kits Yezi Yezidi";
      var ecma13ScriptValues2 = ecma12ScriptValues2 + " Cypro_Minoan Cpmn Old_Uyghur Ougr Tangsa Tnsa Toto Vithkuqi Vith";
      var ecma14ScriptValues2 = ecma13ScriptValues2 + " " + scriptValuesAddedInUnicode2;
      var unicodeScriptValues2 = {
        9: ecma9ScriptValues2,
        10: ecma10ScriptValues2,
        11: ecma11ScriptValues2,
        12: ecma12ScriptValues2,
        13: ecma13ScriptValues2,
        14: ecma14ScriptValues2
      };
      var data2 = {};
      function buildUnicodeData2(ecmaVersion2) {
        var d3 = data2[ecmaVersion2] = {
          binary: wordsRegexp2(unicodeBinaryProperties2[ecmaVersion2] + " " + unicodeGeneralCategoryValues2),
          binaryOfStrings: wordsRegexp2(unicodeBinaryPropertiesOfStrings2[ecmaVersion2]),
          nonBinary: {
            General_Category: wordsRegexp2(unicodeGeneralCategoryValues2),
            Script: wordsRegexp2(unicodeScriptValues2[ecmaVersion2])
          }
        };
        d3.nonBinary.Script_Extensions = d3.nonBinary.Script;
        d3.nonBinary.gc = d3.nonBinary.General_Category;
        d3.nonBinary.sc = d3.nonBinary.Script;
        d3.nonBinary.scx = d3.nonBinary.Script_Extensions;
      }
      for (var i3 = 0, list4 = [9, 10, 11, 12, 13, 14]; i3 < list4.length; i3 += 1) {
        var ecmaVersion = list4[i3];
        buildUnicodeData2(ecmaVersion);
      }
      var pp$12 = Parser3.prototype;
      var BranchID3 = function BranchID4(parent, base) {
        this.parent = parent;
        this.base = base || this;
      };
      BranchID3.prototype.separatedFrom = function separatedFrom2(alt) {
        for (var self2 = this; self2; self2 = self2.parent) {
          for (var other = alt; other; other = other.parent) {
            if (self2.base === other.base && self2 !== other) {
              return true;
            }
          }
        }
        return false;
      };
      BranchID3.prototype.sibling = function sibling2() {
        return new BranchID3(this.parent, this.base);
      };
      var RegExpValidationState3 = function RegExpValidationState4(parser) {
        this.parser = parser;
        this.validFlags = "gim" + (parser.options.ecmaVersion >= 6 ? "uy" : "") + (parser.options.ecmaVersion >= 9 ? "s" : "") + (parser.options.ecmaVersion >= 13 ? "d" : "") + (parser.options.ecmaVersion >= 15 ? "v" : "");
        this.unicodeProperties = data2[parser.options.ecmaVersion >= 14 ? 14 : parser.options.ecmaVersion];
        this.source = "";
        this.flags = "";
        this.start = 0;
        this.switchU = false;
        this.switchV = false;
        this.switchN = false;
        this.pos = 0;
        this.lastIntValue = 0;
        this.lastStringValue = "";
        this.lastAssertionIsQuantifiable = false;
        this.numCapturingParens = 0;
        this.maxBackReference = 0;
        this.groupNames = /* @__PURE__ */ Object.create(null);
        this.backReferenceNames = [];
        this.branchID = null;
      };
      RegExpValidationState3.prototype.reset = function reset2(start2, pattern, flags) {
        var unicodeSets = flags.indexOf("v") !== -1;
        var unicode = flags.indexOf("u") !== -1;
        this.start = start2 | 0;
        this.source = pattern + "";
        this.flags = flags;
        if (unicodeSets && this.parser.options.ecmaVersion >= 15) {
          this.switchU = true;
          this.switchV = true;
          this.switchN = true;
        } else {
          this.switchU = unicode && this.parser.options.ecmaVersion >= 6;
          this.switchV = false;
          this.switchN = unicode && this.parser.options.ecmaVersion >= 9;
        }
      };
      RegExpValidationState3.prototype.raise = function raise2(message) {
        this.parser.raiseRecoverable(this.start, "Invalid regular expression: /" + this.source + "/: " + message);
      };
      RegExpValidationState3.prototype.at = function at3(i4, forceU) {
        if (forceU === void 0) forceU = false;
        var s2 = this.source;
        var l3 = s2.length;
        if (i4 >= l3) {
          return -1;
        }
        var c2 = s2.charCodeAt(i4);
        if (!(forceU || this.switchU) || c2 <= 55295 || c2 >= 57344 || i4 + 1 >= l3) {
          return c2;
        }
        var next = s2.charCodeAt(i4 + 1);
        return next >= 56320 && next <= 57343 ? (c2 << 10) + next - 56613888 : c2;
      };
      RegExpValidationState3.prototype.nextIndex = function nextIndex2(i4, forceU) {
        if (forceU === void 0) forceU = false;
        var s2 = this.source;
        var l3 = s2.length;
        if (i4 >= l3) {
          return l3;
        }
        var c2 = s2.charCodeAt(i4), next;
        if (!(forceU || this.switchU) || c2 <= 55295 || c2 >= 57344 || i4 + 1 >= l3 || (next = s2.charCodeAt(i4 + 1)) < 56320 || next > 57343) {
          return i4 + 1;
        }
        return i4 + 2;
      };
      RegExpValidationState3.prototype.current = function current2(forceU) {
        if (forceU === void 0) forceU = false;
        return this.at(this.pos, forceU);
      };
      RegExpValidationState3.prototype.lookahead = function lookahead2(forceU) {
        if (forceU === void 0) forceU = false;
        return this.at(this.nextIndex(this.pos, forceU), forceU);
      };
      RegExpValidationState3.prototype.advance = function advance2(forceU) {
        if (forceU === void 0) forceU = false;
        this.pos = this.nextIndex(this.pos, forceU);
      };
      RegExpValidationState3.prototype.eat = function eat2(ch, forceU) {
        if (forceU === void 0) forceU = false;
        if (this.current(forceU) === ch) {
          this.advance(forceU);
          return true;
        }
        return false;
      };
      RegExpValidationState3.prototype.eatChars = function eatChars2(chs, forceU) {
        if (forceU === void 0) forceU = false;
        var pos = this.pos;
        for (var i4 = 0, list5 = chs; i4 < list5.length; i4 += 1) {
          var ch = list5[i4];
          var current2 = this.at(pos, forceU);
          if (current2 === -1 || current2 !== ch) {
            return false;
          }
          pos = this.nextIndex(pos, forceU);
        }
        this.pos = pos;
        return true;
      };
      pp$12.validateRegExpFlags = function(state) {
        var validFlags = state.validFlags;
        var flags = state.flags;
        var u2 = false;
        var v3 = false;
        for (var i4 = 0; i4 < flags.length; i4++) {
          var flag = flags.charAt(i4);
          if (validFlags.indexOf(flag) === -1) {
            this.raise(state.start, "Invalid regular expression flag");
          }
          if (flags.indexOf(flag, i4 + 1) > -1) {
            this.raise(state.start, "Duplicate regular expression flag");
          }
          if (flag === "u") {
            u2 = true;
          }
          if (flag === "v") {
            v3 = true;
          }
        }
        if (this.options.ecmaVersion >= 15 && u2 && v3) {
          this.raise(state.start, "Invalid regular expression flag");
        }
      };
      function hasProp2(obj) {
        for (var _2 in obj) {
          return true;
        }
        return false;
      }
      pp$12.validateRegExpPattern = function(state) {
        this.regexp_pattern(state);
        if (!state.switchN && this.options.ecmaVersion >= 9 && hasProp2(state.groupNames)) {
          state.switchN = true;
          this.regexp_pattern(state);
        }
      };
      pp$12.regexp_pattern = function(state) {
        state.pos = 0;
        state.lastIntValue = 0;
        state.lastStringValue = "";
        state.lastAssertionIsQuantifiable = false;
        state.numCapturingParens = 0;
        state.maxBackReference = 0;
        state.groupNames = /* @__PURE__ */ Object.create(null);
        state.backReferenceNames.length = 0;
        state.branchID = null;
        this.regexp_disjunction(state);
        if (state.pos !== state.source.length) {
          if (state.eat(
            41
            /* ) */
          )) {
            state.raise("Unmatched ')'");
          }
          if (state.eat(
            93
            /* ] */
          ) || state.eat(
            125
            /* } */
          )) {
            state.raise("Lone quantifier brackets");
          }
        }
        if (state.maxBackReference > state.numCapturingParens) {
          state.raise("Invalid escape");
        }
        for (var i4 = 0, list5 = state.backReferenceNames; i4 < list5.length; i4 += 1) {
          var name2 = list5[i4];
          if (!state.groupNames[name2]) {
            state.raise("Invalid named capture referenced");
          }
        }
      };
      pp$12.regexp_disjunction = function(state) {
        var trackDisjunction = this.options.ecmaVersion >= 16;
        if (trackDisjunction) {
          state.branchID = new BranchID3(state.branchID, null);
        }
        this.regexp_alternative(state);
        while (state.eat(
          124
          /* | */
        )) {
          if (trackDisjunction) {
            state.branchID = state.branchID.sibling();
          }
          this.regexp_alternative(state);
        }
        if (trackDisjunction) {
          state.branchID = state.branchID.parent;
        }
        if (this.regexp_eatQuantifier(state, true)) {
          state.raise("Nothing to repeat");
        }
        if (state.eat(
          123
          /* { */
        )) {
          state.raise("Lone quantifier brackets");
        }
      };
      pp$12.regexp_alternative = function(state) {
        while (state.pos < state.source.length && this.regexp_eatTerm(state)) {
        }
      };
      pp$12.regexp_eatTerm = function(state) {
        if (this.regexp_eatAssertion(state)) {
          if (state.lastAssertionIsQuantifiable && this.regexp_eatQuantifier(state)) {
            if (state.switchU) {
              state.raise("Invalid quantifier");
            }
          }
          return true;
        }
        if (state.switchU ? this.regexp_eatAtom(state) : this.regexp_eatExtendedAtom(state)) {
          this.regexp_eatQuantifier(state);
          return true;
        }
        return false;
      };
      pp$12.regexp_eatAssertion = function(state) {
        var start2 = state.pos;
        state.lastAssertionIsQuantifiable = false;
        if (state.eat(
          94
          /* ^ */
        ) || state.eat(
          36
          /* $ */
        )) {
          return true;
        }
        if (state.eat(
          92
          /* \ */
        )) {
          if (state.eat(
            66
            /* B */
          ) || state.eat(
            98
            /* b */
          )) {
            return true;
          }
          state.pos = start2;
        }
        if (state.eat(
          40
          /* ( */
        ) && state.eat(
          63
          /* ? */
        )) {
          var lookbehind = false;
          if (this.options.ecmaVersion >= 9) {
            lookbehind = state.eat(
              60
              /* < */
            );
          }
          if (state.eat(
            61
            /* = */
          ) || state.eat(
            33
            /* ! */
          )) {
            this.regexp_disjunction(state);
            if (!state.eat(
              41
              /* ) */
            )) {
              state.raise("Unterminated group");
            }
            state.lastAssertionIsQuantifiable = !lookbehind;
            return true;
          }
        }
        state.pos = start2;
        return false;
      };
      pp$12.regexp_eatQuantifier = function(state, noError) {
        if (noError === void 0) noError = false;
        if (this.regexp_eatQuantifierPrefix(state, noError)) {
          state.eat(
            63
            /* ? */
          );
          return true;
        }
        return false;
      };
      pp$12.regexp_eatQuantifierPrefix = function(state, noError) {
        return state.eat(
          42
          /* * */
        ) || state.eat(
          43
          /* + */
        ) || state.eat(
          63
          /* ? */
        ) || this.regexp_eatBracedQuantifier(state, noError);
      };
      pp$12.regexp_eatBracedQuantifier = function(state, noError) {
        var start2 = state.pos;
        if (state.eat(
          123
          /* { */
        )) {
          var min2 = 0, max2 = -1;
          if (this.regexp_eatDecimalDigits(state)) {
            min2 = state.lastIntValue;
            if (state.eat(
              44
              /* , */
            ) && this.regexp_eatDecimalDigits(state)) {
              max2 = state.lastIntValue;
            }
            if (state.eat(
              125
              /* } */
            )) {
              if (max2 !== -1 && max2 < min2 && !noError) {
                state.raise("numbers out of order in {} quantifier");
              }
              return true;
            }
          }
          if (state.switchU && !noError) {
            state.raise("Incomplete quantifier");
          }
          state.pos = start2;
        }
        return false;
      };
      pp$12.regexp_eatAtom = function(state) {
        return this.regexp_eatPatternCharacters(state) || state.eat(
          46
          /* . */
        ) || this.regexp_eatReverseSolidusAtomEscape(state) || this.regexp_eatCharacterClass(state) || this.regexp_eatUncapturingGroup(state) || this.regexp_eatCapturingGroup(state);
      };
      pp$12.regexp_eatReverseSolidusAtomEscape = function(state) {
        var start2 = state.pos;
        if (state.eat(
          92
          /* \ */
        )) {
          if (this.regexp_eatAtomEscape(state)) {
            return true;
          }
          state.pos = start2;
        }
        return false;
      };
      pp$12.regexp_eatUncapturingGroup = function(state) {
        var start2 = state.pos;
        if (state.eat(
          40
          /* ( */
        )) {
          if (state.eat(
            63
            /* ? */
          )) {
            if (this.options.ecmaVersion >= 16) {
              var addModifiers = this.regexp_eatModifiers(state);
              var hasHyphen = state.eat(
                45
                /* - */
              );
              if (addModifiers || hasHyphen) {
                for (var i4 = 0; i4 < addModifiers.length; i4++) {
                  var modifier = addModifiers.charAt(i4);
                  if (addModifiers.indexOf(modifier, i4 + 1) > -1) {
                    state.raise("Duplicate regular expression modifiers");
                  }
                }
                if (hasHyphen) {
                  var removeModifiers = this.regexp_eatModifiers(state);
                  if (!addModifiers && !removeModifiers && state.current() === 58) {
                    state.raise("Invalid regular expression modifiers");
                  }
                  for (var i$1 = 0; i$1 < removeModifiers.length; i$1++) {
                    var modifier$1 = removeModifiers.charAt(i$1);
                    if (removeModifiers.indexOf(modifier$1, i$1 + 1) > -1 || addModifiers.indexOf(modifier$1) > -1) {
                      state.raise("Duplicate regular expression modifiers");
                    }
                  }
                }
              }
            }
            if (state.eat(
              58
              /* : */
            )) {
              this.regexp_disjunction(state);
              if (state.eat(
                41
                /* ) */
              )) {
                return true;
              }
              state.raise("Unterminated group");
            }
          }
          state.pos = start2;
        }
        return false;
      };
      pp$12.regexp_eatCapturingGroup = function(state) {
        if (state.eat(
          40
          /* ( */
        )) {
          if (this.options.ecmaVersion >= 9) {
            this.regexp_groupSpecifier(state);
          } else if (state.current() === 63) {
            state.raise("Invalid group");
          }
          this.regexp_disjunction(state);
          if (state.eat(
            41
            /* ) */
          )) {
            state.numCapturingParens += 1;
            return true;
          }
          state.raise("Unterminated group");
        }
        return false;
      };
      pp$12.regexp_eatModifiers = function(state) {
        var modifiers = "";
        var ch = 0;
        while ((ch = state.current()) !== -1 && isRegularExpressionModifier2(ch)) {
          modifiers += codePointToString2(ch);
          state.advance();
        }
        return modifiers;
      };
      function isRegularExpressionModifier2(ch) {
        return ch === 105 || ch === 109 || ch === 115;
      }
      pp$12.regexp_eatExtendedAtom = function(state) {
        return state.eat(
          46
          /* . */
        ) || this.regexp_eatReverseSolidusAtomEscape(state) || this.regexp_eatCharacterClass(state) || this.regexp_eatUncapturingGroup(state) || this.regexp_eatCapturingGroup(state) || this.regexp_eatInvalidBracedQuantifier(state) || this.regexp_eatExtendedPatternCharacter(state);
      };
      pp$12.regexp_eatInvalidBracedQuantifier = function(state) {
        if (this.regexp_eatBracedQuantifier(state, true)) {
          state.raise("Nothing to repeat");
        }
        return false;
      };
      pp$12.regexp_eatSyntaxCharacter = function(state) {
        var ch = state.current();
        if (isSyntaxCharacter2(ch)) {
          state.lastIntValue = ch;
          state.advance();
          return true;
        }
        return false;
      };
      function isSyntaxCharacter2(ch) {
        return ch === 36 || ch >= 40 && ch <= 43 || ch === 46 || ch === 63 || ch >= 91 && ch <= 94 || ch >= 123 && ch <= 125;
      }
      pp$12.regexp_eatPatternCharacters = function(state) {
        var start2 = state.pos;
        var ch = 0;
        while ((ch = state.current()) !== -1 && !isSyntaxCharacter2(ch)) {
          state.advance();
        }
        return state.pos !== start2;
      };
      pp$12.regexp_eatExtendedPatternCharacter = function(state) {
        var ch = state.current();
        if (ch !== -1 && ch !== 36 && !(ch >= 40 && ch <= 43) && ch !== 46 && ch !== 63 && ch !== 91 && ch !== 94 && ch !== 124) {
          state.advance();
          return true;
        }
        return false;
      };
      pp$12.regexp_groupSpecifier = function(state) {
        if (state.eat(
          63
          /* ? */
        )) {
          if (!this.regexp_eatGroupName(state)) {
            state.raise("Invalid group");
          }
          var trackDisjunction = this.options.ecmaVersion >= 16;
          var known = state.groupNames[state.lastStringValue];
          if (known) {
            if (trackDisjunction) {
              for (var i4 = 0, list5 = known; i4 < list5.length; i4 += 1) {
                var altID = list5[i4];
                if (!altID.separatedFrom(state.branchID)) {
                  state.raise("Duplicate capture group name");
                }
              }
            } else {
              state.raise("Duplicate capture group name");
            }
          }
          if (trackDisjunction) {
            (known || (state.groupNames[state.lastStringValue] = [])).push(state.branchID);
          } else {
            state.groupNames[state.lastStringValue] = true;
          }
        }
      };
      pp$12.regexp_eatGroupName = function(state) {
        state.lastStringValue = "";
        if (state.eat(
          60
          /* < */
        )) {
          if (this.regexp_eatRegExpIdentifierName(state) && state.eat(
            62
            /* > */
          )) {
            return true;
          }
          state.raise("Invalid capture group name");
        }
        return false;
      };
      pp$12.regexp_eatRegExpIdentifierName = function(state) {
        state.lastStringValue = "";
        if (this.regexp_eatRegExpIdentifierStart(state)) {
          state.lastStringValue += codePointToString2(state.lastIntValue);
          while (this.regexp_eatRegExpIdentifierPart(state)) {
            state.lastStringValue += codePointToString2(state.lastIntValue);
          }
          return true;
        }
        return false;
      };
      pp$12.regexp_eatRegExpIdentifierStart = function(state) {
        var start2 = state.pos;
        var forceU = this.options.ecmaVersion >= 11;
        var ch = state.current(forceU);
        state.advance(forceU);
        if (ch === 92 && this.regexp_eatRegExpUnicodeEscapeSequence(state, forceU)) {
          ch = state.lastIntValue;
        }
        if (isRegExpIdentifierStart2(ch)) {
          state.lastIntValue = ch;
          return true;
        }
        state.pos = start2;
        return false;
      };
      function isRegExpIdentifierStart2(ch) {
        return isIdentifierStart2(ch, true) || ch === 36 || ch === 95;
      }
      pp$12.regexp_eatRegExpIdentifierPart = function(state) {
        var start2 = state.pos;
        var forceU = this.options.ecmaVersion >= 11;
        var ch = state.current(forceU);
        state.advance(forceU);
        if (ch === 92 && this.regexp_eatRegExpUnicodeEscapeSequence(state, forceU)) {
          ch = state.lastIntValue;
        }
        if (isRegExpIdentifierPart2(ch)) {
          state.lastIntValue = ch;
          return true;
        }
        state.pos = start2;
        return false;
      };
      function isRegExpIdentifierPart2(ch) {
        return isIdentifierChar2(ch, true) || ch === 36 || ch === 95 || ch === 8204 || ch === 8205;
      }
      pp$12.regexp_eatAtomEscape = function(state) {
        if (this.regexp_eatBackReference(state) || this.regexp_eatCharacterClassEscape(state) || this.regexp_eatCharacterEscape(state) || state.switchN && this.regexp_eatKGroupName(state)) {
          return true;
        }
        if (state.switchU) {
          if (state.current() === 99) {
            state.raise("Invalid unicode escape");
          }
          state.raise("Invalid escape");
        }
        return false;
      };
      pp$12.regexp_eatBackReference = function(state) {
        var start2 = state.pos;
        if (this.regexp_eatDecimalEscape(state)) {
          var n3 = state.lastIntValue;
          if (state.switchU) {
            if (n3 > state.maxBackReference) {
              state.maxBackReference = n3;
            }
            return true;
          }
          if (n3 <= state.numCapturingParens) {
            return true;
          }
          state.pos = start2;
        }
        return false;
      };
      pp$12.regexp_eatKGroupName = function(state) {
        if (state.eat(
          107
          /* k */
        )) {
          if (this.regexp_eatGroupName(state)) {
            state.backReferenceNames.push(state.lastStringValue);
            return true;
          }
          state.raise("Invalid named reference");
        }
        return false;
      };
      pp$12.regexp_eatCharacterEscape = function(state) {
        return this.regexp_eatControlEscape(state) || this.regexp_eatCControlLetter(state) || this.regexp_eatZero(state) || this.regexp_eatHexEscapeSequence(state) || this.regexp_eatRegExpUnicodeEscapeSequence(state, false) || !state.switchU && this.regexp_eatLegacyOctalEscapeSequence(state) || this.regexp_eatIdentityEscape(state);
      };
      pp$12.regexp_eatCControlLetter = function(state) {
        var start2 = state.pos;
        if (state.eat(
          99
          /* c */
        )) {
          if (this.regexp_eatControlLetter(state)) {
            return true;
          }
          state.pos = start2;
        }
        return false;
      };
      pp$12.regexp_eatZero = function(state) {
        if (state.current() === 48 && !isDecimalDigit2(state.lookahead())) {
          state.lastIntValue = 0;
          state.advance();
          return true;
        }
        return false;
      };
      pp$12.regexp_eatControlEscape = function(state) {
        var ch = state.current();
        if (ch === 116) {
          state.lastIntValue = 9;
          state.advance();
          return true;
        }
        if (ch === 110) {
          state.lastIntValue = 10;
          state.advance();
          return true;
        }
        if (ch === 118) {
          state.lastIntValue = 11;
          state.advance();
          return true;
        }
        if (ch === 102) {
          state.lastIntValue = 12;
          state.advance();
          return true;
        }
        if (ch === 114) {
          state.lastIntValue = 13;
          state.advance();
          return true;
        }
        return false;
      };
      pp$12.regexp_eatControlLetter = function(state) {
        var ch = state.current();
        if (isControlLetter2(ch)) {
          state.lastIntValue = ch % 32;
          state.advance();
          return true;
        }
        return false;
      };
      function isControlLetter2(ch) {
        return ch >= 65 && ch <= 90 || ch >= 97 && ch <= 122;
      }
      pp$12.regexp_eatRegExpUnicodeEscapeSequence = function(state, forceU) {
        if (forceU === void 0) forceU = false;
        var start2 = state.pos;
        var switchU = forceU || state.switchU;
        if (state.eat(
          117
          /* u */
        )) {
          if (this.regexp_eatFixedHexDigits(state, 4)) {
            var lead = state.lastIntValue;
            if (switchU && lead >= 55296 && lead <= 56319) {
              var leadSurrogateEnd = state.pos;
              if (state.eat(
                92
                /* \ */
              ) && state.eat(
                117
                /* u */
              ) && this.regexp_eatFixedHexDigits(state, 4)) {
                var trail = state.lastIntValue;
                if (trail >= 56320 && trail <= 57343) {
                  state.lastIntValue = (lead - 55296) * 1024 + (trail - 56320) + 65536;
                  return true;
                }
              }
              state.pos = leadSurrogateEnd;
              state.lastIntValue = lead;
            }
            return true;
          }
          if (switchU && state.eat(
            123
            /* { */
          ) && this.regexp_eatHexDigits(state) && state.eat(
            125
            /* } */
          ) && isValidUnicode2(state.lastIntValue)) {
            return true;
          }
          if (switchU) {
            state.raise("Invalid unicode escape");
          }
          state.pos = start2;
        }
        return false;
      };
      function isValidUnicode2(ch) {
        return ch >= 0 && ch <= 1114111;
      }
      pp$12.regexp_eatIdentityEscape = function(state) {
        if (state.switchU) {
          if (this.regexp_eatSyntaxCharacter(state)) {
            return true;
          }
          if (state.eat(
            47
            /* / */
          )) {
            state.lastIntValue = 47;
            return true;
          }
          return false;
        }
        var ch = state.current();
        if (ch !== 99 && (!state.switchN || ch !== 107)) {
          state.lastIntValue = ch;
          state.advance();
          return true;
        }
        return false;
      };
      pp$12.regexp_eatDecimalEscape = function(state) {
        state.lastIntValue = 0;
        var ch = state.current();
        if (ch >= 49 && ch <= 57) {
          do {
            state.lastIntValue = 10 * state.lastIntValue + (ch - 48);
            state.advance();
          } while ((ch = state.current()) >= 48 && ch <= 57);
          return true;
        }
        return false;
      };
      var CharSetNone2 = 0;
      var CharSetOk2 = 1;
      var CharSetString2 = 2;
      pp$12.regexp_eatCharacterClassEscape = function(state) {
        var ch = state.current();
        if (isCharacterClassEscape2(ch)) {
          state.lastIntValue = -1;
          state.advance();
          return CharSetOk2;
        }
        var negate = false;
        if (state.switchU && this.options.ecmaVersion >= 9 && ((negate = ch === 80) || ch === 112)) {
          state.lastIntValue = -1;
          state.advance();
          var result;
          if (state.eat(
            123
            /* { */
          ) && (result = this.regexp_eatUnicodePropertyValueExpression(state)) && state.eat(
            125
            /* } */
          )) {
            if (negate && result === CharSetString2) {
              state.raise("Invalid property name");
            }
            return result;
          }
          state.raise("Invalid property name");
        }
        return CharSetNone2;
      };
      function isCharacterClassEscape2(ch) {
        return ch === 100 || ch === 68 || ch === 115 || ch === 83 || ch === 119 || ch === 87;
      }
      pp$12.regexp_eatUnicodePropertyValueExpression = function(state) {
        var start2 = state.pos;
        if (this.regexp_eatUnicodePropertyName(state) && state.eat(
          61
          /* = */
        )) {
          var name2 = state.lastStringValue;
          if (this.regexp_eatUnicodePropertyValue(state)) {
            var value2 = state.lastStringValue;
            this.regexp_validateUnicodePropertyNameAndValue(state, name2, value2);
            return CharSetOk2;
          }
        }
        state.pos = start2;
        if (this.regexp_eatLoneUnicodePropertyNameOrValue(state)) {
          var nameOrValue = state.lastStringValue;
          return this.regexp_validateUnicodePropertyNameOrValue(state, nameOrValue);
        }
        return CharSetNone2;
      };
      pp$12.regexp_validateUnicodePropertyNameAndValue = function(state, name2, value2) {
        if (!hasOwn2(state.unicodeProperties.nonBinary, name2)) {
          state.raise("Invalid property name");
        }
        if (!state.unicodeProperties.nonBinary[name2].test(value2)) {
          state.raise("Invalid property value");
        }
      };
      pp$12.regexp_validateUnicodePropertyNameOrValue = function(state, nameOrValue) {
        if (state.unicodeProperties.binary.test(nameOrValue)) {
          return CharSetOk2;
        }
        if (state.switchV && state.unicodeProperties.binaryOfStrings.test(nameOrValue)) {
          return CharSetString2;
        }
        state.raise("Invalid property name");
      };
      pp$12.regexp_eatUnicodePropertyName = function(state) {
        var ch = 0;
        state.lastStringValue = "";
        while (isUnicodePropertyNameCharacter2(ch = state.current())) {
          state.lastStringValue += codePointToString2(ch);
          state.advance();
        }
        return state.lastStringValue !== "";
      };
      function isUnicodePropertyNameCharacter2(ch) {
        return isControlLetter2(ch) || ch === 95;
      }
      pp$12.regexp_eatUnicodePropertyValue = function(state) {
        var ch = 0;
        state.lastStringValue = "";
        while (isUnicodePropertyValueCharacter2(ch = state.current())) {
          state.lastStringValue += codePointToString2(ch);
          state.advance();
        }
        return state.lastStringValue !== "";
      };
      function isUnicodePropertyValueCharacter2(ch) {
        return isUnicodePropertyNameCharacter2(ch) || isDecimalDigit2(ch);
      }
      pp$12.regexp_eatLoneUnicodePropertyNameOrValue = function(state) {
        return this.regexp_eatUnicodePropertyValue(state);
      };
      pp$12.regexp_eatCharacterClass = function(state) {
        if (state.eat(
          91
          /* [ */
        )) {
          var negate = state.eat(
            94
            /* ^ */
          );
          var result = this.regexp_classContents(state);
          if (!state.eat(
            93
            /* ] */
          )) {
            state.raise("Unterminated character class");
          }
          if (negate && result === CharSetString2) {
            state.raise("Negated character class may contain strings");
          }
          return true;
        }
        return false;
      };
      pp$12.regexp_classContents = function(state) {
        if (state.current() === 93) {
          return CharSetOk2;
        }
        if (state.switchV) {
          return this.regexp_classSetExpression(state);
        }
        this.regexp_nonEmptyClassRanges(state);
        return CharSetOk2;
      };
      pp$12.regexp_nonEmptyClassRanges = function(state) {
        while (this.regexp_eatClassAtom(state)) {
          var left = state.lastIntValue;
          if (state.eat(
            45
            /* - */
          ) && this.regexp_eatClassAtom(state)) {
            var right = state.lastIntValue;
            if (state.switchU && (left === -1 || right === -1)) {
              state.raise("Invalid character class");
            }
            if (left !== -1 && right !== -1 && left > right) {
              state.raise("Range out of order in character class");
            }
          }
        }
      };
      pp$12.regexp_eatClassAtom = function(state) {
        var start2 = state.pos;
        if (state.eat(
          92
          /* \ */
        )) {
          if (this.regexp_eatClassEscape(state)) {
            return true;
          }
          if (state.switchU) {
            var ch$1 = state.current();
            if (ch$1 === 99 || isOctalDigit2(ch$1)) {
              state.raise("Invalid class escape");
            }
            state.raise("Invalid escape");
          }
          state.pos = start2;
        }
        var ch = state.current();
        if (ch !== 93) {
          state.lastIntValue = ch;
          state.advance();
          return true;
        }
        return false;
      };
      pp$12.regexp_eatClassEscape = function(state) {
        var start2 = state.pos;
        if (state.eat(
          98
          /* b */
        )) {
          state.lastIntValue = 8;
          return true;
        }
        if (state.switchU && state.eat(
          45
          /* - */
        )) {
          state.lastIntValue = 45;
          return true;
        }
        if (!state.switchU && state.eat(
          99
          /* c */
        )) {
          if (this.regexp_eatClassControlLetter(state)) {
            return true;
          }
          state.pos = start2;
        }
        return this.regexp_eatCharacterClassEscape(state) || this.regexp_eatCharacterEscape(state);
      };
      pp$12.regexp_classSetExpression = function(state) {
        var result = CharSetOk2, subResult;
        if (this.regexp_eatClassSetRange(state)) ;
        else if (subResult = this.regexp_eatClassSetOperand(state)) {
          if (subResult === CharSetString2) {
            result = CharSetString2;
          }
          var start2 = state.pos;
          while (state.eatChars(
            [38, 38]
            /* && */
          )) {
            if (state.current() !== 38 && (subResult = this.regexp_eatClassSetOperand(state))) {
              if (subResult !== CharSetString2) {
                result = CharSetOk2;
              }
              continue;
            }
            state.raise("Invalid character in character class");
          }
          if (start2 !== state.pos) {
            return result;
          }
          while (state.eatChars(
            [45, 45]
            /* -- */
          )) {
            if (this.regexp_eatClassSetOperand(state)) {
              continue;
            }
            state.raise("Invalid character in character class");
          }
          if (start2 !== state.pos) {
            return result;
          }
        } else {
          state.raise("Invalid character in character class");
        }
        for (; ; ) {
          if (this.regexp_eatClassSetRange(state)) {
            continue;
          }
          subResult = this.regexp_eatClassSetOperand(state);
          if (!subResult) {
            return result;
          }
          if (subResult === CharSetString2) {
            result = CharSetString2;
          }
        }
      };
      pp$12.regexp_eatClassSetRange = function(state) {
        var start2 = state.pos;
        if (this.regexp_eatClassSetCharacter(state)) {
          var left = state.lastIntValue;
          if (state.eat(
            45
            /* - */
          ) && this.regexp_eatClassSetCharacter(state)) {
            var right = state.lastIntValue;
            if (left !== -1 && right !== -1 && left > right) {
              state.raise("Range out of order in character class");
            }
            return true;
          }
          state.pos = start2;
        }
        return false;
      };
      pp$12.regexp_eatClassSetOperand = function(state) {
        if (this.regexp_eatClassSetCharacter(state)) {
          return CharSetOk2;
        }
        return this.regexp_eatClassStringDisjunction(state) || this.regexp_eatNestedClass(state);
      };
      pp$12.regexp_eatNestedClass = function(state) {
        var start2 = state.pos;
        if (state.eat(
          91
          /* [ */
        )) {
          var negate = state.eat(
            94
            /* ^ */
          );
          var result = this.regexp_classContents(state);
          if (state.eat(
            93
            /* ] */
          )) {
            if (negate && result === CharSetString2) {
              state.raise("Negated character class may contain strings");
            }
            return result;
          }
          state.pos = start2;
        }
        if (state.eat(
          92
          /* \ */
        )) {
          var result$1 = this.regexp_eatCharacterClassEscape(state);
          if (result$1) {
            return result$1;
          }
          state.pos = start2;
        }
        return null;
      };
      pp$12.regexp_eatClassStringDisjunction = function(state) {
        var start2 = state.pos;
        if (state.eatChars(
          [92, 113]
          /* \q */
        )) {
          if (state.eat(
            123
            /* { */
          )) {
            var result = this.regexp_classStringDisjunctionContents(state);
            if (state.eat(
              125
              /* } */
            )) {
              return result;
            }
          } else {
            state.raise("Invalid escape");
          }
          state.pos = start2;
        }
        return null;
      };
      pp$12.regexp_classStringDisjunctionContents = function(state) {
        var result = this.regexp_classString(state);
        while (state.eat(
          124
          /* | */
        )) {
          if (this.regexp_classString(state) === CharSetString2) {
            result = CharSetString2;
          }
        }
        return result;
      };
      pp$12.regexp_classString = function(state) {
        var count3 = 0;
        while (this.regexp_eatClassSetCharacter(state)) {
          count3++;
        }
        return count3 === 1 ? CharSetOk2 : CharSetString2;
      };
      pp$12.regexp_eatClassSetCharacter = function(state) {
        var start2 = state.pos;
        if (state.eat(
          92
          /* \ */
        )) {
          if (this.regexp_eatCharacterEscape(state) || this.regexp_eatClassSetReservedPunctuator(state)) {
            return true;
          }
          if (state.eat(
            98
            /* b */
          )) {
            state.lastIntValue = 8;
            return true;
          }
          state.pos = start2;
          return false;
        }
        var ch = state.current();
        if (ch < 0 || ch === state.lookahead() && isClassSetReservedDoublePunctuatorCharacter2(ch)) {
          return false;
        }
        if (isClassSetSyntaxCharacter2(ch)) {
          return false;
        }
        state.advance();
        state.lastIntValue = ch;
        return true;
      };
      function isClassSetReservedDoublePunctuatorCharacter2(ch) {
        return ch === 33 || ch >= 35 && ch <= 38 || ch >= 42 && ch <= 44 || ch === 46 || ch >= 58 && ch <= 64 || ch === 94 || ch === 96 || ch === 126;
      }
      function isClassSetSyntaxCharacter2(ch) {
        return ch === 40 || ch === 41 || ch === 45 || ch === 47 || ch >= 91 && ch <= 93 || ch >= 123 && ch <= 125;
      }
      pp$12.regexp_eatClassSetReservedPunctuator = function(state) {
        var ch = state.current();
        if (isClassSetReservedPunctuator2(ch)) {
          state.lastIntValue = ch;
          state.advance();
          return true;
        }
        return false;
      };
      function isClassSetReservedPunctuator2(ch) {
        return ch === 33 || ch === 35 || ch === 37 || ch === 38 || ch === 44 || ch === 45 || ch >= 58 && ch <= 62 || ch === 64 || ch === 96 || ch === 126;
      }
      pp$12.regexp_eatClassControlLetter = function(state) {
        var ch = state.current();
        if (isDecimalDigit2(ch) || ch === 95) {
          state.lastIntValue = ch % 32;
          state.advance();
          return true;
        }
        return false;
      };
      pp$12.regexp_eatHexEscapeSequence = function(state) {
        var start2 = state.pos;
        if (state.eat(
          120
          /* x */
        )) {
          if (this.regexp_eatFixedHexDigits(state, 2)) {
            return true;
          }
          if (state.switchU) {
            state.raise("Invalid escape");
          }
          state.pos = start2;
        }
        return false;
      };
      pp$12.regexp_eatDecimalDigits = function(state) {
        var start2 = state.pos;
        var ch = 0;
        state.lastIntValue = 0;
        while (isDecimalDigit2(ch = state.current())) {
          state.lastIntValue = 10 * state.lastIntValue + (ch - 48);
          state.advance();
        }
        return state.pos !== start2;
      };
      function isDecimalDigit2(ch) {
        return ch >= 48 && ch <= 57;
      }
      pp$12.regexp_eatHexDigits = function(state) {
        var start2 = state.pos;
        var ch = 0;
        state.lastIntValue = 0;
        while (isHexDigit2(ch = state.current())) {
          state.lastIntValue = 16 * state.lastIntValue + hexToInt2(ch);
          state.advance();
        }
        return state.pos !== start2;
      };
      function isHexDigit2(ch) {
        return ch >= 48 && ch <= 57 || ch >= 65 && ch <= 70 || ch >= 97 && ch <= 102;
      }
      function hexToInt2(ch) {
        if (ch >= 65 && ch <= 70) {
          return 10 + (ch - 65);
        }
        if (ch >= 97 && ch <= 102) {
          return 10 + (ch - 97);
        }
        return ch - 48;
      }
      pp$12.regexp_eatLegacyOctalEscapeSequence = function(state) {
        if (this.regexp_eatOctalDigit(state)) {
          var n1 = state.lastIntValue;
          if (this.regexp_eatOctalDigit(state)) {
            var n22 = state.lastIntValue;
            if (n1 <= 3 && this.regexp_eatOctalDigit(state)) {
              state.lastIntValue = n1 * 64 + n22 * 8 + state.lastIntValue;
            } else {
              state.lastIntValue = n1 * 8 + n22;
            }
          } else {
            state.lastIntValue = n1;
          }
          return true;
        }
        return false;
      };
      pp$12.regexp_eatOctalDigit = function(state) {
        var ch = state.current();
        if (isOctalDigit2(ch)) {
          state.lastIntValue = ch - 48;
          state.advance();
          return true;
        }
        state.lastIntValue = 0;
        return false;
      };
      function isOctalDigit2(ch) {
        return ch >= 48 && ch <= 55;
      }
      pp$12.regexp_eatFixedHexDigits = function(state, length) {
        var start2 = state.pos;
        state.lastIntValue = 0;
        for (var i4 = 0; i4 < length; ++i4) {
          var ch = state.current();
          if (!isHexDigit2(ch)) {
            state.pos = start2;
            return false;
          }
          state.lastIntValue = 16 * state.lastIntValue + hexToInt2(ch);
          state.advance();
        }
        return true;
      };
      var Token3 = function Token4(p2) {
        this.type = p2.type;
        this.value = p2.value;
        this.start = p2.start;
        this.end = p2.end;
        if (p2.options.locations) {
          this.loc = new SourceLocation3(p2, p2.startLoc, p2.endLoc);
        }
        if (p2.options.ranges) {
          this.range = [p2.start, p2.end];
        }
      };
      var pp2 = Parser3.prototype;
      pp2.next = function(ignoreEscapeSequenceInKeyword) {
        if (!ignoreEscapeSequenceInKeyword && this.type.keyword && this.containsEsc) {
          this.raiseRecoverable(this.start, "Escape sequence in keyword " + this.type.keyword);
        }
        if (this.options.onToken) {
          this.options.onToken(new Token3(this));
        }
        this.lastTokEnd = this.end;
        this.lastTokStart = this.start;
        this.lastTokEndLoc = this.endLoc;
        this.lastTokStartLoc = this.startLoc;
        this.nextToken();
      };
      pp2.getToken = function() {
        this.next();
        return new Token3(this);
      };
      if (typeof Symbol !== "undefined") {
        pp2[Symbol.iterator] = function() {
          var this$1$1 = this;
          return {
            next: function() {
              var token = this$1$1.getToken();
              return {
                done: token.type === types$12.eof,
                value: token
              };
            }
          };
        };
      }
      pp2.nextToken = function() {
        var curContext = this.curContext();
        if (!curContext || !curContext.preserveSpace) {
          this.skipSpace();
        }
        this.start = this.pos;
        if (this.options.locations) {
          this.startLoc = this.curPosition();
        }
        if (this.pos >= this.input.length) {
          return this.finishToken(types$12.eof);
        }
        if (curContext.override) {
          return curContext.override(this);
        } else {
          this.readToken(this.fullCharCodeAtPos());
        }
      };
      pp2.readToken = function(code3) {
        if (isIdentifierStart2(code3, this.options.ecmaVersion >= 6) || code3 === 92) {
          return this.readWord();
        }
        return this.getTokenFromCode(code3);
      };
      pp2.fullCharCodeAtPos = function() {
        var code3 = this.input.charCodeAt(this.pos);
        if (code3 <= 55295 || code3 >= 56320) {
          return code3;
        }
        var next = this.input.charCodeAt(this.pos + 1);
        return next <= 56319 || next >= 57344 ? code3 : (code3 << 10) + next - 56613888;
      };
      pp2.skipBlockComment = function() {
        var startLoc = this.options.onComment && this.curPosition();
        var start2 = this.pos, end = this.input.indexOf("*/", this.pos += 2);
        if (end === -1) {
          this.raise(this.pos - 2, "Unterminated comment");
        }
        this.pos = end + 2;
        if (this.options.locations) {
          for (var nextBreak = void 0, pos = start2; (nextBreak = nextLineBreak2(this.input, pos, this.pos)) > -1; ) {
            ++this.curLine;
            pos = this.lineStart = nextBreak;
          }
        }
        if (this.options.onComment) {
          this.options.onComment(
            true,
            this.input.slice(start2 + 2, end),
            start2,
            this.pos,
            startLoc,
            this.curPosition()
          );
        }
      };
      pp2.skipLineComment = function(startSkip) {
        var start2 = this.pos;
        var startLoc = this.options.onComment && this.curPosition();
        var ch = this.input.charCodeAt(this.pos += startSkip);
        while (this.pos < this.input.length && !isNewLine2(ch)) {
          ch = this.input.charCodeAt(++this.pos);
        }
        if (this.options.onComment) {
          this.options.onComment(
            false,
            this.input.slice(start2 + startSkip, this.pos),
            start2,
            this.pos,
            startLoc,
            this.curPosition()
          );
        }
      };
      pp2.skipSpace = function() {
        loop: while (this.pos < this.input.length) {
          var ch = this.input.charCodeAt(this.pos);
          switch (ch) {
            case 32:
            case 160:
              ++this.pos;
              break;
            case 13:
              if (this.input.charCodeAt(this.pos + 1) === 10) {
                ++this.pos;
              }
            case 10:
            case 8232:
            case 8233:
              ++this.pos;
              if (this.options.locations) {
                ++this.curLine;
                this.lineStart = this.pos;
              }
              break;
            case 47:
              switch (this.input.charCodeAt(this.pos + 1)) {
                case 42:
                  this.skipBlockComment();
                  break;
                case 47:
                  this.skipLineComment(2);
                  break;
                default:
                  break loop;
              }
              break;
            default:
              if (ch > 8 && ch < 14 || ch >= 5760 && nonASCIIwhitespace2.test(String.fromCharCode(ch))) {
                ++this.pos;
              } else {
                break loop;
              }
          }
        }
      };
      pp2.finishToken = function(type2, val) {
        this.end = this.pos;
        if (this.options.locations) {
          this.endLoc = this.curPosition();
        }
        var prevType = this.type;
        this.type = type2;
        this.value = val;
        this.updateContext(prevType);
      };
      pp2.readToken_dot = function() {
        var next = this.input.charCodeAt(this.pos + 1);
        if (next >= 48 && next <= 57) {
          return this.readNumber(true);
        }
        var next2 = this.input.charCodeAt(this.pos + 2);
        if (this.options.ecmaVersion >= 6 && next === 46 && next2 === 46) {
          this.pos += 3;
          return this.finishToken(types$12.ellipsis);
        } else {
          ++this.pos;
          return this.finishToken(types$12.dot);
        }
      };
      pp2.readToken_slash = function() {
        var next = this.input.charCodeAt(this.pos + 1);
        if (this.exprAllowed) {
          ++this.pos;
          return this.readRegexp();
        }
        if (next === 61) {
          return this.finishOp(types$12.assign, 2);
        }
        return this.finishOp(types$12.slash, 1);
      };
      pp2.readToken_mult_modulo_exp = function(code3) {
        var next = this.input.charCodeAt(this.pos + 1);
        var size4 = 1;
        var tokentype = code3 === 42 ? types$12.star : types$12.modulo;
        if (this.options.ecmaVersion >= 7 && code3 === 42 && next === 42) {
          ++size4;
          tokentype = types$12.starstar;
          next = this.input.charCodeAt(this.pos + 2);
        }
        if (next === 61) {
          return this.finishOp(types$12.assign, size4 + 1);
        }
        return this.finishOp(tokentype, size4);
      };
      pp2.readToken_pipe_amp = function(code3) {
        var next = this.input.charCodeAt(this.pos + 1);
        if (next === code3) {
          if (this.options.ecmaVersion >= 12) {
            var next2 = this.input.charCodeAt(this.pos + 2);
            if (next2 === 61) {
              return this.finishOp(types$12.assign, 3);
            }
          }
          return this.finishOp(code3 === 124 ? types$12.logicalOR : types$12.logicalAND, 2);
        }
        if (next === 61) {
          return this.finishOp(types$12.assign, 2);
        }
        return this.finishOp(code3 === 124 ? types$12.bitwiseOR : types$12.bitwiseAND, 1);
      };
      pp2.readToken_caret = function() {
        var next = this.input.charCodeAt(this.pos + 1);
        if (next === 61) {
          return this.finishOp(types$12.assign, 2);
        }
        return this.finishOp(types$12.bitwiseXOR, 1);
      };
      pp2.readToken_plus_min = function(code3) {
        var next = this.input.charCodeAt(this.pos + 1);
        if (next === code3) {
          if (next === 45 && !this.inModule && this.input.charCodeAt(this.pos + 2) === 62 && (this.lastTokEnd === 0 || lineBreak2.test(this.input.slice(this.lastTokEnd, this.pos)))) {
            this.skipLineComment(3);
            this.skipSpace();
            return this.nextToken();
          }
          return this.finishOp(types$12.incDec, 2);
        }
        if (next === 61) {
          return this.finishOp(types$12.assign, 2);
        }
        return this.finishOp(types$12.plusMin, 1);
      };
      pp2.readToken_lt_gt = function(code3) {
        var next = this.input.charCodeAt(this.pos + 1);
        var size4 = 1;
        if (next === code3) {
          size4 = code3 === 62 && this.input.charCodeAt(this.pos + 2) === 62 ? 3 : 2;
          if (this.input.charCodeAt(this.pos + size4) === 61) {
            return this.finishOp(types$12.assign, size4 + 1);
          }
          return this.finishOp(types$12.bitShift, size4);
        }
        if (next === 33 && code3 === 60 && !this.inModule && this.input.charCodeAt(this.pos + 2) === 45 && this.input.charCodeAt(this.pos + 3) === 45) {
          this.skipLineComment(4);
          this.skipSpace();
          return this.nextToken();
        }
        if (next === 61) {
          size4 = 2;
        }
        return this.finishOp(types$12.relational, size4);
      };
      pp2.readToken_eq_excl = function(code3) {
        var next = this.input.charCodeAt(this.pos + 1);
        if (next === 61) {
          return this.finishOp(types$12.equality, this.input.charCodeAt(this.pos + 2) === 61 ? 3 : 2);
        }
        if (code3 === 61 && next === 62 && this.options.ecmaVersion >= 6) {
          this.pos += 2;
          return this.finishToken(types$12.arrow);
        }
        return this.finishOp(code3 === 61 ? types$12.eq : types$12.prefix, 1);
      };
      pp2.readToken_question = function() {
        var ecmaVersion2 = this.options.ecmaVersion;
        if (ecmaVersion2 >= 11) {
          var next = this.input.charCodeAt(this.pos + 1);
          if (next === 46) {
            var next2 = this.input.charCodeAt(this.pos + 2);
            if (next2 < 48 || next2 > 57) {
              return this.finishOp(types$12.questionDot, 2);
            }
          }
          if (next === 63) {
            if (ecmaVersion2 >= 12) {
              var next2$1 = this.input.charCodeAt(this.pos + 2);
              if (next2$1 === 61) {
                return this.finishOp(types$12.assign, 3);
              }
            }
            return this.finishOp(types$12.coalesce, 2);
          }
        }
        return this.finishOp(types$12.question, 1);
      };
      pp2.readToken_numberSign = function() {
        var ecmaVersion2 = this.options.ecmaVersion;
        var code3 = 35;
        if (ecmaVersion2 >= 13) {
          ++this.pos;
          code3 = this.fullCharCodeAtPos();
          if (isIdentifierStart2(code3, true) || code3 === 92) {
            return this.finishToken(types$12.privateId, this.readWord1());
          }
        }
        this.raise(this.pos, "Unexpected character '" + codePointToString2(code3) + "'");
      };
      pp2.getTokenFromCode = function(code3) {
        switch (code3) {
          case 46:
            return this.readToken_dot();
          case 40:
            ++this.pos;
            return this.finishToken(types$12.parenL);
          case 41:
            ++this.pos;
            return this.finishToken(types$12.parenR);
          case 59:
            ++this.pos;
            return this.finishToken(types$12.semi);
          case 44:
            ++this.pos;
            return this.finishToken(types$12.comma);
          case 91:
            ++this.pos;
            return this.finishToken(types$12.bracketL);
          case 93:
            ++this.pos;
            return this.finishToken(types$12.bracketR);
          case 123:
            ++this.pos;
            return this.finishToken(types$12.braceL);
          case 125:
            ++this.pos;
            return this.finishToken(types$12.braceR);
          case 58:
            ++this.pos;
            return this.finishToken(types$12.colon);
          case 96:
            if (this.options.ecmaVersion < 6) {
              break;
            }
            ++this.pos;
            return this.finishToken(types$12.backQuote);
          case 48:
            var next = this.input.charCodeAt(this.pos + 1);
            if (next === 120 || next === 88) {
              return this.readRadixNumber(16);
            }
            if (this.options.ecmaVersion >= 6) {
              if (next === 111 || next === 79) {
                return this.readRadixNumber(8);
              }
              if (next === 98 || next === 66) {
                return this.readRadixNumber(2);
              }
            }
          case 49:
          case 50:
          case 51:
          case 52:
          case 53:
          case 54:
          case 55:
          case 56:
          case 57:
            return this.readNumber(false);
          case 34:
          case 39:
            return this.readString(code3);
          case 47:
            return this.readToken_slash();
          case 37:
          case 42:
            return this.readToken_mult_modulo_exp(code3);
          case 124:
          case 38:
            return this.readToken_pipe_amp(code3);
          case 94:
            return this.readToken_caret();
          case 43:
          case 45:
            return this.readToken_plus_min(code3);
          case 60:
          case 62:
            return this.readToken_lt_gt(code3);
          case 61:
          case 33:
            return this.readToken_eq_excl(code3);
          case 63:
            return this.readToken_question();
          case 126:
            return this.finishOp(types$12.prefix, 1);
          case 35:
            return this.readToken_numberSign();
        }
        this.raise(this.pos, "Unexpected character '" + codePointToString2(code3) + "'");
      };
      pp2.finishOp = function(type2, size4) {
        var str2 = this.input.slice(this.pos, this.pos + size4);
        this.pos += size4;
        return this.finishToken(type2, str2);
      };
      pp2.readRegexp = function() {
        var escaped, inClass, start2 = this.pos;
        for (; ; ) {
          if (this.pos >= this.input.length) {
            this.raise(start2, "Unterminated regular expression");
          }
          var ch = this.input.charAt(this.pos);
          if (lineBreak2.test(ch)) {
            this.raise(start2, "Unterminated regular expression");
          }
          if (!escaped) {
            if (ch === "[") {
              inClass = true;
            } else if (ch === "]" && inClass) {
              inClass = false;
            } else if (ch === "/" && !inClass) {
              break;
            }
            escaped = ch === "\\";
          } else {
            escaped = false;
          }
          ++this.pos;
        }
        var pattern = this.input.slice(start2, this.pos);
        ++this.pos;
        var flagsStart = this.pos;
        var flags = this.readWord1();
        if (this.containsEsc) {
          this.unexpected(flagsStart);
        }
        var state = this.regexpState || (this.regexpState = new RegExpValidationState3(this));
        state.reset(start2, pattern, flags);
        this.validateRegExpFlags(state);
        this.validateRegExpPattern(state);
        var value2 = null;
        try {
          value2 = new RegExp(pattern, flags);
        } catch (e2) {
        }
        return this.finishToken(types$12.regexp, { pattern, flags, value: value2 });
      };
      pp2.readInt = function(radix, len, maybeLegacyOctalNumericLiteral) {
        var allowSeparators = this.options.ecmaVersion >= 12 && len === void 0;
        var isLegacyOctalNumericLiteral = maybeLegacyOctalNumericLiteral && this.input.charCodeAt(this.pos) === 48;
        var start2 = this.pos, total = 0, lastCode = 0;
        for (var i4 = 0, e2 = len == null ? Infinity : len; i4 < e2; ++i4, ++this.pos) {
          var code3 = this.input.charCodeAt(this.pos), val = void 0;
          if (allowSeparators && code3 === 95) {
            if (isLegacyOctalNumericLiteral) {
              this.raiseRecoverable(this.pos, "Numeric separator is not allowed in legacy octal numeric literals");
            }
            if (lastCode === 95) {
              this.raiseRecoverable(this.pos, "Numeric separator must be exactly one underscore");
            }
            if (i4 === 0) {
              this.raiseRecoverable(this.pos, "Numeric separator is not allowed at the first of digits");
            }
            lastCode = code3;
            continue;
          }
          if (code3 >= 97) {
            val = code3 - 97 + 10;
          } else if (code3 >= 65) {
            val = code3 - 65 + 10;
          } else if (code3 >= 48 && code3 <= 57) {
            val = code3 - 48;
          } else {
            val = Infinity;
          }
          if (val >= radix) {
            break;
          }
          lastCode = code3;
          total = total * radix + val;
        }
        if (allowSeparators && lastCode === 95) {
          this.raiseRecoverable(this.pos - 1, "Numeric separator is not allowed at the last of digits");
        }
        if (this.pos === start2 || len != null && this.pos - start2 !== len) {
          return null;
        }
        return total;
      };
      function stringToNumber2(str2, isLegacyOctalNumericLiteral) {
        if (isLegacyOctalNumericLiteral) {
          return parseInt(str2, 8);
        }
        return parseFloat(str2.replace(/_/g, ""));
      }
      function stringToBigInt2(str2) {
        if (typeof BigInt !== "function") {
          return null;
        }
        return BigInt(str2.replace(/_/g, ""));
      }
      pp2.readRadixNumber = function(radix) {
        var start2 = this.pos;
        this.pos += 2;
        var val = this.readInt(radix);
        if (val == null) {
          this.raise(this.start + 2, "Expected number in radix " + radix);
        }
        if (this.options.ecmaVersion >= 11 && this.input.charCodeAt(this.pos) === 110) {
          val = stringToBigInt2(this.input.slice(start2, this.pos));
          ++this.pos;
        } else if (isIdentifierStart2(this.fullCharCodeAtPos())) {
          this.raise(this.pos, "Identifier directly after number");
        }
        return this.finishToken(types$12.num, val);
      };
      pp2.readNumber = function(startsWithDot) {
        var start2 = this.pos;
        if (!startsWithDot && this.readInt(10, void 0, true) === null) {
          this.raise(start2, "Invalid number");
        }
        var octal = this.pos - start2 >= 2 && this.input.charCodeAt(start2) === 48;
        if (octal && this.strict) {
          this.raise(start2, "Invalid number");
        }
        var next = this.input.charCodeAt(this.pos);
        if (!octal && !startsWithDot && this.options.ecmaVersion >= 11 && next === 110) {
          var val$1 = stringToBigInt2(this.input.slice(start2, this.pos));
          ++this.pos;
          if (isIdentifierStart2(this.fullCharCodeAtPos())) {
            this.raise(this.pos, "Identifier directly after number");
          }
          return this.finishToken(types$12.num, val$1);
        }
        if (octal && /[89]/.test(this.input.slice(start2, this.pos))) {
          octal = false;
        }
        if (next === 46 && !octal) {
          ++this.pos;
          this.readInt(10);
          next = this.input.charCodeAt(this.pos);
        }
        if ((next === 69 || next === 101) && !octal) {
          next = this.input.charCodeAt(++this.pos);
          if (next === 43 || next === 45) {
            ++this.pos;
          }
          if (this.readInt(10) === null) {
            this.raise(start2, "Invalid number");
          }
        }
        if (isIdentifierStart2(this.fullCharCodeAtPos())) {
          this.raise(this.pos, "Identifier directly after number");
        }
        var val = stringToNumber2(this.input.slice(start2, this.pos), octal);
        return this.finishToken(types$12.num, val);
      };
      pp2.readCodePoint = function() {
        var ch = this.input.charCodeAt(this.pos), code3;
        if (ch === 123) {
          if (this.options.ecmaVersion < 6) {
            this.unexpected();
          }
          var codePos = ++this.pos;
          code3 = this.readHexChar(this.input.indexOf("}", this.pos) - this.pos);
          ++this.pos;
          if (code3 > 1114111) {
            this.invalidStringToken(codePos, "Code point out of bounds");
          }
        } else {
          code3 = this.readHexChar(4);
        }
        return code3;
      };
      pp2.readString = function(quote) {
        var out = "", chunkStart = ++this.pos;
        for (; ; ) {
          if (this.pos >= this.input.length) {
            this.raise(this.start, "Unterminated string constant");
          }
          var ch = this.input.charCodeAt(this.pos);
          if (ch === quote) {
            break;
          }
          if (ch === 92) {
            out += this.input.slice(chunkStart, this.pos);
            out += this.readEscapedChar(false);
            chunkStart = this.pos;
          } else if (ch === 8232 || ch === 8233) {
            if (this.options.ecmaVersion < 10) {
              this.raise(this.start, "Unterminated string constant");
            }
            ++this.pos;
            if (this.options.locations) {
              this.curLine++;
              this.lineStart = this.pos;
            }
          } else {
            if (isNewLine2(ch)) {
              this.raise(this.start, "Unterminated string constant");
            }
            ++this.pos;
          }
        }
        out += this.input.slice(chunkStart, this.pos++);
        return this.finishToken(types$12.string, out);
      };
      var INVALID_TEMPLATE_ESCAPE_ERROR2 = {};
      pp2.tryReadTemplateToken = function() {
        this.inTemplateElement = true;
        try {
          this.readTmplToken();
        } catch (err) {
          if (err === INVALID_TEMPLATE_ESCAPE_ERROR2) {
            this.readInvalidTemplateToken();
          } else {
            throw err;
          }
        }
        this.inTemplateElement = false;
      };
      pp2.invalidStringToken = function(position2, message) {
        if (this.inTemplateElement && this.options.ecmaVersion >= 9) {
          throw INVALID_TEMPLATE_ESCAPE_ERROR2;
        } else {
          this.raise(position2, message);
        }
      };
      pp2.readTmplToken = function() {
        var out = "", chunkStart = this.pos;
        for (; ; ) {
          if (this.pos >= this.input.length) {
            this.raise(this.start, "Unterminated template");
          }
          var ch = this.input.charCodeAt(this.pos);
          if (ch === 96 || ch === 36 && this.input.charCodeAt(this.pos + 1) === 123) {
            if (this.pos === this.start && (this.type === types$12.template || this.type === types$12.invalidTemplate)) {
              if (ch === 36) {
                this.pos += 2;
                return this.finishToken(types$12.dollarBraceL);
              } else {
                ++this.pos;
                return this.finishToken(types$12.backQuote);
              }
            }
            out += this.input.slice(chunkStart, this.pos);
            return this.finishToken(types$12.template, out);
          }
          if (ch === 92) {
            out += this.input.slice(chunkStart, this.pos);
            out += this.readEscapedChar(true);
            chunkStart = this.pos;
          } else if (isNewLine2(ch)) {
            out += this.input.slice(chunkStart, this.pos);
            ++this.pos;
            switch (ch) {
              case 13:
                if (this.input.charCodeAt(this.pos) === 10) {
                  ++this.pos;
                }
              case 10:
                out += "\n";
                break;
              default:
                out += String.fromCharCode(ch);
                break;
            }
            if (this.options.locations) {
              ++this.curLine;
              this.lineStart = this.pos;
            }
            chunkStart = this.pos;
          } else {
            ++this.pos;
          }
        }
      };
      pp2.readInvalidTemplateToken = function() {
        for (; this.pos < this.input.length; this.pos++) {
          switch (this.input[this.pos]) {
            case "\\":
              ++this.pos;
              break;
            case "$":
              if (this.input[this.pos + 1] !== "{") {
                break;
              }
            case "`":
              return this.finishToken(types$12.invalidTemplate, this.input.slice(this.start, this.pos));
            case "\r":
              if (this.input[this.pos + 1] === "\n") {
                ++this.pos;
              }
            case "\n":
            case "\u2028":
            case "\u2029":
              ++this.curLine;
              this.lineStart = this.pos + 1;
              break;
          }
        }
        this.raise(this.start, "Unterminated template");
      };
      pp2.readEscapedChar = function(inTemplate) {
        var ch = this.input.charCodeAt(++this.pos);
        ++this.pos;
        switch (ch) {
          case 110:
            return "\n";
          case 114:
            return "\r";
          case 120:
            return String.fromCharCode(this.readHexChar(2));
          case 117:
            return codePointToString2(this.readCodePoint());
          case 116:
            return "	";
          case 98:
            return "\b";
          case 118:
            return "\v";
          case 102:
            return "\f";
          case 13:
            if (this.input.charCodeAt(this.pos) === 10) {
              ++this.pos;
            }
          case 10:
            if (this.options.locations) {
              this.lineStart = this.pos;
              ++this.curLine;
            }
            return "";
          case 56:
          case 57:
            if (this.strict) {
              this.invalidStringToken(
                this.pos - 1,
                "Invalid escape sequence"
              );
            }
            if (inTemplate) {
              var codePos = this.pos - 1;
              this.invalidStringToken(
                codePos,
                "Invalid escape sequence in template string"
              );
            }
          default:
            if (ch >= 48 && ch <= 55) {
              var octalStr = this.input.substr(this.pos - 1, 3).match(/^[0-7]+/)[0];
              var octal = parseInt(octalStr, 8);
              if (octal > 255) {
                octalStr = octalStr.slice(0, -1);
                octal = parseInt(octalStr, 8);
              }
              this.pos += octalStr.length - 1;
              ch = this.input.charCodeAt(this.pos);
              if ((octalStr !== "0" || ch === 56 || ch === 57) && (this.strict || inTemplate)) {
                this.invalidStringToken(
                  this.pos - 1 - octalStr.length,
                  inTemplate ? "Octal literal in template string" : "Octal literal in strict mode"
                );
              }
              return String.fromCharCode(octal);
            }
            if (isNewLine2(ch)) {
              if (this.options.locations) {
                this.lineStart = this.pos;
                ++this.curLine;
              }
              return "";
            }
            return String.fromCharCode(ch);
        }
      };
      pp2.readHexChar = function(len) {
        var codePos = this.pos;
        var n3 = this.readInt(16, len);
        if (n3 === null) {
          this.invalidStringToken(codePos, "Bad character escape sequence");
        }
        return n3;
      };
      pp2.readWord1 = function() {
        this.containsEsc = false;
        var word = "", first = true, chunkStart = this.pos;
        var astral = this.options.ecmaVersion >= 6;
        while (this.pos < this.input.length) {
          var ch = this.fullCharCodeAtPos();
          if (isIdentifierChar2(ch, astral)) {
            this.pos += ch <= 65535 ? 1 : 2;
          } else if (ch === 92) {
            this.containsEsc = true;
            word += this.input.slice(chunkStart, this.pos);
            var escStart = this.pos;
            if (this.input.charCodeAt(++this.pos) !== 117) {
              this.invalidStringToken(this.pos, "Expecting Unicode escape sequence \\uXXXX");
            }
            ++this.pos;
            var esc = this.readCodePoint();
            if (!(first ? isIdentifierStart2 : isIdentifierChar2)(esc, astral)) {
              this.invalidStringToken(escStart, "Invalid Unicode escape");
            }
            word += codePointToString2(esc);
            chunkStart = this.pos;
          } else {
            break;
          }
          first = false;
        }
        return word + this.input.slice(chunkStart, this.pos);
      };
      pp2.readWord = function() {
        var word = this.readWord1();
        var type2 = types$12.name;
        if (this.keywords.test(word)) {
          type2 = keywords2[word];
        }
        return this.finishToken(type2, word);
      };
      var version2 = "8.14.0";
      Parser3.acorn = {
        Parser: Parser3,
        version: version2,
        defaultOptions: defaultOptions3,
        Position: Position3,
        SourceLocation: SourceLocation3,
        getLineInfo: getLineInfo2,
        Node: Node4,
        TokenType: TokenType3,
        tokTypes: types$12,
        keywordTypes: keywords2,
        TokContext: TokContext3,
        tokContexts: types4,
        isIdentifierChar: isIdentifierChar2,
        isIdentifierStart: isIdentifierStart2,
        Token: Token3,
        isNewLine: isNewLine2,
        lineBreak: lineBreak2,
        lineBreakG: lineBreakG2,
        nonASCIIwhitespace: nonASCIIwhitespace2
      };
      function parse5(input, options) {
        return Parser3.parse(input, options);
      }
      function parseExpressionAt2(input, pos, options) {
        return Parser3.parseExpressionAt(input, pos, options);
      }
      function tokenizer2(input, options) {
        return Parser3.tokenizer(input, options);
      }
      exports2.Node = Node4;
      exports2.Parser = Parser3;
      exports2.Position = Position3;
      exports2.SourceLocation = SourceLocation3;
      exports2.TokContext = TokContext3;
      exports2.Token = Token3;
      exports2.TokenType = TokenType3;
      exports2.defaultOptions = defaultOptions3;
      exports2.getLineInfo = getLineInfo2;
      exports2.isIdentifierChar = isIdentifierChar2;
      exports2.isIdentifierStart = isIdentifierStart2;
      exports2.isNewLine = isNewLine2;
      exports2.keywordTypes = keywords2;
      exports2.lineBreak = lineBreak2;
      exports2.lineBreakG = lineBreakG2;
      exports2.nonASCIIwhitespace = nonASCIIwhitespace2;
      exports2.parse = parse5;
      exports2.parseExpressionAt = parseExpressionAt2;
      exports2.tokContexts = types4;
      exports2.tokTypes = types$12;
      exports2.tokenizer = tokenizer2;
      exports2.version = version2;
    });
  }
});

// node_modules/acorn-jsx/index.js
var require_acorn_jsx = __commonJS({
  "node_modules/acorn-jsx/index.js"(exports, module) {
    "use strict";
    var XHTMLEntities = require_xhtml();
    var hexNumber = /^[\da-fA-F]+$/;
    var decimalNumber = /^\d+$/;
    var acornJsxMap = /* @__PURE__ */ new WeakMap();
    function getJsxTokens(acorn) {
      acorn = acorn.Parser.acorn || acorn;
      let acornJsx2 = acornJsxMap.get(acorn);
      if (!acornJsx2) {
        const tt2 = acorn.tokTypes;
        const TokContext3 = acorn.TokContext;
        const TokenType3 = acorn.TokenType;
        const tc_oTag = new TokContext3("<tag", false);
        const tc_cTag = new TokContext3("</tag", false);
        const tc_expr = new TokContext3("<tag>...</tag>", true, true);
        const tokContexts = {
          tc_oTag,
          tc_cTag,
          tc_expr
        };
        const tokTypes = {
          jsxName: new TokenType3("jsxName"),
          jsxText: new TokenType3("jsxText", { beforeExpr: true }),
          jsxTagStart: new TokenType3("jsxTagStart", { startsExpr: true }),
          jsxTagEnd: new TokenType3("jsxTagEnd")
        };
        tokTypes.jsxTagStart.updateContext = function() {
          this.context.push(tc_expr);
          this.context.push(tc_oTag);
          this.exprAllowed = false;
        };
        tokTypes.jsxTagEnd.updateContext = function(prevType) {
          let out = this.context.pop();
          if (out === tc_oTag && prevType === tt2.slash || out === tc_cTag) {
            this.context.pop();
            this.exprAllowed = this.curContext() === tc_expr;
          } else {
            this.exprAllowed = true;
          }
        };
        acornJsx2 = { tokContexts, tokTypes };
        acornJsxMap.set(acorn, acornJsx2);
      }
      return acornJsx2;
    }
    function getQualifiedJSXName(object) {
      if (!object)
        return object;
      if (object.type === "JSXIdentifier")
        return object.name;
      if (object.type === "JSXNamespacedName")
        return object.namespace.name + ":" + object.name.name;
      if (object.type === "JSXMemberExpression")
        return getQualifiedJSXName(object.object) + "." + getQualifiedJSXName(object.property);
    }
    module.exports = function(options) {
      options = options || {};
      return function(Parser3) {
        return plugin({
          allowNamespaces: options.allowNamespaces !== false,
          allowNamespacedObjects: !!options.allowNamespacedObjects
        }, Parser3);
      };
    };
    Object.defineProperty(module.exports, "tokTypes", {
      get: function get_tokTypes() {
        return getJsxTokens(require_acorn()).tokTypes;
      },
      configurable: true,
      enumerable: true
    });
    function plugin(options, Parser3) {
      const acorn = Parser3.acorn || require_acorn();
      const acornJsx2 = getJsxTokens(acorn);
      const tt2 = acorn.tokTypes;
      const tok = acornJsx2.tokTypes;
      const tokContexts = acorn.tokContexts;
      const tc_oTag = acornJsx2.tokContexts.tc_oTag;
      const tc_cTag = acornJsx2.tokContexts.tc_cTag;
      const tc_expr = acornJsx2.tokContexts.tc_expr;
      const isNewLine2 = acorn.isNewLine;
      const isIdentifierStart2 = acorn.isIdentifierStart;
      const isIdentifierChar2 = acorn.isIdentifierChar;
      return class extends Parser3 {
        // Expose actual `tokTypes` and `tokContexts` to other plugins.
        static get acornJsx() {
          return acornJsx2;
        }
        // Reads inline JSX contents token.
        jsx_readToken() {
          let out = "", chunkStart = this.pos;
          for (; ; ) {
            if (this.pos >= this.input.length)
              this.raise(this.start, "Unterminated JSX contents");
            let ch = this.input.charCodeAt(this.pos);
            switch (ch) {
              case 60:
              case 123:
                if (this.pos === this.start) {
                  if (ch === 60 && this.exprAllowed) {
                    ++this.pos;
                    return this.finishToken(tok.jsxTagStart);
                  }
                  return this.getTokenFromCode(ch);
                }
                out += this.input.slice(chunkStart, this.pos);
                return this.finishToken(tok.jsxText, out);
              case 38:
                out += this.input.slice(chunkStart, this.pos);
                out += this.jsx_readEntity();
                chunkStart = this.pos;
                break;
              case 62:
              case 125:
                this.raise(
                  this.pos,
                  "Unexpected token `" + this.input[this.pos] + "`. Did you mean `" + (ch === 62 ? "&gt;" : "&rbrace;") + '` or `{"' + this.input[this.pos] + '"}`?'
                );
              default:
                if (isNewLine2(ch)) {
                  out += this.input.slice(chunkStart, this.pos);
                  out += this.jsx_readNewLine(true);
                  chunkStart = this.pos;
                } else {
                  ++this.pos;
                }
            }
          }
        }
        jsx_readNewLine(normalizeCRLF) {
          let ch = this.input.charCodeAt(this.pos);
          let out;
          ++this.pos;
          if (ch === 13 && this.input.charCodeAt(this.pos) === 10) {
            ++this.pos;
            out = normalizeCRLF ? "\n" : "\r\n";
          } else {
            out = String.fromCharCode(ch);
          }
          if (this.options.locations) {
            ++this.curLine;
            this.lineStart = this.pos;
          }
          return out;
        }
        jsx_readString(quote) {
          let out = "", chunkStart = ++this.pos;
          for (; ; ) {
            if (this.pos >= this.input.length)
              this.raise(this.start, "Unterminated string constant");
            let ch = this.input.charCodeAt(this.pos);
            if (ch === quote) break;
            if (ch === 38) {
              out += this.input.slice(chunkStart, this.pos);
              out += this.jsx_readEntity();
              chunkStart = this.pos;
            } else if (isNewLine2(ch)) {
              out += this.input.slice(chunkStart, this.pos);
              out += this.jsx_readNewLine(false);
              chunkStart = this.pos;
            } else {
              ++this.pos;
            }
          }
          out += this.input.slice(chunkStart, this.pos++);
          return this.finishToken(tt2.string, out);
        }
        jsx_readEntity() {
          let str2 = "", count3 = 0, entity;
          let ch = this.input[this.pos];
          if (ch !== "&")
            this.raise(this.pos, "Entity must start with an ampersand");
          let startPos = ++this.pos;
          while (this.pos < this.input.length && count3++ < 10) {
            ch = this.input[this.pos++];
            if (ch === ";") {
              if (str2[0] === "#") {
                if (str2[1] === "x") {
                  str2 = str2.substr(2);
                  if (hexNumber.test(str2))
                    entity = String.fromCharCode(parseInt(str2, 16));
                } else {
                  str2 = str2.substr(1);
                  if (decimalNumber.test(str2))
                    entity = String.fromCharCode(parseInt(str2, 10));
                }
              } else {
                entity = XHTMLEntities[str2];
              }
              break;
            }
            str2 += ch;
          }
          if (!entity) {
            this.pos = startPos;
            return "&";
          }
          return entity;
        }
        // Read a JSX identifier (valid tag or attribute name).
        //
        // Optimized version since JSX identifiers can't contain
        // escape characters and so can be read as single slice.
        // Also assumes that first character was already checked
        // by isIdentifierStart in readToken.
        jsx_readWord() {
          let ch, start2 = this.pos;
          do {
            ch = this.input.charCodeAt(++this.pos);
          } while (isIdentifierChar2(ch) || ch === 45);
          return this.finishToken(tok.jsxName, this.input.slice(start2, this.pos));
        }
        // Parse next token as JSX identifier
        jsx_parseIdentifier() {
          let node2 = this.startNode();
          if (this.type === tok.jsxName)
            node2.name = this.value;
          else if (this.type.keyword)
            node2.name = this.type.keyword;
          else
            this.unexpected();
          this.next();
          return this.finishNode(node2, "JSXIdentifier");
        }
        // Parse namespaced identifier.
        jsx_parseNamespacedName() {
          let startPos = this.start, startLoc = this.startLoc;
          let name2 = this.jsx_parseIdentifier();
          if (!options.allowNamespaces || !this.eat(tt2.colon)) return name2;
          var node2 = this.startNodeAt(startPos, startLoc);
          node2.namespace = name2;
          node2.name = this.jsx_parseIdentifier();
          return this.finishNode(node2, "JSXNamespacedName");
        }
        // Parses element name in any form - namespaced, member
        // or single identifier.
        jsx_parseElementName() {
          if (this.type === tok.jsxTagEnd) return "";
          let startPos = this.start, startLoc = this.startLoc;
          let node2 = this.jsx_parseNamespacedName();
          if (this.type === tt2.dot && node2.type === "JSXNamespacedName" && !options.allowNamespacedObjects) {
            this.unexpected();
          }
          while (this.eat(tt2.dot)) {
            let newNode = this.startNodeAt(startPos, startLoc);
            newNode.object = node2;
            newNode.property = this.jsx_parseIdentifier();
            node2 = this.finishNode(newNode, "JSXMemberExpression");
          }
          return node2;
        }
        // Parses any type of JSX attribute value.
        jsx_parseAttributeValue() {
          switch (this.type) {
            case tt2.braceL:
              let node2 = this.jsx_parseExpressionContainer();
              if (node2.expression.type === "JSXEmptyExpression")
                this.raise(node2.start, "JSX attributes must only be assigned a non-empty expression");
              return node2;
            case tok.jsxTagStart:
            case tt2.string:
              return this.parseExprAtom();
            default:
              this.raise(this.start, "JSX value should be either an expression or a quoted JSX text");
          }
        }
        // JSXEmptyExpression is unique type since it doesn't actually parse anything,
        // and so it should start at the end of last read token (left brace) and finish
        // at the beginning of the next one (right brace).
        jsx_parseEmptyExpression() {
          let node2 = this.startNodeAt(this.lastTokEnd, this.lastTokEndLoc);
          return this.finishNodeAt(node2, "JSXEmptyExpression", this.start, this.startLoc);
        }
        // Parses JSX expression enclosed into curly brackets.
        jsx_parseExpressionContainer() {
          let node2 = this.startNode();
          this.next();
          node2.expression = this.type === tt2.braceR ? this.jsx_parseEmptyExpression() : this.parseExpression();
          this.expect(tt2.braceR);
          return this.finishNode(node2, "JSXExpressionContainer");
        }
        // Parses following JSX attribute name-value pair.
        jsx_parseAttribute() {
          let node2 = this.startNode();
          if (this.eat(tt2.braceL)) {
            this.expect(tt2.ellipsis);
            node2.argument = this.parseMaybeAssign();
            this.expect(tt2.braceR);
            return this.finishNode(node2, "JSXSpreadAttribute");
          }
          node2.name = this.jsx_parseNamespacedName();
          node2.value = this.eat(tt2.eq) ? this.jsx_parseAttributeValue() : null;
          return this.finishNode(node2, "JSXAttribute");
        }
        // Parses JSX opening tag starting after '<'.
        jsx_parseOpeningElementAt(startPos, startLoc) {
          let node2 = this.startNodeAt(startPos, startLoc);
          node2.attributes = [];
          let nodeName = this.jsx_parseElementName();
          if (nodeName) node2.name = nodeName;
          while (this.type !== tt2.slash && this.type !== tok.jsxTagEnd)
            node2.attributes.push(this.jsx_parseAttribute());
          node2.selfClosing = this.eat(tt2.slash);
          this.expect(tok.jsxTagEnd);
          return this.finishNode(node2, nodeName ? "JSXOpeningElement" : "JSXOpeningFragment");
        }
        // Parses JSX closing tag starting after '</'.
        jsx_parseClosingElementAt(startPos, startLoc) {
          let node2 = this.startNodeAt(startPos, startLoc);
          let nodeName = this.jsx_parseElementName();
          if (nodeName) node2.name = nodeName;
          this.expect(tok.jsxTagEnd);
          return this.finishNode(node2, nodeName ? "JSXClosingElement" : "JSXClosingFragment");
        }
        // Parses entire JSX element, including it's opening tag
        // (starting after '<'), attributes, contents and closing tag.
        jsx_parseElementAt(startPos, startLoc) {
          let node2 = this.startNodeAt(startPos, startLoc);
          let children = [];
          let openingElement = this.jsx_parseOpeningElementAt(startPos, startLoc);
          let closingElement = null;
          if (!openingElement.selfClosing) {
            contents: for (; ; ) {
              switch (this.type) {
                case tok.jsxTagStart:
                  startPos = this.start;
                  startLoc = this.startLoc;
                  this.next();
                  if (this.eat(tt2.slash)) {
                    closingElement = this.jsx_parseClosingElementAt(startPos, startLoc);
                    break contents;
                  }
                  children.push(this.jsx_parseElementAt(startPos, startLoc));
                  break;
                case tok.jsxText:
                  children.push(this.parseExprAtom());
                  break;
                case tt2.braceL:
                  children.push(this.jsx_parseExpressionContainer());
                  break;
                default:
                  this.unexpected();
              }
            }
            if (getQualifiedJSXName(closingElement.name) !== getQualifiedJSXName(openingElement.name)) {
              this.raise(
                closingElement.start,
                "Expected corresponding JSX closing tag for <" + getQualifiedJSXName(openingElement.name) + ">"
              );
            }
          }
          let fragmentOrElement = openingElement.name ? "Element" : "Fragment";
          node2["opening" + fragmentOrElement] = openingElement;
          node2["closing" + fragmentOrElement] = closingElement;
          node2.children = children;
          if (this.type === tt2.relational && this.value === "<") {
            this.raise(this.start, "Adjacent JSX elements must be wrapped in an enclosing tag");
          }
          return this.finishNode(node2, "JSX" + fragmentOrElement);
        }
        // Parse JSX text
        jsx_parseText() {
          let node2 = this.parseLiteral(this.value);
          node2.type = "JSXText";
          return node2;
        }
        // Parses entire JSX element from current position.
        jsx_parseElement() {
          let startPos = this.start, startLoc = this.startLoc;
          this.next();
          return this.jsx_parseElementAt(startPos, startLoc);
        }
        parseExprAtom(refShortHandDefaultPos) {
          if (this.type === tok.jsxText)
            return this.jsx_parseText();
          else if (this.type === tok.jsxTagStart)
            return this.jsx_parseElement();
          else
            return super.parseExprAtom(refShortHandDefaultPos);
        }
        readToken(code3) {
          let context = this.curContext();
          if (context === tc_expr) return this.jsx_readToken();
          if (context === tc_oTag || context === tc_cTag) {
            if (isIdentifierStart2(code3)) return this.jsx_readWord();
            if (code3 == 62) {
              ++this.pos;
              return this.finishToken(tok.jsxTagEnd);
            }
            if ((code3 === 34 || code3 === 39) && context == tc_oTag)
              return this.jsx_readString(code3);
          }
          if (code3 === 60 && this.exprAllowed && this.input.charCodeAt(this.pos + 1) !== 33) {
            ++this.pos;
            return this.finishToken(tok.jsxTagStart);
          }
          return super.readToken(code3);
        }
        updateContext(prevType) {
          if (this.type == tt2.braceL) {
            var curContext = this.curContext();
            if (curContext == tc_oTag) this.context.push(tokContexts.b_expr);
            else if (curContext == tc_expr) this.context.push(tokContexts.b_tmpl);
            else super.updateContext(prevType);
            this.exprAllowed = true;
          } else if (this.type === tt2.slash && prevType === tok.jsxTagStart) {
            this.context.length -= 2;
            this.context.push(tc_cTag);
            this.exprAllowed = false;
          } else {
            return super.updateContext(prevType);
          }
        }
      };
    }
  }
});

// node_modules/anser/lib/index.js
var require_lib = __commonJS({
  "node_modules/anser/lib/index.js"(exports, module) {
    "use strict";
    var _createClass = /* @__PURE__ */ function() {
      function defineProperties(target, props) {
        for (var i3 = 0; i3 < props.length; i3++) {
          var descriptor = props[i3];
          descriptor.enumerable = descriptor.enumerable || false;
          descriptor.configurable = true;
          if ("value" in descriptor) descriptor.writable = true;
          Object.defineProperty(target, descriptor.key, descriptor);
        }
      }
      return function(Constructor, protoProps, staticProps) {
        if (protoProps) defineProperties(Constructor.prototype, protoProps);
        if (staticProps) defineProperties(Constructor, staticProps);
        return Constructor;
      };
    }();
    function _classCallCheck(instance, Constructor) {
      if (!(instance instanceof Constructor)) {
        throw new TypeError("Cannot call a class as a function");
      }
    }
    var ANSI_COLORS = [[{ color: "0, 0, 0", "class": "ansi-black" }, { color: "187, 0, 0", "class": "ansi-red" }, { color: "0, 187, 0", "class": "ansi-green" }, { color: "187, 187, 0", "class": "ansi-yellow" }, { color: "0, 0, 187", "class": "ansi-blue" }, { color: "187, 0, 187", "class": "ansi-magenta" }, { color: "0, 187, 187", "class": "ansi-cyan" }, { color: "255,255,255", "class": "ansi-white" }], [{ color: "85, 85, 85", "class": "ansi-bright-black" }, { color: "255, 85, 85", "class": "ansi-bright-red" }, { color: "0, 255, 0", "class": "ansi-bright-green" }, { color: "255, 255, 85", "class": "ansi-bright-yellow" }, { color: "85, 85, 255", "class": "ansi-bright-blue" }, { color: "255, 85, 255", "class": "ansi-bright-magenta" }, { color: "85, 255, 255", "class": "ansi-bright-cyan" }, { color: "255, 255, 255", "class": "ansi-bright-white" }]];
    var linkRegex = /(https?:\/\/(?:[A-Za-z0-9#;/?:@=+$',_.!~*()[\]-]|&amp;|%[A-Fa-f0-9]{2})+)/gm;
    var Anser2 = function() {
      _createClass(Anser3, null, [{
        key: "escapeForHtml",
        /**
         * Anser.escapeForHtml
         * Escape the input HTML.
         *
         * This does the minimum escaping of text to make it compliant with HTML.
         * In particular, the '&','<', and '>' characters are escaped. This should
         * be run prior to `ansiToHtml`.
         *
         * @name Anser.escapeForHtml
         * @function
         * @param {String} txt The input text (containing the ANSI snippets).
         * @returns {String} The escaped html.
         */
        value: function escapeForHtml(txt) {
          return new Anser3().escapeForHtml(txt);
        }
        /**
         * Anser.linkify
         * Adds the links in the HTML.
         *
         * This replaces any links in the text with anchor tags that display the
         * link. You should apply this after you have run `ansiToHtml` on the text.
         *
         * @name Anser.linkify
         * @function
         * @param {String} txt The input text.
         * @returns {String} The HTML containing the <a> tags (unescaped).
         */
      }, {
        key: "linkify",
        value: function linkify(txt) {
          return new Anser3().linkify(txt);
        }
        /**
         * Anser.ansiToHtml
         * This replaces ANSI terminal escape codes with SPAN tags that wrap the
         * content.
         *
         * This function only interprets ANSI SGR (Select Graphic Rendition) codes
         * that can be represented in HTML.
         * For example, cursor movement codes are ignored and hidden from output.
         * The default style uses colors that are very close to the prescribed
         * standard. The standard assumes that the text will have a black
         * background. These colors are set as inline styles on the SPAN tags.
         *
         * Another option is to set `use_classes: true` in the options argument.
         * This will instead set classes on the spans so the colors can be set via
         * CSS. The class names used are of the format `ansi-*-fg/bg` and
         * `ansi-bright-*-fg/bg` where `*` is the color name,
         * i.e black/red/green/yellow/blue/magenta/cyan/white.
         *
         * @name Anser.ansiToHtml
         * @function
         * @param {String} txt The input text.
         * @param {Object} options The options passed to the ansiToHTML method.
         * @returns {String} The HTML output.
         */
      }, {
        key: "ansiToHtml",
        value: function ansiToHtml(txt, options) {
          return new Anser3().ansiToHtml(txt, options);
        }
        /**
         * Anser.ansiToJson
         * Converts ANSI input into JSON output.
         *
         * @name Anser.ansiToJson
         * @function
         * @param {String} txt The input text.
         * @param {Object} options The options passed to the ansiToHTML method.
         * @returns {String} The HTML output.
         */
      }, {
        key: "ansiToJson",
        value: function ansiToJson(txt, options) {
          return new Anser3().ansiToJson(txt, options);
        }
        /**
         * Anser.ansiToText
         * Converts ANSI input into text output.
         *
         * @name Anser.ansiToText
         * @function
         * @param {String} txt The input text.
         * @returns {String} The text output.
         */
      }, {
        key: "ansiToText",
        value: function ansiToText(txt) {
          return new Anser3().ansiToText(txt);
        }
        /**
         * Anser
         * The `Anser` class.
         *
         * @name Anser
         * @function
         * @returns {Anser}
         */
      }]);
      function Anser3() {
        _classCallCheck(this, Anser3);
        this.fg = this.bg = this.fg_truecolor = this.bg_truecolor = null;
        this.bright = 0;
        this.decorations = [];
      }
      _createClass(Anser3, [{
        key: "setupPalette",
        value: function setupPalette() {
          this.PALETTE_COLORS = [];
          for (var i3 = 0; i3 < 2; ++i3) {
            for (var j3 = 0; j3 < 8; ++j3) {
              this.PALETTE_COLORS.push(ANSI_COLORS[i3][j3].color);
            }
          }
          var levels = [0, 95, 135, 175, 215, 255];
          var format = function format2(r3, g4, b4) {
            return levels[r3] + ", " + levels[g4] + ", " + levels[b4];
          };
          var r2 = void 0, g3 = void 0, b3 = void 0;
          for (var _r = 0; _r < 6; ++_r) {
            for (var _g = 0; _g < 6; ++_g) {
              for (var _b2 = 0; _b2 < 6; ++_b2) {
                this.PALETTE_COLORS.push(format(_r, _g, _b2));
              }
            }
          }
          var level = 8;
          for (var _i = 0; _i < 24; ++_i, level += 10) {
            this.PALETTE_COLORS.push(format(level, level, level));
          }
        }
        /**
         * escapeForHtml
         * Escapes the input text.
         *
         * @name escapeForHtml
         * @function
         * @param {String} txt The input text.
         * @returns {String} The escpaed HTML output.
         */
      }, {
        key: "escapeForHtml",
        value: function escapeForHtml(txt) {
          return txt.replace(/[&<>\"]/gm, function(str2) {
            return str2 == "&" ? "&amp;" : str2 == '"' ? "&quot;" : str2 == "<" ? "&lt;" : str2 == ">" ? "&gt;" : "";
          });
        }
        /**
         * linkify
         * Adds HTML link elements.
         *
         * @name linkify
         * @function
         * @param {String} txt The input text.
         * @returns {String} The HTML output containing link elements.
         */
      }, {
        key: "linkify",
        value: function linkify(txt) {
          return txt.replace(linkRegex, function(str2) {
            return '<a href="' + str2 + '">' + str2 + "</a>";
          });
        }
        /**
         * ansiToHtml
         * Converts ANSI input into HTML output.
         *
         * @name ansiToHtml
         * @function
         * @param {String} txt The input text.
         * @param {Object} options The options passed ot the `process` method.
         * @returns {String} The HTML output.
         */
      }, {
        key: "ansiToHtml",
        value: function ansiToHtml(txt, options) {
          return this.process(txt, options, true);
        }
        /**
         * ansiToJson
         * Converts ANSI input into HTML output.
         *
         * @name ansiToJson
         * @function
         * @param {String} txt The input text.
         * @param {Object} options The options passed ot the `process` method.
         * @returns {String} The JSON output.
         */
      }, {
        key: "ansiToJson",
        value: function ansiToJson(txt, options) {
          options = options || {};
          options.json = true;
          options.clearLine = false;
          return this.process(txt, options, true);
        }
        /**
         * ansiToText
         * Converts ANSI input into HTML output.
         *
         * @name ansiToText
         * @function
         * @param {String} txt The input text.
         * @returns {String} The text output.
         */
      }, {
        key: "ansiToText",
        value: function ansiToText(txt) {
          return this.process(txt, {}, false);
        }
        /**
         * process
         * Processes the input.
         *
         * @name process
         * @function
         * @param {String} txt The input text.
         * @param {Object} options An object passed to `processChunk` method, extended with:
         *
         *  - `json` (Boolean): If `true`, the result will be an object.
         *  - `use_classes` (Boolean): If `true`, HTML classes will be appended to the HTML output.
         *
         * @param {Boolean} markup
         */
      }, {
        key: "process",
        value: function process2(txt, options, markup) {
          var _this = this;
          var self2 = this;
          var raw_text_chunks = txt.split(/\033\[/);
          var first_chunk = raw_text_chunks.shift();
          if (options === void 0 || options === null) {
            options = {};
          }
          options.clearLine = /\r/.test(txt);
          var color_chunks = raw_text_chunks.map(function(chunk) {
            return _this.processChunk(chunk, options, markup);
          });
          if (options && options.json) {
            var first = self2.processChunkJson("");
            first.content = first_chunk;
            first.clearLine = options.clearLine;
            color_chunks.unshift(first);
            if (options.remove_empty) {
              color_chunks = color_chunks.filter(function(c2) {
                return !c2.isEmpty();
              });
            }
            return color_chunks;
          } else {
            color_chunks.unshift(first_chunk);
          }
          return color_chunks.join("");
        }
        /**
         * processChunkJson
         * Processes the current chunk into json output.
         *
         * @name processChunkJson
         * @function
         * @param {String} text The input text.
         * @param {Object} options An object containing the following fields:
         *
         *  - `json` (Boolean): If `true`, the result will be an object.
         *  - `use_classes` (Boolean): If `true`, HTML classes will be appended to the HTML output.
         *
         * @param {Boolean} markup If false, the colors will not be parsed.
         * @return {Object} The result object:
         *
         *  - `content` (String): The text.
         *  - `fg` (String|null): The foreground color.
         *  - `bg` (String|null): The background color.
         *  - `fg_truecolor` (String|null): The foreground true color (if 16m color is enabled).
         *  - `bg_truecolor` (String|null): The background true color (if 16m color is enabled).
         *  - `clearLine` (Boolean): `true` if a carriageReturn \r was fount at end of line.
         *  - `was_processed` (Bolean): `true` if the colors were processed, `false` otherwise.
         *  - `isEmpty` (Function): A function returning `true` if the content is empty, or `false` otherwise.
         *
         */
      }, {
        key: "processChunkJson",
        value: function processChunkJson(text4, options, markup) {
          options = typeof options == "undefined" ? {} : options;
          var use_classes = options.use_classes = typeof options.use_classes != "undefined" && options.use_classes;
          var key2 = options.key = use_classes ? "class" : "color";
          var result = {
            content: text4,
            fg: null,
            bg: null,
            fg_truecolor: null,
            bg_truecolor: null,
            isInverted: false,
            clearLine: options.clearLine,
            decoration: null,
            decorations: [],
            was_processed: false,
            isEmpty: function isEmpty() {
              return !result.content;
            }
          };
          var matches = text4.match(/^([!\x3c-\x3f]*)([\d;]*)([\x20-\x2c]*[\x40-\x7e])([\s\S]*)/m);
          if (!matches) return result;
          var orig_txt = result.content = matches[4];
          var nums = matches[2].split(";");
          if (matches[1] !== "" || matches[3] !== "m") {
            return result;
          }
          if (!markup) {
            return result;
          }
          var self2 = this;
          while (nums.length > 0) {
            var num_str = nums.shift();
            var num = parseInt(num_str);
            if (isNaN(num) || num === 0) {
              self2.fg = self2.bg = null;
              self2.decorations = [];
            } else if (num === 1) {
              self2.decorations.push("bold");
            } else if (num === 2) {
              self2.decorations.push("dim");
            } else if (num === 3) {
              self2.decorations.push("italic");
            } else if (num === 4) {
              self2.decorations.push("underline");
            } else if (num === 5) {
              self2.decorations.push("blink");
            } else if (num === 7) {
              self2.decorations.push("reverse");
            } else if (num === 8) {
              self2.decorations.push("hidden");
            } else if (num === 9) {
              self2.decorations.push("strikethrough");
            } else if (num === 21) {
              self2.removeDecoration("bold");
            } else if (num === 22) {
              self2.removeDecoration("bold");
              self2.removeDecoration("dim");
            } else if (num === 23) {
              self2.removeDecoration("italic");
            } else if (num === 24) {
              self2.removeDecoration("underline");
            } else if (num === 25) {
              self2.removeDecoration("blink");
            } else if (num === 27) {
              self2.removeDecoration("reverse");
            } else if (num === 28) {
              self2.removeDecoration("hidden");
            } else if (num === 29) {
              self2.removeDecoration("strikethrough");
            } else if (num === 39) {
              self2.fg = null;
            } else if (num === 49) {
              self2.bg = null;
            } else if (num >= 30 && num < 38) {
              self2.fg = ANSI_COLORS[0][num % 10][key2];
            } else if (num >= 90 && num < 98) {
              self2.fg = ANSI_COLORS[1][num % 10][key2];
            } else if (num >= 40 && num < 48) {
              self2.bg = ANSI_COLORS[0][num % 10][key2];
            } else if (num >= 100 && num < 108) {
              self2.bg = ANSI_COLORS[1][num % 10][key2];
            } else if (num === 38 || num === 48) {
              var is_foreground = num === 38;
              if (nums.length >= 1) {
                var mode = nums.shift();
                if (mode === "5" && nums.length >= 1) {
                  var palette_index = parseInt(nums.shift());
                  if (palette_index >= 0 && palette_index <= 255) {
                    if (!use_classes) {
                      if (!this.PALETTE_COLORS) {
                        self2.setupPalette();
                      }
                      if (is_foreground) {
                        self2.fg = this.PALETTE_COLORS[palette_index];
                      } else {
                        self2.bg = this.PALETTE_COLORS[palette_index];
                      }
                    } else {
                      var klass = palette_index >= 16 ? "ansi-palette-" + palette_index : ANSI_COLORS[palette_index > 7 ? 1 : 0][palette_index % 8]["class"];
                      if (is_foreground) {
                        self2.fg = klass;
                      } else {
                        self2.bg = klass;
                      }
                    }
                  }
                } else if (mode === "2" && nums.length >= 3) {
                  var r2 = parseInt(nums.shift());
                  var g3 = parseInt(nums.shift());
                  var b3 = parseInt(nums.shift());
                  if (r2 >= 0 && r2 <= 255 && g3 >= 0 && g3 <= 255 && b3 >= 0 && b3 <= 255) {
                    var color4 = r2 + ", " + g3 + ", " + b3;
                    if (!use_classes) {
                      if (is_foreground) {
                        self2.fg = color4;
                      } else {
                        self2.bg = color4;
                      }
                    } else {
                      if (is_foreground) {
                        self2.fg = "ansi-truecolor";
                        self2.fg_truecolor = color4;
                      } else {
                        self2.bg = "ansi-truecolor";
                        self2.bg_truecolor = color4;
                      }
                    }
                  }
                }
              }
            }
          }
          if (self2.fg === null && self2.bg === null && self2.decorations.length === 0) {
            return result;
          } else {
            var styles2 = [];
            var classes = [];
            var data2 = {};
            result.fg = self2.fg;
            result.bg = self2.bg;
            result.fg_truecolor = self2.fg_truecolor;
            result.bg_truecolor = self2.bg_truecolor;
            result.decorations = self2.decorations;
            result.decoration = self2.decorations.slice(-1).pop() || null;
            result.was_processed = true;
            return result;
          }
        }
        /**
         * processChunk
         * Processes the current chunk of text.
         *
         * @name processChunk
         * @function
         * @param {String} text The input text.
         * @param {Object} options An object containing the following fields:
         *
         *  - `json` (Boolean): If `true`, the result will be an object.
         *  - `use_classes` (Boolean): If `true`, HTML classes will be appended to the HTML output.
         *
         * @param {Boolean} markup If false, the colors will not be parsed.
         * @return {Object|String} The result (object if `json` is wanted back or string otherwise).
         */
      }, {
        key: "processChunk",
        value: function processChunk(text4, options, markup) {
          var _this2 = this;
          options = options || {};
          var jsonChunk = this.processChunkJson(text4, options, markup);
          var use_classes = options.use_classes;
          jsonChunk.decorations = jsonChunk.decorations.filter(function(decoration) {
            if (decoration === "reverse") {
              if (!jsonChunk.fg) {
                jsonChunk.fg = ANSI_COLORS[0][7][use_classes ? "class" : "color"];
              }
              if (!jsonChunk.bg) {
                jsonChunk.bg = ANSI_COLORS[0][0][use_classes ? "class" : "color"];
              }
              var tmpFg = jsonChunk.fg;
              jsonChunk.fg = jsonChunk.bg;
              jsonChunk.bg = tmpFg;
              var tmpFgTrue = jsonChunk.fg_truecolor;
              jsonChunk.fg_truecolor = jsonChunk.bg_truecolor;
              jsonChunk.bg_truecolor = tmpFgTrue;
              jsonChunk.isInverted = true;
              return false;
            }
            return true;
          });
          if (options.json) {
            return jsonChunk;
          }
          if (jsonChunk.isEmpty()) {
            return "";
          }
          if (!jsonChunk.was_processed) {
            return jsonChunk.content;
          }
          var colors = [];
          var decorations = [];
          var textDecorations = [];
          var data2 = {};
          var render_data = function render_data2(data3) {
            var fragments = [];
            var key2 = void 0;
            for (key2 in data3) {
              if (data3.hasOwnProperty(key2)) {
                fragments.push("data-" + key2 + '="' + _this2.escapeForHtml(data3[key2]) + '"');
              }
            }
            return fragments.length > 0 ? " " + fragments.join(" ") : "";
          };
          if (jsonChunk.isInverted) {
            data2["ansi-is-inverted"] = "true";
          }
          if (jsonChunk.fg) {
            if (use_classes) {
              colors.push(jsonChunk.fg + "-fg");
              if (jsonChunk.fg_truecolor !== null) {
                data2["ansi-truecolor-fg"] = jsonChunk.fg_truecolor;
                jsonChunk.fg_truecolor = null;
              }
            } else {
              colors.push("color:rgb(" + jsonChunk.fg + ")");
            }
          }
          if (jsonChunk.bg) {
            if (use_classes) {
              colors.push(jsonChunk.bg + "-bg");
              if (jsonChunk.bg_truecolor !== null) {
                data2["ansi-truecolor-bg"] = jsonChunk.bg_truecolor;
                jsonChunk.bg_truecolor = null;
              }
            } else {
              colors.push("background-color:rgb(" + jsonChunk.bg + ")");
            }
          }
          jsonChunk.decorations.forEach(function(decoration) {
            if (use_classes) {
              decorations.push("ansi-" + decoration);
              return;
            }
            if (decoration === "bold") {
              decorations.push("font-weight:bold");
            } else if (decoration === "dim") {
              decorations.push("opacity:0.5");
            } else if (decoration === "italic") {
              decorations.push("font-style:italic");
            } else if (decoration === "hidden") {
              decorations.push("visibility:hidden");
            } else if (decoration === "strikethrough") {
              textDecorations.push("line-through");
            } else {
              textDecorations.push(decoration);
            }
          });
          if (textDecorations.length) {
            decorations.push("text-decoration:" + textDecorations.join(" "));
          }
          if (use_classes) {
            return '<span class="' + colors.concat(decorations).join(" ") + '"' + render_data(data2) + ">" + jsonChunk.content + "</span>";
          } else {
            return '<span style="' + colors.concat(decorations).join(";") + '"' + render_data(data2) + ">" + jsonChunk.content + "</span>";
          }
        }
      }, {
        key: "removeDecoration",
        value: function removeDecoration(decoration) {
          var index3 = this.decorations.indexOf(decoration);
          if (index3 >= 0) {
            this.decorations.splice(index3, 1);
          }
        }
      }]);
      return Anser3;
    }();
    module.exports = Anser2;
  }
});

// node_modules/escape-carriage/index.js
var require_escape_carriage = __commonJS({
  "node_modules/escape-carriage/index.js"(exports, module) {
    function escapeCarriageReturn2(txt) {
      if (!txt) return "";
      if (!/\r/.test(txt)) return txt;
      txt = txt.replace(/\r+\n/gm, "\n");
      while (/\r./.test(txt)) {
        txt = txt.replace(/^([^\r\n]*)\r+([^\r\n]+)/gm, function(_2, base, insert2) {
          return insert2 + base.slice(insert2.length);
        });
      }
      return txt;
    }
    function findLongestString(arr) {
      var longest = 0;
      for (var i3 = 0; i3 < arr.length; i3++) {
        if (arr[longest].length <= arr[i3].length) {
          longest = i3;
        }
      }
      return longest;
    }
    function escapeSingleLineSafe(txt) {
      if (!/\r/.test(txt)) return txt;
      var arr = txt.split("\r");
      var res = [];
      while (arr.length > 0) {
        var longest = findLongestString(arr);
        res.push(arr[longest]);
        arr = arr.slice(longest + 1);
      }
      return res.join("\r");
    }
    function escapeCarriageReturnSafe(txt) {
      if (!txt) return "";
      if (!/\r/.test(txt)) return txt;
      if (!/\n/.test(txt)) return escapeSingleLineSafe(txt);
      txt = txt.replace(/\r+\n/gm, "\n");
      var idx = txt.lastIndexOf("\n");
      return escapeCarriageReturn2(txt.slice(0, idx)) + "\n" + escapeSingleLineSafe(txt.slice(idx + 1));
    }
    module.exports = escapeCarriageReturn2;
    module.exports.escapeCarriageReturn = escapeCarriageReturn2;
    module.exports.escapeCarriageReturnSafe = escapeCarriageReturnSafe;
  }
});

// node_modules/lz-string/libs/lz-string.js
var require_lz_string = __commonJS({
  "node_modules/lz-string/libs/lz-string.js"(exports, module) {
    var LZString2 = function() {
      var f3 = String.fromCharCode;
      var keyStrBase64 = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=";
      var keyStrUriSafe = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+-$";
      var baseReverseDic = {};
      function getBaseValue(alphabet, character) {
        if (!baseReverseDic[alphabet]) {
          baseReverseDic[alphabet] = {};
          for (var i3 = 0; i3 < alphabet.length; i3++) {
            baseReverseDic[alphabet][alphabet.charAt(i3)] = i3;
          }
        }
        return baseReverseDic[alphabet][character];
      }
      var LZString3 = {
        compressToBase64: function(input) {
          if (input == null) return "";
          var res = LZString3._compress(input, 6, function(a2) {
            return keyStrBase64.charAt(a2);
          });
          switch (res.length % 4) {
            default:
            case 0:
              return res;
            case 1:
              return res + "===";
            case 2:
              return res + "==";
            case 3:
              return res + "=";
          }
        },
        decompressFromBase64: function(input) {
          if (input == null) return "";
          if (input == "") return null;
          return LZString3._decompress(input.length, 32, function(index3) {
            return getBaseValue(keyStrBase64, input.charAt(index3));
          });
        },
        compressToUTF16: function(input) {
          if (input == null) return "";
          return LZString3._compress(input, 15, function(a2) {
            return f3(a2 + 32);
          }) + " ";
        },
        decompressFromUTF16: function(compressed) {
          if (compressed == null) return "";
          if (compressed == "") return null;
          return LZString3._decompress(compressed.length, 16384, function(index3) {
            return compressed.charCodeAt(index3) - 32;
          });
        },
        //compress into uint8array (UCS-2 big endian format)
        compressToUint8Array: function(uncompressed) {
          var compressed = LZString3.compress(uncompressed);
          var buf = new Uint8Array(compressed.length * 2);
          for (var i3 = 0, TotalLen = compressed.length; i3 < TotalLen; i3++) {
            var current_value = compressed.charCodeAt(i3);
            buf[i3 * 2] = current_value >>> 8;
            buf[i3 * 2 + 1] = current_value % 256;
          }
          return buf;
        },
        //decompress from uint8array (UCS-2 big endian format)
        decompressFromUint8Array: function(compressed) {
          if (compressed === null || compressed === void 0) {
            return LZString3.decompress(compressed);
          } else {
            var buf = new Array(compressed.length / 2);
            for (var i3 = 0, TotalLen = buf.length; i3 < TotalLen; i3++) {
              buf[i3] = compressed[i3 * 2] * 256 + compressed[i3 * 2 + 1];
            }
            var result = [];
            buf.forEach(function(c2) {
              result.push(f3(c2));
            });
            return LZString3.decompress(result.join(""));
          }
        },
        //compress into a string that is already URI encoded
        compressToEncodedURIComponent: function(input) {
          if (input == null) return "";
          return LZString3._compress(input, 6, function(a2) {
            return keyStrUriSafe.charAt(a2);
          });
        },
        //decompress from an output of compressToEncodedURIComponent
        decompressFromEncodedURIComponent: function(input) {
          if (input == null) return "";
          if (input == "") return null;
          input = input.replace(/ /g, "+");
          return LZString3._decompress(input.length, 32, function(index3) {
            return getBaseValue(keyStrUriSafe, input.charAt(index3));
          });
        },
        compress: function(uncompressed) {
          return LZString3._compress(uncompressed, 16, function(a2) {
            return f3(a2);
          });
        },
        _compress: function(uncompressed, bitsPerChar, getCharFromInt) {
          if (uncompressed == null) return "";
          var i3, value2, context_dictionary = {}, context_dictionaryToCreate = {}, context_c = "", context_wc = "", context_w = "", context_enlargeIn = 2, context_dictSize = 3, context_numBits = 2, context_data = [], context_data_val = 0, context_data_position = 0, ii;
          for (ii = 0; ii < uncompressed.length; ii += 1) {
            context_c = uncompressed.charAt(ii);
            if (!Object.prototype.hasOwnProperty.call(context_dictionary, context_c)) {
              context_dictionary[context_c] = context_dictSize++;
              context_dictionaryToCreate[context_c] = true;
            }
            context_wc = context_w + context_c;
            if (Object.prototype.hasOwnProperty.call(context_dictionary, context_wc)) {
              context_w = context_wc;
            } else {
              if (Object.prototype.hasOwnProperty.call(context_dictionaryToCreate, context_w)) {
                if (context_w.charCodeAt(0) < 256) {
                  for (i3 = 0; i3 < context_numBits; i3++) {
                    context_data_val = context_data_val << 1;
                    if (context_data_position == bitsPerChar - 1) {
                      context_data_position = 0;
                      context_data.push(getCharFromInt(context_data_val));
                      context_data_val = 0;
                    } else {
                      context_data_position++;
                    }
                  }
                  value2 = context_w.charCodeAt(0);
                  for (i3 = 0; i3 < 8; i3++) {
                    context_data_val = context_data_val << 1 | value2 & 1;
                    if (context_data_position == bitsPerChar - 1) {
                      context_data_position = 0;
                      context_data.push(getCharFromInt(context_data_val));
                      context_data_val = 0;
                    } else {
                      context_data_position++;
                    }
                    value2 = value2 >> 1;
                  }
                } else {
                  value2 = 1;
                  for (i3 = 0; i3 < context_numBits; i3++) {
                    context_data_val = context_data_val << 1 | value2;
                    if (context_data_position == bitsPerChar - 1) {
                      context_data_position = 0;
                      context_data.push(getCharFromInt(context_data_val));
                      context_data_val = 0;
                    } else {
                      context_data_position++;
                    }
                    value2 = 0;
                  }
                  value2 = context_w.charCodeAt(0);
                  for (i3 = 0; i3 < 16; i3++) {
                    context_data_val = context_data_val << 1 | value2 & 1;
                    if (context_data_position == bitsPerChar - 1) {
                      context_data_position = 0;
                      context_data.push(getCharFromInt(context_data_val));
                      context_data_val = 0;
                    } else {
                      context_data_position++;
                    }
                    value2 = value2 >> 1;
                  }
                }
                context_enlargeIn--;
                if (context_enlargeIn == 0) {
                  context_enlargeIn = Math.pow(2, context_numBits);
                  context_numBits++;
                }
                delete context_dictionaryToCreate[context_w];
              } else {
                value2 = context_dictionary[context_w];
                for (i3 = 0; i3 < context_numBits; i3++) {
                  context_data_val = context_data_val << 1 | value2 & 1;
                  if (context_data_position == bitsPerChar - 1) {
                    context_data_position = 0;
                    context_data.push(getCharFromInt(context_data_val));
                    context_data_val = 0;
                  } else {
                    context_data_position++;
                  }
                  value2 = value2 >> 1;
                }
              }
              context_enlargeIn--;
              if (context_enlargeIn == 0) {
                context_enlargeIn = Math.pow(2, context_numBits);
                context_numBits++;
              }
              context_dictionary[context_wc] = context_dictSize++;
              context_w = String(context_c);
            }
          }
          if (context_w !== "") {
            if (Object.prototype.hasOwnProperty.call(context_dictionaryToCreate, context_w)) {
              if (context_w.charCodeAt(0) < 256) {
                for (i3 = 0; i3 < context_numBits; i3++) {
                  context_data_val = context_data_val << 1;
                  if (context_data_position == bitsPerChar - 1) {
                    context_data_position = 0;
                    context_data.push(getCharFromInt(context_data_val));
                    context_data_val = 0;
                  } else {
                    context_data_position++;
                  }
                }
                value2 = context_w.charCodeAt(0);
                for (i3 = 0; i3 < 8; i3++) {
                  context_data_val = context_data_val << 1 | value2 & 1;
                  if (context_data_position == bitsPerChar - 1) {
                    context_data_position = 0;
                    context_data.push(getCharFromInt(context_data_val));
                    context_data_val = 0;
                  } else {
                    context_data_position++;
                  }
                  value2 = value2 >> 1;
                }
              } else {
                value2 = 1;
                for (i3 = 0; i3 < context_numBits; i3++) {
                  context_data_val = context_data_val << 1 | value2;
                  if (context_data_position == bitsPerChar - 1) {
                    context_data_position = 0;
                    context_data.push(getCharFromInt(context_data_val));
                    context_data_val = 0;
                  } else {
                    context_data_position++;
                  }
                  value2 = 0;
                }
                value2 = context_w.charCodeAt(0);
                for (i3 = 0; i3 < 16; i3++) {
                  context_data_val = context_data_val << 1 | value2 & 1;
                  if (context_data_position == bitsPerChar - 1) {
                    context_data_position = 0;
                    context_data.push(getCharFromInt(context_data_val));
                    context_data_val = 0;
                  } else {
                    context_data_position++;
                  }
                  value2 = value2 >> 1;
                }
              }
              context_enlargeIn--;
              if (context_enlargeIn == 0) {
                context_enlargeIn = Math.pow(2, context_numBits);
                context_numBits++;
              }
              delete context_dictionaryToCreate[context_w];
            } else {
              value2 = context_dictionary[context_w];
              for (i3 = 0; i3 < context_numBits; i3++) {
                context_data_val = context_data_val << 1 | value2 & 1;
                if (context_data_position == bitsPerChar - 1) {
                  context_data_position = 0;
                  context_data.push(getCharFromInt(context_data_val));
                  context_data_val = 0;
                } else {
                  context_data_position++;
                }
                value2 = value2 >> 1;
              }
            }
            context_enlargeIn--;
            if (context_enlargeIn == 0) {
              context_enlargeIn = Math.pow(2, context_numBits);
              context_numBits++;
            }
          }
          value2 = 2;
          for (i3 = 0; i3 < context_numBits; i3++) {
            context_data_val = context_data_val << 1 | value2 & 1;
            if (context_data_position == bitsPerChar - 1) {
              context_data_position = 0;
              context_data.push(getCharFromInt(context_data_val));
              context_data_val = 0;
            } else {
              context_data_position++;
            }
            value2 = value2 >> 1;
          }
          while (true) {
            context_data_val = context_data_val << 1;
            if (context_data_position == bitsPerChar - 1) {
              context_data.push(getCharFromInt(context_data_val));
              break;
            } else context_data_position++;
          }
          return context_data.join("");
        },
        decompress: function(compressed) {
          if (compressed == null) return "";
          if (compressed == "") return null;
          return LZString3._decompress(compressed.length, 32768, function(index3) {
            return compressed.charCodeAt(index3);
          });
        },
        _decompress: function(length, resetValue, getNextValue) {
          var dictionary = [], next, enlargeIn = 4, dictSize = 4, numBits = 3, entry = "", result = [], i3, w3, bits, resb, maxpower, power, c2, data2 = { val: getNextValue(0), position: resetValue, index: 1 };
          for (i3 = 0; i3 < 3; i3 += 1) {
            dictionary[i3] = i3;
          }
          bits = 0;
          maxpower = Math.pow(2, 2);
          power = 1;
          while (power != maxpower) {
            resb = data2.val & data2.position;
            data2.position >>= 1;
            if (data2.position == 0) {
              data2.position = resetValue;
              data2.val = getNextValue(data2.index++);
            }
            bits |= (resb > 0 ? 1 : 0) * power;
            power <<= 1;
          }
          switch (next = bits) {
            case 0:
              bits = 0;
              maxpower = Math.pow(2, 8);
              power = 1;
              while (power != maxpower) {
                resb = data2.val & data2.position;
                data2.position >>= 1;
                if (data2.position == 0) {
                  data2.position = resetValue;
                  data2.val = getNextValue(data2.index++);
                }
                bits |= (resb > 0 ? 1 : 0) * power;
                power <<= 1;
              }
              c2 = f3(bits);
              break;
            case 1:
              bits = 0;
              maxpower = Math.pow(2, 16);
              power = 1;
              while (power != maxpower) {
                resb = data2.val & data2.position;
                data2.position >>= 1;
                if (data2.position == 0) {
                  data2.position = resetValue;
                  data2.val = getNextValue(data2.index++);
                }
                bits |= (resb > 0 ? 1 : 0) * power;
                power <<= 1;
              }
              c2 = f3(bits);
              break;
            case 2:
              return "";
          }
          dictionary[3] = c2;
          w3 = c2;
          result.push(c2);
          while (true) {
            if (data2.index > length) {
              return "";
            }
            bits = 0;
            maxpower = Math.pow(2, numBits);
            power = 1;
            while (power != maxpower) {
              resb = data2.val & data2.position;
              data2.position >>= 1;
              if (data2.position == 0) {
                data2.position = resetValue;
                data2.val = getNextValue(data2.index++);
              }
              bits |= (resb > 0 ? 1 : 0) * power;
              power <<= 1;
            }
            switch (c2 = bits) {
              case 0:
                bits = 0;
                maxpower = Math.pow(2, 8);
                power = 1;
                while (power != maxpower) {
                  resb = data2.val & data2.position;
                  data2.position >>= 1;
                  if (data2.position == 0) {
                    data2.position = resetValue;
                    data2.val = getNextValue(data2.index++);
                  }
                  bits |= (resb > 0 ? 1 : 0) * power;
                  power <<= 1;
                }
                dictionary[dictSize++] = f3(bits);
                c2 = dictSize - 1;
                enlargeIn--;
                break;
              case 1:
                bits = 0;
                maxpower = Math.pow(2, 16);
                power = 1;
                while (power != maxpower) {
                  resb = data2.val & data2.position;
                  data2.position >>= 1;
                  if (data2.position == 0) {
                    data2.position = resetValue;
                    data2.val = getNextValue(data2.index++);
                  }
                  bits |= (resb > 0 ? 1 : 0) * power;
                  power <<= 1;
                }
                dictionary[dictSize++] = f3(bits);
                c2 = dictSize - 1;
                enlargeIn--;
                break;
              case 2:
                return result.join("");
            }
            if (enlargeIn == 0) {
              enlargeIn = Math.pow(2, numBits);
              numBits++;
            }
            if (dictionary[c2]) {
              entry = dictionary[c2];
            } else {
              if (c2 === dictSize) {
                entry = w3 + w3.charAt(0);
              } else {
                return null;
              }
            }
            result.push(entry);
            dictionary[dictSize++] = w3 + entry.charAt(0);
            enlargeIn--;
            w3 = entry;
            if (enlargeIn == 0) {
              enlargeIn = Math.pow(2, numBits);
              numBits++;
            }
          }
        }
      };
      return LZString3;
    }();
    if (typeof define === "function" && define.amd) {
      define(function() {
        return LZString2;
      });
    } else if (typeof module !== "undefined" && module != null) {
      module.exports = LZString2;
    } else if (typeof angular !== "undefined" && angular != null) {
      angular.module("LZString", []).factory("LZString", function() {
        return LZString2;
      });
    }
  }
});

// node_modules/prismjs/prism.js
var require_prism = __commonJS({
  "node_modules/prismjs/prism.js"(exports, module) {
    var _self = typeof window !== "undefined" ? window : typeof WorkerGlobalScope !== "undefined" && self instanceof WorkerGlobalScope ? self : {};
    var Prism3 = function(_self2) {
      var lang = /(?:^|\s)lang(?:uage)?-([\w-]+)(?=\s|$)/i;
      var uniqueId = 0;
      var plainTextGrammar = {};
      var _2 = {
        /**
         * By default, Prism will attempt to highlight all code elements (by calling {@link Prism.highlightAll}) on the
         * current page after the page finished loading. This might be a problem if e.g. you wanted to asynchronously load
         * additional languages or plugins yourself.
         *
         * By setting this value to `true`, Prism will not automatically highlight all code elements on the page.
         *
         * You obviously have to change this value before the automatic highlighting started. To do this, you can add an
         * empty Prism object into the global scope before loading the Prism script like this:
         *
         * ```js
         * window.Prism = window.Prism || {};
         * Prism.manual = true;
         * // add a new <script> to load Prism's script
         * ```
         *
         * @default false
         * @type {boolean}
         * @memberof Prism
         * @public
         */
        manual: _self2.Prism && _self2.Prism.manual,
        /**
         * By default, if Prism is in a web worker, it assumes that it is in a worker it created itself, so it uses
         * `addEventListener` to communicate with its parent instance. However, if you're using Prism manually in your
         * own worker, you don't want it to do this.
         *
         * By setting this value to `true`, Prism will not add its own listeners to the worker.
         *
         * You obviously have to change this value before Prism executes. To do this, you can add an
         * empty Prism object into the global scope before loading the Prism script like this:
         *
         * ```js
         * window.Prism = window.Prism || {};
         * Prism.disableWorkerMessageHandler = true;
         * // Load Prism's script
         * ```
         *
         * @default false
         * @type {boolean}
         * @memberof Prism
         * @public
         */
        disableWorkerMessageHandler: _self2.Prism && _self2.Prism.disableWorkerMessageHandler,
        /**
         * A namespace for utility methods.
         *
         * All function in this namespace that are not explicitly marked as _public_ are for __internal use only__ and may
         * change or disappear at any time.
         *
         * @namespace
         * @memberof Prism
         */
        util: {
          encode: function encode2(tokens) {
            if (tokens instanceof Token3) {
              return new Token3(tokens.type, encode2(tokens.content), tokens.alias);
            } else if (Array.isArray(tokens)) {
              return tokens.map(encode2);
            } else {
              return tokens.replace(/&/g, "&amp;").replace(/</g, "&lt;").replace(/\u00a0/g, " ");
            }
          },
          /**
           * Returns the name of the type of the given value.
           *
           * @param {any} o
           * @returns {string}
           * @example
           * type(null)      === 'Null'
           * type(undefined) === 'Undefined'
           * type(123)       === 'Number'
           * type('foo')     === 'String'
           * type(true)      === 'Boolean'
           * type([1, 2])    === 'Array'
           * type({})        === 'Object'
           * type(String)    === 'Function'
           * type(/abc+/)    === 'RegExp'
           */
          type: function(o3) {
            return Object.prototype.toString.call(o3).slice(8, -1);
          },
          /**
           * Returns a unique number for the given object. Later calls will still return the same number.
           *
           * @param {Object} obj
           * @returns {number}
           */
          objId: function(obj) {
            if (!obj["__id"]) {
              Object.defineProperty(obj, "__id", { value: ++uniqueId });
            }
            return obj["__id"];
          },
          /**
           * Creates a deep clone of the given object.
           *
           * The main intended use of this function is to clone language definitions.
           *
           * @param {T} o
           * @param {Record<number, any>} [visited]
           * @returns {T}
           * @template T
           */
          clone: function deepClone(o3, visited) {
            visited = visited || {};
            var clone;
            var id;
            switch (_2.util.type(o3)) {
              case "Object":
                id = _2.util.objId(o3);
                if (visited[id]) {
                  return visited[id];
                }
                clone = /** @type {Record<string, any>} */
                {};
                visited[id] = clone;
                for (var key2 in o3) {
                  if (o3.hasOwnProperty(key2)) {
                    clone[key2] = deepClone(o3[key2], visited);
                  }
                }
                return (
                  /** @type {any} */
                  clone
                );
              case "Array":
                id = _2.util.objId(o3);
                if (visited[id]) {
                  return visited[id];
                }
                clone = [];
                visited[id] = clone;
                /** @type {Array} */
                /** @type {any} */
                o3.forEach(function(v3, i3) {
                  clone[i3] = deepClone(v3, visited);
                });
                return (
                  /** @type {any} */
                  clone
                );
              default:
                return o3;
            }
          },
          /**
           * Returns the Prism language of the given element set by a `language-xxxx` or `lang-xxxx` class.
           *
           * If no language is set for the element or the element is `null` or `undefined`, `none` will be returned.
           *
           * @param {Element} element
           * @returns {string}
           */
          getLanguage: function(element2) {
            while (element2) {
              var m2 = lang.exec(element2.className);
              if (m2) {
                return m2[1].toLowerCase();
              }
              element2 = element2.parentElement;
            }
            return "none";
          },
          /**
           * Sets the Prism `language-xxxx` class of the given element.
           *
           * @param {Element} element
           * @param {string} language
           * @returns {void}
           */
          setLanguage: function(element2, language2) {
            element2.className = element2.className.replace(RegExp(lang, "gi"), "");
            element2.classList.add("language-" + language2);
          },
          /**
           * Returns the script element that is currently executing.
           *
           * This does __not__ work for line script element.
           *
           * @returns {HTMLScriptElement | null}
           */
          currentScript: function() {
            if (typeof document === "undefined") {
              return null;
            }
            if ("currentScript" in document && 1 < 2) {
              return (
                /** @type {any} */
                document.currentScript
              );
            }
            try {
              throw new Error();
            } catch (err) {
              var src = (/at [^(\r\n]*\((.*):[^:]+:[^:]+\)$/i.exec(err.stack) || [])[1];
              if (src) {
                var scripts = document.getElementsByTagName("script");
                for (var i3 in scripts) {
                  if (scripts[i3].src == src) {
                    return scripts[i3];
                  }
                }
              }
              return null;
            }
          },
          /**
           * Returns whether a given class is active for `element`.
           *
           * The class can be activated if `element` or one of its ancestors has the given class and it can be deactivated
           * if `element` or one of its ancestors has the negated version of the given class. The _negated version_ of the
           * given class is just the given class with a `no-` prefix.
           *
           * Whether the class is active is determined by the closest ancestor of `element` (where `element` itself is
           * closest ancestor) that has the given class or the negated version of it. If neither `element` nor any of its
           * ancestors have the given class or the negated version of it, then the default activation will be returned.
           *
           * In the paradoxical situation where the closest ancestor contains __both__ the given class and the negated
           * version of it, the class is considered active.
           *
           * @param {Element} element
           * @param {string} className
           * @param {boolean} [defaultActivation=false]
           * @returns {boolean}
           */
          isActive: function(element2, className, defaultActivation) {
            var no = "no-" + className;
            while (element2) {
              var classList = element2.classList;
              if (classList.contains(className)) {
                return true;
              }
              if (classList.contains(no)) {
                return false;
              }
              element2 = element2.parentElement;
            }
            return !!defaultActivation;
          }
        },
        /**
         * This namespace contains all currently loaded languages and the some helper functions to create and modify languages.
         *
         * @namespace
         * @memberof Prism
         * @public
         */
        languages: {
          /**
           * The grammar for plain, unformatted text.
           */
          plain: plainTextGrammar,
          plaintext: plainTextGrammar,
          text: plainTextGrammar,
          txt: plainTextGrammar,
          /**
           * Creates a deep copy of the language with the given id and appends the given tokens.
           *
           * If a token in `redef` also appears in the copied language, then the existing token in the copied language
           * will be overwritten at its original position.
           *
           * ## Best practices
           *
           * Since the position of overwriting tokens (token in `redef` that overwrite tokens in the copied language)
           * doesn't matter, they can technically be in any order. However, this can be confusing to others that trying to
           * understand the language definition because, normally, the order of tokens matters in Prism grammars.
           *
           * Therefore, it is encouraged to order overwriting tokens according to the positions of the overwritten tokens.
           * Furthermore, all non-overwriting tokens should be placed after the overwriting ones.
           *
           * @param {string} id The id of the language to extend. This has to be a key in `Prism.languages`.
           * @param {Grammar} redef The new tokens to append.
           * @returns {Grammar} The new language created.
           * @public
           * @example
           * Prism.languages['css-with-colors'] = Prism.languages.extend('css', {
           *     // Prism.languages.css already has a 'comment' token, so this token will overwrite CSS' 'comment' token
           *     // at its original position
           *     'comment': { ... },
           *     // CSS doesn't have a 'color' token, so this token will be appended
           *     'color': /\b(?:red|green|blue)\b/
           * });
           */
          extend: function(id, redef) {
            var lang2 = _2.util.clone(_2.languages[id]);
            for (var key2 in redef) {
              lang2[key2] = redef[key2];
            }
            return lang2;
          },
          /**
           * Inserts tokens _before_ another token in a language definition or any other grammar.
           *
           * ## Usage
           *
           * This helper method makes it easy to modify existing languages. For example, the CSS language definition
           * not only defines CSS highlighting for CSS documents, but also needs to define highlighting for CSS embedded
           * in HTML through `<style>` elements. To do this, it needs to modify `Prism.languages.markup` and add the
           * appropriate tokens. However, `Prism.languages.markup` is a regular JavaScript object literal, so if you do
           * this:
           *
           * ```js
           * Prism.languages.markup.style = {
           *     // token
           * };
           * ```
           *
           * then the `style` token will be added (and processed) at the end. `insertBefore` allows you to insert tokens
           * before existing tokens. For the CSS example above, you would use it like this:
           *
           * ```js
           * Prism.languages.insertBefore('markup', 'cdata', {
           *     'style': {
           *         // token
           *     }
           * });
           * ```
           *
           * ## Special cases
           *
           * If the grammars of `inside` and `insert` have tokens with the same name, the tokens in `inside`'s grammar
           * will be ignored.
           *
           * This behavior can be used to insert tokens after `before`:
           *
           * ```js
           * Prism.languages.insertBefore('markup', 'comment', {
           *     'comment': Prism.languages.markup.comment,
           *     // tokens after 'comment'
           * });
           * ```
           *
           * ## Limitations
           *
           * The main problem `insertBefore` has to solve is iteration order. Since ES2015, the iteration order for object
           * properties is guaranteed to be the insertion order (except for integer keys) but some browsers behave
           * differently when keys are deleted and re-inserted. So `insertBefore` can't be implemented by temporarily
           * deleting properties which is necessary to insert at arbitrary positions.
           *
           * To solve this problem, `insertBefore` doesn't actually insert the given tokens into the target object.
           * Instead, it will create a new object and replace all references to the target object with the new one. This
           * can be done without temporarily deleting properties, so the iteration order is well-defined.
           *
           * However, only references that can be reached from `Prism.languages` or `insert` will be replaced. I.e. if
           * you hold the target object in a variable, then the value of the variable will not change.
           *
           * ```js
           * var oldMarkup = Prism.languages.markup;
           * var newMarkup = Prism.languages.insertBefore('markup', 'comment', { ... });
           *
           * assert(oldMarkup !== Prism.languages.markup);
           * assert(newMarkup === Prism.languages.markup);
           * ```
           *
           * @param {string} inside The property of `root` (e.g. a language id in `Prism.languages`) that contains the
           * object to be modified.
           * @param {string} before The key to insert before.
           * @param {Grammar} insert An object containing the key-value pairs to be inserted.
           * @param {Object<string, any>} [root] The object containing `inside`, i.e. the object that contains the
           * object to be modified.
           *
           * Defaults to `Prism.languages`.
           * @returns {Grammar} The new grammar object.
           * @public
           */
          insertBefore: function(inside, before, insert2, root2) {
            root2 = root2 || /** @type {any} */
            _2.languages;
            var grammar = root2[inside];
            var ret = {};
            for (var token in grammar) {
              if (grammar.hasOwnProperty(token)) {
                if (token == before) {
                  for (var newToken in insert2) {
                    if (insert2.hasOwnProperty(newToken)) {
                      ret[newToken] = insert2[newToken];
                    }
                  }
                }
                if (!insert2.hasOwnProperty(token)) {
                  ret[token] = grammar[token];
                }
              }
            }
            var old = root2[inside];
            root2[inside] = ret;
            _2.languages.DFS(_2.languages, function(key2, value2) {
              if (value2 === old && key2 != inside) {
                this[key2] = ret;
              }
            });
            return ret;
          },
          // Traverse a language definition with Depth First Search
          DFS: function DFS(o3, callback, type2, visited) {
            visited = visited || {};
            var objId = _2.util.objId;
            for (var i3 in o3) {
              if (o3.hasOwnProperty(i3)) {
                callback.call(o3, i3, o3[i3], type2 || i3);
                var property = o3[i3];
                var propertyType = _2.util.type(property);
                if (propertyType === "Object" && !visited[objId(property)]) {
                  visited[objId(property)] = true;
                  DFS(property, callback, null, visited);
                } else if (propertyType === "Array" && !visited[objId(property)]) {
                  visited[objId(property)] = true;
                  DFS(property, callback, i3, visited);
                }
              }
            }
          }
        },
        plugins: {},
        /**
         * This is the most high-level function in Prism’s API.
         * It fetches all the elements that have a `.language-xxxx` class and then calls {@link Prism.highlightElement} on
         * each one of them.
         *
         * This is equivalent to `Prism.highlightAllUnder(document, async, callback)`.
         *
         * @param {boolean} [async=false] Same as in {@link Prism.highlightAllUnder}.
         * @param {HighlightCallback} [callback] Same as in {@link Prism.highlightAllUnder}.
         * @memberof Prism
         * @public
         */
        highlightAll: function(async, callback) {
          _2.highlightAllUnder(document, async, callback);
        },
        /**
         * Fetches all the descendants of `container` that have a `.language-xxxx` class and then calls
         * {@link Prism.highlightElement} on each one of them.
         *
         * The following hooks will be run:
         * 1. `before-highlightall`
         * 2. `before-all-elements-highlight`
         * 3. All hooks of {@link Prism.highlightElement} for each element.
         *
         * @param {ParentNode} container The root element, whose descendants that have a `.language-xxxx` class will be highlighted.
         * @param {boolean} [async=false] Whether each element is to be highlighted asynchronously using Web Workers.
         * @param {HighlightCallback} [callback] An optional callback to be invoked on each element after its highlighting is done.
         * @memberof Prism
         * @public
         */
        highlightAllUnder: function(container, async, callback) {
          var env2 = {
            callback,
            container,
            selector: 'code[class*="language-"], [class*="language-"] code, code[class*="lang-"], [class*="lang-"] code'
          };
          _2.hooks.run("before-highlightall", env2);
          env2.elements = Array.prototype.slice.apply(env2.container.querySelectorAll(env2.selector));
          _2.hooks.run("before-all-elements-highlight", env2);
          for (var i3 = 0, element2; element2 = env2.elements[i3++]; ) {
            _2.highlightElement(element2, async === true, env2.callback);
          }
        },
        /**
         * Highlights the code inside a single element.
         *
         * The following hooks will be run:
         * 1. `before-sanity-check`
         * 2. `before-highlight`
         * 3. All hooks of {@link Prism.highlight}. These hooks will be run by an asynchronous worker if `async` is `true`.
         * 4. `before-insert`
         * 5. `after-highlight`
         * 6. `complete`
         *
         * Some the above hooks will be skipped if the element doesn't contain any text or there is no grammar loaded for
         * the element's language.
         *
         * @param {Element} element The element containing the code.
         * It must have a class of `language-xxxx` to be processed, where `xxxx` is a valid language identifier.
         * @param {boolean} [async=false] Whether the element is to be highlighted asynchronously using Web Workers
         * to improve performance and avoid blocking the UI when highlighting very large chunks of code. This option is
         * [disabled by default](https://prismjs.com/faq.html#why-is-asynchronous-highlighting-disabled-by-default).
         *
         * Note: All language definitions required to highlight the code must be included in the main `prism.js` file for
         * asynchronous highlighting to work. You can build your own bundle on the
         * [Download page](https://prismjs.com/download.html).
         * @param {HighlightCallback} [callback] An optional callback to be invoked after the highlighting is done.
         * Mostly useful when `async` is `true`, since in that case, the highlighting is done asynchronously.
         * @memberof Prism
         * @public
         */
        highlightElement: function(element2, async, callback) {
          var language2 = _2.util.getLanguage(element2);
          var grammar = _2.languages[language2];
          _2.util.setLanguage(element2, language2);
          var parent = element2.parentElement;
          if (parent && parent.nodeName.toLowerCase() === "pre") {
            _2.util.setLanguage(parent, language2);
          }
          var code3 = element2.textContent;
          var env2 = {
            element: element2,
            language: language2,
            grammar,
            code: code3
          };
          function insertHighlightedCode(highlightedCode) {
            env2.highlightedCode = highlightedCode;
            _2.hooks.run("before-insert", env2);
            env2.element.innerHTML = env2.highlightedCode;
            _2.hooks.run("after-highlight", env2);
            _2.hooks.run("complete", env2);
            callback && callback.call(env2.element);
          }
          _2.hooks.run("before-sanity-check", env2);
          parent = env2.element.parentElement;
          if (parent && parent.nodeName.toLowerCase() === "pre" && !parent.hasAttribute("tabindex")) {
            parent.setAttribute("tabindex", "0");
          }
          if (!env2.code) {
            _2.hooks.run("complete", env2);
            callback && callback.call(env2.element);
            return;
          }
          _2.hooks.run("before-highlight", env2);
          if (!env2.grammar) {
            insertHighlightedCode(_2.util.encode(env2.code));
            return;
          }
          if (async && _self2.Worker) {
            var worker = new Worker(_2.filename);
            worker.onmessage = function(evt) {
              insertHighlightedCode(evt.data);
            };
            worker.postMessage(JSON.stringify({
              language: env2.language,
              code: env2.code,
              immediateClose: true
            }));
          } else {
            insertHighlightedCode(_2.highlight(env2.code, env2.grammar, env2.language));
          }
        },
        /**
         * Low-level function, only use if you know what you’re doing. It accepts a string of text as input
         * and the language definitions to use, and returns a string with the HTML produced.
         *
         * The following hooks will be run:
         * 1. `before-tokenize`
         * 2. `after-tokenize`
         * 3. `wrap`: On each {@link Token}.
         *
         * @param {string} text A string with the code to be highlighted.
         * @param {Grammar} grammar An object containing the tokens to use.
         *
         * Usually a language definition like `Prism.languages.markup`.
         * @param {string} language The name of the language definition passed to `grammar`.
         * @returns {string} The highlighted HTML.
         * @memberof Prism
         * @public
         * @example
         * Prism.highlight('var foo = true;', Prism.languages.javascript, 'javascript');
         */
        highlight: function(text4, grammar, language2) {
          var env2 = {
            code: text4,
            grammar,
            language: language2
          };
          _2.hooks.run("before-tokenize", env2);
          if (!env2.grammar) {
            throw new Error('The language "' + env2.language + '" has no grammar.');
          }
          env2.tokens = _2.tokenize(env2.code, env2.grammar);
          _2.hooks.run("after-tokenize", env2);
          return Token3.stringify(_2.util.encode(env2.tokens), env2.language);
        },
        /**
         * This is the heart of Prism, and the most low-level function you can use. It accepts a string of text as input
         * and the language definitions to use, and returns an array with the tokenized code.
         *
         * When the language definition includes nested tokens, the function is called recursively on each of these tokens.
         *
         * This method could be useful in other contexts as well, as a very crude parser.
         *
         * @param {string} text A string with the code to be highlighted.
         * @param {Grammar} grammar An object containing the tokens to use.
         *
         * Usually a language definition like `Prism.languages.markup`.
         * @returns {TokenStream} An array of strings and tokens, a token stream.
         * @memberof Prism
         * @public
         * @example
         * let code = `var foo = 0;`;
         * let tokens = Prism.tokenize(code, Prism.languages.javascript);
         * tokens.forEach(token => {
         *     if (token instanceof Prism.Token && token.type === 'number') {
         *         console.log(`Found numeric literal: ${token.content}`);
         *     }
         * });
         */
        tokenize: function(text4, grammar) {
          var rest = grammar.rest;
          if (rest) {
            for (var token in rest) {
              grammar[token] = rest[token];
            }
            delete grammar.rest;
          }
          var tokenList = new LinkedList();
          addAfter(tokenList, tokenList.head, text4);
          matchGrammar(text4, tokenList, grammar, tokenList.head, 0);
          return toArray2(tokenList);
        },
        /**
         * @namespace
         * @memberof Prism
         * @public
         */
        hooks: {
          all: {},
          /**
           * Adds the given callback to the list of callbacks for the given hook.
           *
           * The callback will be invoked when the hook it is registered for is run.
           * Hooks are usually directly run by a highlight function but you can also run hooks yourself.
           *
           * One callback function can be registered to multiple hooks and the same hook multiple times.
           *
           * @param {string} name The name of the hook.
           * @param {HookCallback} callback The callback function which is given environment variables.
           * @public
           */
          add: function(name2, callback) {
            var hooks = _2.hooks.all;
            hooks[name2] = hooks[name2] || [];
            hooks[name2].push(callback);
          },
          /**
           * Runs a hook invoking all registered callbacks with the given environment variables.
           *
           * Callbacks will be invoked synchronously and in the order in which they were registered.
           *
           * @param {string} name The name of the hook.
           * @param {Object<string, any>} env The environment variables of the hook passed to all callbacks registered.
           * @public
           */
          run: function(name2, env2) {
            var callbacks = _2.hooks.all[name2];
            if (!callbacks || !callbacks.length) {
              return;
            }
            for (var i3 = 0, callback; callback = callbacks[i3++]; ) {
              callback(env2);
            }
          }
        },
        Token: Token3
      };
      _self2.Prism = _2;
      function Token3(type2, content3, alias, matchedStr) {
        this.type = type2;
        this.content = content3;
        this.alias = alias;
        this.length = (matchedStr || "").length | 0;
      }
      Token3.stringify = function stringify(o3, language2) {
        if (typeof o3 == "string") {
          return o3;
        }
        if (Array.isArray(o3)) {
          var s2 = "";
          o3.forEach(function(e2) {
            s2 += stringify(e2, language2);
          });
          return s2;
        }
        var env2 = {
          type: o3.type,
          content: stringify(o3.content, language2),
          tag: "span",
          classes: ["token", o3.type],
          attributes: {},
          language: language2
        };
        var aliases = o3.alias;
        if (aliases) {
          if (Array.isArray(aliases)) {
            Array.prototype.push.apply(env2.classes, aliases);
          } else {
            env2.classes.push(aliases);
          }
        }
        _2.hooks.run("wrap", env2);
        var attributes4 = "";
        for (var name2 in env2.attributes) {
          attributes4 += " " + name2 + '="' + (env2.attributes[name2] || "").replace(/"/g, "&quot;") + '"';
        }
        return "<" + env2.tag + ' class="' + env2.classes.join(" ") + '"' + attributes4 + ">" + env2.content + "</" + env2.tag + ">";
      };
      function matchPattern(pattern, pos, text4, lookbehind) {
        pattern.lastIndex = pos;
        var match = pattern.exec(text4);
        if (match && lookbehind && match[1]) {
          var lookbehindLength = match[1].length;
          match.index += lookbehindLength;
          match[0] = match[0].slice(lookbehindLength);
        }
        return match;
      }
      function matchGrammar(text4, tokenList, grammar, startNode, startPos, rematch) {
        for (var token in grammar) {
          if (!grammar.hasOwnProperty(token) || !grammar[token]) {
            continue;
          }
          var patterns = grammar[token];
          patterns = Array.isArray(patterns) ? patterns : [patterns];
          for (var j3 = 0; j3 < patterns.length; ++j3) {
            if (rematch && rematch.cause == token + "," + j3) {
              return;
            }
            var patternObj = patterns[j3];
            var inside = patternObj.inside;
            var lookbehind = !!patternObj.lookbehind;
            var greedy = !!patternObj.greedy;
            var alias = patternObj.alias;
            if (greedy && !patternObj.pattern.global) {
              var flags = patternObj.pattern.toString().match(/[imsuy]*$/)[0];
              patternObj.pattern = RegExp(patternObj.pattern.source, flags + "g");
            }
            var pattern = patternObj.pattern || patternObj;
            for (var currentNode = startNode.next, pos = startPos; currentNode !== tokenList.tail; pos += currentNode.value.length, currentNode = currentNode.next) {
              if (rematch && pos >= rematch.reach) {
                break;
              }
              var str2 = currentNode.value;
              if (tokenList.length > text4.length) {
                return;
              }
              if (str2 instanceof Token3) {
                continue;
              }
              var removeCount = 1;
              var match;
              if (greedy) {
                match = matchPattern(pattern, pos, text4, lookbehind);
                if (!match || match.index >= text4.length) {
                  break;
                }
                var from = match.index;
                var to = match.index + match[0].length;
                var p2 = pos;
                p2 += currentNode.value.length;
                while (from >= p2) {
                  currentNode = currentNode.next;
                  p2 += currentNode.value.length;
                }
                p2 -= currentNode.value.length;
                pos = p2;
                if (currentNode.value instanceof Token3) {
                  continue;
                }
                for (var k3 = currentNode; k3 !== tokenList.tail && (p2 < to || typeof k3.value === "string"); k3 = k3.next) {
                  removeCount++;
                  p2 += k3.value.length;
                }
                removeCount--;
                str2 = text4.slice(pos, p2);
                match.index -= pos;
              } else {
                match = matchPattern(pattern, 0, str2, lookbehind);
                if (!match) {
                  continue;
                }
              }
              var from = match.index;
              var matchStr = match[0];
              var before = str2.slice(0, from);
              var after = str2.slice(from + matchStr.length);
              var reach = pos + str2.length;
              if (rematch && reach > rematch.reach) {
                rematch.reach = reach;
              }
              var removeFrom = currentNode.prev;
              if (before) {
                removeFrom = addAfter(tokenList, removeFrom, before);
                pos += before.length;
              }
              removeRange(tokenList, removeFrom, removeCount);
              var wrapped = new Token3(token, inside ? _2.tokenize(matchStr, inside) : matchStr, alias, matchStr);
              currentNode = addAfter(tokenList, removeFrom, wrapped);
              if (after) {
                addAfter(tokenList, currentNode, after);
              }
              if (removeCount > 1) {
                var nestedRematch = {
                  cause: token + "," + j3,
                  reach
                };
                matchGrammar(text4, tokenList, grammar, currentNode.prev, pos, nestedRematch);
                if (rematch && nestedRematch.reach > rematch.reach) {
                  rematch.reach = nestedRematch.reach;
                }
              }
            }
          }
        }
      }
      function LinkedList() {
        var head = { value: null, prev: null, next: null };
        var tail = { value: null, prev: head, next: null };
        head.next = tail;
        this.head = head;
        this.tail = tail;
        this.length = 0;
      }
      function addAfter(list4, node2, value2) {
        var next = node2.next;
        var newNode = { value: value2, prev: node2, next };
        node2.next = newNode;
        next.prev = newNode;
        list4.length++;
        return newNode;
      }
      function removeRange(list4, node2, count3) {
        var next = node2.next;
        for (var i3 = 0; i3 < count3 && next !== list4.tail; i3++) {
          next = next.next;
        }
        node2.next = next;
        next.prev = node2;
        list4.length -= i3;
      }
      function toArray2(list4) {
        var array = [];
        var node2 = list4.head.next;
        while (node2 !== list4.tail) {
          array.push(node2.value);
          node2 = node2.next;
        }
        return array;
      }
      if (!_self2.document) {
        if (!_self2.addEventListener) {
          return _2;
        }
        if (!_2.disableWorkerMessageHandler) {
          _self2.addEventListener("message", function(evt) {
            var message = JSON.parse(evt.data);
            var lang2 = message.language;
            var code3 = message.code;
            var immediateClose = message.immediateClose;
            _self2.postMessage(_2.highlight(code3, _2.languages[lang2], lang2));
            if (immediateClose) {
              _self2.close();
            }
          }, false);
        }
        return _2;
      }
      var script = _2.util.currentScript();
      if (script) {
        _2.filename = script.src;
        if (script.hasAttribute("data-manual")) {
          _2.manual = true;
        }
      }
      function highlightAutomaticallyCallback() {
        if (!_2.manual) {
          _2.highlightAll();
        }
      }
      if (!_2.manual) {
        var readyState = document.readyState;
        if (readyState === "loading" || readyState === "interactive" && script && script.defer) {
          document.addEventListener("DOMContentLoaded", highlightAutomaticallyCallback);
        } else {
          if (window.requestAnimationFrame) {
            window.requestAnimationFrame(highlightAutomaticallyCallback);
          } else {
            window.setTimeout(highlightAutomaticallyCallback, 16);
          }
        }
      }
      return _2;
    }(_self);
    if (typeof module !== "undefined" && module.exports) {
      module.exports = Prism3;
    }
    if (typeof global !== "undefined") {
      global.Prism = Prism3;
    }
    Prism3.languages.markup = {
      "comment": {
        pattern: /<!--(?:(?!<!--)[\s\S])*?-->/,
        greedy: true
      },
      "prolog": {
        pattern: /<\?[\s\S]+?\?>/,
        greedy: true
      },
      "doctype": {
        // https://www.w3.org/TR/xml/#NT-doctypedecl
        pattern: /<!DOCTYPE(?:[^>"'[\]]|"[^"]*"|'[^']*')+(?:\[(?:[^<"'\]]|"[^"]*"|'[^']*'|<(?!!--)|<!--(?:[^-]|-(?!->))*-->)*\]\s*)?>/i,
        greedy: true,
        inside: {
          "internal-subset": {
            pattern: /(^[^\[]*\[)[\s\S]+(?=\]>$)/,
            lookbehind: true,
            greedy: true,
            inside: null
            // see below
          },
          "string": {
            pattern: /"[^"]*"|'[^']*'/,
            greedy: true
          },
          "punctuation": /^<!|>$|[[\]]/,
          "doctype-tag": /^DOCTYPE/i,
          "name": /[^\s<>'"]+/
        }
      },
      "cdata": {
        pattern: /<!\[CDATA\[[\s\S]*?\]\]>/i,
        greedy: true
      },
      "tag": {
        pattern: /<\/?(?!\d)[^\s>\/=$<%]+(?:\s(?:\s*[^\s>\/=]+(?:\s*=\s*(?:"[^"]*"|'[^']*'|[^\s'">=]+(?=[\s>]))|(?=[\s/>])))+)?\s*\/?>/,
        greedy: true,
        inside: {
          "tag": {
            pattern: /^<\/?[^\s>\/]+/,
            inside: {
              "punctuation": /^<\/?/,
              "namespace": /^[^\s>\/:]+:/
            }
          },
          "special-attr": [],
          "attr-value": {
            pattern: /=\s*(?:"[^"]*"|'[^']*'|[^\s'">=]+)/,
            inside: {
              "punctuation": [
                {
                  pattern: /^=/,
                  alias: "attr-equals"
                },
                {
                  pattern: /^(\s*)["']|["']$/,
                  lookbehind: true
                }
              ]
            }
          },
          "punctuation": /\/?>/,
          "attr-name": {
            pattern: /[^\s>\/]+/,
            inside: {
              "namespace": /^[^\s>\/:]+:/
            }
          }
        }
      },
      "entity": [
        {
          pattern: /&[\da-z]{1,8};/i,
          alias: "named-entity"
        },
        /&#x?[\da-f]{1,8};/i
      ]
    };
    Prism3.languages.markup["tag"].inside["attr-value"].inside["entity"] = Prism3.languages.markup["entity"];
    Prism3.languages.markup["doctype"].inside["internal-subset"].inside = Prism3.languages.markup;
    Prism3.hooks.add("wrap", function(env2) {
      if (env2.type === "entity") {
        env2.attributes["title"] = env2.content.replace(/&amp;/, "&");
      }
    });
    Object.defineProperty(Prism3.languages.markup.tag, "addInlined", {
      /**
       * Adds an inlined language to markup.
       *
       * An example of an inlined language is CSS with `<style>` tags.
       *
       * @param {string} tagName The name of the tag that contains the inlined language. This name will be treated as
       * case insensitive.
       * @param {string} lang The language key.
       * @example
       * addInlined('style', 'css');
       */
      value: function addInlined2(tagName, lang) {
        var includedCdataInside = {};
        includedCdataInside["language-" + lang] = {
          pattern: /(^<!\[CDATA\[)[\s\S]+?(?=\]\]>$)/i,
          lookbehind: true,
          inside: Prism3.languages[lang]
        };
        includedCdataInside["cdata"] = /^<!\[CDATA\[|\]\]>$/i;
        var inside = {
          "included-cdata": {
            pattern: /<!\[CDATA\[[\s\S]*?\]\]>/i,
            inside: includedCdataInside
          }
        };
        inside["language-" + lang] = {
          pattern: /[\s\S]+/,
          inside: Prism3.languages[lang]
        };
        var def = {};
        def[tagName] = {
          pattern: RegExp(/(<__[^>]*>)(?:<!\[CDATA\[(?:[^\]]|\](?!\]>))*\]\]>|(?!<!\[CDATA\[)[\s\S])*?(?=<\/__>)/.source.replace(/__/g, function() {
            return tagName;
          }), "i"),
          lookbehind: true,
          greedy: true,
          inside
        };
        Prism3.languages.insertBefore("markup", "cdata", def);
      }
    });
    Object.defineProperty(Prism3.languages.markup.tag, "addAttribute", {
      /**
       * Adds an pattern to highlight languages embedded in HTML attributes.
       *
       * An example of an inlined language is CSS with `style` attributes.
       *
       * @param {string} attrName The name of the tag that contains the inlined language. This name will be treated as
       * case insensitive.
       * @param {string} lang The language key.
       * @example
       * addAttribute('style', 'css');
       */
      value: function(attrName, lang) {
        Prism3.languages.markup.tag.inside["special-attr"].push({
          pattern: RegExp(
            /(^|["'\s])/.source + "(?:" + attrName + ")" + /\s*=\s*(?:"[^"]*"|'[^']*'|[^\s'">=]+(?=[\s>]))/.source,
            "i"
          ),
          lookbehind: true,
          inside: {
            "attr-name": /^[^\s=]+/,
            "attr-value": {
              pattern: /=[\s\S]+/,
              inside: {
                "value": {
                  pattern: /(^=\s*(["']|(?!["'])))\S[\s\S]*(?=\2$)/,
                  lookbehind: true,
                  alias: [lang, "language-" + lang],
                  inside: Prism3.languages[lang]
                },
                "punctuation": [
                  {
                    pattern: /^=/,
                    alias: "attr-equals"
                  },
                  /"|'/
                ]
              }
            }
          }
        });
      }
    });
    Prism3.languages.html = Prism3.languages.markup;
    Prism3.languages.mathml = Prism3.languages.markup;
    Prism3.languages.svg = Prism3.languages.markup;
    Prism3.languages.xml = Prism3.languages.extend("markup", {});
    Prism3.languages.ssml = Prism3.languages.xml;
    Prism3.languages.atom = Prism3.languages.xml;
    Prism3.languages.rss = Prism3.languages.xml;
    (function(Prism4) {
      var string3 = /(?:"(?:\\(?:\r\n|[\s\S])|[^"\\\r\n])*"|'(?:\\(?:\r\n|[\s\S])|[^'\\\r\n])*')/;
      Prism4.languages.css = {
        "comment": /\/\*[\s\S]*?\*\//,
        "atrule": {
          pattern: RegExp("@[\\w-](?:" + /[^;{\s"']|\s+(?!\s)/.source + "|" + string3.source + ")*?" + /(?:;|(?=\s*\{))/.source),
          inside: {
            "rule": /^@[\w-]+/,
            "selector-function-argument": {
              pattern: /(\bselector\s*\(\s*(?![\s)]))(?:[^()\s]|\s+(?![\s)])|\((?:[^()]|\([^()]*\))*\))+(?=\s*\))/,
              lookbehind: true,
              alias: "selector"
            },
            "keyword": {
              pattern: /(^|[^\w-])(?:and|not|only|or)(?![\w-])/,
              lookbehind: true
            }
            // See rest below
          }
        },
        "url": {
          // https://drafts.csswg.org/css-values-3/#urls
          pattern: RegExp("\\burl\\((?:" + string3.source + "|" + /(?:[^\\\r\n()"']|\\[\s\S])*/.source + ")\\)", "i"),
          greedy: true,
          inside: {
            "function": /^url/i,
            "punctuation": /^\(|\)$/,
            "string": {
              pattern: RegExp("^" + string3.source + "$"),
              alias: "url"
            }
          }
        },
        "selector": {
          pattern: RegExp(`(^|[{}\\s])[^{}\\s](?:[^{};"'\\s]|\\s+(?![\\s{])|` + string3.source + ")*(?=\\s*\\{)"),
          lookbehind: true
        },
        "string": {
          pattern: string3,
          greedy: true
        },
        "property": {
          pattern: /(^|[^-\w\xA0-\uFFFF])(?!\s)[-_a-z\xA0-\uFFFF](?:(?!\s)[-\w\xA0-\uFFFF])*(?=\s*:)/i,
          lookbehind: true
        },
        "important": /!important\b/i,
        "function": {
          pattern: /(^|[^-a-z0-9])[-a-z0-9]+(?=\()/i,
          lookbehind: true
        },
        "punctuation": /[(){};:,]/
      };
      Prism4.languages.css["atrule"].inside.rest = Prism4.languages.css;
      var markup = Prism4.languages.markup;
      if (markup) {
        markup.tag.addInlined("style", "css");
        markup.tag.addAttribute("style", "css");
      }
    })(Prism3);
    Prism3.languages.clike = {
      "comment": [
        {
          pattern: /(^|[^\\])\/\*[\s\S]*?(?:\*\/|$)/,
          lookbehind: true,
          greedy: true
        },
        {
          pattern: /(^|[^\\:])\/\/.*/,
          lookbehind: true,
          greedy: true
        }
      ],
      "string": {
        pattern: /(["'])(?:\\(?:\r\n|[\s\S])|(?!\1)[^\\\r\n])*\1/,
        greedy: true
      },
      "class-name": {
        pattern: /(\b(?:class|extends|implements|instanceof|interface|new|trait)\s+|\bcatch\s+\()[\w.\\]+/i,
        lookbehind: true,
        inside: {
          "punctuation": /[.\\]/
        }
      },
      "keyword": /\b(?:break|catch|continue|do|else|finally|for|function|if|in|instanceof|new|null|return|throw|try|while)\b/,
      "boolean": /\b(?:false|true)\b/,
      "function": /\b\w+(?=\()/,
      "number": /\b0x[\da-f]+\b|(?:\b\d+(?:\.\d*)?|\B\.\d+)(?:e[+-]?\d+)?/i,
      "operator": /[<>]=?|[!=]=?=?|--?|\+\+?|&&?|\|\|?|[?*/~^%]/,
      "punctuation": /[{}[\];(),.:]/
    };
    Prism3.languages.javascript = Prism3.languages.extend("clike", {
      "class-name": [
        Prism3.languages.clike["class-name"],
        {
          pattern: /(^|[^$\w\xA0-\uFFFF])(?!\s)[_$A-Z\xA0-\uFFFF](?:(?!\s)[$\w\xA0-\uFFFF])*(?=\.(?:constructor|prototype))/,
          lookbehind: true
        }
      ],
      "keyword": [
        {
          pattern: /((?:^|\})\s*)catch\b/,
          lookbehind: true
        },
        {
          pattern: /(^|[^.]|\.\.\.\s*)\b(?:as|assert(?=\s*\{)|async(?=\s*(?:function\b|\(|[$\w\xA0-\uFFFF]|$))|await|break|case|class|const|continue|debugger|default|delete|do|else|enum|export|extends|finally(?=\s*(?:\{|$))|for|from(?=\s*(?:['"]|$))|function|(?:get|set)(?=\s*(?:[#\[$\w\xA0-\uFFFF]|$))|if|implements|import|in|instanceof|interface|let|new|null|of|package|private|protected|public|return|static|super|switch|this|throw|try|typeof|undefined|var|void|while|with|yield)\b/,
          lookbehind: true
        }
      ],
      // Allow for all non-ASCII characters (See http://stackoverflow.com/a/2008444)
      "function": /#?(?!\s)[_$a-zA-Z\xA0-\uFFFF](?:(?!\s)[$\w\xA0-\uFFFF])*(?=\s*(?:\.\s*(?:apply|bind|call)\s*)?\()/,
      "number": {
        pattern: RegExp(
          /(^|[^\w$])/.source + "(?:" + // constant
          (/NaN|Infinity/.source + "|" + // binary integer
          /0[bB][01]+(?:_[01]+)*n?/.source + "|" + // octal integer
          /0[oO][0-7]+(?:_[0-7]+)*n?/.source + "|" + // hexadecimal integer
          /0[xX][\dA-Fa-f]+(?:_[\dA-Fa-f]+)*n?/.source + "|" + // decimal bigint
          /\d+(?:_\d+)*n/.source + "|" + // decimal number (integer or float) but no bigint
          /(?:\d+(?:_\d+)*(?:\.(?:\d+(?:_\d+)*)?)?|\.\d+(?:_\d+)*)(?:[Ee][+-]?\d+(?:_\d+)*)?/.source) + ")" + /(?![\w$])/.source
        ),
        lookbehind: true
      },
      "operator": /--|\+\+|\*\*=?|=>|&&=?|\|\|=?|[!=]==|<<=?|>>>?=?|[-+*/%&|^!=<>]=?|\.{3}|\?\?=?|\?\.?|[~:]/
    });
    Prism3.languages.javascript["class-name"][0].pattern = /(\b(?:class|extends|implements|instanceof|interface|new)\s+)[\w.\\]+/;
    Prism3.languages.insertBefore("javascript", "keyword", {
      "regex": {
        pattern: RegExp(
          // lookbehind
          // eslint-disable-next-line regexp/no-dupe-characters-character-class
          /((?:^|[^$\w\xA0-\uFFFF."'\])\s]|\b(?:return|yield))\s*)/.source + // Regex pattern:
          // There are 2 regex patterns here. The RegExp set notation proposal added support for nested character
          // classes if the `v` flag is present. Unfortunately, nested CCs are both context-free and incompatible
          // with the only syntax, so we have to define 2 different regex patterns.
          /\//.source + "(?:" + /(?:\[(?:[^\]\\\r\n]|\\.)*\]|\\.|[^/\\\[\r\n])+\/[dgimyus]{0,7}/.source + "|" + // `v` flag syntax. This supports 3 levels of nested character classes.
          /(?:\[(?:[^[\]\\\r\n]|\\.|\[(?:[^[\]\\\r\n]|\\.|\[(?:[^[\]\\\r\n]|\\.)*\])*\])*\]|\\.|[^/\\\[\r\n])+\/[dgimyus]{0,7}v[dgimyus]{0,7}/.source + ")" + // lookahead
          /(?=(?:\s|\/\*(?:[^*]|\*(?!\/))*\*\/)*(?:$|[\r\n,.;:})\]]|\/\/))/.source
        ),
        lookbehind: true,
        greedy: true,
        inside: {
          "regex-source": {
            pattern: /^(\/)[\s\S]+(?=\/[a-z]*$)/,
            lookbehind: true,
            alias: "language-regex",
            inside: Prism3.languages.regex
          },
          "regex-delimiter": /^\/|\/$/,
          "regex-flags": /^[a-z]+$/
        }
      },
      // This must be declared before keyword because we use "function" inside the look-forward
      "function-variable": {
        pattern: /#?(?!\s)[_$a-zA-Z\xA0-\uFFFF](?:(?!\s)[$\w\xA0-\uFFFF])*(?=\s*[=:]\s*(?:async\s*)?(?:\bfunction\b|(?:\((?:[^()]|\([^()]*\))*\)|(?!\s)[_$a-zA-Z\xA0-\uFFFF](?:(?!\s)[$\w\xA0-\uFFFF])*)\s*=>))/,
        alias: "function"
      },
      "parameter": [
        {
          pattern: /(function(?:\s+(?!\s)[_$a-zA-Z\xA0-\uFFFF](?:(?!\s)[$\w\xA0-\uFFFF])*)?\s*\(\s*)(?!\s)(?:[^()\s]|\s+(?![\s)])|\([^()]*\))+(?=\s*\))/,
          lookbehind: true,
          inside: Prism3.languages.javascript
        },
        {
          pattern: /(^|[^$\w\xA0-\uFFFF])(?!\s)[_$a-z\xA0-\uFFFF](?:(?!\s)[$\w\xA0-\uFFFF])*(?=\s*=>)/i,
          lookbehind: true,
          inside: Prism3.languages.javascript
        },
        {
          pattern: /(\(\s*)(?!\s)(?:[^()\s]|\s+(?![\s)])|\([^()]*\))+(?=\s*\)\s*=>)/,
          lookbehind: true,
          inside: Prism3.languages.javascript
        },
        {
          pattern: /((?:\b|\s|^)(?!(?:as|async|await|break|case|catch|class|const|continue|debugger|default|delete|do|else|enum|export|extends|finally|for|from|function|get|if|implements|import|in|instanceof|interface|let|new|null|of|package|private|protected|public|return|set|static|super|switch|this|throw|try|typeof|undefined|var|void|while|with|yield)(?![$\w\xA0-\uFFFF]))(?:(?!\s)[_$a-zA-Z\xA0-\uFFFF](?:(?!\s)[$\w\xA0-\uFFFF])*\s*)\(\s*|\]\s*\(\s*)(?!\s)(?:[^()\s]|\s+(?![\s)])|\([^()]*\))+(?=\s*\)\s*\{)/,
          lookbehind: true,
          inside: Prism3.languages.javascript
        }
      ],
      "constant": /\b[A-Z](?:[A-Z_]|\dx?)*\b/
    });
    Prism3.languages.insertBefore("javascript", "string", {
      "hashbang": {
        pattern: /^#!.*/,
        greedy: true,
        alias: "comment"
      },
      "template-string": {
        pattern: /`(?:\\[\s\S]|\$\{(?:[^{}]|\{(?:[^{}]|\{[^}]*\})*\})+\}|(?!\$\{)[^\\`])*`/,
        greedy: true,
        inside: {
          "template-punctuation": {
            pattern: /^`|`$/,
            alias: "string"
          },
          "interpolation": {
            pattern: /((?:^|[^\\])(?:\\{2})*)\$\{(?:[^{}]|\{(?:[^{}]|\{[^}]*\})*\})+\}/,
            lookbehind: true,
            inside: {
              "interpolation-punctuation": {
                pattern: /^\$\{|\}$/,
                alias: "punctuation"
              },
              rest: Prism3.languages.javascript
            }
          },
          "string": /[\s\S]+/
        }
      },
      "string-property": {
        pattern: /((?:^|[,{])[ \t]*)(["'])(?:\\(?:\r\n|[\s\S])|(?!\2)[^\\\r\n])*\2(?=\s*:)/m,
        lookbehind: true,
        greedy: true,
        alias: "property"
      }
    });
    Prism3.languages.insertBefore("javascript", "operator", {
      "literal-property": {
        pattern: /((?:^|[,{])[ \t]*)(?!\s)[_$a-zA-Z\xA0-\uFFFF](?:(?!\s)[$\w\xA0-\uFFFF])*(?=\s*:)/m,
        lookbehind: true,
        alias: "property"
      }
    });
    if (Prism3.languages.markup) {
      Prism3.languages.markup.tag.addInlined("script", "javascript");
      Prism3.languages.markup.tag.addAttribute(
        /on(?:abort|blur|change|click|composition(?:end|start|update)|dblclick|error|focus(?:in|out)?|key(?:down|up)|load|mouse(?:down|enter|leave|move|out|over|up)|reset|resize|scroll|select|slotchange|submit|unload|wheel)/.source,
        "javascript"
      );
    }
    Prism3.languages.js = Prism3.languages.javascript;
    (function() {
      if (typeof Prism3 === "undefined" || typeof document === "undefined") {
        return;
      }
      if (!Element.prototype.matches) {
        Element.prototype.matches = Element.prototype.msMatchesSelector || Element.prototype.webkitMatchesSelector;
      }
      var LOADING_MESSAGE = "Loading…";
      var FAILURE_MESSAGE = function(status, message) {
        return "✖ Error " + status + " while fetching file: " + message;
      };
      var FAILURE_EMPTY_MESSAGE = "✖ Error: File does not exist or is empty";
      var EXTENSIONS = {
        "js": "javascript",
        "py": "python",
        "rb": "ruby",
        "ps1": "powershell",
        "psm1": "powershell",
        "sh": "bash",
        "bat": "batch",
        "h": "c",
        "tex": "latex"
      };
      var STATUS_ATTR = "data-src-status";
      var STATUS_LOADING = "loading";
      var STATUS_LOADED = "loaded";
      var STATUS_FAILED = "failed";
      var SELECTOR = "pre[data-src]:not([" + STATUS_ATTR + '="' + STATUS_LOADED + '"]):not([' + STATUS_ATTR + '="' + STATUS_LOADING + '"])';
      function loadFile(src, success, error) {
        var xhr = new XMLHttpRequest();
        xhr.open("GET", src, true);
        xhr.onreadystatechange = function() {
          if (xhr.readyState == 4) {
            if (xhr.status < 400 && xhr.responseText) {
              success(xhr.responseText);
            } else {
              if (xhr.status >= 400) {
                error(FAILURE_MESSAGE(xhr.status, xhr.statusText));
              } else {
                error(FAILURE_EMPTY_MESSAGE);
              }
            }
          }
        };
        xhr.send(null);
      }
      function parseRange(range) {
        var m2 = /^\s*(\d+)\s*(?:(,)\s*(?:(\d+)\s*)?)?$/.exec(range || "");
        if (m2) {
          var start2 = Number(m2[1]);
          var comma = m2[2];
          var end = m2[3];
          if (!comma) {
            return [start2, start2];
          }
          if (!end) {
            return [start2, void 0];
          }
          return [start2, Number(end)];
        }
        return void 0;
      }
      Prism3.hooks.add("before-highlightall", function(env2) {
        env2.selector += ", " + SELECTOR;
      });
      Prism3.hooks.add("before-sanity-check", function(env2) {
        var pre = (
          /** @type {HTMLPreElement} */
          env2.element
        );
        if (pre.matches(SELECTOR)) {
          env2.code = "";
          pre.setAttribute(STATUS_ATTR, STATUS_LOADING);
          var code3 = pre.appendChild(document.createElement("CODE"));
          code3.textContent = LOADING_MESSAGE;
          var src = pre.getAttribute("data-src");
          var language2 = env2.language;
          if (language2 === "none") {
            var extension2 = (/\.(\w+)$/.exec(src) || [, "none"])[1];
            language2 = EXTENSIONS[extension2] || extension2;
          }
          Prism3.util.setLanguage(code3, language2);
          Prism3.util.setLanguage(pre, language2);
          var autoloader = Prism3.plugins.autoloader;
          if (autoloader) {
            autoloader.loadLanguages(language2);
          }
          loadFile(
            src,
            function(text4) {
              pre.setAttribute(STATUS_ATTR, STATUS_LOADED);
              var range = parseRange(pre.getAttribute("data-range"));
              if (range) {
                var lines = text4.split(/\r\n?|\n/g);
                var start2 = range[0];
                var end = range[1] == null ? lines.length : range[1];
                if (start2 < 0) {
                  start2 += lines.length;
                }
                start2 = Math.max(0, Math.min(start2 - 1, lines.length));
                if (end < 0) {
                  end += lines.length;
                }
                end = Math.max(0, Math.min(end, lines.length));
                text4 = lines.slice(start2, end).join("\n");
                if (!pre.hasAttribute("data-start")) {
                  pre.setAttribute("data-start", String(start2 + 1));
                }
              }
              code3.textContent = text4;
              Prism3.highlightElement(code3);
            },
            function(error) {
              pre.setAttribute(STATUS_ATTR, STATUS_FAILED);
              code3.textContent = error;
            }
          );
        }
      });
      Prism3.plugins.fileHighlight = {
        /**
         * Executes the File Highlight plugin for all matching `pre` elements under the given container.
         *
         * Note: Elements which are already loaded or currently loading will not be touched by this method.
         *
         * @param {ParentNode} [container=document]
         */
        highlight: function highlight(container) {
          var elements = (container || document).querySelectorAll(SELECTOR);
          for (var i3 = 0, element2; element2 = elements[i3++]; ) {
            Prism3.highlightElement(element2);
          }
        }
      };
      var logged = false;
      Prism3.fileHighlight = function() {
        if (!logged) {
          console.warn("Prism.fileHighlight is deprecated. Use `Prism.plugins.fileHighlight.highlight` instead.");
          logged = true;
        }
        Prism3.plugins.fileHighlight.highlight.apply(this, arguments);
      };
    })();
  }
});

// node_modules/@mdxeditor/gurx/dist/index.js
var d = __toESM(require_react());
var import_jsx_runtime = __toESM(require_jsx_runtime());
var v = Object.defineProperty;
var P = (s2, t3, e2) => t3 in s2 ? v(s2, t3, { enumerable: true, configurable: true, writable: true, value: e2 }) : s2[t3] = e2;
var f = (s2, t3, e2) => P(s2, typeof t3 != "symbol" ? t3 + "" : t3, e2);
var M = class _M {
  constructor(t3 = /* @__PURE__ */ new Map()) {
    this.map = t3;
  }
  clone() {
    return new _M(new Map(this.map));
  }
  increment(t3) {
    const e2 = this.map.get(t3) ?? 0;
    this.map.set(t3, e2 + 1);
  }
  decrement(t3, e2) {
    let n3 = this.map.get(t3);
    n3 !== void 0 && (n3 -= 1, this.map.set(t3, n3), n3 === 0 && e2());
  }
};
var C = class {
  constructor() {
    f(this, "map", /* @__PURE__ */ new Map());
  }
  getOrCreate(t3) {
    let e2 = this.map.get(t3);
    return e2 === void 0 && (e2 = /* @__PURE__ */ new Set(), this.map.set(t3, e2)), e2;
  }
  get(t3) {
    return this.map.get(t3);
  }
  use(t3, e2) {
    const n3 = this.get(t3);
    n3 !== void 0 && e2(n3);
  }
  delete(t3) {
    return this.map.delete(t3);
  }
};
function g(s2, t3) {
  return t3(s2), s2;
}
function x() {
}
var I = "cell";
function O(s2, t3) {
  return s2 === t3;
}
var k = /* @__PURE__ */ new Map();
var w;
var T = class {
  /**
   * Creates a new realm.
   * @param initialValues - the initial cell values that will populate the realm.
   * Those values will not trigger a recomputation cycle, and will overwrite the initial values specified for each cell.
   */
  constructor(t3 = {}) {
    f(this, "subscriptions", new C());
    f(this, "singletonSubscriptions", /* @__PURE__ */ new Map());
    f(this, "graph", new C());
    f(this, "state", /* @__PURE__ */ new Map());
    f(this, "distinctNodes", /* @__PURE__ */ new Map());
    f(this, "executionMaps", /* @__PURE__ */ new Map());
    f(this, "definitionRegistry", /* @__PURE__ */ new Set());
    for (const e2 of Object.getOwnPropertySymbols(t3))
      this.state.set(e2, t3[e2]);
  }
  /**
   * Creates or resolves an existing cell instance in the realm. Useful as a joint point when building your own operators.
   * @returns a reference to the cell.
   * @param value - the initial value of the cell
   * @param distinct - true by default. Pass false to mark the signal as a non-distinct one, meaning that publishing the same value multiple times will re-trigger a recomputation cycle.
   * @param node - optional, a reference to a cell. If the cell has not been touched in the realm before, the realm will instantiate a reference to it. If it's registered already, the function will return the reference.
   */
  cellInstance(t3, e2 = true, n3 = Symbol()) {
    return this.state.has(n3) || this.state.set(n3, t3), e2 !== false && !this.distinctNodes.has(n3) && this.distinctNodes.set(n3, e2 === true ? O : e2), n3;
  }
  /**
   * Creates or resolves an existing signal instance in the realm. Useful as a joint point when building your own operators.
   * @returns a reference to the signal.
   * @param distinct - true by default. Pass false to mark the signal as a non-distinct one, meaning that publishing the same value multiple times will re-trigger a recomputation cycle.
   * @param node - optional, a reference to a signal. If the signal has not been touched in the realm before, the realm will instantiate a reference to it. If it's registered already, the function will return the reference.
   */
  signalInstance(t3 = true, e2 = Symbol()) {
    return t3 !== false && this.distinctNodes.set(e2, t3 === true ? O : t3), e2;
  }
  /**
   * Subscribes to the values published in the referred node.
   * @param node - the cell/signal to subscribe to.
   * @param subscription - the callback to execute when the node receives a new value.
   * @returns a function that, when called, will cancel the subscription.
   *
   * @example
   * ```ts
   * const signal$ = Signal<number>()
   * const r = new Realm()
   * const unsub = r.sub(signal$, console.log)
   * r.pub(signal$, 2)
   * unsub()
   * r.pub(signal$, 3)
   * ```
   */
  sub(t3, e2) {
    this.register(t3);
    const n3 = this.subscriptions.getOrCreate(t3);
    return n3.add(e2), () => n3.delete(e2);
  }
  /**
   * Subscribes exclusively to values in the referred node.
   * Calling this multiple times on a single node will remove the previous subscription created through `singletonSub`.
   * Subscriptions created through `sub` are not affected.
   * @returns a function that, when called, will cancel the subscription.
   *
   * @example
   * ```ts
   * const signal$ = Signal<number>()
   * const r = new Realm()
   * // console.log will run only once.
   * r.singletonSub(signal$, console.log)
   * r.singletonSub(signal$, console.log)
   * r.singletonSub(signal$, console.log)
   * r.pub(signal$, 2)
   * ```
   */
  singletonSub(t3, e2) {
    return this.register(t3), e2 === void 0 ? this.singletonSubscriptions.delete(t3) : this.singletonSubscriptions.set(t3, e2), () => this.singletonSubscriptions.delete(t3);
  }
  /**
   * Clears all exclusive subscriptions.
   */
  resetSingletonSubs() {
    this.singletonSubscriptions.clear();
  }
  // biome-ignore lint/suspicious/noExplicitAny: I know why we need any here
  subMultiple(t3, e2) {
    const n3 = this.signalInstance();
    return this.connect({
      map: (i3) => (...r2) => {
        i3(r2);
      },
      sink: n3,
      sources: t3
    }), this.sub(n3, e2);
  }
  /**
   * Publishes into multiple nodes simultaneously, triggering a single re-computation cycle.
   * @param values - a record of node references and their values.
   *
   * @example
   * ```ts
   * const foo$ = Cell('foo')
   * const bar$ = Cell('bar')
   *
   * const r = new Realm()
   * r.pubIn({[foo$]: 'foo1', [bar$]: 'bar1'})
   * ```
   */
  pubIn(t3) {
    var a2;
    const e2 = Reflect.ownKeys(t3), n3 = this.getExecutionMap(e2), i3 = n3.refCount.clone(), r2 = n3.participatingNodes.slice(), o3 = new Map(this.state), l3 = (p2) => {
      this.graph.use(p2, (c2) => {
        for (const { sources: u2, sink: y2 } of c2)
          u2.has(p2) && i3.decrement(y2, () => {
            r2.splice(r2.indexOf(y2), 1), l3(y2);
          });
      });
    };
    for (; ; ) {
      const p2 = r2.shift();
      if (p2 === void 0)
        break;
      const c2 = p2;
      let u2 = false;
      const y2 = (m2) => {
        const h2 = this.distinctNodes.get(c2);
        if (h2 != null && h2(o3.get(c2), m2)) {
          u2 = false;
          return;
        }
        u2 = true, o3.set(c2, m2), this.state.has(c2) && this.state.set(c2, m2);
      };
      if (Object.prototype.hasOwnProperty.call(t3, c2) ? y2(t3[c2]) : n3.projections.use(c2, (m2) => {
        for (const h2 of m2) {
          const S2 = [...Array.from(h2.sources), ...Array.from(h2.pulls)].map((N2) => o3.get(N2));
          h2.map(y2)(...S2);
        }
      }), u2) {
        const m2 = o3.get(c2);
        this.inContext(() => {
          this.subscriptions.use(c2, (h2) => {
            for (const S2 of h2)
              S2(m2);
          });
        }), (a2 = this.singletonSubscriptions.get(c2)) == null || a2(m2);
      } else
        l3(c2);
    }
  }
  /**
   * A low-level utility that connects multiple nodes to a sink node with a map function. Used as a foundation for the higher-level operators.
   * The nodes can be active (sources) or passive (pulls).
   */
  connect({
    sources: t3,
    pulls: e2 = [],
    map: n3,
    sink: i3
  }) {
    const r2 = {
      map: n3,
      pulls: new Set(e2),
      sink: this.register(i3),
      sources: new Set(t3)
    };
    for (const o3 of [...t3, ...e2])
      this.register(o3), this.graph.getOrCreate(o3).add(r2);
    this.executionMaps.clear();
  }
  pub(t3, e2) {
    this.pubIn({ [t3]: e2 });
  }
  pipe(t3, ...e2) {
    return this.combineOperators(...e2)(t3);
  }
  transformer(...t3) {
    return (e2) => g(this.signalInstance(), (n3) => (this.link(this.pipe(n3, ...t3), e2), n3));
  }
  /**
   * Links the output of a node to the input of another node.
   */
  link(t3, e2) {
    this.connect({
      map: (n3) => (i3) => {
        n3(i3);
      },
      sink: e2,
      sources: [t3]
    });
  }
  // prettier-ignore
  combine(...t3) {
    return g(this.signalInstance(), (e2) => {
      this.connect({
        map: (n3) => (...i3) => {
          n3(i3);
        },
        sink: e2,
        sources: t3
      });
    });
  }
  // prettier-ignore
  combineCells(...t3) {
    return g(
      this.cellInstance(
        t3.map((e2) => this.getValue(e2)),
        true
      ),
      (e2) => {
        this.connect({
          map: (n3) => (...i3) => {
            n3(i3);
          },
          sink: e2,
          sources: t3
        });
      }
    );
  }
  /**
   * Gets the current value of a node. The node must be stateful.
   * @remark if possible, use {@link withLatestFrom} or {@link combine}, as getValue will not create a dependency to the passed node,
   * which means that if you call it within a computational cycle, you may not get the correct value.
   * @param node - the node instance.
   * @example
   * ```ts
   * const foo$ = Cell('foo')
   *
   * const r = new Realm()
   * r.getValue(foo$) // 'foo'
   * r.pub(foo$, 'bar')
   * //...
   * r.getValue(foo$) // 'bar'
   * ```
   */
  getValue(t3) {
    return this.register(t3), this.state.get(t3);
  }
  getValues(t3) {
    return t3.map((e2) => this.getValue(e2));
  }
  /**
   * Explicitly includes the specified cell/signal reference in the realm.
   * Most of the time you don't need to do that, since any interaction with the node through a realm will register it.
   * The only exception of that rule should be when the interaction is conditional, and the node definition includes an init function that needs to be eagerly evaluated.
   */
  register(t3) {
    const e2 = k.get(t3);
    return e2 === void 0 || this.definitionRegistry.has(t3) ? t3 : (this.definitionRegistry.add(t3), g(
      e2.type === I ? this.cellInstance(e2.initial, e2.distinct, t3) : this.signalInstance(e2.distinct, t3),
      (n3) => {
        this.inContext(() => {
          e2.init(this, n3);
        });
      }
    ));
  }
  inContext(t3) {
    const e2 = w;
    w = this;
    const n3 = t3();
    return w = e2, n3;
  }
  /**
   * Convenient for mutation of cells that contian non-primitive values (e.g. arrays, or objects).
   * Specifies that the cell value should be changed when source emits, with the result of the map callback parameter.
   * the map parameter gets called with the current value of the cell and the value published through the source.
   * @typeParam T - the type of the cell value.
   * @typeParam K - the type of the value published through the source.
   * @example
   * ```ts
   * const items$ = Cell<string[]([])
   * const addItem$ = Signal<string>(false, (r) => {
   *   r.changeWith(items$, addItem$, (items, item) => [...items, item])
   * })
   * const r = new Realm()
   * r.pub(addItem$, 'foo')
   * r.pub(addItem$, 'bar')
   * r.getValue(items$) // ['foo', 'bar']
   * ```
   */
  changeWith(t3, e2, n3) {
    this.connect({
      sources: [e2],
      pulls: [t3],
      sink: t3,
      map: (i3) => (r2, o3) => {
        i3(n3(o3, r2));
      }
    });
  }
  calculateExecutionMap(t3) {
    const e2 = [], n3 = /* @__PURE__ */ new Set(), i3 = new C(), r2 = new M(), o3 = new C(), l3 = (a2, p2 = 0) => {
      r2.increment(a2), !n3.has(a2) && (this.register(a2), i3.use(a2, (c2) => {
        p2 = Math.max(...Array.from(c2).map((u2) => e2.indexOf(u2))) + 1;
      }), this.graph.use(a2, (c2) => {
        for (const u2 of c2)
          u2.sources.has(a2) ? (o3.getOrCreate(u2.sink).add(u2), l3(u2.sink, p2)) : i3.getOrCreate(u2.sink).add(a2);
      }), n3.add(a2), e2.splice(p2, 0, a2));
    };
    return t3.forEach(l3), { participatingNodes: e2, pendingPulls: i3, projections: o3, refCount: r2 };
  }
  getExecutionMap(t3) {
    let e2 = t3;
    if (t3.length === 1) {
      e2 = t3[0];
      const i3 = this.executionMaps.get(e2);
      if (i3 !== void 0)
        return i3;
    } else
      for (const [i3, r2] of this.executionMaps.entries())
        if (Array.isArray(i3) && i3.length === t3.length && i3.every((o3) => t3.includes(o3)))
          return r2;
    const n3 = this.calculateExecutionMap(t3);
    return this.executionMaps.set(e2, n3), n3;
  }
  combineOperators(...t3) {
    return (e2) => {
      for (const n3 of t3)
        e2 = n3(e2, this);
      return e2;
    };
  }
};
function $(s2, t3 = x, e2 = true) {
  return g(Symbol(), (n3) => {
    k.set(n3, { type: I, distinct: e2, initial: s2, init: t3 });
  });
}
function D(s2, t3, e2 = true) {
  return g(Symbol(), (n3) => {
    k.set(n3, {
      type: I,
      distinct: e2,
      initial: s2,
      init: (i3, r2) => {
        i3.link(t3(i3, r2), r2);
      }
    });
  });
}
function K(s2 = x, t3 = false) {
  return g(Symbol(), (e2) => {
    k.set(e2, { type: "signal", distinct: t3, init: s2 });
  });
}
function q(s2 = x) {
  return g(Symbol(), (t3) => {
    k.set(t3, { type: "signal", distinct: false, init: s2 });
  });
}
function b() {
  if (!w)
    throw new Error("This function must be called within a realm instance");
  return w;
}
var F = (s2, t3) => {
  b().link(s2, t3);
};
var Y = (...s2) => {
  b().pub(...s2);
};
var z = (...s2) => b().sub(...s2);
var B = (...s2) => {
  b().pubIn(...s2);
};
var G = (...s2) => b().pipe(...s2);
var H = (...s2) => {
  b().changeWith(...s2);
};
var J = (...s2) => b().combine(...s2);
var Q = (s2) => b().getValue(s2);
var V = d.createContext(null);
function U({
  children: s2,
  initWith: t3,
  updateWith: e2 = {}
}) {
  const n3 = d.useMemo(() => new T(t3), []);
  return d.useEffect(() => {
    n3.pubIn(e2);
  }, [e2, n3]), (0, import_jsx_runtime.jsx)(V.Provider, { value: n3, children: s2 });
}
function R() {
  const s2 = d.useContext(V);
  if (s2 === null)
    throw new Error("useRealm must be used within a RealmContextProvider");
  return s2;
}
function E(s2) {
  const t3 = R();
  t3.register(s2);
  const e2 = d.useCallback((n3) => t3.sub(s2, n3), [t3, s2]);
  return d.useSyncExternalStore(
    e2,
    () => t3.getValue(s2),
    () => t3.getValue(s2)
  );
}
function X(...s2) {
  const t3 = R();
  return E(t3.combineCells.apply(t3, s2));
}
function A(s2) {
  const t3 = R();
  return t3.register(s2), d.useCallback(
    (e2) => {
      t3.pub(s2, e2);
    },
    [t3, s2]
  );
}
function Z(s2) {
  return [E(s2), A(s2)];
}
function _(s2) {
  return (t3, e2) => {
    const n3 = e2.signalInstance();
    return e2.connect({
      map: (i3) => (r2) => {
        i3(s2(r2));
      },
      sink: n3,
      sources: [t3]
    }), n3;
  };
}
function tt(...s2) {
  return (t3, e2) => {
    const n3 = e2.signalInstance();
    return e2.connect({
      map: (i3) => (...r2) => {
        i3(r2);
      },
      pulls: s2,
      sink: n3,
      sources: [t3]
    }), n3;
  };
}
function et(s2) {
  return (t3, e2) => {
    const n3 = e2.signalInstance();
    return e2.connect({
      map: (i3) => () => {
        i3(s2);
      },
      sink: n3,
      sources: [t3]
    }), n3;
  };
}
function nt(s2) {
  return (t3, e2) => {
    const n3 = e2.signalInstance();
    return e2.connect({
      map: (i3) => (r2) => {
        s2(r2) && i3(r2);
      },
      sink: n3,
      sources: [t3]
    }), n3;
  };
}
function st() {
  return (s2, t3) => {
    const e2 = t3.signalInstance();
    let n3 = false;
    return t3.connect({
      map: (i3) => (r2) => {
        n3 || (n3 = true, i3(r2));
      },
      sink: e2,
      sources: [s2]
    }), e2;
  };
}
function it(s2, t3) {
  return (e2, n3) => {
    const i3 = n3.signalInstance();
    return n3.connect({
      map: (r2) => (o3) => {
        r2(t3 = s2(t3, o3));
      },
      sink: i3,
      sources: [e2]
    }), i3;
  };
}
function rt(s2) {
  return (t3, e2) => {
    const n3 = e2.signalInstance();
    let i3, r2 = null;
    return e2.sub(t3, (o3) => {
      i3 = o3, r2 === null && (r2 = setTimeout(() => {
        r2 = null, e2.pub(n3, i3);
      }, s2));
    }), n3;
  };
}
function ot(s2) {
  return (t3, e2) => {
    const n3 = e2.signalInstance();
    let i3, r2 = null;
    return e2.sub(t3, (o3) => {
      i3 = o3, r2 !== null && clearTimeout(r2), r2 = setTimeout(() => {
        e2.pub(n3, i3);
      }, s2);
    }), n3;
  };
}
function ct() {
  return (s2, t3) => {
    const e2 = t3.signalInstance();
    return t3.sub(s2, (n3) => {
      queueMicrotask(() => {
        t3.pub(e2, n3);
      });
    }), e2;
  };
}
function ut(s2) {
  return (t3, e2) => {
    const n3 = e2.signalInstance(), i3 = Symbol();
    let r2 = i3;
    return e2.connect({
      map: (o3) => (l3) => {
        r2 !== i3 && (o3([r2, l3]), r2 = i3);
      },
      sink: n3,
      sources: [s2]
    }), e2.sub(t3, (o3) => {
      r2 = o3;
    }), n3;
  };
}
function at(s2, t3, e2) {
  return (n3, i3) => {
    const r2 = i3.signalInstance();
    return i3.sub(n3, (o3) => {
      o3 !== null && typeof o3 == "object" && "then" in o3 ? (i3.pub(r2, s2()), o3.then((l3) => {
        i3.pub(r2, t3(l3));
      }).catch((l3) => {
        i3.pub(r2, e2(l3));
      })) : i3.pub(r2, t3(o3));
    }), r2;
  };
}

// node_modules/@mdxeditor/editor/dist/MDXEditor.js
var import_react9 = __toESM(require_react(), 1);

// node_modules/@mdxeditor/editor/dist/RealmWithPlugins.js
var import_react = __toESM(require_react(), 1);

// node_modules/@mdxeditor/editor/dist/utils/fp.js
function compose(a2, b3) {
  return (arg) => a2(b3(arg));
}
function thrush(arg, proc) {
  return proc(arg);
}
function curry2to1(proc, arg1) {
  return (arg2) => proc(arg1, arg2);
}
function curry1to0(proc, arg) {
  return () => proc(arg);
}
function prop(property) {
  return (object) => object[property];
}
function tap(arg, proc) {
  proc(arg);
  return arg;
}
function call(proc) {
  proc();
}
function always(value2) {
  return () => value2;
}
function joinProc(...procs) {
  return () => {
    procs.map(call);
  };
}
function noop() {
}

// node_modules/@mdxeditor/editor/dist/RealmWithPlugins.js
function realmPlugin(plugin) {
  return function(params) {
    return {
      init: (realm) => {
        var _a2;
        return (_a2 = plugin.init) == null ? void 0 : _a2.call(plugin, realm, params);
      },
      postInit: (realm) => {
        var _a2;
        return (_a2 = plugin.postInit) == null ? void 0 : _a2.call(plugin, realm, params);
      },
      update: (realm) => {
        var _a2;
        return (_a2 = plugin.update) == null ? void 0 : _a2.call(plugin, realm, params);
      }
    };
  };
}
function RealmWithPlugins({ children, plugins }) {
  const theRealm = import_react.default.useMemo(() => {
    return tap(new T(), (r2) => {
      var _a2, _b2;
      for (const plugin of plugins) {
        (_a2 = plugin.init) == null ? void 0 : _a2.call(plugin, r2);
      }
      for (const plugin of plugins) {
        (_b2 = plugin.postInit) == null ? void 0 : _b2.call(plugin, r2);
      }
    });
  }, []);
  import_react.default.useEffect(() => {
    var _a2;
    for (const plugin of plugins) {
      (_a2 = plugin.update) == null ? void 0 : _a2.call(plugin, theRealm);
    }
  });
  return import_react.default.createElement(V.Provider, { value: theRealm }, children);
}

// node_modules/@lexical/react/LexicalComposerContext.dev.mjs
var import_react2 = __toESM(require_react(), 1);
var LexicalComposerContext = (0, import_react2.createContext)(null);
function createLexicalComposerContext(parent, theme) {
  let parentContext = null;
  if (parent != null) {
    parentContext = parent[1];
  }
  function getTheme() {
    if (theme != null) {
      return theme;
    }
    return parentContext != null ? parentContext.getTheme() : null;
  }
  return {
    getTheme
  };
}
function useLexicalComposerContext() {
  const composerContext = (0, import_react2.useContext)(LexicalComposerContext);
  if (composerContext == null) {
    {
      throw Error(`LexicalComposerContext.useLexicalComposerContext: cannot find a LexicalComposerContext`);
    }
  }
  return composerContext;
}

// node_modules/lexical/Lexical.dev.mjs
function createCommand(type2) {
  return {
    type: type2
  };
}
var SELECTION_CHANGE_COMMAND = createCommand("SELECTION_CHANGE_COMMAND");
var SELECTION_INSERT_CLIPBOARD_NODES_COMMAND = createCommand("SELECTION_INSERT_CLIPBOARD_NODES_COMMAND");
var CLICK_COMMAND = createCommand("CLICK_COMMAND");
var DELETE_CHARACTER_COMMAND = createCommand("DELETE_CHARACTER_COMMAND");
var INSERT_LINE_BREAK_COMMAND = createCommand("INSERT_LINE_BREAK_COMMAND");
var INSERT_PARAGRAPH_COMMAND = createCommand("INSERT_PARAGRAPH_COMMAND");
var CONTROLLED_TEXT_INSERTION_COMMAND = createCommand("CONTROLLED_TEXT_INSERTION_COMMAND");
var PASTE_COMMAND = createCommand("PASTE_COMMAND");
var REMOVE_TEXT_COMMAND = createCommand("REMOVE_TEXT_COMMAND");
var DELETE_WORD_COMMAND = createCommand("DELETE_WORD_COMMAND");
var DELETE_LINE_COMMAND = createCommand("DELETE_LINE_COMMAND");
var FORMAT_TEXT_COMMAND = createCommand("FORMAT_TEXT_COMMAND");
var UNDO_COMMAND = createCommand("UNDO_COMMAND");
var REDO_COMMAND = createCommand("REDO_COMMAND");
var KEY_DOWN_COMMAND = createCommand("KEYDOWN_COMMAND");
var KEY_ARROW_RIGHT_COMMAND = createCommand("KEY_ARROW_RIGHT_COMMAND");
var MOVE_TO_END = createCommand("MOVE_TO_END");
var KEY_ARROW_LEFT_COMMAND = createCommand("KEY_ARROW_LEFT_COMMAND");
var MOVE_TO_START = createCommand("MOVE_TO_START");
var KEY_ARROW_UP_COMMAND = createCommand("KEY_ARROW_UP_COMMAND");
var KEY_ARROW_DOWN_COMMAND = createCommand("KEY_ARROW_DOWN_COMMAND");
var KEY_ENTER_COMMAND = createCommand("KEY_ENTER_COMMAND");
var KEY_SPACE_COMMAND = createCommand("KEY_SPACE_COMMAND");
var KEY_BACKSPACE_COMMAND = createCommand("KEY_BACKSPACE_COMMAND");
var KEY_ESCAPE_COMMAND = createCommand("KEY_ESCAPE_COMMAND");
var KEY_DELETE_COMMAND = createCommand("KEY_DELETE_COMMAND");
var KEY_TAB_COMMAND = createCommand("KEY_TAB_COMMAND");
var INSERT_TAB_COMMAND = createCommand("INSERT_TAB_COMMAND");
var INDENT_CONTENT_COMMAND = createCommand("INDENT_CONTENT_COMMAND");
var OUTDENT_CONTENT_COMMAND = createCommand("OUTDENT_CONTENT_COMMAND");
var DROP_COMMAND = createCommand("DROP_COMMAND");
var FORMAT_ELEMENT_COMMAND = createCommand("FORMAT_ELEMENT_COMMAND");
var DRAGSTART_COMMAND = createCommand("DRAGSTART_COMMAND");
var DRAGOVER_COMMAND = createCommand("DRAGOVER_COMMAND");
var DRAGEND_COMMAND = createCommand("DRAGEND_COMMAND");
var COPY_COMMAND = createCommand("COPY_COMMAND");
var CUT_COMMAND = createCommand("CUT_COMMAND");
var SELECT_ALL_COMMAND = createCommand("SELECT_ALL_COMMAND");
var CLEAR_EDITOR_COMMAND = createCommand("CLEAR_EDITOR_COMMAND");
var CLEAR_HISTORY_COMMAND = createCommand("CLEAR_HISTORY_COMMAND");
var CAN_REDO_COMMAND = createCommand("CAN_REDO_COMMAND");
var CAN_UNDO_COMMAND = createCommand("CAN_UNDO_COMMAND");
var FOCUS_COMMAND = createCommand("FOCUS_COMMAND");
var BLUR_COMMAND = createCommand("BLUR_COMMAND");
var KEY_MODIFIER_COMMAND = createCommand("KEY_MODIFIER_COMMAND");
var CAN_USE_DOM = typeof window !== "undefined" && typeof window.document !== "undefined" && typeof window.document.createElement !== "undefined";
var documentMode = CAN_USE_DOM && "documentMode" in document ? document.documentMode : null;
var IS_APPLE = CAN_USE_DOM && /Mac|iPod|iPhone|iPad/.test(navigator.platform);
var IS_FIREFOX = CAN_USE_DOM && /^(?!.*Seamonkey)(?=.*Firefox).*/i.test(navigator.userAgent);
var CAN_USE_BEFORE_INPUT = CAN_USE_DOM && "InputEvent" in window && !documentMode ? "getTargetRanges" in new window.InputEvent("input") : false;
var IS_SAFARI = CAN_USE_DOM && /Version\/[\d.]+.*Safari/.test(navigator.userAgent);
var IS_IOS = CAN_USE_DOM && /iPad|iPhone|iPod/.test(navigator.userAgent) && !window.MSStream;
var IS_ANDROID = CAN_USE_DOM && /Android/.test(navigator.userAgent);
var IS_CHROME = CAN_USE_DOM && /^(?=.*Chrome).*/i.test(navigator.userAgent);
var IS_ANDROID_CHROME = CAN_USE_DOM && IS_ANDROID && IS_CHROME;
var IS_APPLE_WEBKIT = CAN_USE_DOM && /AppleWebKit\/[\d.]+/.test(navigator.userAgent) && !IS_CHROME;
var DOM_ELEMENT_TYPE = 1;
var DOM_TEXT_TYPE = 3;
var DOM_DOCUMENT_TYPE = 9;
var DOM_DOCUMENT_FRAGMENT_TYPE = 11;
var NO_DIRTY_NODES = 0;
var HAS_DIRTY_NODES = 1;
var FULL_RECONCILE = 2;
var IS_NORMAL = 0;
var IS_TOKEN = 1;
var IS_SEGMENTED = 2;
var IS_BOLD = 1;
var IS_ITALIC = 1 << 1;
var IS_STRIKETHROUGH = 1 << 2;
var IS_UNDERLINE = 1 << 3;
var IS_CODE = 1 << 4;
var IS_SUBSCRIPT = 1 << 5;
var IS_SUPERSCRIPT = 1 << 6;
var IS_HIGHLIGHT = 1 << 7;
var IS_LOWERCASE = 1 << 8;
var IS_UPPERCASE = 1 << 9;
var IS_CAPITALIZE = 1 << 10;
var IS_ALL_FORMATTING = IS_BOLD | IS_ITALIC | IS_STRIKETHROUGH | IS_UNDERLINE | IS_CODE | IS_SUBSCRIPT | IS_SUPERSCRIPT | IS_HIGHLIGHT | IS_LOWERCASE | IS_UPPERCASE | IS_CAPITALIZE;
var IS_DIRECTIONLESS = 1;
var IS_UNMERGEABLE = 1 << 1;
var IS_ALIGN_LEFT = 1;
var IS_ALIGN_CENTER = 2;
var IS_ALIGN_RIGHT = 3;
var IS_ALIGN_JUSTIFY = 4;
var IS_ALIGN_START = 5;
var IS_ALIGN_END = 6;
var NON_BREAKING_SPACE = " ";
var ZERO_WIDTH_SPACE = "​";
var COMPOSITION_SUFFIX = IS_SAFARI || IS_IOS || IS_APPLE_WEBKIT ? NON_BREAKING_SPACE : ZERO_WIDTH_SPACE;
var DOUBLE_LINE_BREAK = "\n\n";
var COMPOSITION_START_CHAR = IS_FIREFOX ? NON_BREAKING_SPACE : COMPOSITION_SUFFIX;
var RTL = "֑-߿יִ-﷽ﹰ-ﻼ";
var LTR = "A-Za-zÀ-ÖØ-öø-ʸ̀-֐ࠀ-῿‎Ⰰ-﬜︀-﹯﻽-￿";
var RTL_REGEX = new RegExp("^[^" + LTR + "]*[" + RTL + "]");
var LTR_REGEX = new RegExp("^[^" + RTL + "]*[" + LTR + "]");
var TEXT_TYPE_TO_FORMAT = {
  bold: IS_BOLD,
  capitalize: IS_CAPITALIZE,
  code: IS_CODE,
  highlight: IS_HIGHLIGHT,
  italic: IS_ITALIC,
  lowercase: IS_LOWERCASE,
  strikethrough: IS_STRIKETHROUGH,
  subscript: IS_SUBSCRIPT,
  superscript: IS_SUPERSCRIPT,
  underline: IS_UNDERLINE,
  uppercase: IS_UPPERCASE
};
var DETAIL_TYPE_TO_DETAIL = {
  directionless: IS_DIRECTIONLESS,
  unmergeable: IS_UNMERGEABLE
};
var ELEMENT_TYPE_TO_FORMAT = {
  center: IS_ALIGN_CENTER,
  end: IS_ALIGN_END,
  justify: IS_ALIGN_JUSTIFY,
  left: IS_ALIGN_LEFT,
  right: IS_ALIGN_RIGHT,
  start: IS_ALIGN_START
};
var ELEMENT_FORMAT_TO_TYPE = {
  [IS_ALIGN_CENTER]: "center",
  [IS_ALIGN_END]: "end",
  [IS_ALIGN_JUSTIFY]: "justify",
  [IS_ALIGN_LEFT]: "left",
  [IS_ALIGN_RIGHT]: "right",
  [IS_ALIGN_START]: "start"
};
var TEXT_MODE_TO_TYPE = {
  normal: IS_NORMAL,
  segmented: IS_SEGMENTED,
  token: IS_TOKEN
};
var TEXT_TYPE_TO_MODE = {
  [IS_NORMAL]: "normal",
  [IS_SEGMENTED]: "segmented",
  [IS_TOKEN]: "token"
};
function normalizeClassNames(...classNames14) {
  const rval = [];
  for (const className of classNames14) {
    if (className && typeof className === "string") {
      for (const [s2] of className.matchAll(/\S+/g)) {
        rval.push(s2);
      }
    }
  }
  return rval;
}
var TEXT_MUTATION_VARIANCE = 100;
var isProcessingMutations = false;
var lastTextEntryTimeStamp = 0;
function getIsProcessingMutations() {
  return isProcessingMutations;
}
function updateTimeStamp(event) {
  lastTextEntryTimeStamp = event.timeStamp;
}
function initTextEntryListener(editor) {
  if (lastTextEntryTimeStamp === 0) {
    getWindow(editor).addEventListener("textInput", updateTimeStamp, true);
  }
}
function isManagedLineBreak(dom, target, editor) {
  const isBR = dom.nodeName === "BR";
  const lexicalLineBreak = target.__lexicalLineBreak;
  return lexicalLineBreak && (dom === lexicalLineBreak || isBR && dom.previousSibling === lexicalLineBreak) || isBR && getNodeKeyFromDOMNode(dom, editor) !== void 0;
}
function getLastSelection(editor) {
  return editor.getEditorState().read(() => {
    const selection2 = $getSelection();
    return selection2 !== null ? selection2.clone() : null;
  });
}
function $handleTextMutation(target, node2, editor) {
  const domSelection = getDOMSelection(editor._window);
  let anchorOffset = null;
  let focusOffset = null;
  if (domSelection !== null && domSelection.anchorNode === target) {
    anchorOffset = domSelection.anchorOffset;
    focusOffset = domSelection.focusOffset;
  }
  const text4 = target.nodeValue;
  if (text4 !== null) {
    $updateTextNodeFromDOMContent(node2, text4, anchorOffset, focusOffset, false);
  }
}
function shouldUpdateTextNodeFromMutation(selection2, targetDOM, targetNode) {
  if ($isRangeSelection(selection2)) {
    const anchorNode = selection2.anchor.getNode();
    if (anchorNode.is(targetNode) && selection2.format !== anchorNode.getFormat()) {
      return false;
    }
  }
  return isDOMTextNode(targetDOM) && targetNode.isAttached();
}
function $getNearestManagedNodePairFromDOMNode(startingDOM, editor, editorState, rootElement) {
  for (let dom = startingDOM; dom && !isDOMUnmanaged(dom); dom = getParentElement(dom)) {
    const key2 = getNodeKeyFromDOMNode(dom, editor);
    if (key2 !== void 0) {
      const node2 = $getNodeByKey(key2, editorState);
      if (node2) {
        return $isDecoratorNode(node2) || !isHTMLElement(dom) ? void 0 : [dom, node2];
      }
    } else if (dom === rootElement) {
      return [rootElement, internalGetRoot(editorState)];
    }
  }
}
function $flushMutations$1(editor, mutations, observer) {
  isProcessingMutations = true;
  const shouldFlushTextMutations = performance.now() - lastTextEntryTimeStamp > TEXT_MUTATION_VARIANCE;
  try {
    updateEditor(editor, () => {
      const selection2 = $getSelection() || getLastSelection(editor);
      const badDOMTargets = /* @__PURE__ */ new Map();
      const rootElement = editor.getRootElement();
      const currentEditorState = editor._editorState;
      const blockCursorElement = editor._blockCursorElement;
      let shouldRevertSelection = false;
      let possibleTextForFirefoxPaste = "";
      for (let i3 = 0; i3 < mutations.length; i3++) {
        const mutation = mutations[i3];
        const type2 = mutation.type;
        const targetDOM = mutation.target;
        const pair = $getNearestManagedNodePairFromDOMNode(targetDOM, editor, currentEditorState, rootElement);
        if (!pair) {
          continue;
        }
        const [nodeDOM, targetNode] = pair;
        if (type2 === "characterData") {
          if (shouldFlushTextMutations && $isTextNode(targetNode) && isDOMTextNode(targetDOM) && shouldUpdateTextNodeFromMutation(selection2, targetDOM, targetNode)) {
            $handleTextMutation(targetDOM, targetNode, editor);
          }
        } else if (type2 === "childList") {
          shouldRevertSelection = true;
          const addedDOMs = mutation.addedNodes;
          for (let s2 = 0; s2 < addedDOMs.length; s2++) {
            const addedDOM = addedDOMs[s2];
            const node2 = $getNodeFromDOMNode(addedDOM);
            const parentDOM = addedDOM.parentNode;
            if (parentDOM != null && addedDOM !== blockCursorElement && node2 === null && !isManagedLineBreak(addedDOM, parentDOM, editor)) {
              if (IS_FIREFOX) {
                const possibleText = (isHTMLElement(addedDOM) ? addedDOM.innerText : null) || addedDOM.nodeValue;
                if (possibleText) {
                  possibleTextForFirefoxPaste += possibleText;
                }
              }
              parentDOM.removeChild(addedDOM);
            }
          }
          const removedDOMs = mutation.removedNodes;
          const removedDOMsLength = removedDOMs.length;
          if (removedDOMsLength > 0) {
            let unremovedBRs = 0;
            for (let s2 = 0; s2 < removedDOMsLength; s2++) {
              const removedDOM = removedDOMs[s2];
              if (isManagedLineBreak(removedDOM, targetDOM, editor) || blockCursorElement === removedDOM) {
                targetDOM.appendChild(removedDOM);
                unremovedBRs++;
              }
            }
            if (removedDOMsLength !== unremovedBRs) {
              badDOMTargets.set(nodeDOM, targetNode);
            }
          }
        }
      }
      if (badDOMTargets.size > 0) {
        for (const [nodeDOM, targetNode] of badDOMTargets) {
          targetNode.reconcileObservedMutation(nodeDOM, editor);
        }
      }
      const records = observer.takeRecords();
      if (records.length > 0) {
        for (let i3 = 0; i3 < records.length; i3++) {
          const record = records[i3];
          const addedNodes = record.addedNodes;
          const target = record.target;
          for (let s2 = 0; s2 < addedNodes.length; s2++) {
            const addedDOM = addedNodes[s2];
            const parentDOM = addedDOM.parentNode;
            if (parentDOM != null && addedDOM.nodeName === "BR" && !isManagedLineBreak(addedDOM, target, editor)) {
              parentDOM.removeChild(addedDOM);
            }
          }
        }
        observer.takeRecords();
      }
      if (selection2 !== null) {
        if (shouldRevertSelection) {
          selection2.dirty = true;
          $setSelection(selection2);
        }
        if (IS_FIREFOX && isFirefoxClipboardEvents(editor)) {
          selection2.insertRawText(possibleTextForFirefoxPaste);
        }
      }
    });
  } finally {
    isProcessingMutations = false;
  }
}
function $flushRootMutations(editor) {
  const observer = editor._observer;
  if (observer !== null) {
    const mutations = observer.takeRecords();
    $flushMutations$1(editor, mutations, observer);
  }
}
function initMutationObserver(editor) {
  initTextEntryListener(editor);
  editor._observer = new MutationObserver((mutations, observer) => {
    $flushMutations$1(editor, mutations, observer);
  });
}
function $canSimpleTextNodesBeMerged(node1, node2) {
  const node1Mode = node1.__mode;
  const node1Format = node1.__format;
  const node1Style = node1.__style;
  const node2Mode = node2.__mode;
  const node2Format = node2.__format;
  const node2Style = node2.__style;
  return (node1Mode === null || node1Mode === node2Mode) && (node1Format === null || node1Format === node2Format) && (node1Style === null || node1Style === node2Style);
}
function $mergeTextNodes(node1, node2) {
  const writableNode1 = node1.mergeWithSibling(node2);
  const normalizedNodes = getActiveEditor()._normalizedNodes;
  normalizedNodes.add(node1.__key);
  normalizedNodes.add(node2.__key);
  return writableNode1;
}
function $normalizeTextNode(textNode) {
  let node2 = textNode;
  if (node2.__text === "" && node2.isSimpleText() && !node2.isUnmergeable()) {
    node2.remove();
    return;
  }
  let previousNode;
  while ((previousNode = node2.getPreviousSibling()) !== null && $isTextNode(previousNode) && previousNode.isSimpleText() && !previousNode.isUnmergeable()) {
    if (previousNode.__text === "") {
      previousNode.remove();
    } else if ($canSimpleTextNodesBeMerged(previousNode, node2)) {
      node2 = $mergeTextNodes(previousNode, node2);
      break;
    } else {
      break;
    }
  }
  let nextNode;
  while ((nextNode = node2.getNextSibling()) !== null && $isTextNode(nextNode) && nextNode.isSimpleText() && !nextNode.isUnmergeable()) {
    if (nextNode.__text === "") {
      nextNode.remove();
    } else if ($canSimpleTextNodesBeMerged(node2, nextNode)) {
      node2 = $mergeTextNodes(node2, nextNode);
      break;
    } else {
      break;
    }
  }
}
function $normalizeSelection(selection2) {
  $normalizePoint(selection2.anchor);
  $normalizePoint(selection2.focus);
  return selection2;
}
function $normalizePoint(point3) {
  while (point3.type === "element") {
    const node2 = point3.getNode();
    const offset5 = point3.offset;
    let nextNode;
    let nextOffsetAtEnd;
    if (offset5 === node2.getChildrenSize()) {
      nextNode = node2.getChildAtIndex(offset5 - 1);
      nextOffsetAtEnd = true;
    } else {
      nextNode = node2.getChildAtIndex(offset5);
      nextOffsetAtEnd = false;
    }
    if ($isTextNode(nextNode)) {
      point3.set(nextNode.__key, nextOffsetAtEnd ? nextNode.getTextContentSize() : 0, "text");
      break;
    } else if (!$isElementNode(nextNode)) {
      break;
    }
    point3.set(nextNode.__key, nextOffsetAtEnd ? nextNode.getChildrenSize() : 0, "element");
  }
}
var keyCounter = 1;
function generateRandomKey() {
  return "" + keyCounter++;
}
function getRegisteredNodeOrThrow(editor, nodeType) {
  const registeredNode = editor._nodes.get(nodeType);
  if (registeredNode === void 0) {
    {
      throw Error(`registeredNode: Type ${nodeType} not found`);
    }
  }
  return registeredNode;
}
var scheduleMicroTask = typeof queueMicrotask === "function" ? queueMicrotask : (fn) => {
  Promise.resolve().then(fn);
};
function $isSelectionCapturedInDecorator(node2) {
  return $isDecoratorNode($getNearestNodeFromDOMNode(node2));
}
function isSelectionCapturedInDecoratorInput(anchorDOM) {
  const activeElement = document.activeElement;
  if (!isHTMLElement(activeElement)) {
    return false;
  }
  const nodeName = activeElement.nodeName;
  return $isDecoratorNode($getNearestNodeFromDOMNode(anchorDOM)) && (nodeName === "INPUT" || nodeName === "TEXTAREA" || activeElement.contentEditable === "true" && getEditorPropertyFromDOMNode(activeElement) == null);
}
function isSelectionWithinEditor(editor, anchorDOM, focusDOM) {
  const rootElement = editor.getRootElement();
  try {
    return rootElement !== null && rootElement.contains(anchorDOM) && rootElement.contains(focusDOM) && // Ignore if selection is within nested editor
    anchorDOM !== null && !isSelectionCapturedInDecoratorInput(anchorDOM) && getNearestEditorFromDOMNode(anchorDOM) === editor;
  } catch (error) {
    return false;
  }
}
function isLexicalEditor(editor) {
  return editor instanceof LexicalEditor;
}
function getNearestEditorFromDOMNode(node2) {
  let currentNode = node2;
  while (currentNode != null) {
    const editor = getEditorPropertyFromDOMNode(currentNode);
    if (isLexicalEditor(editor)) {
      return editor;
    }
    currentNode = getParentElement(currentNode);
  }
  return null;
}
function getEditorPropertyFromDOMNode(node2) {
  return node2 ? node2.__lexicalEditor : null;
}
function getTextDirection(text4) {
  if (RTL_REGEX.test(text4)) {
    return "rtl";
  }
  if (LTR_REGEX.test(text4)) {
    return "ltr";
  }
  return null;
}
function $isTokenOrSegmented(node2) {
  return node2.isToken() || node2.isSegmented();
}
function isDOMTextNode(node2) {
  return isDOMNode(node2) && node2.nodeType === DOM_TEXT_TYPE;
}
function isDOMDocumentNode(node2) {
  return isDOMNode(node2) && node2.nodeType === DOM_DOCUMENT_TYPE;
}
function getDOMTextNode(element2) {
  let node2 = element2;
  while (node2 != null) {
    if (isDOMTextNode(node2)) {
      return node2;
    }
    node2 = node2.firstChild;
  }
  return null;
}
function toggleTextFormatType(format, type2, alignWithFormat) {
  const activeFormat = TEXT_TYPE_TO_FORMAT[type2];
  if (alignWithFormat !== null && (format & activeFormat) === (alignWithFormat & activeFormat)) {
    return format;
  }
  let newFormat = format ^ activeFormat;
  if (type2 === "subscript") {
    newFormat &= ~TEXT_TYPE_TO_FORMAT.superscript;
  } else if (type2 === "superscript") {
    newFormat &= ~TEXT_TYPE_TO_FORMAT.subscript;
  } else if (type2 === "lowercase") {
    newFormat &= ~TEXT_TYPE_TO_FORMAT.uppercase;
    newFormat &= ~TEXT_TYPE_TO_FORMAT.capitalize;
  } else if (type2 === "uppercase") {
    newFormat &= ~TEXT_TYPE_TO_FORMAT.lowercase;
    newFormat &= ~TEXT_TYPE_TO_FORMAT.capitalize;
  } else if (type2 === "capitalize") {
    newFormat &= ~TEXT_TYPE_TO_FORMAT.lowercase;
    newFormat &= ~TEXT_TYPE_TO_FORMAT.uppercase;
  }
  return newFormat;
}
function $isLeafNode(node2) {
  return $isTextNode(node2) || $isLineBreakNode(node2) || $isDecoratorNode(node2);
}
function $setNodeKey(node2, existingKey) {
  if (existingKey != null) {
    {
      errorOnNodeKeyConstructorMismatch(node2, existingKey);
    }
    node2.__key = existingKey;
    return;
  }
  errorOnReadOnly();
  errorOnInfiniteTransforms();
  const editor = getActiveEditor();
  const editorState = getActiveEditorState();
  const key2 = generateRandomKey();
  editorState._nodeMap.set(key2, node2);
  if ($isElementNode(node2)) {
    editor._dirtyElements.set(key2, true);
  } else {
    editor._dirtyLeaves.add(key2);
  }
  editor._cloneNotNeeded.add(key2);
  editor._dirtyType = HAS_DIRTY_NODES;
  node2.__key = key2;
}
function errorOnNodeKeyConstructorMismatch(node2, existingKey) {
  const editorState = internalGetActiveEditorState();
  if (!editorState) {
    return;
  }
  const existingNode = editorState._nodeMap.get(existingKey);
  if (existingNode && existingNode.constructor !== node2.constructor) {
    if (node2.constructor.name !== existingNode.constructor.name) {
      {
        throw Error(`Lexical node with constructor ${node2.constructor.name} attempted to re-use key from node in active editor state with constructor ${existingNode.constructor.name}. Keys must not be re-used when the type is changed.`);
      }
    } else {
      {
        throw Error(`Lexical node with constructor ${node2.constructor.name} attempted to re-use key from node in active editor state with different constructor with the same name (possibly due to invalid Hot Module Replacement). Keys must not be re-used when the type is changed.`);
      }
    }
  }
}
function internalMarkParentElementsAsDirty(parentKey, nodeMap, dirtyElements) {
  let nextParentKey = parentKey;
  while (nextParentKey !== null) {
    if (dirtyElements.has(nextParentKey)) {
      return;
    }
    const node2 = nodeMap.get(nextParentKey);
    if (node2 === void 0) {
      break;
    }
    dirtyElements.set(nextParentKey, false);
    nextParentKey = node2.__parent;
  }
}
function removeFromParent(node2) {
  const oldParent = node2.getParent();
  if (oldParent !== null) {
    const writableNode = node2.getWritable();
    const writableParent = oldParent.getWritable();
    const prevSibling = node2.getPreviousSibling();
    const nextSibling = node2.getNextSibling();
    if (prevSibling === null) {
      if (nextSibling !== null) {
        const writableNextSibling = nextSibling.getWritable();
        writableParent.__first = nextSibling.__key;
        writableNextSibling.__prev = null;
      } else {
        writableParent.__first = null;
      }
    } else {
      const writablePrevSibling = prevSibling.getWritable();
      if (nextSibling !== null) {
        const writableNextSibling = nextSibling.getWritable();
        writableNextSibling.__prev = writablePrevSibling.__key;
        writablePrevSibling.__next = writableNextSibling.__key;
      } else {
        writablePrevSibling.__next = null;
      }
      writableNode.__prev = null;
    }
    if (nextSibling === null) {
      if (prevSibling !== null) {
        const writablePrevSibling = prevSibling.getWritable();
        writableParent.__last = prevSibling.__key;
        writablePrevSibling.__next = null;
      } else {
        writableParent.__last = null;
      }
    } else {
      const writableNextSibling = nextSibling.getWritable();
      if (prevSibling !== null) {
        const writablePrevSibling = prevSibling.getWritable();
        writablePrevSibling.__next = writableNextSibling.__key;
        writableNextSibling.__prev = writablePrevSibling.__key;
      } else {
        writableNextSibling.__prev = null;
      }
      writableNode.__next = null;
    }
    writableParent.__size--;
    writableNode.__parent = null;
  }
}
function internalMarkNodeAsDirty(node2) {
  errorOnInfiniteTransforms();
  const latest = node2.getLatest();
  const parent = latest.__parent;
  const editorState = getActiveEditorState();
  const editor = getActiveEditor();
  const nodeMap = editorState._nodeMap;
  const dirtyElements = editor._dirtyElements;
  if (parent !== null) {
    internalMarkParentElementsAsDirty(parent, nodeMap, dirtyElements);
  }
  const key2 = latest.__key;
  editor._dirtyType = HAS_DIRTY_NODES;
  if ($isElementNode(node2)) {
    dirtyElements.set(key2, true);
  } else {
    editor._dirtyLeaves.add(key2);
  }
}
function internalMarkSiblingsAsDirty(node2) {
  const previousNode = node2.getPreviousSibling();
  const nextNode = node2.getNextSibling();
  if (previousNode !== null) {
    internalMarkNodeAsDirty(previousNode);
  }
  if (nextNode !== null) {
    internalMarkNodeAsDirty(nextNode);
  }
}
function $setCompositionKey(compositionKey) {
  errorOnReadOnly();
  const editor = getActiveEditor();
  const previousCompositionKey = editor._compositionKey;
  if (compositionKey !== previousCompositionKey) {
    editor._compositionKey = compositionKey;
    if (previousCompositionKey !== null) {
      const node2 = $getNodeByKey(previousCompositionKey);
      if (node2 !== null) {
        node2.getWritable();
      }
    }
    if (compositionKey !== null) {
      const node2 = $getNodeByKey(compositionKey);
      if (node2 !== null) {
        node2.getWritable();
      }
    }
  }
}
function $getCompositionKey() {
  if (isCurrentlyReadOnlyMode()) {
    return null;
  }
  const editor = getActiveEditor();
  return editor._compositionKey;
}
function $getNodeByKey(key2, _editorState) {
  const editorState = _editorState || getActiveEditorState();
  const node2 = editorState._nodeMap.get(key2);
  if (node2 === void 0) {
    return null;
  }
  return node2;
}
function $getNodeFromDOMNode(dom, editorState) {
  const editor = getActiveEditor();
  const key2 = getNodeKeyFromDOMNode(dom, editor);
  if (key2 !== void 0) {
    return $getNodeByKey(key2, editorState);
  }
  return null;
}
function setNodeKeyOnDOMNode(dom, editor, key2) {
  const prop2 = `__lexicalKey_${editor._key}`;
  dom[prop2] = key2;
}
function getNodeKeyFromDOMNode(dom, editor) {
  const prop2 = `__lexicalKey_${editor._key}`;
  return dom[prop2];
}
function $getNearestNodeFromDOMNode(startingDOM, editorState) {
  let dom = startingDOM;
  while (dom != null) {
    const node2 = $getNodeFromDOMNode(dom, editorState);
    if (node2 !== null) {
      return node2;
    }
    dom = getParentElement(dom);
  }
  return null;
}
function cloneDecorators(editor) {
  const currentDecorators = editor._decorators;
  const pendingDecorators = Object.assign({}, currentDecorators);
  editor._pendingDecorators = pendingDecorators;
  return pendingDecorators;
}
function getEditorStateTextContent(editorState) {
  return editorState.read(() => $getRoot().getTextContent());
}
function markNodesWithTypesAsDirty(editor, types4) {
  const cachedMap = getCachedTypeToNodeMap(editor.getEditorState());
  const dirtyNodeMaps = [];
  for (const type2 of types4) {
    const nodeMap = cachedMap.get(type2);
    if (nodeMap) {
      dirtyNodeMaps.push(nodeMap);
    }
  }
  if (dirtyNodeMaps.length === 0) {
    return;
  }
  editor.update(() => {
    for (const nodeMap of dirtyNodeMaps) {
      for (const nodeKey of nodeMap.keys()) {
        const latest = $getNodeByKey(nodeKey);
        if (latest) {
          latest.markDirty();
        }
      }
    }
  }, editor._pendingEditorState === null ? {
    tag: "history-merge"
  } : void 0);
}
function $getRoot() {
  return internalGetRoot(getActiveEditorState());
}
function internalGetRoot(editorState) {
  return editorState._nodeMap.get("root");
}
function $setSelection(selection2) {
  errorOnReadOnly();
  const editorState = getActiveEditorState();
  if (selection2 !== null) {
    {
      if (Object.isFrozen(selection2)) {
        {
          throw Error(`$setSelection called on frozen selection object. Ensure selection is cloned before passing in.`);
        }
      }
    }
    selection2.dirty = true;
    selection2.setCachedNodes(null);
  }
  editorState._selection = selection2;
}
function $flushMutations() {
  errorOnReadOnly();
  const editor = getActiveEditor();
  $flushRootMutations(editor);
}
function $getNodeFromDOM(dom) {
  const editor = getActiveEditor();
  const nodeKey = getNodeKeyFromDOMTree(dom, editor);
  if (nodeKey === null) {
    const rootElement = editor.getRootElement();
    if (dom === rootElement) {
      return $getNodeByKey("root");
    }
    return null;
  }
  return $getNodeByKey(nodeKey);
}
function getTextNodeOffset(node2, moveSelectionToEnd) {
  return moveSelectionToEnd ? node2.getTextContentSize() : 0;
}
function getNodeKeyFromDOMTree(dom, editor) {
  let node2 = dom;
  while (node2 != null) {
    const key2 = getNodeKeyFromDOMNode(node2, editor);
    if (key2 !== void 0) {
      return key2;
    }
    node2 = getParentElement(node2);
  }
  return null;
}
function doesContainGrapheme(str2) {
  return /[\uD800-\uDBFF][\uDC00-\uDFFF]/g.test(str2);
}
function getEditorsToPropagate(editor) {
  const editorsToPropagate = [];
  let currentEditor = editor;
  while (currentEditor !== null) {
    editorsToPropagate.push(currentEditor);
    currentEditor = currentEditor._parentEditor;
  }
  return editorsToPropagate;
}
function createUID() {
  return Math.random().toString(36).replace(/[^a-z]+/g, "").substr(0, 5);
}
function getAnchorTextFromDOM(anchorNode) {
  return isDOMTextNode(anchorNode) ? anchorNode.nodeValue : null;
}
function $updateSelectedTextFromDOM(isCompositionEnd, editor, data2) {
  const domSelection = getDOMSelection(editor._window);
  if (domSelection === null) {
    return;
  }
  const anchorNode = domSelection.anchorNode;
  let {
    anchorOffset,
    focusOffset
  } = domSelection;
  if (anchorNode !== null) {
    let textContent = getAnchorTextFromDOM(anchorNode);
    const node2 = $getNearestNodeFromDOMNode(anchorNode);
    if (textContent !== null && $isTextNode(node2)) {
      if (textContent === COMPOSITION_SUFFIX && data2) {
        const offset5 = data2.length;
        textContent = data2;
        anchorOffset = offset5;
        focusOffset = offset5;
      }
      if (textContent !== null) {
        $updateTextNodeFromDOMContent(node2, textContent, anchorOffset, focusOffset, isCompositionEnd);
      }
    }
  }
}
function $updateTextNodeFromDOMContent(textNode, textContent, anchorOffset, focusOffset, compositionEnd) {
  let node2 = textNode;
  if (node2.isAttached() && (compositionEnd || !node2.isDirty())) {
    const isComposing = node2.isComposing();
    let normalizedTextContent = textContent;
    if ((isComposing || compositionEnd) && textContent[textContent.length - 1] === COMPOSITION_SUFFIX) {
      normalizedTextContent = textContent.slice(0, -1);
    }
    const prevTextContent = node2.getTextContent();
    if (compositionEnd || normalizedTextContent !== prevTextContent) {
      if (normalizedTextContent === "") {
        $setCompositionKey(null);
        if (!IS_SAFARI && !IS_IOS && !IS_APPLE_WEBKIT) {
          const editor = getActiveEditor();
          setTimeout(() => {
            editor.update(() => {
              if (node2.isAttached()) {
                node2.remove();
              }
            });
          }, 20);
        } else {
          node2.remove();
        }
        return;
      }
      const parent = node2.getParent();
      const prevSelection = $getPreviousSelection();
      const prevTextContentSize = node2.getTextContentSize();
      const compositionKey = $getCompositionKey();
      const nodeKey = node2.getKey();
      if (node2.isToken() || compositionKey !== null && nodeKey === compositionKey && !isComposing || // Check if character was added at the start or boundaries when not insertable, and we need
      // to clear this input from occurring as that action wasn't permitted.
      $isRangeSelection(prevSelection) && (parent !== null && !parent.canInsertTextBefore() && prevSelection.anchor.offset === 0 || prevSelection.anchor.key === textNode.__key && prevSelection.anchor.offset === 0 && !node2.canInsertTextBefore() && !isComposing || prevSelection.focus.key === textNode.__key && prevSelection.focus.offset === prevTextContentSize && !node2.canInsertTextAfter() && !isComposing)) {
        node2.markDirty();
        return;
      }
      const selection2 = $getSelection();
      if (!$isRangeSelection(selection2) || anchorOffset === null || focusOffset === null) {
        node2.setTextContent(normalizedTextContent);
        return;
      }
      selection2.setTextNodeRange(node2, anchorOffset, node2, focusOffset);
      if (node2.isSegmented()) {
        const originalTextContent = node2.getTextContent();
        const replacement = $createTextNode(originalTextContent);
        node2.replace(replacement);
        node2 = replacement;
      }
      node2.setTextContent(normalizedTextContent);
    }
  }
}
function $previousSiblingDoesNotAcceptText(node2) {
  const previousSibling = node2.getPreviousSibling();
  return ($isTextNode(previousSibling) || $isElementNode(previousSibling) && previousSibling.isInline()) && !previousSibling.canInsertTextAfter();
}
function $shouldInsertTextAfterOrBeforeTextNode(selection2, node2) {
  if (node2.isSegmented()) {
    return true;
  }
  if (!selection2.isCollapsed()) {
    return false;
  }
  const offset5 = selection2.anchor.offset;
  const parent = node2.getParentOrThrow();
  const isToken = node2.isToken();
  if (offset5 === 0) {
    return !node2.canInsertTextBefore() || !parent.canInsertTextBefore() && !node2.isComposing() || isToken || $previousSiblingDoesNotAcceptText(node2);
  } else if (offset5 === node2.getTextContentSize()) {
    return !node2.canInsertTextAfter() || !parent.canInsertTextAfter() && !node2.isComposing() || isToken;
  } else {
    return false;
  }
}
function isTab(key2, altKey, ctrlKey, metaKey) {
  return key2 === "Tab" && !altKey && !ctrlKey && !metaKey;
}
function isBold(key2, altKey, metaKey, ctrlKey) {
  return key2.toLowerCase() === "b" && !altKey && controlOrMeta(metaKey, ctrlKey);
}
function isItalic(key2, altKey, metaKey, ctrlKey) {
  return key2.toLowerCase() === "i" && !altKey && controlOrMeta(metaKey, ctrlKey);
}
function isUnderline(key2, altKey, metaKey, ctrlKey) {
  return key2.toLowerCase() === "u" && !altKey && controlOrMeta(metaKey, ctrlKey);
}
function isParagraph(key2, shiftKey) {
  return isReturn(key2) && !shiftKey;
}
function isLineBreak(key2, shiftKey) {
  return isReturn(key2) && shiftKey;
}
function isOpenLineBreak(key2, ctrlKey) {
  return IS_APPLE && ctrlKey && key2.toLowerCase() === "o";
}
function isDeleteWordBackward(key2, altKey, ctrlKey) {
  return isBackspace(key2) && (IS_APPLE ? altKey : ctrlKey);
}
function isDeleteWordForward(key2, altKey, ctrlKey) {
  return isDelete(key2) && (IS_APPLE ? altKey : ctrlKey);
}
function isDeleteLineBackward(key2, metaKey) {
  return IS_APPLE && metaKey && isBackspace(key2);
}
function isDeleteLineForward(key2, metaKey) {
  return IS_APPLE && metaKey && isDelete(key2);
}
function isDeleteBackward(key2, altKey, metaKey, ctrlKey) {
  if (IS_APPLE) {
    if (altKey || metaKey) {
      return false;
    }
    return isBackspace(key2) || key2.toLowerCase() === "h" && ctrlKey;
  }
  if (ctrlKey || altKey || metaKey) {
    return false;
  }
  return isBackspace(key2);
}
function isDeleteForward(key2, ctrlKey, shiftKey, altKey, metaKey) {
  if (IS_APPLE) {
    if (shiftKey || altKey || metaKey) {
      return false;
    }
    return isDelete(key2) || key2.toLowerCase() === "d" && ctrlKey;
  }
  if (ctrlKey || altKey || metaKey) {
    return false;
  }
  return isDelete(key2);
}
function isUndo(key2, shiftKey, metaKey, ctrlKey) {
  return key2.toLowerCase() === "z" && !shiftKey && controlOrMeta(metaKey, ctrlKey);
}
function isRedo(key2, shiftKey, metaKey, ctrlKey) {
  if (IS_APPLE) {
    return key2.toLowerCase() === "z" && metaKey && shiftKey;
  }
  return key2.toLowerCase() === "y" && ctrlKey || key2.toLowerCase() === "z" && ctrlKey && shiftKey;
}
function isCopy(key2, shiftKey, metaKey, ctrlKey) {
  if (shiftKey) {
    return false;
  }
  if (key2.toLowerCase() === "c") {
    return IS_APPLE ? metaKey : ctrlKey;
  }
  return false;
}
function isCut(key2, shiftKey, metaKey, ctrlKey) {
  if (shiftKey) {
    return false;
  }
  if (key2.toLowerCase() === "x") {
    return IS_APPLE ? metaKey : ctrlKey;
  }
  return false;
}
function isArrowLeft(key2) {
  return key2 === "ArrowLeft";
}
function isArrowRight(key2) {
  return key2 === "ArrowRight";
}
function isArrowUp(key2) {
  return key2 === "ArrowUp";
}
function isArrowDown(key2) {
  return key2 === "ArrowDown";
}
function isMoveBackward(key2, ctrlKey, altKey, metaKey) {
  return isArrowLeft(key2) && !ctrlKey && !metaKey && !altKey;
}
function isMoveToStart(key2, ctrlKey, shiftKey, altKey, metaKey) {
  return isArrowLeft(key2) && !altKey && !shiftKey && (ctrlKey || metaKey);
}
function isMoveForward(key2, ctrlKey, altKey, metaKey) {
  return isArrowRight(key2) && !ctrlKey && !metaKey && !altKey;
}
function isMoveToEnd(key2, ctrlKey, shiftKey, altKey, metaKey) {
  return isArrowRight(key2) && !altKey && !shiftKey && (ctrlKey || metaKey);
}
function isMoveUp(key2, ctrlKey, metaKey) {
  return isArrowUp(key2) && !ctrlKey && !metaKey;
}
function isMoveDown(key2, ctrlKey, metaKey) {
  return isArrowDown(key2) && !ctrlKey && !metaKey;
}
function isModifier(ctrlKey, shiftKey, altKey, metaKey) {
  return ctrlKey || shiftKey || altKey || metaKey;
}
function isSpace(key2) {
  return key2 === " ";
}
function controlOrMeta(metaKey, ctrlKey) {
  if (IS_APPLE) {
    return metaKey;
  }
  return ctrlKey;
}
function isReturn(key2) {
  return key2 === "Enter";
}
function isBackspace(key2) {
  return key2 === "Backspace";
}
function isEscape(key2) {
  return key2 === "Escape";
}
function isDelete(key2) {
  return key2 === "Delete";
}
function isSelectAll(key2, metaKey, ctrlKey) {
  return key2.toLowerCase() === "a" && controlOrMeta(metaKey, ctrlKey);
}
function $selectAll(selection2) {
  const root2 = $getRoot();
  if ($isRangeSelection(selection2)) {
    const anchor = selection2.anchor;
    const focus2 = selection2.focus;
    const anchorNode = anchor.getNode();
    const topParent = anchorNode.getTopLevelElementOrThrow();
    const rootNode = topParent.getParentOrThrow();
    anchor.set(rootNode.getKey(), 0, "element");
    focus2.set(rootNode.getKey(), rootNode.getChildrenSize(), "element");
    $normalizeSelection(selection2);
    return selection2;
  } else {
    const newSelection = root2.select(0, root2.getChildrenSize());
    $setSelection($normalizeSelection(newSelection));
    return newSelection;
  }
}
function getCachedClassNameArray(classNamesTheme, classNameThemeType) {
  if (classNamesTheme.__lexicalClassNameCache === void 0) {
    classNamesTheme.__lexicalClassNameCache = {};
  }
  const classNamesCache = classNamesTheme.__lexicalClassNameCache;
  const cachedClassNames = classNamesCache[classNameThemeType];
  if (cachedClassNames !== void 0) {
    return cachedClassNames;
  }
  const classNames14 = classNamesTheme[classNameThemeType];
  if (typeof classNames14 === "string") {
    const classNamesArr = normalizeClassNames(classNames14);
    classNamesCache[classNameThemeType] = classNamesArr;
    return classNamesArr;
  }
  return classNames14;
}
function setMutatedNode(mutatedNodes2, registeredNodes, mutationListeners, node2, mutation) {
  if (mutationListeners.size === 0) {
    return;
  }
  const nodeType = node2.__type;
  const nodeKey = node2.__key;
  const registeredNode = registeredNodes.get(nodeType);
  if (registeredNode === void 0) {
    {
      throw Error(`Type ${nodeType} not in registeredNodes`);
    }
  }
  const klass = registeredNode.klass;
  let mutatedNodesByType = mutatedNodes2.get(klass);
  if (mutatedNodesByType === void 0) {
    mutatedNodesByType = /* @__PURE__ */ new Map();
    mutatedNodes2.set(klass, mutatedNodesByType);
  }
  const prevMutation = mutatedNodesByType.get(nodeKey);
  const isMove = prevMutation === "destroyed" && mutation === "created";
  if (prevMutation === void 0 || isMove) {
    mutatedNodesByType.set(nodeKey, isMove ? "updated" : mutation);
  }
}
function resolveElement(element2, isBackward, focusOffset) {
  const parent = element2.getParent();
  let offset5 = focusOffset;
  let block = element2;
  if (parent !== null) {
    if (isBackward && focusOffset === 0) {
      offset5 = block.getIndexWithinParent();
      block = parent;
    } else if (!isBackward && focusOffset === block.getChildrenSize()) {
      offset5 = block.getIndexWithinParent() + 1;
      block = parent;
    }
  }
  return block.getChildAtIndex(isBackward ? offset5 - 1 : offset5);
}
function $getAdjacentNode(focus2, isBackward) {
  const focusOffset = focus2.offset;
  if (focus2.type === "element") {
    const block = focus2.getNode();
    return resolveElement(block, isBackward, focusOffset);
  } else {
    const focusNode = focus2.getNode();
    if (isBackward && focusOffset === 0 || !isBackward && focusOffset === focusNode.getTextContentSize()) {
      const possibleNode = isBackward ? focusNode.getPreviousSibling() : focusNode.getNextSibling();
      if (possibleNode === null) {
        return resolveElement(focusNode.getParentOrThrow(), isBackward, focusNode.getIndexWithinParent() + (isBackward ? 0 : 1));
      }
      return possibleNode;
    }
  }
  return null;
}
function isFirefoxClipboardEvents(editor) {
  const event = getWindow(editor).event;
  const inputType = event && event.inputType;
  return inputType === "insertFromPaste" || inputType === "insertFromPasteAsQuotation";
}
function dispatchCommand(editor, command2, payload) {
  return triggerCommandListeners(editor, command2, payload);
}
function $textContentRequiresDoubleLinebreakAtEnd(node2) {
  return !$isRootNode(node2) && !node2.isLastChild() && !node2.isInline();
}
function getElementByKeyOrThrow(editor, key2) {
  const element2 = editor._keyToDOMMap.get(key2);
  if (element2 === void 0) {
    {
      throw Error(`Reconciliation: could not find DOM element for node key ${key2}`);
    }
  }
  return element2;
}
function getParentElement(node2) {
  const parentElement = node2.assignedSlot || node2.parentElement;
  return isDocumentFragment(parentElement) ? parentElement.host : parentElement;
}
function getDOMOwnerDocument(target) {
  return isDOMDocumentNode(target) ? target : isHTMLElement(target) ? target.ownerDocument : null;
}
function scrollIntoViewIfNeeded(editor, selectionRect, rootElement) {
  const doc = getDOMOwnerDocument(rootElement);
  const defaultView = getDefaultView(doc);
  if (doc === null || defaultView === null) {
    return;
  }
  let {
    top: currentTop,
    bottom: currentBottom
  } = selectionRect;
  let targetTop = 0;
  let targetBottom = 0;
  let element2 = rootElement;
  while (element2 !== null) {
    const isBodyElement = element2 === doc.body;
    if (isBodyElement) {
      targetTop = 0;
      targetBottom = getWindow(editor).innerHeight;
    } else {
      const targetRect = element2.getBoundingClientRect();
      targetTop = targetRect.top;
      targetBottom = targetRect.bottom;
    }
    let diff2 = 0;
    if (currentTop < targetTop) {
      diff2 = -(targetTop - currentTop);
    } else if (currentBottom > targetBottom) {
      diff2 = currentBottom - targetBottom;
    }
    if (diff2 !== 0) {
      if (isBodyElement) {
        defaultView.scrollBy(0, diff2);
      } else {
        const scrollTop = element2.scrollTop;
        element2.scrollTop += diff2;
        const yOffset = element2.scrollTop - scrollTop;
        currentTop -= yOffset;
        currentBottom -= yOffset;
      }
    }
    if (isBodyElement) {
      break;
    }
    element2 = getParentElement(element2);
  }
}
function $addUpdateTag(tag) {
  errorOnReadOnly();
  const editor = getActiveEditor();
  editor._updateTags.add(tag);
}
function $maybeMoveChildrenSelectionToParent(parentNode) {
  const selection2 = $getSelection();
  if (!$isRangeSelection(selection2) || !$isElementNode(parentNode)) {
    return selection2;
  }
  const {
    anchor,
    focus: focus2
  } = selection2;
  const anchorNode = anchor.getNode();
  const focusNode = focus2.getNode();
  if ($hasAncestor(anchorNode, parentNode)) {
    anchor.set(parentNode.__key, 0, "element");
  }
  if ($hasAncestor(focusNode, parentNode)) {
    focus2.set(parentNode.__key, 0, "element");
  }
  return selection2;
}
function $hasAncestor(child, targetNode) {
  let parent = child.getParent();
  while (parent !== null) {
    if (parent.is(targetNode)) {
      return true;
    }
    parent = parent.getParent();
  }
  return false;
}
function getDefaultView(domElem) {
  const ownerDoc = getDOMOwnerDocument(domElem);
  return ownerDoc ? ownerDoc.defaultView : null;
}
function getWindow(editor) {
  const windowObj = editor._window;
  if (windowObj === null) {
    {
      throw Error(`window object not found`);
    }
  }
  return windowObj;
}
function $getNearestRootOrShadowRoot(node2) {
  let parent = node2.getParentOrThrow();
  while (parent !== null) {
    if ($isRootOrShadowRoot(parent)) {
      return parent;
    }
    parent = parent.getParentOrThrow();
  }
  return parent;
}
function $isRootOrShadowRoot(node2) {
  return $isRootNode(node2) || $isElementNode(node2) && node2.isShadowRoot();
}
function $copyNode(node2) {
  const copy = node2.constructor.clone(node2);
  $setNodeKey(copy, null);
  return copy;
}
function $applyNodeReplacement(node2) {
  const editor = getActiveEditor();
  const nodeType = node2.constructor.getType();
  const registeredNode = editor._nodes.get(nodeType);
  if (!(registeredNode !== void 0)) {
    throw Error(`$applyNodeReplacement node ${node2.constructor.name} with type ${nodeType} must be registered to the editor. You can do this by passing the node class via the "nodes" array in the editor config.`);
  }
  const {
    replace: replace2,
    replaceWithKlass
  } = registeredNode;
  if (replace2 !== null) {
    const replacementNode = replace2(node2);
    const replacementNodeKlass = replacementNode.constructor;
    if (replaceWithKlass !== null) {
      if (!(replacementNode instanceof replaceWithKlass)) {
        throw Error(`$applyNodeReplacement failed. Expected replacement node to be an instance of ${replaceWithKlass.name} with type ${replaceWithKlass.getType()} but returned ${replacementNodeKlass.name} with type ${replacementNodeKlass.getType()} from original node ${node2.constructor.name} with type ${nodeType}`);
      }
    } else {
      if (!(replacementNode instanceof node2.constructor && replacementNodeKlass !== node2.constructor)) {
        throw Error(`$applyNodeReplacement failed. Ensure replacement node ${replacementNodeKlass.name} with type ${replacementNodeKlass.getType()} is a subclass of the original node ${node2.constructor.name} with type ${nodeType}.`);
      }
    }
    if (!(replacementNode.__key !== node2.__key)) {
      throw Error(`$applyNodeReplacement failed. Ensure that the key argument is *not* used in your replace function (from node ${node2.constructor.name} with type ${nodeType} to node ${replacementNodeKlass.name} with type ${replacementNodeKlass.getType()}), Node keys must never be re-used except by the static clone method.`);
    }
    return replacementNode;
  }
  return node2;
}
function errorOnInsertTextNodeOnRoot(node2, insertNode) {
  const parentNode = node2.getParent();
  if ($isRootNode(parentNode) && !$isElementNode(insertNode) && !$isDecoratorNode(insertNode)) {
    {
      throw Error(`Only element or decorator nodes can be inserted in to the root node`);
    }
  }
}
function createBlockCursorElement(editorConfig) {
  const theme = editorConfig.theme;
  const element2 = document.createElement("div");
  element2.contentEditable = "false";
  element2.setAttribute("data-lexical-cursor", "true");
  let blockCursorTheme = theme.blockCursor;
  if (blockCursorTheme !== void 0) {
    if (typeof blockCursorTheme === "string") {
      const classNamesArr = normalizeClassNames(blockCursorTheme);
      blockCursorTheme = theme.blockCursor = classNamesArr;
    }
    if (blockCursorTheme !== void 0) {
      element2.classList.add(...blockCursorTheme);
    }
  }
  return element2;
}
function needsBlockCursor(node2) {
  return ($isDecoratorNode(node2) || $isElementNode(node2) && !node2.canBeEmpty()) && !node2.isInline();
}
function removeDOMBlockCursorElement(blockCursorElement, editor, rootElement) {
  rootElement.style.removeProperty("caret-color");
  editor._blockCursorElement = null;
  const parentElement = blockCursorElement.parentElement;
  if (parentElement !== null) {
    parentElement.removeChild(blockCursorElement);
  }
}
function updateDOMBlockCursorElement(editor, rootElement, nextSelection) {
  let blockCursorElement = editor._blockCursorElement;
  if ($isRangeSelection(nextSelection) && nextSelection.isCollapsed() && nextSelection.anchor.type === "element" && rootElement.contains(document.activeElement)) {
    const anchor = nextSelection.anchor;
    const elementNode = anchor.getNode();
    const offset5 = anchor.offset;
    const elementNodeSize = elementNode.getChildrenSize();
    let isBlockCursor = false;
    let insertBeforeElement = null;
    if (offset5 === elementNodeSize) {
      const child = elementNode.getChildAtIndex(offset5 - 1);
      if (needsBlockCursor(child)) {
        isBlockCursor = true;
      }
    } else {
      const child = elementNode.getChildAtIndex(offset5);
      if (child !== null && needsBlockCursor(child)) {
        const sibling2 = child.getPreviousSibling();
        if (sibling2 === null || needsBlockCursor(sibling2)) {
          isBlockCursor = true;
          insertBeforeElement = editor.getElementByKey(child.__key);
        }
      }
    }
    if (isBlockCursor) {
      const elementDOM = editor.getElementByKey(elementNode.__key);
      if (blockCursorElement === null) {
        editor._blockCursorElement = blockCursorElement = createBlockCursorElement(editor._config);
      }
      rootElement.style.caretColor = "transparent";
      if (insertBeforeElement === null) {
        elementDOM.appendChild(blockCursorElement);
      } else {
        elementDOM.insertBefore(blockCursorElement, insertBeforeElement);
      }
      return;
    }
  }
  if (blockCursorElement !== null) {
    removeDOMBlockCursorElement(blockCursorElement, editor, rootElement);
  }
}
function getDOMSelection(targetWindow) {
  return !CAN_USE_DOM ? null : (targetWindow || window).getSelection();
}
function getDOMSelectionFromTarget(eventTarget) {
  const defaultView = getDefaultView(eventTarget);
  return defaultView ? defaultView.getSelection() : null;
}
function $splitNode(node2, offset5) {
  let startNode = node2.getChildAtIndex(offset5);
  if (startNode == null) {
    startNode = node2;
  }
  if (!!$isRootOrShadowRoot(node2)) {
    throw Error(`Can not call $splitNode() on root element`);
  }
  const recurse = (currentNode) => {
    const parent = currentNode.getParentOrThrow();
    const isParentRoot = $isRootOrShadowRoot(parent);
    const nodeToMove = currentNode === startNode && !isParentRoot ? currentNode : $copyNode(currentNode);
    if (isParentRoot) {
      if (!($isElementNode(currentNode) && $isElementNode(nodeToMove))) {
        throw Error(`Children of a root must be ElementNode`);
      }
      currentNode.insertAfter(nodeToMove);
      return [currentNode, nodeToMove, nodeToMove];
    } else {
      const [leftTree2, rightTree2, newParent] = recurse(parent);
      const nextSiblings = currentNode.getNextSiblings();
      newParent.append(nodeToMove, ...nextSiblings);
      return [leftTree2, rightTree2, nodeToMove];
    }
  };
  const [leftTree, rightTree] = recurse(startNode);
  return [leftTree, rightTree];
}
function isHTMLAnchorElement(x3) {
  return isHTMLElement(x3) && x3.tagName === "A";
}
function isHTMLElement(x3) {
  return isDOMNode(x3) && x3.nodeType === DOM_ELEMENT_TYPE;
}
function isDOMNode(x3) {
  return typeof x3 === "object" && x3 !== null && "nodeType" in x3 && typeof x3.nodeType === "number";
}
function isDocumentFragment(x3) {
  return isDOMNode(x3) && x3.nodeType === DOM_DOCUMENT_FRAGMENT_TYPE;
}
function isInlineDomNode(node2) {
  const inlineNodes = new RegExp(/^(a|abbr|acronym|b|cite|code|del|em|i|ins|kbd|label|output|q|ruby|s|samp|span|strong|sub|sup|time|u|tt|var|#text)$/, "i");
  return node2.nodeName.match(inlineNodes) !== null;
}
function isBlockDomNode(node2) {
  const blockNodes = new RegExp(/^(address|article|aside|blockquote|canvas|dd|div|dl|dt|fieldset|figcaption|figure|footer|form|h1|h2|h3|h4|h5|h6|header|hr|li|main|nav|noscript|ol|p|pre|section|table|td|tfoot|ul|video)$/, "i");
  return node2.nodeName.match(blockNodes) !== null;
}
function INTERNAL_$isBlock(node2) {
  if ($isDecoratorNode(node2) && !node2.isInline()) {
    return true;
  }
  if (!$isElementNode(node2) || $isRootOrShadowRoot(node2)) {
    return false;
  }
  const firstChild = node2.getFirstChild();
  const isLeafElement = firstChild === null || $isLineBreakNode(firstChild) || $isTextNode(firstChild) || firstChild.isInline();
  return !node2.isInline() && node2.canBeEmpty() !== false && isLeafElement;
}
function $getAncestor(node2, predicate) {
  let parent = node2;
  while (parent !== null && parent.getParent() !== null && !predicate(parent)) {
    parent = parent.getParentOrThrow();
  }
  return predicate(parent) ? parent : null;
}
function $getEditor() {
  return getActiveEditor();
}
var cachedNodeMaps = /* @__PURE__ */ new WeakMap();
var EMPTY_TYPE_TO_NODE_MAP = /* @__PURE__ */ new Map();
function getCachedTypeToNodeMap(editorState) {
  if (!editorState._readOnly && editorState.isEmpty()) {
    return EMPTY_TYPE_TO_NODE_MAP;
  }
  if (!editorState._readOnly) {
    throw Error(`getCachedTypeToNodeMap called with a writable EditorState`);
  }
  let typeToNodeMap = cachedNodeMaps.get(editorState);
  if (!typeToNodeMap) {
    typeToNodeMap = computeTypeToNodeMap(editorState);
    cachedNodeMaps.set(editorState, typeToNodeMap);
  }
  return typeToNodeMap;
}
function computeTypeToNodeMap(editorState) {
  const typeToNodeMap = /* @__PURE__ */ new Map();
  for (const [nodeKey, node2] of editorState._nodeMap) {
    const nodeType = node2.__type;
    let nodeMap = typeToNodeMap.get(nodeType);
    if (!nodeMap) {
      nodeMap = /* @__PURE__ */ new Map();
      typeToNodeMap.set(nodeType, nodeMap);
    }
    nodeMap.set(nodeKey, node2);
  }
  return typeToNodeMap;
}
function $cloneWithProperties(latestNode) {
  const constructor = latestNode.constructor;
  const mutableNode = constructor.clone(latestNode);
  mutableNode.afterCloneFrom(latestNode);
  {
    if (!(mutableNode.__key === latestNode.__key)) {
      throw Error(`$cloneWithProperties: ${constructor.name}.clone(node) (with type '${constructor.getType()}') did not return a node with the same key, make sure to specify node.__key as the last argument to the constructor`);
    }
    if (!(mutableNode.__parent === latestNode.__parent && mutableNode.__next === latestNode.__next && mutableNode.__prev === latestNode.__prev)) {
      throw Error(`$cloneWithProperties: ${constructor.name}.clone(node) (with type '${constructor.getType()}') overrided afterCloneFrom but did not call super.afterCloneFrom(prevNode)`);
    }
  }
  return mutableNode;
}
function setNodeIndentFromDOM(elementDom, elementNode) {
  const indentSize2 = parseInt(elementDom.style.paddingInlineStart, 10) || 0;
  const indent2 = indentSize2 / 40;
  elementNode.setIndent(indent2);
}
function isDOMUnmanaged(elementDom) {
  const el = elementDom;
  return el.__lexicalUnmanaged === true;
}
function $garbageCollectDetachedDecorators(editor, pendingEditorState) {
  const currentDecorators = editor._decorators;
  const pendingDecorators = editor._pendingDecorators;
  let decorators = pendingDecorators || currentDecorators;
  const nodeMap = pendingEditorState._nodeMap;
  let key2;
  for (key2 in decorators) {
    if (!nodeMap.has(key2)) {
      if (decorators === currentDecorators) {
        decorators = cloneDecorators(editor);
      }
      delete decorators[key2];
    }
  }
}
function $garbageCollectDetachedDeepChildNodes(node2, parentKey, prevNodeMap, nodeMap, nodeMapDelete, dirtyNodes) {
  let child = node2.getFirstChild();
  while (child !== null) {
    const childKey = child.__key;
    if (child.__parent === parentKey) {
      if ($isElementNode(child)) {
        $garbageCollectDetachedDeepChildNodes(child, childKey, prevNodeMap, nodeMap, nodeMapDelete, dirtyNodes);
      }
      if (!prevNodeMap.has(childKey)) {
        dirtyNodes.delete(childKey);
      }
      nodeMapDelete.push(childKey);
    }
    child = child.getNextSibling();
  }
}
function $garbageCollectDetachedNodes(prevEditorState, editorState, dirtyLeaves, dirtyElements) {
  const prevNodeMap = prevEditorState._nodeMap;
  const nodeMap = editorState._nodeMap;
  const nodeMapDelete = [];
  for (const [nodeKey] of dirtyElements) {
    const node2 = nodeMap.get(nodeKey);
    if (node2 !== void 0) {
      if (!node2.isAttached()) {
        if ($isElementNode(node2)) {
          $garbageCollectDetachedDeepChildNodes(node2, nodeKey, prevNodeMap, nodeMap, nodeMapDelete, dirtyElements);
        }
        if (!prevNodeMap.has(nodeKey)) {
          dirtyElements.delete(nodeKey);
        }
        nodeMapDelete.push(nodeKey);
      }
    }
  }
  for (const nodeKey of nodeMapDelete) {
    nodeMap.delete(nodeKey);
  }
  for (const nodeKey of dirtyLeaves) {
    const node2 = nodeMap.get(nodeKey);
    if (node2 !== void 0 && !node2.isAttached()) {
      if (!prevNodeMap.has(nodeKey)) {
        dirtyLeaves.delete(nodeKey);
      }
      nodeMap.delete(nodeKey);
    }
  }
}
var subTreeTextContent = "";
var subTreeDirectionedTextContent = "";
var subTreeTextFormat = null;
var subTreeTextStyle = "";
var editorTextContent = "";
var activeEditorConfig;
var activeEditor$1;
var activeEditorNodes;
var treatAllNodesAsDirty = false;
var activeEditorStateReadOnly = false;
var activeMutationListeners;
var activeTextDirection = null;
var activeDirtyElements;
var activeDirtyLeaves;
var activePrevNodeMap;
var activeNextNodeMap;
var activePrevKeyToDOMMap;
var mutatedNodes;
function destroyNode(key2, parentDOM) {
  const node2 = activePrevNodeMap.get(key2);
  if (parentDOM !== null) {
    const dom = getPrevElementByKeyOrThrow(key2);
    if (dom.parentNode === parentDOM) {
      parentDOM.removeChild(dom);
    }
  }
  if (!activeNextNodeMap.has(key2)) {
    activeEditor$1._keyToDOMMap.delete(key2);
  }
  if ($isElementNode(node2)) {
    const children = createChildrenArray(node2, activePrevNodeMap);
    destroyChildren(children, 0, children.length - 1, null);
  }
  if (node2 !== void 0) {
    setMutatedNode(mutatedNodes, activeEditorNodes, activeMutationListeners, node2, "destroyed");
  }
}
function destroyChildren(children, _startIndex, endIndex, dom) {
  let startIndex = _startIndex;
  for (; startIndex <= endIndex; ++startIndex) {
    const child = children[startIndex];
    if (child !== void 0) {
      destroyNode(child, dom);
    }
  }
}
function setTextAlign(domStyle, value2) {
  domStyle.setProperty("text-align", value2);
}
var DEFAULT_INDENT_VALUE = "40px";
function setElementIndent(dom, indent2) {
  const indentClassName = activeEditorConfig.theme.indent;
  if (typeof indentClassName === "string") {
    const elementHasClassName = dom.classList.contains(indentClassName);
    if (indent2 > 0 && !elementHasClassName) {
      dom.classList.add(indentClassName);
    } else if (indent2 < 1 && elementHasClassName) {
      dom.classList.remove(indentClassName);
    }
  }
  const indentationBaseValue = getComputedStyle(dom).getPropertyValue("--lexical-indent-base-value") || DEFAULT_INDENT_VALUE;
  dom.style.setProperty("padding-inline-start", indent2 === 0 ? "" : `calc(${indent2} * ${indentationBaseValue})`);
}
function setElementFormat(dom, format) {
  const domStyle = dom.style;
  if (format === 0) {
    setTextAlign(domStyle, "");
  } else if (format === IS_ALIGN_LEFT) {
    setTextAlign(domStyle, "left");
  } else if (format === IS_ALIGN_CENTER) {
    setTextAlign(domStyle, "center");
  } else if (format === IS_ALIGN_RIGHT) {
    setTextAlign(domStyle, "right");
  } else if (format === IS_ALIGN_JUSTIFY) {
    setTextAlign(domStyle, "justify");
  } else if (format === IS_ALIGN_START) {
    setTextAlign(domStyle, "start");
  } else if (format === IS_ALIGN_END) {
    setTextAlign(domStyle, "end");
  }
}
function $createNode(key2, slot) {
  const node2 = activeNextNodeMap.get(key2);
  if (node2 === void 0) {
    {
      throw Error(`createNode: node does not exist in nodeMap`);
    }
  }
  const dom = node2.createDOM(activeEditorConfig, activeEditor$1);
  storeDOMWithKey(key2, dom, activeEditor$1);
  if ($isTextNode(node2)) {
    dom.setAttribute("data-lexical-text", "true");
  } else if ($isDecoratorNode(node2)) {
    dom.setAttribute("data-lexical-decorator", "true");
  }
  if ($isElementNode(node2)) {
    const indent2 = node2.__indent;
    const childrenSize = node2.__size;
    if (indent2 !== 0) {
      setElementIndent(dom, indent2);
    }
    if (childrenSize !== 0) {
      const endIndex = childrenSize - 1;
      const children = createChildrenArray(node2, activeNextNodeMap);
      $createChildrenWithDirection(children, endIndex, node2, dom);
    }
    const format = node2.__format;
    if (format !== 0) {
      setElementFormat(dom, format);
    }
    if (!node2.isInline()) {
      reconcileElementTerminatingLineBreak(null, node2, dom);
    }
    if ($textContentRequiresDoubleLinebreakAtEnd(node2)) {
      subTreeTextContent += DOUBLE_LINE_BREAK;
      editorTextContent += DOUBLE_LINE_BREAK;
    }
  } else {
    const text4 = node2.getTextContent();
    if ($isDecoratorNode(node2)) {
      const decorator = node2.decorate(activeEditor$1, activeEditorConfig);
      if (decorator !== null) {
        reconcileDecorator(key2, decorator);
      }
      dom.contentEditable = "false";
    } else if ($isTextNode(node2)) {
      if (!node2.isDirectionless()) {
        subTreeDirectionedTextContent += text4;
      }
    }
    subTreeTextContent += text4;
    editorTextContent += text4;
  }
  if (slot !== null) {
    slot.insertChild(dom);
  }
  {
    Object.freeze(node2);
  }
  setMutatedNode(mutatedNodes, activeEditorNodes, activeMutationListeners, node2, "created");
  return dom;
}
function $createChildrenWithDirection(children, endIndex, element2, dom) {
  const previousSubTreeDirectionedTextContent = subTreeDirectionedTextContent;
  subTreeDirectionedTextContent = "";
  $createChildren(children, element2, 0, endIndex, element2.getDOMSlot(dom));
  reconcileBlockDirection(element2, dom);
  subTreeDirectionedTextContent = previousSubTreeDirectionedTextContent;
}
function $createChildren(children, element2, _startIndex, endIndex, slot) {
  const previousSubTreeTextContent = subTreeTextContent;
  subTreeTextContent = "";
  let startIndex = _startIndex;
  for (; startIndex <= endIndex; ++startIndex) {
    $createNode(children[startIndex], slot);
    const node2 = activeNextNodeMap.get(children[startIndex]);
    if (node2 !== null && $isTextNode(node2)) {
      if (subTreeTextFormat === null) {
        subTreeTextFormat = node2.getFormat();
      }
      if (subTreeTextStyle === "") {
        subTreeTextStyle = node2.getStyle();
      }
    }
  }
  if ($textContentRequiresDoubleLinebreakAtEnd(element2)) {
    subTreeTextContent += DOUBLE_LINE_BREAK;
  }
  const dom = slot.element;
  dom.__lexicalTextContent = subTreeTextContent;
  subTreeTextContent = previousSubTreeTextContent + subTreeTextContent;
}
function isLastChildLineBreakOrDecorator(element2, nodeMap) {
  if (element2) {
    const lastKey = element2.__last;
    if (lastKey) {
      const node2 = nodeMap.get(lastKey);
      if (node2) {
        return $isLineBreakNode(node2) ? "line-break" : $isDecoratorNode(node2) && node2.isInline() ? "decorator" : null;
      }
    }
    return "empty";
  }
  return null;
}
function reconcileElementTerminatingLineBreak(prevElement, nextElement, dom) {
  const prevLineBreak = isLastChildLineBreakOrDecorator(prevElement, activePrevNodeMap);
  const nextLineBreak2 = isLastChildLineBreakOrDecorator(nextElement, activeNextNodeMap);
  if (prevLineBreak !== nextLineBreak2) {
    nextElement.getDOMSlot(dom).setManagedLineBreak(nextLineBreak2);
  }
}
function reconcileTextFormat(element2) {
  if (subTreeTextFormat != null && subTreeTextFormat !== element2.__textFormat && !activeEditorStateReadOnly) {
    element2.setTextFormat(subTreeTextFormat);
    element2.setTextStyle(subTreeTextStyle);
  }
}
function reconcileTextStyle(element2) {
  if (subTreeTextStyle !== "" && subTreeTextStyle !== element2.__textStyle && !activeEditorStateReadOnly) {
    element2.setTextStyle(subTreeTextStyle);
  }
}
function reconcileBlockDirection(element2, dom) {
  const previousSubTreeDirectionTextContent = dom.__lexicalDirTextContent || "";
  const previousDirection = dom.__lexicalDir || "";
  if (previousSubTreeDirectionTextContent !== subTreeDirectionedTextContent || previousDirection !== activeTextDirection) {
    const hasEmptyDirectionedTextContent = subTreeDirectionedTextContent === "";
    const direction = hasEmptyDirectionedTextContent ? activeTextDirection : getTextDirection(subTreeDirectionedTextContent);
    if (direction !== previousDirection) {
      const classList = dom.classList;
      const theme = activeEditorConfig.theme;
      let previousDirectionTheme = previousDirection !== null ? theme[previousDirection] : void 0;
      let nextDirectionTheme = direction !== null ? theme[direction] : void 0;
      if (previousDirectionTheme !== void 0) {
        if (typeof previousDirectionTheme === "string") {
          const classNamesArr = normalizeClassNames(previousDirectionTheme);
          previousDirectionTheme = theme[previousDirection] = classNamesArr;
        }
        classList.remove(...previousDirectionTheme);
      }
      if (direction === null || hasEmptyDirectionedTextContent && direction === "ltr") {
        dom.removeAttribute("dir");
      } else {
        if (nextDirectionTheme !== void 0) {
          if (typeof nextDirectionTheme === "string") {
            const classNamesArr = normalizeClassNames(nextDirectionTheme);
            nextDirectionTheme = theme[direction] = classNamesArr;
          }
          if (nextDirectionTheme !== void 0) {
            classList.add(...nextDirectionTheme);
          }
        }
        dom.dir = direction;
      }
      if (!activeEditorStateReadOnly) {
        const writableNode = element2.getWritable();
        writableNode.__dir = direction;
      }
    }
    activeTextDirection = direction;
    dom.__lexicalDirTextContent = subTreeDirectionedTextContent;
    dom.__lexicalDir = direction;
  }
}
function $reconcileChildrenWithDirection(prevElement, nextElement, dom) {
  const previousSubTreeDirectionTextContent = subTreeDirectionedTextContent;
  subTreeDirectionedTextContent = "";
  subTreeTextFormat = null;
  subTreeTextStyle = "";
  $reconcileChildren(prevElement, nextElement, nextElement.getDOMSlot(dom));
  reconcileBlockDirection(nextElement, dom);
  reconcileTextFormat(nextElement);
  reconcileTextStyle(nextElement);
  subTreeDirectionedTextContent = previousSubTreeDirectionTextContent;
}
function createChildrenArray(element2, nodeMap) {
  const children = [];
  let nodeKey = element2.__first;
  while (nodeKey !== null) {
    const node2 = nodeMap.get(nodeKey);
    if (node2 === void 0) {
      {
        throw Error(`createChildrenArray: node does not exist in nodeMap`);
      }
    }
    children.push(nodeKey);
    nodeKey = node2.__next;
  }
  return children;
}
function $reconcileChildren(prevElement, nextElement, slot) {
  const previousSubTreeTextContent = subTreeTextContent;
  const prevChildrenSize = prevElement.__size;
  const nextChildrenSize = nextElement.__size;
  subTreeTextContent = "";
  const dom = slot.element;
  if (prevChildrenSize === 1 && nextChildrenSize === 1) {
    const prevFirstChildKey = prevElement.__first;
    const nextFirstChildKey = nextElement.__first;
    if (prevFirstChildKey === nextFirstChildKey) {
      $reconcileNode(prevFirstChildKey, dom);
    } else {
      const lastDOM = getPrevElementByKeyOrThrow(prevFirstChildKey);
      const replacementDOM = $createNode(nextFirstChildKey, null);
      try {
        dom.replaceChild(replacementDOM, lastDOM);
      } catch (error) {
        if (typeof error === "object" && error != null) {
          const msg = `${error.toString()} Parent: ${dom.tagName}, new child: {tag: ${replacementDOM.tagName} key: ${nextFirstChildKey}}, old child: {tag: ${lastDOM.tagName}, key: ${prevFirstChildKey}}.`;
          throw new Error(msg);
        } else {
          throw error;
        }
      }
      destroyNode(prevFirstChildKey, null);
    }
    const nextChildNode = activeNextNodeMap.get(nextFirstChildKey);
    if ($isTextNode(nextChildNode)) {
      if (subTreeTextFormat === null) {
        subTreeTextFormat = nextChildNode.getFormat();
      }
      if (subTreeTextStyle === "") {
        subTreeTextStyle = nextChildNode.getStyle();
      }
    }
  } else {
    const prevChildren = createChildrenArray(prevElement, activePrevNodeMap);
    const nextChildren = createChildrenArray(nextElement, activeNextNodeMap);
    if (!(prevChildren.length === prevChildrenSize)) {
      throw Error(`$reconcileChildren: prevChildren.length !== prevChildrenSize`);
    }
    if (!(nextChildren.length === nextChildrenSize)) {
      throw Error(`$reconcileChildren: nextChildren.length !== nextChildrenSize`);
    }
    if (prevChildrenSize === 0) {
      if (nextChildrenSize !== 0) {
        $createChildren(nextChildren, nextElement, 0, nextChildrenSize - 1, slot);
      }
    } else if (nextChildrenSize === 0) {
      if (prevChildrenSize !== 0) {
        const canUseFastPath = slot.after == null && slot.before == null && slot.element.__lexicalLineBreak == null;
        destroyChildren(prevChildren, 0, prevChildrenSize - 1, canUseFastPath ? null : dom);
        if (canUseFastPath) {
          dom.textContent = "";
        }
      }
    } else {
      $reconcileNodeChildren(nextElement, prevChildren, nextChildren, prevChildrenSize, nextChildrenSize, slot);
    }
  }
  if ($textContentRequiresDoubleLinebreakAtEnd(nextElement)) {
    subTreeTextContent += DOUBLE_LINE_BREAK;
  }
  dom.__lexicalTextContent = subTreeTextContent;
  subTreeTextContent = previousSubTreeTextContent + subTreeTextContent;
}
function $reconcileNode(key2, parentDOM) {
  const prevNode = activePrevNodeMap.get(key2);
  let nextNode = activeNextNodeMap.get(key2);
  if (prevNode === void 0 || nextNode === void 0) {
    {
      throw Error(`reconcileNode: prevNode or nextNode does not exist in nodeMap`);
    }
  }
  const isDirty = treatAllNodesAsDirty || activeDirtyLeaves.has(key2) || activeDirtyElements.has(key2);
  const dom = getElementByKeyOrThrow(activeEditor$1, key2);
  if (prevNode === nextNode && !isDirty) {
    if ($isElementNode(prevNode)) {
      const previousSubTreeTextContent = dom.__lexicalTextContent;
      if (previousSubTreeTextContent !== void 0) {
        subTreeTextContent += previousSubTreeTextContent;
        editorTextContent += previousSubTreeTextContent;
      }
      const previousSubTreeDirectionTextContent = dom.__lexicalDirTextContent;
      if (previousSubTreeDirectionTextContent !== void 0) {
        subTreeDirectionedTextContent += previousSubTreeDirectionTextContent;
      }
    } else {
      const text4 = prevNode.getTextContent();
      if ($isTextNode(prevNode) && !prevNode.isDirectionless()) {
        subTreeDirectionedTextContent += text4;
      }
      editorTextContent += text4;
      subTreeTextContent += text4;
    }
    return dom;
  }
  if (prevNode !== nextNode && isDirty) {
    setMutatedNode(mutatedNodes, activeEditorNodes, activeMutationListeners, nextNode, "updated");
  }
  if (nextNode.updateDOM(prevNode, dom, activeEditorConfig)) {
    const replacementDOM = $createNode(key2, null);
    if (parentDOM === null) {
      {
        throw Error(`reconcileNode: parentDOM is null`);
      }
    }
    parentDOM.replaceChild(replacementDOM, dom);
    destroyNode(key2, null);
    return replacementDOM;
  }
  if ($isElementNode(prevNode) && $isElementNode(nextNode)) {
    const nextIndent = nextNode.__indent;
    if (nextIndent !== prevNode.__indent) {
      setElementIndent(dom, nextIndent);
    }
    const nextFormat = nextNode.__format;
    if (nextFormat !== prevNode.__format) {
      setElementFormat(dom, nextFormat);
    }
    if (isDirty) {
      $reconcileChildrenWithDirection(prevNode, nextNode, dom);
      if (!$isRootNode(nextNode) && !nextNode.isInline()) {
        reconcileElementTerminatingLineBreak(prevNode, nextNode, dom);
      }
    }
    if ($textContentRequiresDoubleLinebreakAtEnd(nextNode)) {
      subTreeTextContent += DOUBLE_LINE_BREAK;
      editorTextContent += DOUBLE_LINE_BREAK;
    }
  } else {
    const text4 = nextNode.getTextContent();
    if ($isDecoratorNode(nextNode)) {
      const decorator = nextNode.decorate(activeEditor$1, activeEditorConfig);
      if (decorator !== null) {
        reconcileDecorator(key2, decorator);
      }
    } else if ($isTextNode(nextNode) && !nextNode.isDirectionless()) {
      subTreeDirectionedTextContent += text4;
    }
    subTreeTextContent += text4;
    editorTextContent += text4;
  }
  if (!activeEditorStateReadOnly && $isRootNode(nextNode) && nextNode.__cachedText !== editorTextContent) {
    const nextRootNode = nextNode.getWritable();
    nextRootNode.__cachedText = editorTextContent;
    nextNode = nextRootNode;
  }
  {
    Object.freeze(nextNode);
  }
  return dom;
}
function reconcileDecorator(key2, decorator) {
  let pendingDecorators = activeEditor$1._pendingDecorators;
  const currentDecorators = activeEditor$1._decorators;
  if (pendingDecorators === null) {
    if (currentDecorators[key2] === decorator) {
      return;
    }
    pendingDecorators = cloneDecorators(activeEditor$1);
  }
  pendingDecorators[key2] = decorator;
}
function getNextSibling(element2) {
  let nextSibling = element2.nextSibling;
  if (nextSibling !== null && nextSibling === activeEditor$1._blockCursorElement) {
    nextSibling = nextSibling.nextSibling;
  }
  return nextSibling;
}
function $reconcileNodeChildren(nextElement, prevChildren, nextChildren, prevChildrenLength, nextChildrenLength, slot) {
  const prevEndIndex = prevChildrenLength - 1;
  const nextEndIndex = nextChildrenLength - 1;
  let prevChildrenSet;
  let nextChildrenSet;
  let siblingDOM = slot.getFirstChild();
  let prevIndex = 0;
  let nextIndex2 = 0;
  while (prevIndex <= prevEndIndex && nextIndex2 <= nextEndIndex) {
    const prevKey = prevChildren[prevIndex];
    const nextKey = nextChildren[nextIndex2];
    if (prevKey === nextKey) {
      siblingDOM = getNextSibling($reconcileNode(nextKey, slot.element));
      prevIndex++;
      nextIndex2++;
    } else {
      if (prevChildrenSet === void 0) {
        prevChildrenSet = new Set(prevChildren);
      }
      if (nextChildrenSet === void 0) {
        nextChildrenSet = new Set(nextChildren);
      }
      const nextHasPrevKey = nextChildrenSet.has(prevKey);
      const prevHasNextKey = prevChildrenSet.has(nextKey);
      if (!nextHasPrevKey) {
        siblingDOM = getNextSibling(getPrevElementByKeyOrThrow(prevKey));
        destroyNode(prevKey, slot.element);
        prevIndex++;
      } else if (!prevHasNextKey) {
        $createNode(nextKey, slot.withBefore(siblingDOM));
        nextIndex2++;
      } else {
        const childDOM = getElementByKeyOrThrow(activeEditor$1, nextKey);
        if (childDOM === siblingDOM) {
          siblingDOM = getNextSibling($reconcileNode(nextKey, slot.element));
        } else {
          slot.withBefore(siblingDOM).insertChild(childDOM);
          $reconcileNode(nextKey, slot.element);
        }
        prevIndex++;
        nextIndex2++;
      }
    }
    const node2 = activeNextNodeMap.get(nextKey);
    if (node2 !== null && $isTextNode(node2)) {
      if (subTreeTextFormat === null) {
        subTreeTextFormat = node2.getFormat();
      }
      if (subTreeTextStyle === "") {
        subTreeTextStyle = node2.getStyle();
      }
    }
  }
  const appendNewChildren = prevIndex > prevEndIndex;
  const removeOldChildren = nextIndex2 > nextEndIndex;
  if (appendNewChildren && !removeOldChildren) {
    const previousNode = nextChildren[nextEndIndex + 1];
    const insertDOM = previousNode === void 0 ? null : activeEditor$1.getElementByKey(previousNode);
    $createChildren(nextChildren, nextElement, nextIndex2, nextEndIndex, slot.withBefore(insertDOM));
  } else if (removeOldChildren && !appendNewChildren) {
    destroyChildren(prevChildren, prevIndex, prevEndIndex, slot.element);
  }
}
function $reconcileRoot(prevEditorState, nextEditorState, editor, dirtyType, dirtyElements, dirtyLeaves) {
  subTreeTextContent = "";
  editorTextContent = "";
  subTreeDirectionedTextContent = "";
  treatAllNodesAsDirty = dirtyType === FULL_RECONCILE;
  activeTextDirection = null;
  activeEditor$1 = editor;
  activeEditorConfig = editor._config;
  activeEditorNodes = editor._nodes;
  activeMutationListeners = activeEditor$1._listeners.mutation;
  activeDirtyElements = dirtyElements;
  activeDirtyLeaves = dirtyLeaves;
  activePrevNodeMap = prevEditorState._nodeMap;
  activeNextNodeMap = nextEditorState._nodeMap;
  activeEditorStateReadOnly = nextEditorState._readOnly;
  activePrevKeyToDOMMap = new Map(editor._keyToDOMMap);
  const currentMutatedNodes = /* @__PURE__ */ new Map();
  mutatedNodes = currentMutatedNodes;
  $reconcileNode("root", null);
  activeEditor$1 = void 0;
  activeEditorNodes = void 0;
  activeDirtyElements = void 0;
  activeDirtyLeaves = void 0;
  activePrevNodeMap = void 0;
  activeNextNodeMap = void 0;
  activeEditorConfig = void 0;
  activePrevKeyToDOMMap = void 0;
  mutatedNodes = void 0;
  return currentMutatedNodes;
}
function storeDOMWithKey(key2, dom, editor) {
  const keyToDOMMap = editor._keyToDOMMap;
  setNodeKeyOnDOMNode(dom, editor, key2);
  keyToDOMMap.set(key2, dom);
}
function getPrevElementByKeyOrThrow(key2) {
  const element2 = activePrevKeyToDOMMap.get(key2);
  if (element2 === void 0) {
    {
      throw Error(`Reconciliation: could not find DOM element for node key ${key2}`);
    }
  }
  return element2;
}
var PASS_THROUGH_COMMAND = Object.freeze({});
var ANDROID_COMPOSITION_LATENCY = 30;
var rootElementEvents = [["keydown", onKeyDown], ["pointerdown", onPointerDown], ["compositionstart", onCompositionStart], ["compositionend", onCompositionEnd], ["input", onInput], ["click", onClick], ["cut", PASS_THROUGH_COMMAND], ["copy", PASS_THROUGH_COMMAND], ["dragstart", PASS_THROUGH_COMMAND], ["dragover", PASS_THROUGH_COMMAND], ["dragend", PASS_THROUGH_COMMAND], ["paste", PASS_THROUGH_COMMAND], ["focus", PASS_THROUGH_COMMAND], ["blur", PASS_THROUGH_COMMAND], ["drop", PASS_THROUGH_COMMAND]];
if (CAN_USE_BEFORE_INPUT) {
  rootElementEvents.push(["beforeinput", (event, editor) => onBeforeInput(event, editor)]);
}
var lastKeyDownTimeStamp = 0;
var lastKeyCode = null;
var lastBeforeInputInsertTextTimeStamp = 0;
var unprocessedBeforeInputData = null;
var rootElementsRegistered = /* @__PURE__ */ new WeakMap();
var isSelectionChangeFromDOMUpdate = false;
var isSelectionChangeFromMouseDown = false;
var isInsertLineBreak = false;
var isFirefoxEndingComposition = false;
var collapsedSelectionFormat = [0, "", 0, "root", 0];
function $shouldPreventDefaultAndInsertText(selection2, domTargetRange, text4, timeStamp, isBeforeInput) {
  const anchor = selection2.anchor;
  const focus2 = selection2.focus;
  const anchorNode = anchor.getNode();
  const editor = getActiveEditor();
  const domSelection = getDOMSelection(editor._window);
  const domAnchorNode = domSelection !== null ? domSelection.anchorNode : null;
  const anchorKey = anchor.key;
  const backingAnchorElement = editor.getElementByKey(anchorKey);
  const textLength = text4.length;
  return anchorKey !== focus2.key || // If we're working with a non-text node.
  !$isTextNode(anchorNode) || // If we are replacing a range with a single character or grapheme, and not composing.
  (!isBeforeInput && (!CAN_USE_BEFORE_INPUT || // We check to see if there has been
  // a recent beforeinput event for "textInput". If there has been one in the last
  // 50ms then we proceed as normal. However, if there is not, then this is likely
  // a dangling `input` event caused by execCommand('insertText').
  lastBeforeInputInsertTextTimeStamp < timeStamp + 50) || anchorNode.isDirty() && textLength < 2 || doesContainGrapheme(text4)) && anchor.offset !== focus2.offset && !anchorNode.isComposing() || // Any non standard text node.
  $isTokenOrSegmented(anchorNode) || // If the text length is more than a single character and we're either
  // dealing with this in "beforeinput" or where the node has already recently
  // been changed (thus is dirty).
  anchorNode.isDirty() && textLength > 1 || // If the DOM selection element is not the same as the backing node during beforeinput.
  (isBeforeInput || !CAN_USE_BEFORE_INPUT) && backingAnchorElement !== null && !anchorNode.isComposing() && domAnchorNode !== getDOMTextNode(backingAnchorElement) || // If TargetRange is not the same as the DOM selection; browser trying to edit random parts
  // of the editor.
  domSelection !== null && domTargetRange !== null && (!domTargetRange.collapsed || domTargetRange.startContainer !== domSelection.anchorNode || domTargetRange.startOffset !== domSelection.anchorOffset) || // Check if we're changing from bold to italics, or some other format.
  anchorNode.getFormat() !== selection2.format || anchorNode.getStyle() !== selection2.style || // One last set of heuristics to check against.
  $shouldInsertTextAfterOrBeforeTextNode(selection2, anchorNode);
}
function shouldSkipSelectionChange(domNode, offset5) {
  return isDOMTextNode(domNode) && domNode.nodeValue !== null && offset5 !== 0 && offset5 !== domNode.nodeValue.length;
}
function onSelectionChange(domSelection, editor, isActive) {
  const {
    anchorNode: anchorDOM,
    anchorOffset,
    focusNode: focusDOM,
    focusOffset
  } = domSelection;
  if (isSelectionChangeFromDOMUpdate) {
    isSelectionChangeFromDOMUpdate = false;
    if (shouldSkipSelectionChange(anchorDOM, anchorOffset) && shouldSkipSelectionChange(focusDOM, focusOffset)) {
      return;
    }
  }
  updateEditor(editor, () => {
    if (!isActive) {
      $setSelection(null);
      return;
    }
    if (!isSelectionWithinEditor(editor, anchorDOM, focusDOM)) {
      return;
    }
    const selection2 = $getSelection();
    if ($isRangeSelection(selection2)) {
      const anchor = selection2.anchor;
      const anchorNode = anchor.getNode();
      if (selection2.isCollapsed()) {
        if (domSelection.type === "Range" && domSelection.anchorNode === domSelection.focusNode) {
          selection2.dirty = true;
        }
        const windowEvent = getWindow(editor).event;
        const currentTimeStamp = windowEvent ? windowEvent.timeStamp : performance.now();
        const [lastFormat, lastStyle, lastOffset, lastKey, timeStamp] = collapsedSelectionFormat;
        const root2 = $getRoot();
        const isRootTextContentEmpty = editor.isComposing() === false && root2.getTextContent() === "";
        if (currentTimeStamp < timeStamp + 200 && anchor.offset === lastOffset && anchor.key === lastKey) {
          selection2.format = lastFormat;
          selection2.style = lastStyle;
        } else {
          if (anchor.type === "text") {
            if (!$isTextNode(anchorNode)) {
              throw Error(`Point.getNode() must return TextNode when type is text`);
            }
            selection2.format = anchorNode.getFormat();
            selection2.style = anchorNode.getStyle();
          } else if (anchor.type === "element" && !isRootTextContentEmpty) {
            if (!$isElementNode(anchorNode)) {
              throw Error(`Point.getNode() must return ElementNode when type is element`);
            }
            const lastNode = anchor.getNode();
            selection2.style = "";
            if (
              // This previously applied to all ParagraphNode
              lastNode.isEmpty()
            ) {
              selection2.format = lastNode.getTextFormat();
              selection2.style = lastNode.getTextStyle();
            } else {
              selection2.format = 0;
            }
          }
        }
      } else {
        const anchorKey = anchor.key;
        const focus2 = selection2.focus;
        const focusKey = focus2.key;
        const nodes = selection2.getNodes();
        const nodesLength = nodes.length;
        const isBackward = selection2.isBackward();
        const startOffset = isBackward ? focusOffset : anchorOffset;
        const endOffset = isBackward ? anchorOffset : focusOffset;
        const startKey = isBackward ? focusKey : anchorKey;
        const endKey = isBackward ? anchorKey : focusKey;
        let combinedFormat = IS_ALL_FORMATTING;
        let hasTextNodes = false;
        for (let i3 = 0; i3 < nodesLength; i3++) {
          const node2 = nodes[i3];
          const textContentSize = node2.getTextContentSize();
          if ($isTextNode(node2) && textContentSize !== 0 && // Exclude empty text nodes at boundaries resulting from user's selection
          !(i3 === 0 && node2.__key === startKey && startOffset === textContentSize || i3 === nodesLength - 1 && node2.__key === endKey && endOffset === 0)) {
            hasTextNodes = true;
            combinedFormat &= node2.getFormat();
            if (combinedFormat === 0) {
              break;
            }
          }
        }
        selection2.format = hasTextNodes ? combinedFormat : 0;
      }
    }
    dispatchCommand(editor, SELECTION_CHANGE_COMMAND, void 0);
  });
}
function onClick(event, editor) {
  updateEditor(editor, () => {
    const selection2 = $getSelection();
    const domSelection = getDOMSelection(editor._window);
    const lastSelection = $getPreviousSelection();
    if (domSelection) {
      if ($isRangeSelection(selection2)) {
        const anchor = selection2.anchor;
        const anchorNode = anchor.getNode();
        if (anchor.type === "element" && anchor.offset === 0 && selection2.isCollapsed() && !$isRootNode(anchorNode) && $getRoot().getChildrenSize() === 1 && anchorNode.getTopLevelElementOrThrow().isEmpty() && lastSelection !== null && selection2.is(lastSelection)) {
          domSelection.removeAllRanges();
          selection2.dirty = true;
        } else if (event.detail === 3 && !selection2.isCollapsed()) {
          const focus2 = selection2.focus;
          const focusNode = focus2.getNode();
          if (anchorNode !== focusNode) {
            if ($isElementNode(anchorNode)) {
              anchorNode.select(0);
            } else {
              anchorNode.getParentOrThrow().select(0);
            }
          }
        }
      } else if (event.pointerType === "touch") {
        const domAnchorNode = domSelection.anchorNode;
        if (isHTMLElement(domAnchorNode) || isDOMTextNode(domAnchorNode)) {
          const newSelection = $internalCreateRangeSelection(lastSelection, domSelection, editor, event);
          $setSelection(newSelection);
        }
      }
    }
    dispatchCommand(editor, CLICK_COMMAND, event);
  });
}
function onPointerDown(event, editor) {
  const target = event.target;
  const pointerType = event.pointerType;
  if (isDOMNode(target) && pointerType !== "touch" && event.button === 0) {
    updateEditor(editor, () => {
      if (!$isSelectionCapturedInDecorator(target)) {
        isSelectionChangeFromMouseDown = true;
      }
    });
  }
}
function getTargetRange(event) {
  if (!event.getTargetRanges) {
    return null;
  }
  const targetRanges = event.getTargetRanges();
  if (targetRanges.length === 0) {
    return null;
  }
  return targetRanges[0];
}
function $canRemoveText(anchorNode, focusNode) {
  return anchorNode !== focusNode || $isElementNode(anchorNode) || $isElementNode(focusNode) || !anchorNode.isToken() || !focusNode.isToken();
}
function isPossiblyAndroidKeyPress(timeStamp) {
  return lastKeyCode === "MediaLast" && timeStamp < lastKeyDownTimeStamp + ANDROID_COMPOSITION_LATENCY;
}
function onBeforeInput(event, editor) {
  const inputType = event.inputType;
  const targetRange = getTargetRange(event);
  if (inputType === "deleteCompositionText" || // If we're pasting in FF, we shouldn't get this event
  // as the `paste` event should have triggered, unless the
  // user has dom.event.clipboardevents.enabled disabled in
  // about:config. In that case, we need to process the
  // pasted content in the DOM mutation phase.
  IS_FIREFOX && isFirefoxClipboardEvents(editor)) {
    return;
  } else if (inputType === "insertCompositionText") {
    return;
  }
  updateEditor(editor, () => {
    const selection2 = $getSelection();
    if (inputType === "deleteContentBackward") {
      if (selection2 === null) {
        const prevSelection = $getPreviousSelection();
        if (!$isRangeSelection(prevSelection)) {
          return;
        }
        $setSelection(prevSelection.clone());
      }
      if ($isRangeSelection(selection2)) {
        const isSelectionAnchorSameAsFocus = selection2.anchor.key === selection2.focus.key;
        if (isPossiblyAndroidKeyPress(event.timeStamp) && editor.isComposing() && isSelectionAnchorSameAsFocus) {
          $setCompositionKey(null);
          lastKeyDownTimeStamp = 0;
          setTimeout(() => {
            updateEditor(editor, () => {
              $setCompositionKey(null);
            });
          }, ANDROID_COMPOSITION_LATENCY);
          if ($isRangeSelection(selection2)) {
            const anchorNode2 = selection2.anchor.getNode();
            anchorNode2.markDirty();
            selection2.format = anchorNode2.getFormat();
            if (!$isTextNode(anchorNode2)) {
              throw Error(`Anchor node must be a TextNode`);
            }
            selection2.style = anchorNode2.getStyle();
          }
        } else {
          $setCompositionKey(null);
          event.preventDefault();
          const selectedNode = selection2.anchor.getNode();
          const selectedNodeText = selectedNode.getTextContent();
          const selectedNodeCanInsertTextAfter = selectedNode.canInsertTextAfter();
          const hasSelectedAllTextInNode = selection2.anchor.offset === 0 && selection2.focus.offset === selectedNodeText.length;
          const shouldLetBrowserHandleDelete = IS_ANDROID_CHROME && isSelectionAnchorSameAsFocus && !hasSelectedAllTextInNode && selectedNodeCanInsertTextAfter;
          if (!shouldLetBrowserHandleDelete) {
            dispatchCommand(editor, DELETE_CHARACTER_COMMAND, true);
          }
        }
        return;
      }
    }
    if (!$isRangeSelection(selection2)) {
      return;
    }
    const data2 = event.data;
    if (unprocessedBeforeInputData !== null) {
      $updateSelectedTextFromDOM(false, editor, unprocessedBeforeInputData);
    }
    if ((!selection2.dirty || unprocessedBeforeInputData !== null) && selection2.isCollapsed() && !$isRootNode(selection2.anchor.getNode()) && targetRange !== null) {
      selection2.applyDOMRange(targetRange);
    }
    unprocessedBeforeInputData = null;
    const anchor = selection2.anchor;
    const focus2 = selection2.focus;
    const anchorNode = anchor.getNode();
    const focusNode = focus2.getNode();
    if (inputType === "insertText" || inputType === "insertTranspose") {
      if (data2 === "\n") {
        event.preventDefault();
        dispatchCommand(editor, INSERT_LINE_BREAK_COMMAND, false);
      } else if (data2 === DOUBLE_LINE_BREAK) {
        event.preventDefault();
        dispatchCommand(editor, INSERT_PARAGRAPH_COMMAND, void 0);
      } else if (data2 == null && event.dataTransfer) {
        const text4 = event.dataTransfer.getData("text/plain");
        event.preventDefault();
        selection2.insertRawText(text4);
      } else if (data2 != null && $shouldPreventDefaultAndInsertText(selection2, targetRange, data2, event.timeStamp, true)) {
        event.preventDefault();
        dispatchCommand(editor, CONTROLLED_TEXT_INSERTION_COMMAND, data2);
      } else {
        unprocessedBeforeInputData = data2;
      }
      lastBeforeInputInsertTextTimeStamp = event.timeStamp;
      return;
    }
    event.preventDefault();
    switch (inputType) {
      case "insertFromYank":
      case "insertFromDrop":
      case "insertReplacementText": {
        dispatchCommand(editor, CONTROLLED_TEXT_INSERTION_COMMAND, event);
        break;
      }
      case "insertFromComposition": {
        $setCompositionKey(null);
        dispatchCommand(editor, CONTROLLED_TEXT_INSERTION_COMMAND, event);
        break;
      }
      case "insertLineBreak": {
        $setCompositionKey(null);
        dispatchCommand(editor, INSERT_LINE_BREAK_COMMAND, false);
        break;
      }
      case "insertParagraph": {
        $setCompositionKey(null);
        if (isInsertLineBreak && !IS_IOS) {
          isInsertLineBreak = false;
          dispatchCommand(editor, INSERT_LINE_BREAK_COMMAND, false);
        } else {
          dispatchCommand(editor, INSERT_PARAGRAPH_COMMAND, void 0);
        }
        break;
      }
      case "insertFromPaste":
      case "insertFromPasteAsQuotation": {
        dispatchCommand(editor, PASTE_COMMAND, event);
        break;
      }
      case "deleteByComposition": {
        if ($canRemoveText(anchorNode, focusNode)) {
          dispatchCommand(editor, REMOVE_TEXT_COMMAND, event);
        }
        break;
      }
      case "deleteByDrag":
      case "deleteByCut": {
        dispatchCommand(editor, REMOVE_TEXT_COMMAND, event);
        break;
      }
      case "deleteContent": {
        dispatchCommand(editor, DELETE_CHARACTER_COMMAND, false);
        break;
      }
      case "deleteWordBackward": {
        dispatchCommand(editor, DELETE_WORD_COMMAND, true);
        break;
      }
      case "deleteWordForward": {
        dispatchCommand(editor, DELETE_WORD_COMMAND, false);
        break;
      }
      case "deleteHardLineBackward":
      case "deleteSoftLineBackward": {
        dispatchCommand(editor, DELETE_LINE_COMMAND, true);
        break;
      }
      case "deleteContentForward":
      case "deleteHardLineForward":
      case "deleteSoftLineForward": {
        dispatchCommand(editor, DELETE_LINE_COMMAND, false);
        break;
      }
      case "formatStrikeThrough": {
        dispatchCommand(editor, FORMAT_TEXT_COMMAND, "strikethrough");
        break;
      }
      case "formatBold": {
        dispatchCommand(editor, FORMAT_TEXT_COMMAND, "bold");
        break;
      }
      case "formatItalic": {
        dispatchCommand(editor, FORMAT_TEXT_COMMAND, "italic");
        break;
      }
      case "formatUnderline": {
        dispatchCommand(editor, FORMAT_TEXT_COMMAND, "underline");
        break;
      }
      case "historyUndo": {
        dispatchCommand(editor, UNDO_COMMAND, void 0);
        break;
      }
      case "historyRedo": {
        dispatchCommand(editor, REDO_COMMAND, void 0);
        break;
      }
    }
  });
}
function onInput(event, editor) {
  event.stopPropagation();
  updateEditor(editor, () => {
    const selection2 = $getSelection();
    const data2 = event.data;
    const targetRange = getTargetRange(event);
    if (data2 != null && $isRangeSelection(selection2) && $shouldPreventDefaultAndInsertText(selection2, targetRange, data2, event.timeStamp, false)) {
      if (isFirefoxEndingComposition) {
        $onCompositionEndImpl(editor, data2);
        isFirefoxEndingComposition = false;
      }
      const anchor = selection2.anchor;
      const anchorNode = anchor.getNode();
      const domSelection = getDOMSelection(editor._window);
      if (domSelection === null) {
        return;
      }
      const isBackward = selection2.isBackward();
      const startOffset = isBackward ? selection2.anchor.offset : selection2.focus.offset;
      const endOffset = isBackward ? selection2.focus.offset : selection2.anchor.offset;
      if (!CAN_USE_BEFORE_INPUT || selection2.isCollapsed() || !$isTextNode(anchorNode) || domSelection.anchorNode === null || anchorNode.getTextContent().slice(0, startOffset) + data2 + anchorNode.getTextContent().slice(startOffset + endOffset) !== getAnchorTextFromDOM(domSelection.anchorNode)) {
        dispatchCommand(editor, CONTROLLED_TEXT_INSERTION_COMMAND, data2);
      }
      const textLength = data2.length;
      if (IS_FIREFOX && textLength > 1 && event.inputType === "insertCompositionText" && !editor.isComposing()) {
        selection2.anchor.offset -= textLength;
      }
      if (!IS_SAFARI && !IS_IOS && !IS_APPLE_WEBKIT && editor.isComposing()) {
        lastKeyDownTimeStamp = 0;
        $setCompositionKey(null);
      }
    } else {
      const characterData = data2 !== null ? data2 : void 0;
      $updateSelectedTextFromDOM(false, editor, characterData);
      if (isFirefoxEndingComposition) {
        $onCompositionEndImpl(editor, data2 || void 0);
        isFirefoxEndingComposition = false;
      }
    }
    $flushMutations();
  });
  unprocessedBeforeInputData = null;
}
function onCompositionStart(event, editor) {
  updateEditor(editor, () => {
    const selection2 = $getSelection();
    if ($isRangeSelection(selection2) && !editor.isComposing()) {
      const anchor = selection2.anchor;
      const node2 = selection2.anchor.getNode();
      $setCompositionKey(anchor.key);
      if (
        // If it has been 30ms since the last keydown, then we should
        // apply the empty space heuristic. We can't do this for Safari,
        // as the keydown fires after composition start.
        event.timeStamp < lastKeyDownTimeStamp + ANDROID_COMPOSITION_LATENCY || // FF has issues around composing multibyte characters, so we also
        // need to invoke the empty space heuristic below.
        anchor.type === "element" || !selection2.isCollapsed() || node2.getFormat() !== selection2.format || $isTextNode(node2) && node2.getStyle() !== selection2.style
      ) {
        dispatchCommand(editor, CONTROLLED_TEXT_INSERTION_COMMAND, COMPOSITION_START_CHAR);
      }
    }
  });
}
function $onCompositionEndImpl(editor, data2) {
  const compositionKey = editor._compositionKey;
  $setCompositionKey(null);
  if (compositionKey !== null && data2 != null) {
    if (data2 === "") {
      const node2 = $getNodeByKey(compositionKey);
      const textNode = getDOMTextNode(editor.getElementByKey(compositionKey));
      if (textNode !== null && textNode.nodeValue !== null && $isTextNode(node2)) {
        $updateTextNodeFromDOMContent(node2, textNode.nodeValue, null, null, true);
      }
      return;
    }
    if (data2[data2.length - 1] === "\n") {
      const selection2 = $getSelection();
      if ($isRangeSelection(selection2)) {
        const focus2 = selection2.focus;
        selection2.anchor.set(focus2.key, focus2.offset, focus2.type);
        dispatchCommand(editor, KEY_ENTER_COMMAND, null);
        return;
      }
    }
  }
  $updateSelectedTextFromDOM(true, editor, data2);
}
function onCompositionEnd(event, editor) {
  if (IS_FIREFOX) {
    isFirefoxEndingComposition = true;
  } else {
    updateEditor(editor, () => {
      $onCompositionEndImpl(editor, event.data);
    });
  }
}
function onKeyDown(event, editor) {
  lastKeyDownTimeStamp = event.timeStamp;
  lastKeyCode = event.key;
  if (editor.isComposing()) {
    return;
  }
  const {
    key: key2,
    shiftKey,
    ctrlKey,
    metaKey,
    altKey
  } = event;
  if (dispatchCommand(editor, KEY_DOWN_COMMAND, event)) {
    return;
  }
  if (key2 == null) {
    return;
  }
  if (isMoveForward(key2, ctrlKey, altKey, metaKey)) {
    dispatchCommand(editor, KEY_ARROW_RIGHT_COMMAND, event);
  } else if (isMoveToEnd(key2, ctrlKey, shiftKey, altKey, metaKey)) {
    dispatchCommand(editor, MOVE_TO_END, event);
  } else if (isMoveBackward(key2, ctrlKey, altKey, metaKey)) {
    dispatchCommand(editor, KEY_ARROW_LEFT_COMMAND, event);
  } else if (isMoveToStart(key2, ctrlKey, shiftKey, altKey, metaKey)) {
    dispatchCommand(editor, MOVE_TO_START, event);
  } else if (isMoveUp(key2, ctrlKey, metaKey)) {
    dispatchCommand(editor, KEY_ARROW_UP_COMMAND, event);
  } else if (isMoveDown(key2, ctrlKey, metaKey)) {
    dispatchCommand(editor, KEY_ARROW_DOWN_COMMAND, event);
  } else if (isLineBreak(key2, shiftKey)) {
    isInsertLineBreak = true;
    dispatchCommand(editor, KEY_ENTER_COMMAND, event);
  } else if (isSpace(key2)) {
    dispatchCommand(editor, KEY_SPACE_COMMAND, event);
  } else if (isOpenLineBreak(key2, ctrlKey)) {
    event.preventDefault();
    isInsertLineBreak = true;
    dispatchCommand(editor, INSERT_LINE_BREAK_COMMAND, true);
  } else if (isParagraph(key2, shiftKey)) {
    isInsertLineBreak = false;
    dispatchCommand(editor, KEY_ENTER_COMMAND, event);
  } else if (isDeleteBackward(key2, altKey, metaKey, ctrlKey)) {
    if (isBackspace(key2)) {
      dispatchCommand(editor, KEY_BACKSPACE_COMMAND, event);
    } else {
      event.preventDefault();
      dispatchCommand(editor, DELETE_CHARACTER_COMMAND, true);
    }
  } else if (isEscape(key2)) {
    dispatchCommand(editor, KEY_ESCAPE_COMMAND, event);
  } else if (isDeleteForward(key2, ctrlKey, shiftKey, altKey, metaKey)) {
    if (isDelete(key2)) {
      dispatchCommand(editor, KEY_DELETE_COMMAND, event);
    } else {
      event.preventDefault();
      dispatchCommand(editor, DELETE_CHARACTER_COMMAND, false);
    }
  } else if (isDeleteWordBackward(key2, altKey, ctrlKey)) {
    event.preventDefault();
    dispatchCommand(editor, DELETE_WORD_COMMAND, true);
  } else if (isDeleteWordForward(key2, altKey, ctrlKey)) {
    event.preventDefault();
    dispatchCommand(editor, DELETE_WORD_COMMAND, false);
  } else if (isDeleteLineBackward(key2, metaKey)) {
    event.preventDefault();
    dispatchCommand(editor, DELETE_LINE_COMMAND, true);
  } else if (isDeleteLineForward(key2, metaKey)) {
    event.preventDefault();
    dispatchCommand(editor, DELETE_LINE_COMMAND, false);
  } else if (isBold(key2, altKey, metaKey, ctrlKey)) {
    event.preventDefault();
    dispatchCommand(editor, FORMAT_TEXT_COMMAND, "bold");
  } else if (isUnderline(key2, altKey, metaKey, ctrlKey)) {
    event.preventDefault();
    dispatchCommand(editor, FORMAT_TEXT_COMMAND, "underline");
  } else if (isItalic(key2, altKey, metaKey, ctrlKey)) {
    event.preventDefault();
    dispatchCommand(editor, FORMAT_TEXT_COMMAND, "italic");
  } else if (isTab(key2, altKey, ctrlKey, metaKey)) {
    dispatchCommand(editor, KEY_TAB_COMMAND, event);
  } else if (isUndo(key2, shiftKey, metaKey, ctrlKey)) {
    event.preventDefault();
    dispatchCommand(editor, UNDO_COMMAND, void 0);
  } else if (isRedo(key2, shiftKey, metaKey, ctrlKey)) {
    event.preventDefault();
    dispatchCommand(editor, REDO_COMMAND, void 0);
  } else {
    const prevSelection = editor._editorState._selection;
    if (prevSelection !== null && !$isRangeSelection(prevSelection)) {
      if (isCopy(key2, shiftKey, metaKey, ctrlKey)) {
        event.preventDefault();
        dispatchCommand(editor, COPY_COMMAND, event);
      } else if (isCut(key2, shiftKey, metaKey, ctrlKey)) {
        event.preventDefault();
        dispatchCommand(editor, CUT_COMMAND, event);
      } else if (isSelectAll(key2, metaKey, ctrlKey)) {
        event.preventDefault();
        dispatchCommand(editor, SELECT_ALL_COMMAND, event);
      }
    } else if (!IS_FIREFOX && isSelectAll(key2, metaKey, ctrlKey)) {
      event.preventDefault();
      dispatchCommand(editor, SELECT_ALL_COMMAND, event);
    }
  }
  if (isModifier(ctrlKey, shiftKey, altKey, metaKey)) {
    dispatchCommand(editor, KEY_MODIFIER_COMMAND, event);
  }
}
function getRootElementRemoveHandles(rootElement) {
  let eventHandles = rootElement.__lexicalEventHandles;
  if (eventHandles === void 0) {
    eventHandles = [];
    rootElement.__lexicalEventHandles = eventHandles;
  }
  return eventHandles;
}
var activeNestedEditorsMap = /* @__PURE__ */ new Map();
function onDocumentSelectionChange(event) {
  const domSelection = getDOMSelectionFromTarget(event.target);
  if (domSelection === null) {
    return;
  }
  const nextActiveEditor = getNearestEditorFromDOMNode(domSelection.anchorNode);
  if (nextActiveEditor === null) {
    return;
  }
  if (isSelectionChangeFromMouseDown) {
    isSelectionChangeFromMouseDown = false;
    updateEditor(nextActiveEditor, () => {
      const lastSelection = $getPreviousSelection();
      const domAnchorNode = domSelection.anchorNode;
      if (isHTMLElement(domAnchorNode) || isDOMTextNode(domAnchorNode)) {
        const newSelection = $internalCreateRangeSelection(lastSelection, domSelection, nextActiveEditor, event);
        $setSelection(newSelection);
      }
    });
  }
  const editors = getEditorsToPropagate(nextActiveEditor);
  const rootEditor = editors[editors.length - 1];
  const rootEditorKey = rootEditor._key;
  const activeNestedEditor = activeNestedEditorsMap.get(rootEditorKey);
  const prevActiveEditor = activeNestedEditor || rootEditor;
  if (prevActiveEditor !== nextActiveEditor) {
    onSelectionChange(domSelection, prevActiveEditor, false);
  }
  onSelectionChange(domSelection, nextActiveEditor, true);
  if (nextActiveEditor !== rootEditor) {
    activeNestedEditorsMap.set(rootEditorKey, nextActiveEditor);
  } else if (activeNestedEditor) {
    activeNestedEditorsMap.delete(rootEditorKey);
  }
}
function stopLexicalPropagation(event) {
  event._lexicalHandled = true;
}
function hasStoppedLexicalPropagation(event) {
  const stopped = event._lexicalHandled === true;
  return stopped;
}
function addRootElementEvents(rootElement, editor) {
  const doc = rootElement.ownerDocument;
  const documentRootElementsCount = rootElementsRegistered.get(doc);
  if (documentRootElementsCount === void 0 || documentRootElementsCount < 1) {
    doc.addEventListener("selectionchange", onDocumentSelectionChange);
  }
  rootElementsRegistered.set(doc, (documentRootElementsCount || 0) + 1);
  rootElement.__lexicalEditor = editor;
  const removeHandles = getRootElementRemoveHandles(rootElement);
  for (let i3 = 0; i3 < rootElementEvents.length; i3++) {
    const [eventName, onEvent] = rootElementEvents[i3];
    const eventHandler = typeof onEvent === "function" ? (event) => {
      if (hasStoppedLexicalPropagation(event)) {
        return;
      }
      stopLexicalPropagation(event);
      if (editor.isEditable() || eventName === "click") {
        onEvent(event, editor);
      }
    } : (event) => {
      if (hasStoppedLexicalPropagation(event)) {
        return;
      }
      stopLexicalPropagation(event);
      const isEditable = editor.isEditable();
      switch (eventName) {
        case "cut":
          return isEditable && dispatchCommand(editor, CUT_COMMAND, event);
        case "copy":
          return dispatchCommand(editor, COPY_COMMAND, event);
        case "paste":
          return isEditable && dispatchCommand(editor, PASTE_COMMAND, event);
        case "dragstart":
          return isEditable && dispatchCommand(editor, DRAGSTART_COMMAND, event);
        case "dragover":
          return isEditable && dispatchCommand(editor, DRAGOVER_COMMAND, event);
        case "dragend":
          return isEditable && dispatchCommand(editor, DRAGEND_COMMAND, event);
        case "focus":
          return isEditable && dispatchCommand(editor, FOCUS_COMMAND, event);
        case "blur": {
          return isEditable && dispatchCommand(editor, BLUR_COMMAND, event);
        }
        case "drop":
          return isEditable && dispatchCommand(editor, DROP_COMMAND, event);
      }
    };
    rootElement.addEventListener(eventName, eventHandler);
    removeHandles.push(() => {
      rootElement.removeEventListener(eventName, eventHandler);
    });
  }
}
function removeRootElementEvents(rootElement) {
  const doc = rootElement.ownerDocument;
  const documentRootElementsCount = rootElementsRegistered.get(doc);
  if (!(documentRootElementsCount !== void 0)) {
    throw Error(`Root element not registered`);
  }
  const newCount = documentRootElementsCount - 1;
  if (!(newCount >= 0)) {
    throw Error(`Root element count less than 0`);
  }
  rootElementsRegistered.set(doc, newCount);
  if (newCount === 0) {
    doc.removeEventListener("selectionchange", onDocumentSelectionChange);
  }
  const editor = getEditorPropertyFromDOMNode(rootElement);
  if (isLexicalEditor(editor)) {
    cleanActiveNestedEditorsMap(editor);
    rootElement.__lexicalEditor = null;
  } else if (editor) {
    {
      throw Error(`Attempted to remove event handlers from a node that does not belong to this build of Lexical`);
    }
  }
  const removeHandles = getRootElementRemoveHandles(rootElement);
  for (let i3 = 0; i3 < removeHandles.length; i3++) {
    removeHandles[i3]();
  }
  rootElement.__lexicalEventHandles = [];
}
function cleanActiveNestedEditorsMap(editor) {
  if (editor._parentEditor !== null) {
    const editors = getEditorsToPropagate(editor);
    const rootEditor = editors[editors.length - 1];
    const rootEditorKey = rootEditor._key;
    if (activeNestedEditorsMap.get(rootEditorKey) === editor) {
      activeNestedEditorsMap.delete(rootEditorKey);
    }
  } else {
    activeNestedEditorsMap.delete(editor._key);
  }
}
function markSelectionChangeFromDOMUpdate() {
  isSelectionChangeFromDOMUpdate = true;
}
function markCollapsedSelectionFormat(format, style, offset5, key2, timeStamp) {
  collapsedSelectionFormat = [format, style, offset5, key2, timeStamp];
}
function $removeNode(nodeToRemove, restoreSelection, preserveEmptyParent) {
  errorOnReadOnly();
  const key2 = nodeToRemove.__key;
  const parent = nodeToRemove.getParent();
  if (parent === null) {
    return;
  }
  const selection2 = $maybeMoveChildrenSelectionToParent(nodeToRemove);
  let selectionMoved = false;
  if ($isRangeSelection(selection2) && restoreSelection) {
    const anchor = selection2.anchor;
    const focus2 = selection2.focus;
    if (anchor.key === key2) {
      moveSelectionPointToSibling(anchor, nodeToRemove, parent, nodeToRemove.getPreviousSibling(), nodeToRemove.getNextSibling());
      selectionMoved = true;
    }
    if (focus2.key === key2) {
      moveSelectionPointToSibling(focus2, nodeToRemove, parent, nodeToRemove.getPreviousSibling(), nodeToRemove.getNextSibling());
      selectionMoved = true;
    }
  } else if ($isNodeSelection(selection2) && restoreSelection && nodeToRemove.isSelected()) {
    nodeToRemove.selectPrevious();
  }
  if ($isRangeSelection(selection2) && restoreSelection && !selectionMoved) {
    const index3 = nodeToRemove.getIndexWithinParent();
    removeFromParent(nodeToRemove);
    $updateElementSelectionOnCreateDeleteNode(selection2, parent, index3, -1);
  } else {
    removeFromParent(nodeToRemove);
  }
  if (!preserveEmptyParent && !$isRootOrShadowRoot(parent) && !parent.canBeEmpty() && parent.isEmpty()) {
    $removeNode(parent, restoreSelection);
  }
  if (restoreSelection && $isRootNode(parent) && parent.isEmpty()) {
    parent.selectEnd();
  }
}
var LexicalNode = class {
  // Allow us to look up the type including static props
  /** @internal */
  /** @internal */
  //@ts-ignore We set the key in the constructor.
  /** @internal */
  /** @internal */
  /** @internal */
  // Flow doesn't support abstract classes unfortunately, so we can't _force_
  // subclasses of Node to implement statics. All subclasses of Node should have
  // a static getType and clone method though. We define getType and clone here so we can call it
  // on any  Node, and we throw this error by default since the subclass should provide
  // their own implementation.
  /**
   * Returns the string type of this node. Every node must
   * implement this and it MUST BE UNIQUE amongst nodes registered
   * on the editor.
   *
   */
  static getType() {
    {
      throw Error(`LexicalNode: Node ${this.name} does not implement .getType().`);
    }
  }
  /**
   * Clones this node, creating a new node with a different key
   * and adding it to the EditorState (but not attaching it anywhere!). All nodes must
   * implement this method.
   *
   */
  static clone(_data) {
    {
      throw Error(`LexicalNode: Node ${this.name} does not implement .clone().`);
    }
  }
  /**
   * Perform any state updates on the clone of prevNode that are not already
   * handled by the constructor call in the static clone method. If you have
   * state to update in your clone that is not handled directly by the
   * constructor, it is advisable to override this method but it is required
   * to include a call to `super.afterCloneFrom(prevNode)` in your
   * implementation. This is only intended to be called by
   * {@link $cloneWithProperties} function or via a super call.
   *
   * @example
   * ```ts
   * class ClassesTextNode extends TextNode {
   *   // Not shown: static getType, static importJSON, exportJSON, createDOM, updateDOM
   *   __classes = new Set<string>();
   *   static clone(node: ClassesTextNode): ClassesTextNode {
   *     // The inherited TextNode constructor is used here, so
   *     // classes is not set by this method.
   *     return new ClassesTextNode(node.__text, node.__key);
   *   }
   *   afterCloneFrom(node: this): void {
   *     // This calls TextNode.afterCloneFrom and LexicalNode.afterCloneFrom
   *     // for necessary state updates
   *     super.afterCloneFrom(node);
   *     this.__addClasses(node.__classes);
   *   }
   *   // This method is a private implementation detail, it is not
   *   // suitable for the public API because it does not call getWritable
   *   __addClasses(classNames: Iterable<string>): this {
   *     for (const className of classNames) {
   *       this.__classes.add(className);
   *     }
   *     return this;
   *   }
   *   addClass(...classNames: string[]): this {
   *     return this.getWritable().__addClasses(classNames);
   *   }
   *   removeClass(...classNames: string[]): this {
   *     const node = this.getWritable();
   *     for (const className of classNames) {
   *       this.__classes.delete(className);
   *     }
   *     return this;
   *   }
   *   getClasses(): Set<string> {
   *     return this.getLatest().__classes;
   *   }
   * }
   * ```
   *
   */
  afterCloneFrom(prevNode) {
    this.__parent = prevNode.__parent;
    this.__next = prevNode.__next;
    this.__prev = prevNode.__prev;
  }
  // eslint-disable-next-line @typescript-eslint/no-explicit-any
  constructor(key2) {
    this.__type = this.constructor.getType();
    this.__parent = null;
    this.__prev = null;
    this.__next = null;
    $setNodeKey(this, key2);
    {
      if (this.__type !== "root") {
        errorOnReadOnly();
        errorOnTypeKlassMismatch(this.__type, this.constructor);
      }
    }
  }
  // Getters and Traversers
  /**
   * Returns the string type of this node.
   */
  getType() {
    return this.__type;
  }
  isInline() {
    {
      throw Error(`LexicalNode: Node ${this.constructor.name} does not implement .isInline().`);
    }
  }
  /**
   * Returns true if there is a path between this node and the RootNode, false otherwise.
   * This is a way of determining if the node is "attached" EditorState. Unattached nodes
   * won't be reconciled and will ultimatelt be cleaned up by the Lexical GC.
   */
  isAttached() {
    let nodeKey = this.__key;
    while (nodeKey !== null) {
      if (nodeKey === "root") {
        return true;
      }
      const node2 = $getNodeByKey(nodeKey);
      if (node2 === null) {
        break;
      }
      nodeKey = node2.__parent;
    }
    return false;
  }
  /**
   * Returns true if this node is contained within the provided Selection., false otherwise.
   * Relies on the algorithms implemented in {@link BaseSelection.getNodes} to determine
   * what's included.
   *
   * @param selection - The selection that we want to determine if the node is in.
   */
  isSelected(selection2) {
    const targetSelection = selection2 || $getSelection();
    if (targetSelection == null) {
      return false;
    }
    const isSelected = targetSelection.getNodes().some((n3) => n3.__key === this.__key);
    if ($isTextNode(this)) {
      return isSelected;
    }
    const isElementRangeSelection = $isRangeSelection(targetSelection) && targetSelection.anchor.type === "element" && targetSelection.focus.type === "element";
    if (isElementRangeSelection) {
      if (targetSelection.isCollapsed()) {
        return false;
      }
      const parentNode = this.getParent();
      if ($isDecoratorNode(this) && this.isInline() && parentNode) {
        const firstPoint = targetSelection.isBackward() ? targetSelection.focus : targetSelection.anchor;
        const firstElement = firstPoint.getNode();
        if (firstPoint.offset === firstElement.getChildrenSize() && firstElement.is(parentNode) && firstElement.getLastChildOrThrow().is(this)) {
          return false;
        }
      }
    }
    return isSelected;
  }
  /**
   * Returns this nodes key.
   */
  getKey() {
    return this.__key;
  }
  /**
   * Returns the zero-based index of this node within the parent.
   */
  getIndexWithinParent() {
    const parent = this.getParent();
    if (parent === null) {
      return -1;
    }
    let node2 = parent.getFirstChild();
    let index3 = 0;
    while (node2 !== null) {
      if (this.is(node2)) {
        return index3;
      }
      index3++;
      node2 = node2.getNextSibling();
    }
    return -1;
  }
  /**
   * Returns the parent of this node, or null if none is found.
   */
  getParent() {
    const parent = this.getLatest().__parent;
    if (parent === null) {
      return null;
    }
    return $getNodeByKey(parent);
  }
  /**
   * Returns the parent of this node, or throws if none is found.
   */
  getParentOrThrow() {
    const parent = this.getParent();
    if (parent === null) {
      {
        throw Error(`Expected node ${this.__key} to have a parent.`);
      }
    }
    return parent;
  }
  /**
   * Returns the highest (in the EditorState tree)
   * non-root ancestor of this node, or null if none is found. See {@link lexical!$isRootOrShadowRoot}
   * for more information on which Elements comprise "roots".
   */
  getTopLevelElement() {
    let node2 = this;
    while (node2 !== null) {
      const parent = node2.getParent();
      if ($isRootOrShadowRoot(parent)) {
        if (!($isElementNode(node2) || node2 === this && $isDecoratorNode(node2))) {
          throw Error(`Children of root nodes must be elements or decorators`);
        }
        return node2;
      }
      node2 = parent;
    }
    return null;
  }
  /**
   * Returns the highest (in the EditorState tree)
   * non-root ancestor of this node, or throws if none is found. See {@link lexical!$isRootOrShadowRoot}
   * for more information on which Elements comprise "roots".
   */
  getTopLevelElementOrThrow() {
    const parent = this.getTopLevelElement();
    if (parent === null) {
      {
        throw Error(`Expected node ${this.__key} to have a top parent element.`);
      }
    }
    return parent;
  }
  /**
   * Returns a list of the every ancestor of this node,
   * all the way up to the RootNode.
   *
   */
  getParents() {
    const parents = [];
    let node2 = this.getParent();
    while (node2 !== null) {
      parents.push(node2);
      node2 = node2.getParent();
    }
    return parents;
  }
  /**
   * Returns a list of the keys of every ancestor of this node,
   * all the way up to the RootNode.
   *
   */
  getParentKeys() {
    const parents = [];
    let node2 = this.getParent();
    while (node2 !== null) {
      parents.push(node2.__key);
      node2 = node2.getParent();
    }
    return parents;
  }
  /**
   * Returns the "previous" siblings - that is, the node that comes
   * before this one in the same parent.
   *
   */
  getPreviousSibling() {
    const self2 = this.getLatest();
    const prevKey = self2.__prev;
    return prevKey === null ? null : $getNodeByKey(prevKey);
  }
  /**
   * Returns the "previous" siblings - that is, the nodes that come between
   * this one and the first child of it's parent, inclusive.
   *
   */
  getPreviousSiblings() {
    const siblings = [];
    const parent = this.getParent();
    if (parent === null) {
      return siblings;
    }
    let node2 = parent.getFirstChild();
    while (node2 !== null) {
      if (node2.is(this)) {
        break;
      }
      siblings.push(node2);
      node2 = node2.getNextSibling();
    }
    return siblings;
  }
  /**
   * Returns the "next" siblings - that is, the node that comes
   * after this one in the same parent
   *
   */
  getNextSibling() {
    const self2 = this.getLatest();
    const nextKey = self2.__next;
    return nextKey === null ? null : $getNodeByKey(nextKey);
  }
  /**
   * Returns all "next" siblings - that is, the nodes that come between this
   * one and the last child of it's parent, inclusive.
   *
   */
  getNextSiblings() {
    const siblings = [];
    let node2 = this.getNextSibling();
    while (node2 !== null) {
      siblings.push(node2);
      node2 = node2.getNextSibling();
    }
    return siblings;
  }
  /**
   * Returns the closest common ancestor of this node and the provided one or null
   * if one cannot be found.
   *
   * @param node - the other node to find the common ancestor of.
   */
  getCommonAncestor(node2) {
    const a2 = this.getParents();
    const b3 = node2.getParents();
    if ($isElementNode(this)) {
      a2.unshift(this);
    }
    if ($isElementNode(node2)) {
      b3.unshift(node2);
    }
    const aLength = a2.length;
    const bLength = b3.length;
    if (aLength === 0 || bLength === 0 || a2[aLength - 1] !== b3[bLength - 1]) {
      return null;
    }
    const bSet = new Set(b3);
    for (let i3 = 0; i3 < aLength; i3++) {
      const ancestor = a2[i3];
      if (bSet.has(ancestor)) {
        return ancestor;
      }
    }
    return null;
  }
  /**
   * Returns true if the provided node is the exact same one as this node, from Lexical's perspective.
   * Always use this instead of referential equality.
   *
   * @param object - the node to perform the equality comparison on.
   */
  is(object) {
    if (object == null) {
      return false;
    }
    return this.__key === object.__key;
  }
  /**
   * Returns true if this node logical precedes the target node in the editor state.
   *
   * @param targetNode - the node we're testing to see if it's after this one.
   */
  isBefore(targetNode) {
    if (this === targetNode) {
      return false;
    }
    if (targetNode.isParentOf(this)) {
      return true;
    }
    if (this.isParentOf(targetNode)) {
      return false;
    }
    const commonAncestor = this.getCommonAncestor(targetNode);
    let indexA = 0;
    let indexB = 0;
    let node2 = this;
    while (true) {
      const parent = node2.getParentOrThrow();
      if (parent === commonAncestor) {
        indexA = node2.getIndexWithinParent();
        break;
      }
      node2 = parent;
    }
    node2 = targetNode;
    while (true) {
      const parent = node2.getParentOrThrow();
      if (parent === commonAncestor) {
        indexB = node2.getIndexWithinParent();
        break;
      }
      node2 = parent;
    }
    return indexA < indexB;
  }
  /**
   * Returns true if this node is the parent of the target node, false otherwise.
   *
   * @param targetNode - the would-be child node.
   */
  isParentOf(targetNode) {
    const key2 = this.__key;
    if (key2 === targetNode.__key) {
      return false;
    }
    let node2 = targetNode;
    while (node2 !== null) {
      if (node2.__key === key2) {
        return true;
      }
      node2 = node2.getParent();
    }
    return false;
  }
  // TO-DO: this function can be simplified a lot
  /**
   * Returns a list of nodes that are between this node and
   * the target node in the EditorState.
   *
   * @param targetNode - the node that marks the other end of the range of nodes to be returned.
   */
  getNodesBetween(targetNode) {
    const isBefore = this.isBefore(targetNode);
    const nodes = [];
    const visited = /* @__PURE__ */ new Set();
    let node2 = this;
    while (true) {
      if (node2 === null) {
        break;
      }
      const key2 = node2.__key;
      if (!visited.has(key2)) {
        visited.add(key2);
        nodes.push(node2);
      }
      if (node2 === targetNode) {
        break;
      }
      const child = $isElementNode(node2) ? isBefore ? node2.getFirstChild() : node2.getLastChild() : null;
      if (child !== null) {
        node2 = child;
        continue;
      }
      const nextSibling = isBefore ? node2.getNextSibling() : node2.getPreviousSibling();
      if (nextSibling !== null) {
        node2 = nextSibling;
        continue;
      }
      const parent = node2.getParentOrThrow();
      if (!visited.has(parent.__key)) {
        nodes.push(parent);
      }
      if (parent === targetNode) {
        break;
      }
      let parentSibling = null;
      let ancestor = parent;
      do {
        if (ancestor === null) {
          {
            throw Error(`getNodesBetween: ancestor is null`);
          }
        }
        parentSibling = isBefore ? ancestor.getNextSibling() : ancestor.getPreviousSibling();
        ancestor = ancestor.getParent();
        if (ancestor !== null) {
          if (parentSibling === null && !visited.has(ancestor.__key)) {
            nodes.push(ancestor);
          }
        } else {
          break;
        }
      } while (parentSibling === null);
      node2 = parentSibling;
    }
    if (!isBefore) {
      nodes.reverse();
    }
    return nodes;
  }
  /**
   * Returns true if this node has been marked dirty during this update cycle.
   *
   */
  isDirty() {
    const editor = getActiveEditor();
    const dirtyLeaves = editor._dirtyLeaves;
    return dirtyLeaves !== null && dirtyLeaves.has(this.__key);
  }
  /**
   * Returns the latest version of the node from the active EditorState.
   * This is used to avoid getting values from stale node references.
   *
   */
  getLatest() {
    const latest = $getNodeByKey(this.__key);
    if (latest === null) {
      {
        throw Error(`Lexical node does not exist in active editor state. Avoid using the same node references between nested closures from editorState.read/editor.update.`);
      }
    }
    return latest;
  }
  /**
   * Returns a mutable version of the node using {@link $cloneWithProperties}
   * if necessary. Will throw an error if called outside of a Lexical Editor
   * {@link LexicalEditor.update} callback.
   *
   */
  getWritable() {
    errorOnReadOnly();
    const editorState = getActiveEditorState();
    const editor = getActiveEditor();
    const nodeMap = editorState._nodeMap;
    const key2 = this.__key;
    const latestNode = this.getLatest();
    const cloneNotNeeded = editor._cloneNotNeeded;
    const selection2 = $getSelection();
    if (selection2 !== null) {
      selection2.setCachedNodes(null);
    }
    if (cloneNotNeeded.has(key2)) {
      internalMarkNodeAsDirty(latestNode);
      return latestNode;
    }
    const mutableNode = $cloneWithProperties(latestNode);
    cloneNotNeeded.add(key2);
    internalMarkNodeAsDirty(mutableNode);
    nodeMap.set(key2, mutableNode);
    return mutableNode;
  }
  /**
   * Returns the text content of the node. Override this for
   * custom nodes that should have a representation in plain text
   * format (for copy + paste, for example)
   *
   */
  getTextContent() {
    return "";
  }
  /**
   * Returns the length of the string produced by calling getTextContent on this node.
   *
   */
  getTextContentSize() {
    return this.getTextContent().length;
  }
  // View
  /**
   * Called during the reconciliation process to determine which nodes
   * to insert into the DOM for this Lexical Node.
   *
   * This method must return exactly one HTMLElement. Nested elements are not supported.
   *
   * Do not attempt to update the Lexical EditorState during this phase of the update lifecyle.
   *
   * @param _config - allows access to things like the EditorTheme (to apply classes) during reconciliation.
   * @param _editor - allows access to the editor for context during reconciliation.
   *
   * */
  createDOM(_config, _editor) {
    {
      throw Error(`createDOM: base method not extended`);
    }
  }
  /**
   * Called when a node changes and should update the DOM
   * in whatever way is necessary to make it align with any changes that might
   * have happened during the update.
   *
   * Returning "true" here will cause lexical to unmount and recreate the DOM node
   * (by calling createDOM). You would need to do this if the element tag changes,
   * for instance.
   *
   * */
  updateDOM(_prevNode, _dom, _config) {
    {
      throw Error(`updateDOM: base method not extended`);
    }
  }
  /**
   * Controls how the this node is serialized to HTML. This is important for
   * copy and paste between Lexical and non-Lexical editors, or Lexical editors with different namespaces,
   * in which case the primary transfer format is HTML. It's also important if you're serializing
   * to HTML for any other reason via {@link @lexical/html!$generateHtmlFromNodes}. You could
   * also use this method to build your own HTML renderer.
   *
   * */
  exportDOM(editor) {
    const element2 = this.createDOM(editor._config, editor);
    return {
      element: element2
    };
  }
  /**
   * Controls how the this node is serialized to JSON. This is important for
   * copy and paste between Lexical editors sharing the same namespace. It's also important
   * if you're serializing to JSON for persistent storage somewhere.
   * See [Serialization & Deserialization](https://lexical.dev/docs/concepts/serialization#lexical---html).
   *
   * */
  exportJSON() {
    return {
      type: this.__type,
      version: 1
    };
  }
  /**
   * Controls how the this node is deserialized from JSON. This is usually boilerplate,
   * but provides an abstraction between the node implementation and serialized interface that can
   * be important if you ever make breaking changes to a node schema (by adding or removing properties).
   * See [Serialization & Deserialization](https://lexical.dev/docs/concepts/serialization#lexical---html).
   *
   * */
  static importJSON(_serializedNode) {
    {
      throw Error(`LexicalNode: Node ${this.name} does not implement .importJSON().`);
    }
  }
  /**
   * Update this LexicalNode instance from serialized JSON. It's recommended
   * to implement as much logic as possible in this method instead of the
   * static importJSON method, so that the functionality can be inherited in subclasses.
   *
   * The LexicalUpdateJSON utility type should be used to ignore any type, version,
   * or children properties in the JSON so that the extended JSON from subclasses
   * are acceptable parameters for the super call.
   *
   * If overridden, this method must call super.
   *
   * @example
   * ```ts
   * class MyTextNode extends TextNode {
   *   // ...
   *   static importJSON(serializedNode: SerializedMyTextNode): MyTextNode {
   *     return $createMyTextNode()
   *       .updateFromJSON(serializedNode);
   *   }
   *   updateFromJSON(
   *     serializedNode: LexicalUpdateJSON<SerializedMyTextNode>,
   *   ): this {
   *     return super.updateFromJSON(serializedNode)
   *       .setMyProperty(serializedNode.myProperty);
   *   }
   * }
   * ```
   **/
  updateFromJSON(serializedNode) {
    return this;
  }
  /**
   * @experimental
   *
   * Registers the returned function as a transform on the node during
   * Editor initialization. Most such use cases should be addressed via
   * the {@link LexicalEditor.registerNodeTransform} API.
   *
   * Experimental - use at your own risk.
   */
  static transform() {
    return null;
  }
  // Setters and mutators
  /**
   * Removes this LexicalNode from the EditorState. If the node isn't re-inserted
   * somewhere, the Lexical garbage collector will eventually clean it up.
   *
   * @param preserveEmptyParent - If falsy, the node's parent will be removed if
   * it's empty after the removal operation. This is the default behavior, subject to
   * other node heuristics such as {@link ElementNode#canBeEmpty}
   * */
  remove(preserveEmptyParent) {
    $removeNode(this, true, preserveEmptyParent);
  }
  /**
   * Replaces this LexicalNode with the provided node, optionally transferring the children
   * of the replaced node to the replacing node.
   *
   * @param replaceWith - The node to replace this one with.
   * @param includeChildren - Whether or not to transfer the children of this node to the replacing node.
   * */
  replace(replaceWith, includeChildren) {
    errorOnReadOnly();
    let selection2 = $getSelection();
    if (selection2 !== null) {
      selection2 = selection2.clone();
    }
    errorOnInsertTextNodeOnRoot(this, replaceWith);
    const self2 = this.getLatest();
    const toReplaceKey = this.__key;
    const key2 = replaceWith.__key;
    const writableReplaceWith = replaceWith.getWritable();
    const writableParent = this.getParentOrThrow().getWritable();
    const size4 = writableParent.__size;
    removeFromParent(writableReplaceWith);
    const prevSibling = self2.getPreviousSibling();
    const nextSibling = self2.getNextSibling();
    const prevKey = self2.__prev;
    const nextKey = self2.__next;
    const parentKey = self2.__parent;
    $removeNode(self2, false, true);
    if (prevSibling === null) {
      writableParent.__first = key2;
    } else {
      const writablePrevSibling = prevSibling.getWritable();
      writablePrevSibling.__next = key2;
    }
    writableReplaceWith.__prev = prevKey;
    if (nextSibling === null) {
      writableParent.__last = key2;
    } else {
      const writableNextSibling = nextSibling.getWritable();
      writableNextSibling.__prev = key2;
    }
    writableReplaceWith.__next = nextKey;
    writableReplaceWith.__parent = parentKey;
    writableParent.__size = size4;
    if (includeChildren) {
      if (!($isElementNode(this) && $isElementNode(writableReplaceWith))) {
        throw Error(`includeChildren should only be true for ElementNodes`);
      }
      this.getChildren().forEach((child) => {
        writableReplaceWith.append(child);
      });
    }
    if ($isRangeSelection(selection2)) {
      $setSelection(selection2);
      const anchor = selection2.anchor;
      const focus2 = selection2.focus;
      if (anchor.key === toReplaceKey) {
        $moveSelectionPointToEnd(anchor, writableReplaceWith);
      }
      if (focus2.key === toReplaceKey) {
        $moveSelectionPointToEnd(focus2, writableReplaceWith);
      }
    }
    if ($getCompositionKey() === toReplaceKey) {
      $setCompositionKey(key2);
    }
    return writableReplaceWith;
  }
  /**
   * Inserts a node after this LexicalNode (as the next sibling).
   *
   * @param nodeToInsert - The node to insert after this one.
   * @param restoreSelection - Whether or not to attempt to resolve the
   * selection to the appropriate place after the operation is complete.
   * */
  insertAfter(nodeToInsert, restoreSelection = true) {
    errorOnReadOnly();
    errorOnInsertTextNodeOnRoot(this, nodeToInsert);
    const writableSelf = this.getWritable();
    const writableNodeToInsert = nodeToInsert.getWritable();
    const oldParent = writableNodeToInsert.getParent();
    const selection2 = $getSelection();
    let elementAnchorSelectionOnNode = false;
    let elementFocusSelectionOnNode = false;
    if (oldParent !== null) {
      const oldIndex = nodeToInsert.getIndexWithinParent();
      removeFromParent(writableNodeToInsert);
      if ($isRangeSelection(selection2)) {
        const oldParentKey = oldParent.__key;
        const anchor = selection2.anchor;
        const focus2 = selection2.focus;
        elementAnchorSelectionOnNode = anchor.type === "element" && anchor.key === oldParentKey && anchor.offset === oldIndex + 1;
        elementFocusSelectionOnNode = focus2.type === "element" && focus2.key === oldParentKey && focus2.offset === oldIndex + 1;
      }
    }
    const nextSibling = this.getNextSibling();
    const writableParent = this.getParentOrThrow().getWritable();
    const insertKey = writableNodeToInsert.__key;
    const nextKey = writableSelf.__next;
    if (nextSibling === null) {
      writableParent.__last = insertKey;
    } else {
      const writableNextSibling = nextSibling.getWritable();
      writableNextSibling.__prev = insertKey;
    }
    writableParent.__size++;
    writableSelf.__next = insertKey;
    writableNodeToInsert.__next = nextKey;
    writableNodeToInsert.__prev = writableSelf.__key;
    writableNodeToInsert.__parent = writableSelf.__parent;
    if (restoreSelection && $isRangeSelection(selection2)) {
      const index3 = this.getIndexWithinParent();
      $updateElementSelectionOnCreateDeleteNode(selection2, writableParent, index3 + 1);
      const writableParentKey = writableParent.__key;
      if (elementAnchorSelectionOnNode) {
        selection2.anchor.set(writableParentKey, index3 + 2, "element");
      }
      if (elementFocusSelectionOnNode) {
        selection2.focus.set(writableParentKey, index3 + 2, "element");
      }
    }
    return nodeToInsert;
  }
  /**
   * Inserts a node before this LexicalNode (as the previous sibling).
   *
   * @param nodeToInsert - The node to insert before this one.
   * @param restoreSelection - Whether or not to attempt to resolve the
   * selection to the appropriate place after the operation is complete.
   * */
  insertBefore(nodeToInsert, restoreSelection = true) {
    errorOnReadOnly();
    errorOnInsertTextNodeOnRoot(this, nodeToInsert);
    const writableSelf = this.getWritable();
    const writableNodeToInsert = nodeToInsert.getWritable();
    const insertKey = writableNodeToInsert.__key;
    removeFromParent(writableNodeToInsert);
    const prevSibling = this.getPreviousSibling();
    const writableParent = this.getParentOrThrow().getWritable();
    const prevKey = writableSelf.__prev;
    const index3 = this.getIndexWithinParent();
    if (prevSibling === null) {
      writableParent.__first = insertKey;
    } else {
      const writablePrevSibling = prevSibling.getWritable();
      writablePrevSibling.__next = insertKey;
    }
    writableParent.__size++;
    writableSelf.__prev = insertKey;
    writableNodeToInsert.__prev = prevKey;
    writableNodeToInsert.__next = writableSelf.__key;
    writableNodeToInsert.__parent = writableSelf.__parent;
    const selection2 = $getSelection();
    if (restoreSelection && $isRangeSelection(selection2)) {
      const parent = this.getParentOrThrow();
      $updateElementSelectionOnCreateDeleteNode(selection2, parent, index3);
    }
    return nodeToInsert;
  }
  /**
   * Whether or not this node has a required parent. Used during copy + paste operations
   * to normalize nodes that would otherwise be orphaned. For example, ListItemNodes without
   * a ListNode parent or TextNodes with a ParagraphNode parent.
   *
   * */
  isParentRequired() {
    return false;
  }
  /**
   * The creation logic for any required parent. Should be implemented if {@link isParentRequired} returns true.
   *
   * */
  createParentElementNode() {
    return $createParagraphNode();
  }
  selectStart() {
    return this.selectPrevious();
  }
  selectEnd() {
    return this.selectNext(0, 0);
  }
  /**
   * Moves selection to the previous sibling of this node, at the specified offsets.
   *
   * @param anchorOffset - The anchor offset for selection.
   * @param focusOffset -  The focus offset for selection
   * */
  selectPrevious(anchorOffset, focusOffset) {
    errorOnReadOnly();
    const prevSibling = this.getPreviousSibling();
    const parent = this.getParentOrThrow();
    if (prevSibling === null) {
      return parent.select(0, 0);
    }
    if ($isElementNode(prevSibling)) {
      return prevSibling.select();
    } else if (!$isTextNode(prevSibling)) {
      const index3 = prevSibling.getIndexWithinParent() + 1;
      return parent.select(index3, index3);
    }
    return prevSibling.select(anchorOffset, focusOffset);
  }
  /**
   * Moves selection to the next sibling of this node, at the specified offsets.
   *
   * @param anchorOffset - The anchor offset for selection.
   * @param focusOffset -  The focus offset for selection
   * */
  selectNext(anchorOffset, focusOffset) {
    errorOnReadOnly();
    const nextSibling = this.getNextSibling();
    const parent = this.getParentOrThrow();
    if (nextSibling === null) {
      return parent.select();
    }
    if ($isElementNode(nextSibling)) {
      return nextSibling.select(0, 0);
    } else if (!$isTextNode(nextSibling)) {
      const index3 = nextSibling.getIndexWithinParent();
      return parent.select(index3, index3);
    }
    return nextSibling.select(anchorOffset, focusOffset);
  }
  /**
   * Marks a node dirty, triggering transforms and
   * forcing it to be reconciled during the update cycle.
   *
   * */
  markDirty() {
    this.getWritable();
  }
  /**
   * @internal
   *
   * When the reconciler detects that a node was mutated, this method
   * may be called to restore the node to a known good state.
   */
  reconcileObservedMutation(dom, editor) {
    this.markDirty();
  }
};
function errorOnTypeKlassMismatch(type2, klass) {
  const registeredNode = getActiveEditor()._nodes.get(type2);
  if (registeredNode === void 0) {
    {
      throw Error(`Create node: Attempted to create node ${klass.name} that was not configured to be used on the editor.`);
    }
  }
  const editorKlass = registeredNode.klass;
  if (editorKlass !== klass) {
    {
      throw Error(`Create node: Type ${type2} in node ${klass.name} does not match registered node ${editorKlass.name} with the same type`);
    }
  }
}
function insertRangeAfter(node2, firstToInsert, lastToInsert) {
  const lastToInsert2 = firstToInsert.getParentOrThrow().getLastChild();
  let current2 = firstToInsert;
  const nodesToInsert = [firstToInsert];
  while (current2 !== lastToInsert2) {
    if (!current2.getNextSibling()) {
      {
        throw Error(`insertRangeAfter: lastToInsert must be a later sibling of firstToInsert`);
      }
    }
    current2 = current2.getNextSibling();
    nodesToInsert.push(current2);
  }
  let currentNode = node2;
  for (const nodeToInsert of nodesToInsert) {
    currentNode = currentNode.insertAfter(nodeToInsert);
  }
}
var LineBreakNode = class _LineBreakNode extends LexicalNode {
  static getType() {
    return "linebreak";
  }
  static clone(node2) {
    return new _LineBreakNode(node2.__key);
  }
  constructor(key2) {
    super(key2);
  }
  getTextContent() {
    return "\n";
  }
  createDOM() {
    return document.createElement("br");
  }
  updateDOM() {
    return false;
  }
  static importDOM() {
    return {
      br: (node2) => {
        if (isOnlyChildInBlockNode(node2) || isLastChildInBlockNode(node2)) {
          return null;
        }
        return {
          conversion: $convertLineBreakElement,
          priority: 0
        };
      }
    };
  }
  static importJSON(serializedLineBreakNode) {
    return $createLineBreakNode().updateFromJSON(serializedLineBreakNode);
  }
};
function $convertLineBreakElement(node2) {
  return {
    node: $createLineBreakNode()
  };
}
function $createLineBreakNode() {
  return $applyNodeReplacement(new LineBreakNode());
}
function $isLineBreakNode(node2) {
  return node2 instanceof LineBreakNode;
}
function isOnlyChildInBlockNode(node2) {
  const parentElement = node2.parentElement;
  if (parentElement !== null && isBlockDomNode(parentElement)) {
    const firstChild = parentElement.firstChild;
    if (firstChild === node2 || firstChild.nextSibling === node2 && isWhitespaceDomTextNode(firstChild)) {
      const lastChild = parentElement.lastChild;
      if (lastChild === node2 || lastChild.previousSibling === node2 && isWhitespaceDomTextNode(lastChild)) {
        return true;
      }
    }
  }
  return false;
}
function isLastChildInBlockNode(node2) {
  const parentElement = node2.parentElement;
  if (parentElement !== null && isBlockDomNode(parentElement)) {
    const firstChild = parentElement.firstChild;
    if (firstChild === node2 || firstChild.nextSibling === node2 && isWhitespaceDomTextNode(firstChild)) {
      return false;
    }
    const lastChild = parentElement.lastChild;
    if (lastChild === node2 || lastChild.previousSibling === node2 && isWhitespaceDomTextNode(lastChild)) {
      return true;
    }
  }
  return false;
}
function isWhitespaceDomTextNode(node2) {
  return isDOMTextNode(node2) && /^( |\t|\r?\n)+$/.test(node2.textContent || "");
}
function getElementOuterTag(node2, format) {
  if (format & IS_CODE) {
    return "code";
  }
  if (format & IS_HIGHLIGHT) {
    return "mark";
  }
  if (format & IS_SUBSCRIPT) {
    return "sub";
  }
  if (format & IS_SUPERSCRIPT) {
    return "sup";
  }
  return null;
}
function getElementInnerTag(node2, format) {
  if (format & IS_BOLD) {
    return "strong";
  }
  if (format & IS_ITALIC) {
    return "em";
  }
  return "span";
}
function setTextThemeClassNames(tag, prevFormat, nextFormat, dom, textClassNames) {
  const domClassList = dom.classList;
  let classNames14 = getCachedClassNameArray(textClassNames, "base");
  if (classNames14 !== void 0) {
    domClassList.add(...classNames14);
  }
  classNames14 = getCachedClassNameArray(textClassNames, "underlineStrikethrough");
  let hasUnderlineStrikethrough = false;
  const prevUnderlineStrikethrough = prevFormat & IS_UNDERLINE && prevFormat & IS_STRIKETHROUGH;
  const nextUnderlineStrikethrough = nextFormat & IS_UNDERLINE && nextFormat & IS_STRIKETHROUGH;
  if (classNames14 !== void 0) {
    if (nextUnderlineStrikethrough) {
      hasUnderlineStrikethrough = true;
      if (!prevUnderlineStrikethrough) {
        domClassList.add(...classNames14);
      }
    } else if (prevUnderlineStrikethrough) {
      domClassList.remove(...classNames14);
    }
  }
  for (const key2 in TEXT_TYPE_TO_FORMAT) {
    const format = key2;
    const flag = TEXT_TYPE_TO_FORMAT[format];
    classNames14 = getCachedClassNameArray(textClassNames, key2);
    if (classNames14 !== void 0) {
      if (nextFormat & flag) {
        if (hasUnderlineStrikethrough && (key2 === "underline" || key2 === "strikethrough")) {
          if (prevFormat & flag) {
            domClassList.remove(...classNames14);
          }
          continue;
        }
        if ((prevFormat & flag) === 0 || prevUnderlineStrikethrough && key2 === "underline" || key2 === "strikethrough") {
          domClassList.add(...classNames14);
        }
      } else if (prevFormat & flag) {
        domClassList.remove(...classNames14);
      }
    }
  }
}
function diffComposedText(a2, b3) {
  const aLength = a2.length;
  const bLength = b3.length;
  let left = 0;
  let right = 0;
  while (left < aLength && left < bLength && a2[left] === b3[left]) {
    left++;
  }
  while (right + left < aLength && right + left < bLength && a2[aLength - right - 1] === b3[bLength - right - 1]) {
    right++;
  }
  return [left, aLength - left - right, b3.slice(left, bLength - right)];
}
function setTextContent(nextText, dom, node2) {
  const firstChild = dom.firstChild;
  const isComposing = node2.isComposing();
  const suffix = isComposing ? COMPOSITION_SUFFIX : "";
  const text4 = nextText + suffix;
  if (firstChild == null) {
    dom.textContent = text4;
  } else {
    const nodeValue = firstChild.nodeValue;
    if (nodeValue !== text4) {
      if (isComposing || IS_FIREFOX) {
        const [index3, remove, insert2] = diffComposedText(nodeValue, text4);
        if (remove !== 0) {
          firstChild.deleteData(index3, remove);
        }
        firstChild.insertData(index3, insert2);
      } else {
        firstChild.nodeValue = text4;
      }
    }
  }
}
function createTextInnerDOM(innerDOM, node2, innerTag, format, text4, config) {
  setTextContent(text4, innerDOM, node2);
  const theme = config.theme;
  const textClassNames = theme.text;
  if (textClassNames !== void 0) {
    setTextThemeClassNames(innerTag, 0, format, innerDOM, textClassNames);
  }
}
function wrapElementWith(element2, tag) {
  const el = document.createElement(tag);
  el.appendChild(element2);
  return el;
}
var TextNode = class _TextNode extends LexicalNode {
  /** @internal */
  /** @internal */
  /** @internal */
  /** @internal */
  static getType() {
    return "text";
  }
  static clone(node2) {
    return new _TextNode(node2.__text, node2.__key);
  }
  afterCloneFrom(prevNode) {
    super.afterCloneFrom(prevNode);
    this.__text = prevNode.__text;
    this.__format = prevNode.__format;
    this.__style = prevNode.__style;
    this.__mode = prevNode.__mode;
    this.__detail = prevNode.__detail;
  }
  constructor(text4 = "", key2) {
    super(key2);
    this.__text = text4;
    this.__format = 0;
    this.__style = "";
    this.__mode = 0;
    this.__detail = 0;
  }
  /**
   * Returns a 32-bit integer that represents the TextFormatTypes currently applied to the
   * TextNode. You probably don't want to use this method directly - consider using TextNode.hasFormat instead.
   *
   * @returns a number representing the format of the text node.
   */
  getFormat() {
    const self2 = this.getLatest();
    return self2.__format;
  }
  /**
   * Returns a 32-bit integer that represents the TextDetailTypes currently applied to the
   * TextNode. You probably don't want to use this method directly - consider using TextNode.isDirectionless
   * or TextNode.isUnmergeable instead.
   *
   * @returns a number representing the detail of the text node.
   */
  getDetail() {
    const self2 = this.getLatest();
    return self2.__detail;
  }
  /**
   * Returns the mode (TextModeType) of the TextNode, which may be "normal", "token", or "segmented"
   *
   * @returns TextModeType.
   */
  getMode() {
    const self2 = this.getLatest();
    return TEXT_TYPE_TO_MODE[self2.__mode];
  }
  /**
   * Returns the styles currently applied to the node. This is analogous to CSSText in the DOM.
   *
   * @returns CSSText-like string of styles applied to the underlying DOM node.
   */
  getStyle() {
    const self2 = this.getLatest();
    return self2.__style;
  }
  /**
   * Returns whether or not the node is in "token" mode. TextNodes in token mode can be navigated through character-by-character
   * with a RangeSelection, but are deleted as a single entity (not invdividually by character).
   *
   * @returns true if the node is in token mode, false otherwise.
   */
  isToken() {
    const self2 = this.getLatest();
    return self2.__mode === IS_TOKEN;
  }
  /**
   *
   * @returns true if Lexical detects that an IME or other 3rd-party script is attempting to
   * mutate the TextNode, false otherwise.
   */
  isComposing() {
    return this.__key === $getCompositionKey();
  }
  /**
   * Returns whether or not the node is in "segemented" mode. TextNodes in segemented mode can be navigated through character-by-character
   * with a RangeSelection, but are deleted in space-delimited "segments".
   *
   * @returns true if the node is in segmented mode, false otherwise.
   */
  isSegmented() {
    const self2 = this.getLatest();
    return self2.__mode === IS_SEGMENTED;
  }
  /**
   * Returns whether or not the node is "directionless". Directionless nodes don't respect changes between RTL and LTR modes.
   *
   * @returns true if the node is directionless, false otherwise.
   */
  isDirectionless() {
    const self2 = this.getLatest();
    return (self2.__detail & IS_DIRECTIONLESS) !== 0;
  }
  /**
   * Returns whether or not the node is unmergeable. In some scenarios, Lexical tries to merge
   * adjacent TextNodes into a single TextNode. If a TextNode is unmergeable, this won't happen.
   *
   * @returns true if the node is unmergeable, false otherwise.
   */
  isUnmergeable() {
    const self2 = this.getLatest();
    return (self2.__detail & IS_UNMERGEABLE) !== 0;
  }
  /**
   * Returns whether or not the node has the provided format applied. Use this with the human-readable TextFormatType
   * string values to get the format of a TextNode.
   *
   * @param type - the TextFormatType to check for.
   *
   * @returns true if the node has the provided format, false otherwise.
   */
  hasFormat(type2) {
    const formatFlag = TEXT_TYPE_TO_FORMAT[type2];
    return (this.getFormat() & formatFlag) !== 0;
  }
  /**
   * Returns whether or not the node is simple text. Simple text is defined as a TextNode that has the string type "text"
   * (i.e., not a subclass) and has no mode applied to it (i.e., not segmented or token).
   *
   * @returns true if the node is simple text, false otherwise.
   */
  isSimpleText() {
    return this.__type === "text" && this.__mode === 0;
  }
  /**
   * Returns the text content of the node as a string.
   *
   * @returns a string representing the text content of the node.
   */
  getTextContent() {
    const self2 = this.getLatest();
    return self2.__text;
  }
  /**
   * Returns the format flags applied to the node as a 32-bit integer.
   *
   * @returns a number representing the TextFormatTypes applied to the node.
   */
  getFormatFlags(type2, alignWithFormat) {
    const self2 = this.getLatest();
    const format = self2.__format;
    return toggleTextFormatType(format, type2, alignWithFormat);
  }
  /**
   *
   * @returns true if the text node supports font styling, false otherwise.
   */
  canHaveFormat() {
    return true;
  }
  // View
  createDOM(config, editor) {
    const format = this.__format;
    const outerTag = getElementOuterTag(this, format);
    const innerTag = getElementInnerTag(this, format);
    const tag = outerTag === null ? innerTag : outerTag;
    const dom = document.createElement(tag);
    let innerDOM = dom;
    if (this.hasFormat("code")) {
      dom.setAttribute("spellcheck", "false");
    }
    if (outerTag !== null) {
      innerDOM = document.createElement(innerTag);
      dom.appendChild(innerDOM);
    }
    const text4 = this.__text;
    createTextInnerDOM(innerDOM, this, innerTag, format, text4, config);
    const style = this.__style;
    if (style !== "") {
      dom.style.cssText = style;
    }
    return dom;
  }
  updateDOM(prevNode, dom, config) {
    const nextText = this.__text;
    const prevFormat = prevNode.__format;
    const nextFormat = this.__format;
    const prevOuterTag = getElementOuterTag(this, prevFormat);
    const nextOuterTag = getElementOuterTag(this, nextFormat);
    const prevInnerTag = getElementInnerTag(this, prevFormat);
    const nextInnerTag = getElementInnerTag(this, nextFormat);
    const prevTag = prevOuterTag === null ? prevInnerTag : prevOuterTag;
    const nextTag = nextOuterTag === null ? nextInnerTag : nextOuterTag;
    if (prevTag !== nextTag) {
      return true;
    }
    if (prevOuterTag === nextOuterTag && prevInnerTag !== nextInnerTag) {
      const prevInnerDOM = dom.firstChild;
      if (prevInnerDOM == null) {
        {
          throw Error(`updateDOM: prevInnerDOM is null or undefined`);
        }
      }
      const nextInnerDOM = document.createElement(nextInnerTag);
      createTextInnerDOM(nextInnerDOM, this, nextInnerTag, nextFormat, nextText, config);
      dom.replaceChild(nextInnerDOM, prevInnerDOM);
      return false;
    }
    let innerDOM = dom;
    if (nextOuterTag !== null) {
      if (prevOuterTag !== null) {
        innerDOM = dom.firstChild;
        if (innerDOM == null) {
          {
            throw Error(`updateDOM: innerDOM is null or undefined`);
          }
        }
      }
    }
    setTextContent(nextText, innerDOM, this);
    const theme = config.theme;
    const textClassNames = theme.text;
    if (textClassNames !== void 0 && prevFormat !== nextFormat) {
      setTextThemeClassNames(nextInnerTag, prevFormat, nextFormat, innerDOM, textClassNames);
    }
    const prevStyle = prevNode.__style;
    const nextStyle = this.__style;
    if (prevStyle !== nextStyle) {
      dom.style.cssText = nextStyle;
    }
    return false;
  }
  static importDOM() {
    return {
      "#text": () => ({
        conversion: $convertTextDOMNode,
        priority: 0
      }),
      b: () => ({
        conversion: convertBringAttentionToElement,
        priority: 0
      }),
      code: () => ({
        conversion: convertTextFormatElement,
        priority: 0
      }),
      em: () => ({
        conversion: convertTextFormatElement,
        priority: 0
      }),
      i: () => ({
        conversion: convertTextFormatElement,
        priority: 0
      }),
      s: () => ({
        conversion: convertTextFormatElement,
        priority: 0
      }),
      span: () => ({
        conversion: convertSpanElement,
        priority: 0
      }),
      strong: () => ({
        conversion: convertTextFormatElement,
        priority: 0
      }),
      sub: () => ({
        conversion: convertTextFormatElement,
        priority: 0
      }),
      sup: () => ({
        conversion: convertTextFormatElement,
        priority: 0
      }),
      u: () => ({
        conversion: convertTextFormatElement,
        priority: 0
      })
    };
  }
  static importJSON(serializedNode) {
    return $createTextNode().updateFromJSON(serializedNode);
  }
  updateFromJSON(serializedNode) {
    return super.updateFromJSON(serializedNode).setTextContent(serializedNode.text).setFormat(serializedNode.format).setDetail(serializedNode.detail).setMode(serializedNode.mode).setStyle(serializedNode.style);
  }
  // This improves Lexical's basic text output in copy+paste plus
  // for headless mode where people might use Lexical to generate
  // HTML content and not have the ability to use CSS classes.
  exportDOM(editor) {
    let {
      element: element2
    } = super.exportDOM(editor);
    if (!isHTMLElement(element2)) {
      throw Error(`Expected TextNode createDOM to always return a HTMLElement`);
    }
    element2.style.whiteSpace = "pre-wrap";
    if (this.hasFormat("bold")) {
      element2 = wrapElementWith(element2, "b");
    }
    if (this.hasFormat("italic")) {
      element2 = wrapElementWith(element2, "i");
    }
    if (this.hasFormat("strikethrough")) {
      element2 = wrapElementWith(element2, "s");
    }
    if (this.hasFormat("underline")) {
      element2 = wrapElementWith(element2, "u");
    }
    return {
      element: element2
    };
  }
  exportJSON() {
    return {
      detail: this.getDetail(),
      format: this.getFormat(),
      mode: this.getMode(),
      style: this.getStyle(),
      text: this.getTextContent(),
      // As an exception here we invoke super at the end for historical reasons.
      // Namely, to preserve the order of the properties and not to break the tests
      // that use the serialized string representation.
      ...super.exportJSON()
    };
  }
  // Mutators
  selectionTransform(prevSelection, nextSelection) {
    return;
  }
  /**
   * Sets the node format to the provided TextFormatType or 32-bit integer. Note that the TextFormatType
   * version of the argument can only specify one format and doing so will remove all other formats that
   * may be applied to the node. For toggling behavior, consider using {@link TextNode.toggleFormat}
   *
   * @param format - TextFormatType or 32-bit integer representing the node format.
   *
   * @returns this TextNode.
   * // TODO 0.12 This should just be a `string`.
   */
  setFormat(format) {
    const self2 = this.getWritable();
    self2.__format = typeof format === "string" ? TEXT_TYPE_TO_FORMAT[format] : format;
    return self2;
  }
  /**
   * Sets the node detail to the provided TextDetailType or 32-bit integer. Note that the TextDetailType
   * version of the argument can only specify one detail value and doing so will remove all other detail values that
   * may be applied to the node. For toggling behavior, consider using {@link TextNode.toggleDirectionless}
   * or {@link TextNode.toggleUnmergeable}
   *
   * @param detail - TextDetailType or 32-bit integer representing the node detail.
   *
   * @returns this TextNode.
   * // TODO 0.12 This should just be a `string`.
   */
  setDetail(detail) {
    const self2 = this.getWritable();
    self2.__detail = typeof detail === "string" ? DETAIL_TYPE_TO_DETAIL[detail] : detail;
    return self2;
  }
  /**
   * Sets the node style to the provided CSSText-like string. Set this property as you
   * would an HTMLElement style attribute to apply inline styles to the underlying DOM Element.
   *
   * @param style - CSSText to be applied to the underlying HTMLElement.
   *
   * @returns this TextNode.
   */
  setStyle(style) {
    const self2 = this.getWritable();
    self2.__style = style;
    return self2;
  }
  /**
   * Applies the provided format to this TextNode if it's not present. Removes it if it's present.
   * The subscript and superscript formats are mutually exclusive.
   * Prefer using this method to turn specific formats on and off.
   *
   * @param type - TextFormatType to toggle.
   *
   * @returns this TextNode.
   */
  toggleFormat(type2) {
    const format = this.getFormat();
    const newFormat = toggleTextFormatType(format, type2, null);
    return this.setFormat(newFormat);
  }
  /**
   * Toggles the directionless detail value of the node. Prefer using this method over setDetail.
   *
   * @returns this TextNode.
   */
  toggleDirectionless() {
    const self2 = this.getWritable();
    self2.__detail ^= IS_DIRECTIONLESS;
    return self2;
  }
  /**
   * Toggles the unmergeable detail value of the node. Prefer using this method over setDetail.
   *
   * @returns this TextNode.
   */
  toggleUnmergeable() {
    const self2 = this.getWritable();
    self2.__detail ^= IS_UNMERGEABLE;
    return self2;
  }
  /**
   * Sets the mode of the node.
   *
   * @returns this TextNode.
   */
  setMode(type2) {
    const mode = TEXT_MODE_TO_TYPE[type2];
    if (this.__mode === mode) {
      return this;
    }
    const self2 = this.getWritable();
    self2.__mode = mode;
    return self2;
  }
  /**
   * Sets the text content of the node.
   *
   * @param text - the string to set as the text value of the node.
   *
   * @returns this TextNode.
   */
  setTextContent(text4) {
    if (this.__text === text4) {
      return this;
    }
    const self2 = this.getWritable();
    self2.__text = text4;
    return self2;
  }
  /**
   * Sets the current Lexical selection to be a RangeSelection with anchor and focus on this TextNode at the provided offsets.
   *
   * @param _anchorOffset - the offset at which the Selection anchor will be placed.
   * @param _focusOffset - the offset at which the Selection focus will be placed.
   *
   * @returns the new RangeSelection.
   */
  select(_anchorOffset, _focusOffset) {
    errorOnReadOnly();
    let anchorOffset = _anchorOffset;
    let focusOffset = _focusOffset;
    const selection2 = $getSelection();
    const text4 = this.getTextContent();
    const key2 = this.__key;
    if (typeof text4 === "string") {
      const lastOffset = text4.length;
      if (anchorOffset === void 0) {
        anchorOffset = lastOffset;
      }
      if (focusOffset === void 0) {
        focusOffset = lastOffset;
      }
    } else {
      anchorOffset = 0;
      focusOffset = 0;
    }
    if (!$isRangeSelection(selection2)) {
      return $internalMakeRangeSelection(key2, anchorOffset, key2, focusOffset, "text", "text");
    } else {
      const compositionKey = $getCompositionKey();
      if (compositionKey === selection2.anchor.key || compositionKey === selection2.focus.key) {
        $setCompositionKey(key2);
      }
      selection2.setTextNodeRange(this, anchorOffset, this, focusOffset);
    }
    return selection2;
  }
  selectStart() {
    return this.select(0, 0);
  }
  selectEnd() {
    const size4 = this.getTextContentSize();
    return this.select(size4, size4);
  }
  /**
   * Inserts the provided text into this TextNode at the provided offset, deleting the number of characters
   * specified. Can optionally calculate a new selection after the operation is complete.
   *
   * @param offset - the offset at which the splice operation should begin.
   * @param delCount - the number of characters to delete, starting from the offset.
   * @param newText - the text to insert into the TextNode at the offset.
   * @param moveSelection - optional, whether or not to move selection to the end of the inserted substring.
   *
   * @returns this TextNode.
   */
  spliceText(offset5, delCount, newText, moveSelection) {
    const writableSelf = this.getWritable();
    const text4 = writableSelf.__text;
    const handledTextLength = newText.length;
    let index3 = offset5;
    if (index3 < 0) {
      index3 = handledTextLength + index3;
      if (index3 < 0) {
        index3 = 0;
      }
    }
    const selection2 = $getSelection();
    if (moveSelection && $isRangeSelection(selection2)) {
      const newOffset = offset5 + handledTextLength;
      selection2.setTextNodeRange(writableSelf, newOffset, writableSelf, newOffset);
    }
    const updatedText = text4.slice(0, index3) + newText + text4.slice(index3 + delCount);
    writableSelf.__text = updatedText;
    return writableSelf;
  }
  /**
   * This method is meant to be overriden by TextNode subclasses to control the behavior of those nodes
   * when a user event would cause text to be inserted before them in the editor. If true, Lexical will attempt
   * to insert text into this node. If false, it will insert the text in a new sibling node.
   *
   * @returns true if text can be inserted before the node, false otherwise.
   */
  canInsertTextBefore() {
    return true;
  }
  /**
   * This method is meant to be overriden by TextNode subclasses to control the behavior of those nodes
   * when a user event would cause text to be inserted after them in the editor. If true, Lexical will attempt
   * to insert text into this node. If false, it will insert the text in a new sibling node.
   *
   * @returns true if text can be inserted after the node, false otherwise.
   */
  canInsertTextAfter() {
    return true;
  }
  /**
   * Splits this TextNode at the provided character offsets, forming new TextNodes from the substrings
   * formed by the split, and inserting those new TextNodes into the editor, replacing the one that was split.
   *
   * @param splitOffsets - rest param of the text content character offsets at which this node should be split.
   *
   * @returns an Array containing the newly-created TextNodes.
   */
  splitText(...splitOffsets) {
    errorOnReadOnly();
    const self2 = this.getLatest();
    const textContent = self2.getTextContent();
    const key2 = self2.__key;
    const compositionKey = $getCompositionKey();
    const offsetsSet = new Set(splitOffsets);
    const parts = [];
    const textLength = textContent.length;
    let string3 = "";
    for (let i3 = 0; i3 < textLength; i3++) {
      if (string3 !== "" && offsetsSet.has(i3)) {
        parts.push(string3);
        string3 = "";
      }
      string3 += textContent[i3];
    }
    if (string3 !== "") {
      parts.push(string3);
    }
    const partsLength = parts.length;
    if (partsLength === 0) {
      return [];
    } else if (parts[0] === textContent) {
      return [self2];
    }
    const firstPart = parts[0];
    const parent = self2.getParent();
    let writableNode;
    const format = self2.getFormat();
    const style = self2.getStyle();
    const detail = self2.__detail;
    let hasReplacedSelf = false;
    if (self2.isSegmented()) {
      writableNode = $createTextNode(firstPart);
      writableNode.__format = format;
      writableNode.__style = style;
      writableNode.__detail = detail;
      hasReplacedSelf = true;
    } else {
      writableNode = self2.getWritable();
      writableNode.__text = firstPart;
    }
    const selection2 = $getSelection();
    const splitNodes = [writableNode];
    let textSize = firstPart.length;
    for (let i3 = 1; i3 < partsLength; i3++) {
      const part = parts[i3];
      const partSize = part.length;
      const sibling2 = $createTextNode(part).getWritable();
      sibling2.__format = format;
      sibling2.__style = style;
      sibling2.__detail = detail;
      const siblingKey = sibling2.__key;
      const nextTextSize = textSize + partSize;
      if ($isRangeSelection(selection2)) {
        const anchor = selection2.anchor;
        const focus2 = selection2.focus;
        if (anchor.key === key2 && anchor.type === "text" && anchor.offset > textSize && anchor.offset <= nextTextSize) {
          anchor.key = siblingKey;
          anchor.offset -= textSize;
          selection2.dirty = true;
        }
        if (focus2.key === key2 && focus2.type === "text" && focus2.offset > textSize && focus2.offset <= nextTextSize) {
          focus2.key = siblingKey;
          focus2.offset -= textSize;
          selection2.dirty = true;
        }
      }
      if (compositionKey === key2) {
        $setCompositionKey(siblingKey);
      }
      textSize = nextTextSize;
      splitNodes.push(sibling2);
    }
    if (parent !== null) {
      internalMarkSiblingsAsDirty(this);
      const writableParent = parent.getWritable();
      const insertionIndex = this.getIndexWithinParent();
      if (hasReplacedSelf) {
        writableParent.splice(insertionIndex, 0, splitNodes);
        this.remove();
      } else {
        writableParent.splice(insertionIndex, 1, splitNodes);
      }
      if ($isRangeSelection(selection2)) {
        $updateElementSelectionOnCreateDeleteNode(selection2, parent, insertionIndex, partsLength - 1);
      }
    }
    return splitNodes;
  }
  /**
   * Merges the target TextNode into this TextNode, removing the target node.
   *
   * @param target - the TextNode to merge into this one.
   *
   * @returns this TextNode.
   */
  mergeWithSibling(target) {
    const isBefore = target === this.getPreviousSibling();
    if (!isBefore && target !== this.getNextSibling()) {
      {
        throw Error(`mergeWithSibling: sibling must be a previous or next sibling`);
      }
    }
    const key2 = this.__key;
    const targetKey = target.__key;
    const text4 = this.__text;
    const textLength = text4.length;
    const compositionKey = $getCompositionKey();
    if (compositionKey === targetKey) {
      $setCompositionKey(key2);
    }
    const selection2 = $getSelection();
    if ($isRangeSelection(selection2)) {
      const anchor = selection2.anchor;
      const focus2 = selection2.focus;
      if (anchor !== null && anchor.key === targetKey) {
        adjustPointOffsetForMergedSibling(anchor, isBefore, key2, target, textLength);
        selection2.dirty = true;
      }
      if (focus2 !== null && focus2.key === targetKey) {
        adjustPointOffsetForMergedSibling(focus2, isBefore, key2, target, textLength);
        selection2.dirty = true;
      }
    }
    const targetText = target.__text;
    const newText = isBefore ? targetText + text4 : text4 + targetText;
    this.setTextContent(newText);
    const writableSelf = this.getWritable();
    target.remove();
    return writableSelf;
  }
  /**
   * This method is meant to be overriden by TextNode subclasses to control the behavior of those nodes
   * when used with the registerLexicalTextEntity function. If you're using registerLexicalTextEntity, the
   * node class that you create and replace matched text with should return true from this method.
   *
   * @returns true if the node is to be treated as a "text entity", false otherwise.
   */
  isTextEntity() {
    return false;
  }
};
function convertSpanElement(domNode) {
  const span = domNode;
  const style = span.style;
  return {
    forChild: applyTextFormatFromStyle(style),
    node: null
  };
}
function convertBringAttentionToElement(domNode) {
  const b3 = domNode;
  const hasNormalFontWeight = b3.style.fontWeight === "normal";
  return {
    forChild: applyTextFormatFromStyle(b3.style, hasNormalFontWeight ? void 0 : "bold"),
    node: null
  };
}
var preParentCache = /* @__PURE__ */ new WeakMap();
function isNodePre(node2) {
  if (!isHTMLElement(node2)) {
    return false;
  } else if (node2.nodeName === "PRE") {
    return true;
  }
  const whiteSpace = node2.style.whiteSpace;
  return typeof whiteSpace === "string" && whiteSpace.startsWith("pre");
}
function findParentPreDOMNode(node2) {
  let cached;
  let parent = node2.parentNode;
  const visited = [node2];
  while (parent !== null && (cached = preParentCache.get(parent)) === void 0 && !isNodePre(parent)) {
    visited.push(parent);
    parent = parent.parentNode;
  }
  const resultNode = cached === void 0 ? parent : cached;
  for (let i3 = 0; i3 < visited.length; i3++) {
    preParentCache.set(visited[i3], resultNode);
  }
  return resultNode;
}
function $convertTextDOMNode(domNode) {
  const domNode_ = domNode;
  const parentDom = domNode.parentElement;
  if (!(parentDom !== null)) {
    throw Error(`Expected parentElement of Text not to be null`);
  }
  let textContent = domNode_.textContent || "";
  if (findParentPreDOMNode(domNode_) !== null) {
    const parts = textContent.split(/(\r?\n|\t)/);
    const nodes = [];
    const length = parts.length;
    for (let i3 = 0; i3 < length; i3++) {
      const part = parts[i3];
      if (part === "\n" || part === "\r\n") {
        nodes.push($createLineBreakNode());
      } else if (part === "	") {
        nodes.push($createTabNode());
      } else if (part !== "") {
        nodes.push($createTextNode(part));
      }
    }
    return {
      node: nodes
    };
  }
  textContent = textContent.replace(/\r/g, "").replace(/[ \t\n]+/g, " ");
  if (textContent === "") {
    return {
      node: null
    };
  }
  if (textContent[0] === " ") {
    let previousText = domNode_;
    let isStartOfLine = true;
    while (previousText !== null && (previousText = findTextInLine(previousText, false)) !== null) {
      const previousTextContent = previousText.textContent || "";
      if (previousTextContent.length > 0) {
        if (/[ \t\n]$/.test(previousTextContent)) {
          textContent = textContent.slice(1);
        }
        isStartOfLine = false;
        break;
      }
    }
    if (isStartOfLine) {
      textContent = textContent.slice(1);
    }
  }
  if (textContent[textContent.length - 1] === " ") {
    let nextText = domNode_;
    let isEndOfLine = true;
    while (nextText !== null && (nextText = findTextInLine(nextText, true)) !== null) {
      const nextTextContent = (nextText.textContent || "").replace(/^( |\t|\r?\n)+/, "");
      if (nextTextContent.length > 0) {
        isEndOfLine = false;
        break;
      }
    }
    if (isEndOfLine) {
      textContent = textContent.slice(0, textContent.length - 1);
    }
  }
  if (textContent === "") {
    return {
      node: null
    };
  }
  return {
    node: $createTextNode(textContent)
  };
}
function findTextInLine(text4, forward) {
  let node2 = text4;
  while (true) {
    let sibling2;
    while ((sibling2 = forward ? node2.nextSibling : node2.previousSibling) === null) {
      const parentElement = node2.parentElement;
      if (parentElement === null) {
        return null;
      }
      node2 = parentElement;
    }
    node2 = sibling2;
    if (isHTMLElement(node2)) {
      const display = node2.style.display;
      if (display === "" && !isInlineDomNode(node2) || display !== "" && !display.startsWith("inline")) {
        return null;
      }
    }
    let descendant = node2;
    while ((descendant = forward ? node2.firstChild : node2.lastChild) !== null) {
      node2 = descendant;
    }
    if (isDOMTextNode(node2)) {
      return node2;
    } else if (node2.nodeName === "BR") {
      return null;
    }
  }
}
var nodeNameToTextFormat = {
  code: "code",
  em: "italic",
  i: "italic",
  s: "strikethrough",
  strong: "bold",
  sub: "subscript",
  sup: "superscript",
  u: "underline"
};
function convertTextFormatElement(domNode) {
  const format = nodeNameToTextFormat[domNode.nodeName.toLowerCase()];
  if (format === void 0) {
    return {
      node: null
    };
  }
  return {
    forChild: applyTextFormatFromStyle(domNode.style, format),
    node: null
  };
}
function $createTextNode(text4 = "") {
  return $applyNodeReplacement(new TextNode(text4));
}
function $isTextNode(node2) {
  return node2 instanceof TextNode;
}
function applyTextFormatFromStyle(style, shouldApply) {
  const fontWeight = style.fontWeight;
  const textDecoration = style.textDecoration.split(" ");
  const hasBoldFontWeight = fontWeight === "700" || fontWeight === "bold";
  const hasLinethroughTextDecoration = textDecoration.includes("line-through");
  const hasItalicFontStyle = style.fontStyle === "italic";
  const hasUnderlineTextDecoration = textDecoration.includes("underline");
  const verticalAlign = style.verticalAlign;
  return (lexicalNode) => {
    if (!$isTextNode(lexicalNode)) {
      return lexicalNode;
    }
    if (hasBoldFontWeight && !lexicalNode.hasFormat("bold")) {
      lexicalNode.toggleFormat("bold");
    }
    if (hasLinethroughTextDecoration && !lexicalNode.hasFormat("strikethrough")) {
      lexicalNode.toggleFormat("strikethrough");
    }
    if (hasItalicFontStyle && !lexicalNode.hasFormat("italic")) {
      lexicalNode.toggleFormat("italic");
    }
    if (hasUnderlineTextDecoration && !lexicalNode.hasFormat("underline")) {
      lexicalNode.toggleFormat("underline");
    }
    if (verticalAlign === "sub" && !lexicalNode.hasFormat("subscript")) {
      lexicalNode.toggleFormat("subscript");
    }
    if (verticalAlign === "super" && !lexicalNode.hasFormat("superscript")) {
      lexicalNode.toggleFormat("superscript");
    }
    if (shouldApply && !lexicalNode.hasFormat(shouldApply)) {
      lexicalNode.toggleFormat(shouldApply);
    }
    return lexicalNode;
  };
}
var TabNode = class _TabNode extends TextNode {
  static getType() {
    return "tab";
  }
  static clone(node2) {
    return new _TabNode(node2.__key);
  }
  constructor(key2) {
    super("	", key2);
    this.__detail = IS_UNMERGEABLE;
  }
  static importDOM() {
    return null;
  }
  createDOM(config) {
    const dom = super.createDOM(config);
    const classNames14 = getCachedClassNameArray(config.theme, "tab");
    if (classNames14 !== void 0) {
      const domClassList = dom.classList;
      domClassList.add(...classNames14);
    }
    return dom;
  }
  static importJSON(serializedTabNode) {
    return $createTabNode().updateFromJSON(serializedTabNode);
  }
  setTextContent(text4) {
    if (!(text4 === "	" || text4 === "")) {
      throw Error(`TabNode does not support setTextContent`);
    }
    return super.setTextContent(text4);
  }
  setDetail(detail) {
    if (!(detail === IS_UNMERGEABLE)) {
      throw Error(`TabNode does not support setDetail`);
    }
    return this;
  }
  setMode(type2) {
    if (!(type2 === "normal")) {
      throw Error(`TabNode does not support setMode`);
    }
    return this;
  }
  canInsertTextBefore() {
    return false;
  }
  canInsertTextAfter() {
    return false;
  }
};
function $createTabNode() {
  return $applyNodeReplacement(new TabNode());
}
function $isTabNode(node2) {
  return node2 instanceof TabNode;
}
var Point = class {
  constructor(key2, offset5, type2) {
    {
      Object.defineProperty(this, "_selection", {
        enumerable: false,
        writable: true
      });
    }
    this._selection = null;
    this.key = key2;
    this.offset = offset5;
    this.type = type2;
  }
  is(point3) {
    return this.key === point3.key && this.offset === point3.offset && this.type === point3.type;
  }
  isBefore(b3) {
    let aNode = this.getNode();
    let bNode = b3.getNode();
    const aOffset = this.offset;
    const bOffset = b3.offset;
    if ($isElementNode(aNode)) {
      const aNodeDescendant = aNode.getDescendantByIndex(aOffset);
      aNode = aNodeDescendant != null ? aNodeDescendant : aNode;
    }
    if ($isElementNode(bNode)) {
      const bNodeDescendant = bNode.getDescendantByIndex(bOffset);
      bNode = bNodeDescendant != null ? bNodeDescendant : bNode;
    }
    if (aNode === bNode) {
      return aOffset < bOffset;
    }
    return aNode.isBefore(bNode);
  }
  getNode() {
    const key2 = this.key;
    const node2 = $getNodeByKey(key2);
    if (node2 === null) {
      {
        throw Error(`Point.getNode: node not found`);
      }
    }
    return node2;
  }
  set(key2, offset5, type2) {
    const selection2 = this._selection;
    const oldKey = this.key;
    this.key = key2;
    this.offset = offset5;
    this.type = type2;
    if (!isCurrentlyReadOnlyMode()) {
      if ($getCompositionKey() === oldKey) {
        $setCompositionKey(key2);
      }
      if (selection2 !== null) {
        selection2.setCachedNodes(null);
        selection2.dirty = true;
      }
    }
  }
};
function $createPoint(key2, offset5, type2) {
  return new Point(key2, offset5, type2);
}
function selectPointOnNode(point3, node2) {
  let key2 = node2.__key;
  let offset5 = point3.offset;
  let type2 = "element";
  if ($isTextNode(node2)) {
    type2 = "text";
    const textContentLength = node2.getTextContentSize();
    if (offset5 > textContentLength) {
      offset5 = textContentLength;
    }
  } else if (!$isElementNode(node2)) {
    const nextSibling = node2.getNextSibling();
    if ($isTextNode(nextSibling)) {
      key2 = nextSibling.__key;
      offset5 = 0;
      type2 = "text";
    } else {
      const parentNode = node2.getParent();
      if (parentNode) {
        key2 = parentNode.__key;
        offset5 = node2.getIndexWithinParent() + 1;
      }
    }
  }
  point3.set(key2, offset5, type2);
}
function $moveSelectionPointToEnd(point3, node2) {
  if ($isElementNode(node2)) {
    const lastNode = node2.getLastDescendant();
    if ($isElementNode(lastNode) || $isTextNode(lastNode)) {
      selectPointOnNode(point3, lastNode);
    } else {
      selectPointOnNode(point3, node2);
    }
  } else {
    selectPointOnNode(point3, node2);
  }
}
function $transferStartingElementPointToTextPoint(start2, end, format, style) {
  const element2 = start2.getNode();
  const placementNode = element2.getChildAtIndex(start2.offset);
  const textNode = $createTextNode();
  const target = $isRootNode(element2) ? $createParagraphNode().append(textNode) : textNode;
  textNode.setFormat(format);
  textNode.setStyle(style);
  if (placementNode === null) {
    element2.append(target);
  } else {
    placementNode.insertBefore(target);
  }
  if (start2.is(end)) {
    end.set(textNode.__key, 0, "text");
  }
  start2.set(textNode.__key, 0, "text");
}
function $setPointValues(point3, key2, offset5, type2) {
  point3.key = key2;
  point3.offset = offset5;
  point3.type = type2;
}
var NodeSelection = class _NodeSelection {
  constructor(objects) {
    this._cachedNodes = null;
    this._nodes = objects;
    this.dirty = false;
  }
  getCachedNodes() {
    return this._cachedNodes;
  }
  setCachedNodes(nodes) {
    this._cachedNodes = nodes;
  }
  is(selection2) {
    if (!$isNodeSelection(selection2)) {
      return false;
    }
    const a2 = this._nodes;
    const b3 = selection2._nodes;
    return a2.size === b3.size && Array.from(a2).every((key2) => b3.has(key2));
  }
  isCollapsed() {
    return false;
  }
  isBackward() {
    return false;
  }
  getStartEndPoints() {
    return null;
  }
  add(key2) {
    this.dirty = true;
    this._nodes.add(key2);
    this._cachedNodes = null;
  }
  delete(key2) {
    this.dirty = true;
    this._nodes.delete(key2);
    this._cachedNodes = null;
  }
  clear() {
    this.dirty = true;
    this._nodes.clear();
    this._cachedNodes = null;
  }
  has(key2) {
    return this._nodes.has(key2);
  }
  clone() {
    return new _NodeSelection(new Set(this._nodes));
  }
  extract() {
    return this.getNodes();
  }
  insertRawText(text4) {
  }
  insertText() {
  }
  insertNodes(nodes) {
    const selectedNodes = this.getNodes();
    const selectedNodesLength = selectedNodes.length;
    const lastSelectedNode = selectedNodes[selectedNodesLength - 1];
    let selectionAtEnd;
    if ($isTextNode(lastSelectedNode)) {
      selectionAtEnd = lastSelectedNode.select();
    } else {
      const index3 = lastSelectedNode.getIndexWithinParent() + 1;
      selectionAtEnd = lastSelectedNode.getParentOrThrow().select(index3, index3);
    }
    selectionAtEnd.insertNodes(nodes);
    for (let i3 = 0; i3 < selectedNodesLength; i3++) {
      selectedNodes[i3].remove();
    }
  }
  getNodes() {
    const cachedNodes = this._cachedNodes;
    if (cachedNodes !== null) {
      return cachedNodes;
    }
    const objects = this._nodes;
    const nodes = [];
    for (const object of objects) {
      const node2 = $getNodeByKey(object);
      if (node2 !== null) {
        nodes.push(node2);
      }
    }
    if (!isCurrentlyReadOnlyMode()) {
      this._cachedNodes = nodes;
    }
    return nodes;
  }
  getTextContent() {
    const nodes = this.getNodes();
    let textContent = "";
    for (let i3 = 0; i3 < nodes.length; i3++) {
      textContent += nodes[i3].getTextContent();
    }
    return textContent;
  }
};
function $isRangeSelection(x3) {
  return x3 instanceof RangeSelection;
}
var RangeSelection = class _RangeSelection {
  constructor(anchor, focus2, format, style) {
    this.anchor = anchor;
    this.focus = focus2;
    anchor._selection = this;
    focus2._selection = this;
    this._cachedNodes = null;
    this.format = format;
    this.style = style;
    this.dirty = false;
  }
  getCachedNodes() {
    return this._cachedNodes;
  }
  setCachedNodes(nodes) {
    this._cachedNodes = nodes;
  }
  /**
   * Used to check if the provided selections is equal to this one by value,
   * inluding anchor, focus, format, and style properties.
   * @param selection - the Selection to compare this one to.
   * @returns true if the Selections are equal, false otherwise.
   */
  is(selection2) {
    if (!$isRangeSelection(selection2)) {
      return false;
    }
    return this.anchor.is(selection2.anchor) && this.focus.is(selection2.focus) && this.format === selection2.format && this.style === selection2.style;
  }
  /**
   * Returns whether the Selection is "collapsed", meaning the anchor and focus are
   * the same node and have the same offset.
   *
   * @returns true if the Selection is collapsed, false otherwise.
   */
  isCollapsed() {
    return this.anchor.is(this.focus);
  }
  /**
   * Gets all the nodes in the Selection. Uses caching to make it generally suitable
   * for use in hot paths.
   *
   * @returns an Array containing all the nodes in the Selection
   */
  getNodes() {
    const cachedNodes = this._cachedNodes;
    if (cachedNodes !== null) {
      return cachedNodes;
    }
    const anchor = this.anchor;
    const focus2 = this.focus;
    const isBefore = anchor.isBefore(focus2);
    const firstPoint = isBefore ? anchor : focus2;
    const lastPoint = isBefore ? focus2 : anchor;
    let firstNode = firstPoint.getNode();
    let lastNode = lastPoint.getNode();
    const overselectedFirstNode = $isElementNode(firstNode) && firstPoint.offset > 0 && firstPoint.offset >= firstNode.getChildrenSize();
    const startOffset = firstPoint.offset;
    const endOffset = lastPoint.offset;
    if ($isElementNode(firstNode)) {
      const firstNodeDescendant = firstNode.getDescendantByIndex(startOffset);
      firstNode = firstNodeDescendant != null ? firstNodeDescendant : firstNode;
    }
    if ($isElementNode(lastNode)) {
      let lastNodeDescendant = lastNode.getDescendantByIndex(endOffset);
      if (lastNodeDescendant !== null && lastNodeDescendant !== firstNode && lastNode.getChildAtIndex(endOffset) === lastNodeDescendant) {
        lastNodeDescendant = lastNodeDescendant.getPreviousSibling();
      }
      lastNode = lastNodeDescendant != null ? lastNodeDescendant : lastNode;
    }
    let nodes;
    if (firstNode.is(lastNode)) {
      if ($isElementNode(firstNode) && firstNode.getChildrenSize() > 0) {
        nodes = [];
      } else {
        nodes = [firstNode];
      }
    } else {
      nodes = firstNode.getNodesBetween(lastNode);
      if (overselectedFirstNode) {
        const deleteCount = nodes.findIndex((node2) => !node2.is(firstNode) && !node2.isBefore(firstNode));
        nodes.splice(0, deleteCount);
      }
    }
    if (!isCurrentlyReadOnlyMode()) {
      this._cachedNodes = nodes;
    }
    return nodes;
  }
  /**
   * Sets this Selection to be of type "text" at the provided anchor and focus values.
   *
   * @param anchorNode - the anchor node to set on the Selection
   * @param anchorOffset - the offset to set on the Selection
   * @param focusNode - the focus node to set on the Selection
   * @param focusOffset - the focus offset to set on the Selection
   */
  setTextNodeRange(anchorNode, anchorOffset, focusNode, focusOffset) {
    $setPointValues(this.anchor, anchorNode.__key, anchorOffset, "text");
    $setPointValues(this.focus, focusNode.__key, focusOffset, "text");
    this._cachedNodes = null;
    this.dirty = true;
  }
  /**
   * Gets the (plain) text content of all the nodes in the selection.
   *
   * @returns a string representing the text content of all the nodes in the Selection
   */
  getTextContent() {
    const nodes = this.getNodes();
    if (nodes.length === 0) {
      return "";
    }
    const firstNode = nodes[0];
    const lastNode = nodes[nodes.length - 1];
    const anchor = this.anchor;
    const focus2 = this.focus;
    const isBefore = anchor.isBefore(focus2);
    const [anchorOffset, focusOffset] = $getCharacterOffsets(this);
    let textContent = "";
    let prevWasElement = true;
    for (let i3 = 0; i3 < nodes.length; i3++) {
      const node2 = nodes[i3];
      if ($isElementNode(node2) && !node2.isInline()) {
        if (!prevWasElement) {
          textContent += "\n";
        }
        if (node2.isEmpty()) {
          prevWasElement = false;
        } else {
          prevWasElement = true;
        }
      } else {
        prevWasElement = false;
        if ($isTextNode(node2)) {
          let text4 = node2.getTextContent();
          if (node2 === firstNode) {
            if (node2 === lastNode) {
              if (anchor.type !== "element" || focus2.type !== "element" || focus2.offset === anchor.offset) {
                text4 = anchorOffset < focusOffset ? text4.slice(anchorOffset, focusOffset) : text4.slice(focusOffset, anchorOffset);
              }
            } else {
              text4 = isBefore ? text4.slice(anchorOffset) : text4.slice(focusOffset);
            }
          } else if (node2 === lastNode) {
            text4 = isBefore ? text4.slice(0, focusOffset) : text4.slice(0, anchorOffset);
          }
          textContent += text4;
        } else if (($isDecoratorNode(node2) || $isLineBreakNode(node2)) && (node2 !== lastNode || !this.isCollapsed())) {
          textContent += node2.getTextContent();
        }
      }
    }
    return textContent;
  }
  /**
   * Attempts to map a DOM selection range onto this Lexical Selection,
   * setting the anchor, focus, and type accordingly
   *
   * @param range a DOM Selection range conforming to the StaticRange interface.
   */
  applyDOMRange(range) {
    const editor = getActiveEditor();
    const currentEditorState = editor.getEditorState();
    const lastSelection = currentEditorState._selection;
    const resolvedSelectionPoints = $internalResolveSelectionPoints(range.startContainer, range.startOffset, range.endContainer, range.endOffset, editor, lastSelection);
    if (resolvedSelectionPoints === null) {
      return;
    }
    const [anchorPoint, focusPoint] = resolvedSelectionPoints;
    $setPointValues(this.anchor, anchorPoint.key, anchorPoint.offset, anchorPoint.type);
    $setPointValues(this.focus, focusPoint.key, focusPoint.offset, focusPoint.type);
    this._cachedNodes = null;
  }
  /**
   * Creates a new RangeSelection, copying over all the property values from this one.
   *
   * @returns a new RangeSelection with the same property values as this one.
   */
  clone() {
    const anchor = this.anchor;
    const focus2 = this.focus;
    const selection2 = new _RangeSelection($createPoint(anchor.key, anchor.offset, anchor.type), $createPoint(focus2.key, focus2.offset, focus2.type), this.format, this.style);
    return selection2;
  }
  /**
   * Toggles the provided format on all the TextNodes in the Selection.
   *
   * @param format a string TextFormatType to toggle on the TextNodes in the selection
   */
  toggleFormat(format) {
    this.format = toggleTextFormatType(this.format, format, null);
    this.dirty = true;
  }
  /**
   * Sets the value of the style property on the Selection
   *
   * @param style - the style to set at the value of the style property.
   */
  setStyle(style) {
    this.style = style;
    this.dirty = true;
  }
  /**
   * Returns whether the provided TextFormatType is present on the Selection. This will be true if any node in the Selection
   * has the specified format.
   *
   * @param type the TextFormatType to check for.
   * @returns true if the provided format is currently toggled on on the Selection, false otherwise.
   */
  hasFormat(type2) {
    const formatFlag = TEXT_TYPE_TO_FORMAT[type2];
    return (this.format & formatFlag) !== 0;
  }
  /**
   * Attempts to insert the provided text into the EditorState at the current Selection.
   * converts tabs, newlines, and carriage returns into LexicalNodes.
   *
   * @param text the text to insert into the Selection
   */
  insertRawText(text4) {
    const parts = text4.split(/(\r?\n|\t)/);
    const nodes = [];
    const length = parts.length;
    for (let i3 = 0; i3 < length; i3++) {
      const part = parts[i3];
      if (part === "\n" || part === "\r\n") {
        nodes.push($createLineBreakNode());
      } else if (part === "	") {
        nodes.push($createTabNode());
      } else {
        nodes.push($createTextNode(part));
      }
    }
    this.insertNodes(nodes);
  }
  /**
   * Insert the provided text into the EditorState at the current Selection.
   *
   * @param text the text to insert into the Selection
   */
  insertText(text4) {
    const anchor = this.anchor;
    const focus2 = this.focus;
    const format = this.format;
    const style = this.style;
    let firstPoint = anchor;
    let endPoint = focus2;
    if (!this.isCollapsed() && focus2.isBefore(anchor)) {
      firstPoint = focus2;
      endPoint = anchor;
    }
    if (firstPoint.type === "element") {
      $transferStartingElementPointToTextPoint(firstPoint, endPoint, format, style);
    }
    const startOffset = firstPoint.offset;
    let endOffset = endPoint.offset;
    const selectedNodes = this.getNodes();
    const selectedNodesLength = selectedNodes.length;
    let firstNode = selectedNodes[0];
    if (!$isTextNode(firstNode)) {
      {
        throw Error(`insertText: first node is not a text node`);
      }
    }
    const firstNodeText = firstNode.getTextContent();
    const firstNodeTextLength = firstNodeText.length;
    const firstNodeParent = firstNode.getParentOrThrow();
    const lastIndex = selectedNodesLength - 1;
    let lastNode = selectedNodes[lastIndex];
    if (selectedNodesLength === 1 && endPoint.type === "element") {
      endOffset = firstNodeTextLength;
      endPoint.set(firstPoint.key, endOffset, "text");
    }
    if (this.isCollapsed() && startOffset === firstNodeTextLength && (firstNode.isSegmented() || firstNode.isToken() || !firstNode.canInsertTextAfter() || !firstNodeParent.canInsertTextAfter() && firstNode.getNextSibling() === null)) {
      let nextSibling = firstNode.getNextSibling();
      if (!$isTextNode(nextSibling) || !nextSibling.canInsertTextBefore() || $isTokenOrSegmented(nextSibling)) {
        nextSibling = $createTextNode();
        nextSibling.setFormat(format);
        nextSibling.setStyle(style);
        if (!firstNodeParent.canInsertTextAfter()) {
          firstNodeParent.insertAfter(nextSibling);
        } else {
          firstNode.insertAfter(nextSibling);
        }
      }
      nextSibling.select(0, 0);
      firstNode = nextSibling;
      if (text4 !== "") {
        this.insertText(text4);
        return;
      }
    } else if (this.isCollapsed() && startOffset === 0 && (firstNode.isSegmented() || firstNode.isToken() || !firstNode.canInsertTextBefore() || !firstNodeParent.canInsertTextBefore() && firstNode.getPreviousSibling() === null)) {
      let prevSibling = firstNode.getPreviousSibling();
      if (!$isTextNode(prevSibling) || $isTokenOrSegmented(prevSibling)) {
        prevSibling = $createTextNode();
        prevSibling.setFormat(format);
        if (!firstNodeParent.canInsertTextBefore()) {
          firstNodeParent.insertBefore(prevSibling);
        } else {
          firstNode.insertBefore(prevSibling);
        }
      }
      prevSibling.select();
      firstNode = prevSibling;
      if (text4 !== "") {
        this.insertText(text4);
        return;
      }
    } else if (firstNode.isSegmented() && startOffset !== firstNodeTextLength) {
      const textNode = $createTextNode(firstNode.getTextContent());
      textNode.setFormat(format);
      firstNode.replace(textNode);
      firstNode = textNode;
    } else if (!this.isCollapsed() && text4 !== "") {
      const lastNodeParent = lastNode.getParent();
      if (!firstNodeParent.canInsertTextBefore() || !firstNodeParent.canInsertTextAfter() || $isElementNode(lastNodeParent) && (!lastNodeParent.canInsertTextBefore() || !lastNodeParent.canInsertTextAfter())) {
        this.insertText("");
        $normalizeSelectionPointsForBoundaries(this.anchor, this.focus, null);
        this.insertText(text4);
        return;
      }
    }
    if (selectedNodesLength === 1) {
      if (firstNode.isToken()) {
        const textNode = $createTextNode(text4);
        textNode.select();
        firstNode.replace(textNode);
        return;
      }
      const firstNodeFormat = firstNode.getFormat();
      const firstNodeStyle = firstNode.getStyle();
      if (startOffset === endOffset && (firstNodeFormat !== format || firstNodeStyle !== style)) {
        if (firstNode.getTextContent() === "") {
          firstNode.setFormat(format);
          firstNode.setStyle(style);
        } else {
          const textNode = $createTextNode(text4);
          textNode.setFormat(format);
          textNode.setStyle(style);
          textNode.select();
          if (startOffset === 0) {
            firstNode.insertBefore(textNode, false);
          } else {
            const [targetNode] = firstNode.splitText(startOffset);
            targetNode.insertAfter(textNode, false);
          }
          if (textNode.isComposing() && this.anchor.type === "text") {
            this.anchor.offset -= text4.length;
          }
          return;
        }
      } else if ($isTabNode(firstNode)) {
        const textNode = $createTextNode(text4);
        textNode.setFormat(format);
        textNode.setStyle(style);
        textNode.select();
        firstNode.replace(textNode);
        return;
      }
      const delCount = endOffset - startOffset;
      firstNode = firstNode.spliceText(startOffset, delCount, text4, true);
      if (firstNode.getTextContent() === "") {
        firstNode.remove();
      } else if (this.anchor.type === "text") {
        if (firstNode.isComposing()) {
          this.anchor.offset -= text4.length;
        } else {
          this.format = firstNodeFormat;
          this.style = firstNodeStyle;
        }
      }
    } else {
      const markedNodeKeysForKeep = /* @__PURE__ */ new Set([...firstNode.getParentKeys(), ...lastNode.getParentKeys()]);
      const firstElement = $isElementNode(firstNode) ? firstNode : firstNode.getParentOrThrow();
      let lastElement = $isElementNode(lastNode) ? lastNode : lastNode.getParentOrThrow();
      let lastElementChild = lastNode;
      if (!firstElement.is(lastElement) && lastElement.isInline()) {
        do {
          lastElementChild = lastElement;
          lastElement = lastElement.getParentOrThrow();
        } while (lastElement.isInline());
      }
      if (endPoint.type === "text" && (endOffset !== 0 || lastNode.getTextContent() === "") || endPoint.type === "element" && lastNode.getIndexWithinParent() < endOffset) {
        if ($isTextNode(lastNode) && !lastNode.isToken() && endOffset !== lastNode.getTextContentSize()) {
          if (lastNode.isSegmented()) {
            const textNode = $createTextNode(lastNode.getTextContent());
            lastNode.replace(textNode);
            lastNode = textNode;
          }
          if (!$isRootNode(endPoint.getNode()) && endPoint.type === "text") {
            lastNode = lastNode.spliceText(0, endOffset, "");
          }
          markedNodeKeysForKeep.add(lastNode.__key);
        } else {
          const lastNodeParent = lastNode.getParentOrThrow();
          if (!lastNodeParent.canBeEmpty() && lastNodeParent.getChildrenSize() === 1) {
            lastNodeParent.remove();
          } else {
            lastNode.remove();
          }
        }
      } else {
        markedNodeKeysForKeep.add(lastNode.__key);
      }
      const lastNodeChildren = lastElement.getChildren();
      const selectedNodesSet = new Set(selectedNodes);
      const firstAndLastElementsAreEqual = firstElement.is(lastElement);
      const insertionTarget = firstElement.isInline() && firstNode.getNextSibling() === null ? firstElement : firstNode;
      for (let i3 = lastNodeChildren.length - 1; i3 >= 0; i3--) {
        const lastNodeChild = lastNodeChildren[i3];
        if (lastNodeChild.is(firstNode) || $isElementNode(lastNodeChild) && lastNodeChild.isParentOf(firstNode)) {
          break;
        }
        if (lastNodeChild.isAttached()) {
          if (!selectedNodesSet.has(lastNodeChild) || lastNodeChild.is(lastElementChild)) {
            if (!firstAndLastElementsAreEqual) {
              insertionTarget.insertAfter(lastNodeChild, false);
            }
          } else {
            lastNodeChild.remove();
          }
        }
      }
      if (!firstAndLastElementsAreEqual) {
        let parent = lastElement;
        let lastRemovedParent = null;
        while (parent !== null) {
          const children = parent.getChildren();
          const childrenLength = children.length;
          if (childrenLength === 0 || children[childrenLength - 1].is(lastRemovedParent)) {
            markedNodeKeysForKeep.delete(parent.__key);
            lastRemovedParent = parent;
          }
          parent = parent.getParent();
        }
      }
      if (!firstNode.isToken()) {
        firstNode = firstNode.spliceText(startOffset, firstNodeTextLength - startOffset, text4, true);
        if (firstNode.getTextContent() === "") {
          firstNode.remove();
        } else if (firstNode.isComposing() && this.anchor.type === "text") {
          this.anchor.offset -= text4.length;
        }
      } else if (startOffset === firstNodeTextLength) {
        firstNode.select();
      } else {
        const textNode = $createTextNode(text4);
        textNode.select();
        firstNode.replace(textNode);
      }
      for (let i3 = 1; i3 < selectedNodesLength; i3++) {
        const selectedNode = selectedNodes[i3];
        const key2 = selectedNode.__key;
        if (!markedNodeKeysForKeep.has(key2)) {
          selectedNode.remove();
        }
      }
    }
  }
  /**
   * Removes the text in the Selection, adjusting the EditorState accordingly.
   */
  removeText() {
    if (this.isCollapsed()) {
      return;
    }
    const {
      anchor,
      focus: focus2
    } = this;
    const selectedNodes = this.getNodes();
    const firstPoint = this.isBackward() ? focus2 : anchor;
    const lastPoint = this.isBackward() ? anchor : focus2;
    let firstNode = firstPoint.getNode();
    let lastNode = lastPoint.getNode();
    const firstBlock = $getAncestor(firstNode, INTERNAL_$isBlock);
    const lastBlock = $getAncestor(lastNode, INTERNAL_$isBlock);
    if ($isTextNode(firstNode) && firstNode.isToken() && firstPoint.offset < firstNode.getTextContentSize()) {
      firstPoint.offset = 0;
    }
    if (lastPoint.offset > 0 && $isTextNode(lastNode) && lastNode.isToken()) {
      lastPoint.offset = lastNode.getTextContentSize();
    }
    for (const node2 of selectedNodes) {
      if (!$hasAncestor(firstNode, node2) && !$hasAncestor(lastNode, node2) && node2.getKey() !== firstNode.getKey() && node2.getKey() !== lastNode.getKey()) {
        node2.remove();
      }
    }
    const fixText = (node2, del) => {
      if (node2.getTextContent() === "") {
        node2.remove();
      } else if (del !== 0 && $isTokenOrSegmented(node2)) {
        const textNode = $createTextNode(node2.getTextContent());
        textNode.setFormat(node2.getFormat());
        textNode.setStyle(node2.getStyle());
        return node2.replace(textNode);
      }
    };
    if (firstNode === lastNode && $isTextNode(firstNode)) {
      const del = Math.abs(focus2.offset - anchor.offset);
      firstNode.spliceText(firstPoint.offset, del, "", true);
      fixText(firstNode, del);
      return;
    }
    if ($isTextNode(firstNode)) {
      const del = firstNode.getTextContentSize() - firstPoint.offset;
      firstNode.spliceText(firstPoint.offset, del, "");
      firstNode = fixText(firstNode, del) || firstNode;
    }
    if ($isTextNode(lastNode)) {
      lastNode.spliceText(0, lastPoint.offset, "");
      lastNode = fixText(lastNode, lastPoint.offset) || lastNode;
    }
    if (firstNode.isAttached() && $isTextNode(firstNode)) {
      firstNode.selectEnd();
    } else if (lastNode.isAttached() && $isTextNode(lastNode)) {
      lastNode.selectStart();
    }
    const bothElem = $isElementNode(firstBlock) && $isElementNode(lastBlock);
    if (bothElem && firstBlock !== lastBlock) {
      firstBlock.append(...lastBlock.getChildren());
      lastBlock.remove();
      lastPoint.set(firstPoint.key, firstPoint.offset, firstPoint.type);
    }
  }
  // TO-DO: Migrate this method to the new utility function $forEachSelectedTextNode (share similar logic)
  /**
   * Applies the provided format to the TextNodes in the Selection, splitting or
   * merging nodes as necessary.
   *
   * @param formatType the format type to apply to the nodes in the Selection.
   * @param alignWithFormat a 32-bit integer representing formatting flags to align with.
   */
  formatText(formatType, alignWithFormat = null) {
    if (this.isCollapsed()) {
      this.toggleFormat(formatType);
      $setCompositionKey(null);
      return;
    }
    const selectedNodes = this.getNodes();
    const selectedTextNodes = [];
    for (const selectedNode of selectedNodes) {
      if ($isTextNode(selectedNode)) {
        selectedTextNodes.push(selectedNode);
      }
    }
    const applyFormatToElements = (alignWith) => {
      selectedNodes.forEach((node2) => {
        if ($isElementNode(node2)) {
          const newFormat = node2.getFormatFlags(formatType, alignWith);
          node2.setTextFormat(newFormat);
        }
      });
    };
    const selectedTextNodesLength = selectedTextNodes.length;
    if (selectedTextNodesLength === 0) {
      this.toggleFormat(formatType);
      $setCompositionKey(null);
      applyFormatToElements(alignWithFormat);
      return;
    }
    const anchor = this.anchor;
    const focus2 = this.focus;
    const isBackward = this.isBackward();
    const startPoint = isBackward ? focus2 : anchor;
    const endPoint = isBackward ? anchor : focus2;
    let firstIndex = 0;
    let firstNode = selectedTextNodes[0];
    let startOffset = startPoint.type === "element" ? 0 : startPoint.offset;
    if (startPoint.type === "text" && startOffset === firstNode.getTextContentSize()) {
      firstIndex = 1;
      firstNode = selectedTextNodes[1];
      startOffset = 0;
    }
    if (firstNode == null) {
      return;
    }
    const firstNextFormat = firstNode.getFormatFlags(formatType, alignWithFormat);
    applyFormatToElements(firstNextFormat);
    const lastIndex = selectedTextNodesLength - 1;
    let lastNode = selectedTextNodes[lastIndex];
    const endOffset = endPoint.type === "text" ? endPoint.offset : lastNode.getTextContentSize();
    if (firstNode.is(lastNode)) {
      if (startOffset === endOffset) {
        return;
      }
      if ($isTokenOrSegmented(firstNode) || startOffset === 0 && endOffset === firstNode.getTextContentSize()) {
        firstNode.setFormat(firstNextFormat);
      } else {
        const splitNodes = firstNode.splitText(startOffset, endOffset);
        const replacement = startOffset === 0 ? splitNodes[0] : splitNodes[1];
        replacement.setFormat(firstNextFormat);
        if (startPoint.type === "text") {
          startPoint.set(replacement.__key, 0, "text");
        }
        if (endPoint.type === "text") {
          endPoint.set(replacement.__key, endOffset - startOffset, "text");
        }
      }
      this.format = firstNextFormat;
      return;
    }
    if (startOffset !== 0 && !$isTokenOrSegmented(firstNode)) {
      [, firstNode] = firstNode.splitText(startOffset);
      startOffset = 0;
    }
    firstNode.setFormat(firstNextFormat);
    const lastNextFormat = lastNode.getFormatFlags(formatType, firstNextFormat);
    if (endOffset > 0) {
      if (endOffset !== lastNode.getTextContentSize() && !$isTokenOrSegmented(lastNode)) {
        [lastNode] = lastNode.splitText(endOffset);
      }
      lastNode.setFormat(lastNextFormat);
    }
    for (let i3 = firstIndex + 1; i3 < lastIndex; i3++) {
      const textNode = selectedTextNodes[i3];
      const nextFormat = textNode.getFormatFlags(formatType, lastNextFormat);
      textNode.setFormat(nextFormat);
    }
    if (startPoint.type === "text") {
      startPoint.set(firstNode.__key, startOffset, "text");
    }
    if (endPoint.type === "text") {
      endPoint.set(lastNode.__key, endOffset, "text");
    }
    this.format = firstNextFormat | lastNextFormat;
  }
  /**
   * Attempts to "intelligently" insert an arbitrary list of Lexical nodes into the EditorState at the
   * current Selection according to a set of heuristics that determine how surrounding nodes
   * should be changed, replaced, or moved to accommodate the incoming ones.
   *
   * @param nodes - the nodes to insert
   */
  insertNodes(nodes) {
    if (nodes.length === 0) {
      return;
    }
    if (this.anchor.key === "root") {
      this.insertParagraph();
      const selection2 = $getSelection();
      if (!$isRangeSelection(selection2)) {
        throw Error(`Expected RangeSelection after insertParagraph`);
      }
      return selection2.insertNodes(nodes);
    }
    const firstPoint = this.isBackward() ? this.focus : this.anchor;
    const firstNode = firstPoint.getNode();
    const firstBlock = $getAncestor(firstNode, INTERNAL_$isBlock);
    const last = nodes[nodes.length - 1];
    if ($isElementNode(firstBlock) && "__language" in firstBlock) {
      if ("__language" in nodes[0]) {
        this.insertText(nodes[0].getTextContent());
      } else {
        const index3 = $removeTextAndSplitBlock(this);
        firstBlock.splice(index3, 0, nodes);
        last.selectEnd();
      }
      return;
    }
    const notInline = (node2) => ($isElementNode(node2) || $isDecoratorNode(node2)) && !node2.isInline();
    if (!nodes.some(notInline)) {
      if (!$isElementNode(firstBlock)) {
        throw Error(`Expected node ${firstNode.constructor.name} of type ${firstNode.getType()} to have a block ElementNode ancestor`);
      }
      const index3 = $removeTextAndSplitBlock(this);
      firstBlock.splice(index3, 0, nodes);
      last.selectEnd();
      return;
    }
    const blocksParent = $wrapInlineNodes(nodes);
    const nodeToSelect = blocksParent.getLastDescendant();
    const blocks = blocksParent.getChildren();
    const isMergeable = (node2) => $isElementNode(node2) && INTERNAL_$isBlock(node2) && !node2.isEmpty() && $isElementNode(firstBlock) && (!firstBlock.isEmpty() || firstBlock.canMergeWhenEmpty());
    const shouldInsert = !$isElementNode(firstBlock) || !firstBlock.isEmpty();
    const insertedParagraph = shouldInsert ? this.insertParagraph() : null;
    const lastToInsert = blocks[blocks.length - 1];
    let firstToInsert = blocks[0];
    if (isMergeable(firstToInsert)) {
      if (!$isElementNode(firstBlock)) {
        throw Error(`Expected node ${firstNode.constructor.name} of type ${firstNode.getType()} to have a block ElementNode ancestor`);
      }
      firstBlock.append(...firstToInsert.getChildren());
      firstToInsert = blocks[1];
    }
    if (firstToInsert) {
      if (!(firstBlock !== null)) {
        throw Error(`Expected node ${firstNode.constructor.name} of type ${firstNode.getType()} to have a block ancestor`);
      }
      insertRangeAfter(firstBlock, firstToInsert);
    }
    const lastInsertedBlock = $getAncestor(nodeToSelect, INTERNAL_$isBlock);
    if (insertedParagraph && $isElementNode(lastInsertedBlock) && (insertedParagraph.canMergeWhenEmpty() || INTERNAL_$isBlock(lastToInsert))) {
      lastInsertedBlock.append(...insertedParagraph.getChildren());
      insertedParagraph.remove();
    }
    if ($isElementNode(firstBlock) && firstBlock.isEmpty()) {
      firstBlock.remove();
    }
    nodeToSelect.selectEnd();
    const lastChild = $isElementNode(firstBlock) ? firstBlock.getLastChild() : null;
    if ($isLineBreakNode(lastChild) && lastInsertedBlock !== firstBlock) {
      lastChild.remove();
    }
  }
  /**
   * Inserts a new ParagraphNode into the EditorState at the current Selection
   *
   * @returns the newly inserted node.
   */
  insertParagraph() {
    if (this.anchor.key === "root") {
      const paragraph2 = $createParagraphNode();
      $getRoot().splice(this.anchor.offset, 0, [paragraph2]);
      paragraph2.select();
      return paragraph2;
    }
    const index3 = $removeTextAndSplitBlock(this);
    const block = $getAncestor(this.anchor.getNode(), INTERNAL_$isBlock);
    if (!$isElementNode(block)) {
      throw Error(`Expected ancestor to be a block ElementNode`);
    }
    const firstToAppend = block.getChildAtIndex(index3);
    const nodesToInsert = firstToAppend ? [firstToAppend, ...firstToAppend.getNextSiblings()] : [];
    const newBlock = block.insertNewAfter(this, false);
    if (newBlock) {
      newBlock.append(...nodesToInsert);
      newBlock.selectStart();
      return newBlock;
    }
    return null;
  }
  /**
   * Inserts a logical linebreak, which may be a new LineBreakNode or a new ParagraphNode, into the EditorState at the
   * current Selection.
   */
  insertLineBreak(selectStart) {
    const lineBreak2 = $createLineBreakNode();
    this.insertNodes([lineBreak2]);
    if (selectStart) {
      const parent = lineBreak2.getParentOrThrow();
      const index3 = lineBreak2.getIndexWithinParent();
      parent.select(index3, index3);
    }
  }
  /**
   * Extracts the nodes in the Selection, splitting nodes where necessary
   * to get offset-level precision.
   *
   * @returns The nodes in the Selection
   */
  extract() {
    const selectedNodes = this.getNodes();
    const selectedNodesLength = selectedNodes.length;
    const lastIndex = selectedNodesLength - 1;
    const anchor = this.anchor;
    const focus2 = this.focus;
    let firstNode = selectedNodes[0];
    let lastNode = selectedNodes[lastIndex];
    const [anchorOffset, focusOffset] = $getCharacterOffsets(this);
    if (selectedNodesLength === 0) {
      return [];
    } else if (selectedNodesLength === 1) {
      if ($isTextNode(firstNode) && !this.isCollapsed()) {
        const startOffset = anchorOffset > focusOffset ? focusOffset : anchorOffset;
        const endOffset = anchorOffset > focusOffset ? anchorOffset : focusOffset;
        const splitNodes = firstNode.splitText(startOffset, endOffset);
        const node2 = startOffset === 0 ? splitNodes[0] : splitNodes[1];
        return node2 != null ? [node2] : [];
      }
      return [firstNode];
    }
    const isBefore = anchor.isBefore(focus2);
    if ($isTextNode(firstNode)) {
      const startOffset = isBefore ? anchorOffset : focusOffset;
      if (startOffset === firstNode.getTextContentSize()) {
        selectedNodes.shift();
      } else if (startOffset !== 0) {
        [, firstNode] = firstNode.splitText(startOffset);
        selectedNodes[0] = firstNode;
      }
    }
    if ($isTextNode(lastNode)) {
      const lastNodeText = lastNode.getTextContent();
      const lastNodeTextLength = lastNodeText.length;
      const endOffset = isBefore ? focusOffset : anchorOffset;
      if (endOffset === 0) {
        selectedNodes.pop();
      } else if (endOffset !== lastNodeTextLength) {
        [lastNode] = lastNode.splitText(endOffset);
        selectedNodes[lastIndex] = lastNode;
      }
    }
    return selectedNodes;
  }
  /**
   * Modifies the Selection according to the parameters and a set of heuristics that account for
   * various node types. Can be used to safely move or extend selection by one logical "unit" without
   * dealing explicitly with all the possible node types.
   *
   * @param alter the type of modification to perform
   * @param isBackward whether or not selection is backwards
   * @param granularity the granularity at which to apply the modification
   */
  modify(alter, isBackward, granularity) {
    const focus2 = this.focus;
    const anchor = this.anchor;
    const collapse = alter === "move";
    const possibleNode = $getAdjacentNode(focus2, isBackward);
    if ($isDecoratorNode(possibleNode) && !possibleNode.isIsolated()) {
      if (collapse && possibleNode.isKeyboardSelectable()) {
        const nodeSelection = $createNodeSelection();
        nodeSelection.add(possibleNode.__key);
        $setSelection(nodeSelection);
        return;
      }
      const sibling2 = isBackward ? possibleNode.getPreviousSibling() : possibleNode.getNextSibling();
      if (!$isTextNode(sibling2)) {
        const parent = possibleNode.getParentOrThrow();
        let offset5;
        let elementKey;
        if ($isElementNode(sibling2)) {
          elementKey = sibling2.__key;
          offset5 = isBackward ? sibling2.getChildrenSize() : 0;
        } else {
          offset5 = possibleNode.getIndexWithinParent();
          elementKey = parent.__key;
          if (!isBackward) {
            offset5++;
          }
        }
        focus2.set(elementKey, offset5, "element");
        if (collapse) {
          anchor.set(elementKey, offset5, "element");
        }
        return;
      } else {
        const siblingKey = sibling2.__key;
        const offset5 = isBackward ? sibling2.getTextContent().length : 0;
        focus2.set(siblingKey, offset5, "text");
        if (collapse) {
          anchor.set(siblingKey, offset5, "text");
        }
        return;
      }
    }
    const editor = getActiveEditor();
    const domSelection = getDOMSelection(editor._window);
    if (!domSelection) {
      return;
    }
    const blockCursorElement = editor._blockCursorElement;
    const rootElement = editor._rootElement;
    if (rootElement !== null && blockCursorElement !== null && $isElementNode(possibleNode) && !possibleNode.isInline() && !possibleNode.canBeEmpty()) {
      removeDOMBlockCursorElement(blockCursorElement, editor, rootElement);
    }
    moveNativeSelection(domSelection, alter, isBackward ? "backward" : "forward", granularity);
    if (domSelection.rangeCount > 0) {
      const range = domSelection.getRangeAt(0);
      const anchorNode = this.anchor.getNode();
      const root2 = $isRootNode(anchorNode) ? anchorNode : $getNearestRootOrShadowRoot(anchorNode);
      this.applyDOMRange(range);
      this.dirty = true;
      if (!collapse) {
        const nodes = this.getNodes();
        const validNodes = [];
        let shrinkSelection = false;
        for (let i3 = 0; i3 < nodes.length; i3++) {
          const nextNode = nodes[i3];
          if ($hasAncestor(nextNode, root2)) {
            validNodes.push(nextNode);
          } else {
            shrinkSelection = true;
          }
        }
        if (shrinkSelection && validNodes.length > 0) {
          if (isBackward) {
            const firstValidNode = validNodes[0];
            if ($isElementNode(firstValidNode)) {
              firstValidNode.selectStart();
            } else {
              firstValidNode.getParentOrThrow().selectStart();
            }
          } else {
            const lastValidNode = validNodes[validNodes.length - 1];
            if ($isElementNode(lastValidNode)) {
              lastValidNode.selectEnd();
            } else {
              lastValidNode.getParentOrThrow().selectEnd();
            }
          }
        }
        if (domSelection.anchorNode !== range.startContainer || domSelection.anchorOffset !== range.startOffset) {
          $swapPoints(this);
        }
      }
    }
  }
  /**
   * Helper for handling forward character and word deletion that prevents element nodes
   * like a table, columns layout being destroyed
   *
   * @param anchor the anchor
   * @param anchorNode the anchor node in the selection
   * @param isBackward whether or not selection is backwards
   */
  forwardDeletion(anchor, anchorNode, isBackward) {
    if (!isBackward && // Delete forward handle case
    (anchor.type === "element" && $isElementNode(anchorNode) && anchor.offset === anchorNode.getChildrenSize() || anchor.type === "text" && anchor.offset === anchorNode.getTextContentSize())) {
      const parent = anchorNode.getParent();
      const nextSibling = anchorNode.getNextSibling() || (parent === null ? null : parent.getNextSibling());
      if ($isElementNode(nextSibling) && nextSibling.isShadowRoot()) {
        return true;
      }
    }
    return false;
  }
  /**
   * Performs one logical character deletion operation on the EditorState based on the current Selection.
   * Handles different node types.
   *
   * @param isBackward whether or not the selection is backwards.
   */
  deleteCharacter(isBackward) {
    const wasCollapsed = this.isCollapsed();
    if (this.isCollapsed()) {
      const anchor = this.anchor;
      let anchorNode = anchor.getNode();
      if (this.forwardDeletion(anchor, anchorNode, isBackward)) {
        return;
      }
      const focus2 = this.focus;
      const possibleNode = $getAdjacentNode(focus2, isBackward);
      if ($isDecoratorNode(possibleNode) && !possibleNode.isIsolated()) {
        if (possibleNode.isKeyboardSelectable() && $isElementNode(anchorNode) && anchorNode.getChildrenSize() === 0) {
          anchorNode.remove();
          const nodeSelection = $createNodeSelection();
          nodeSelection.add(possibleNode.__key);
          $setSelection(nodeSelection);
        } else {
          possibleNode.remove();
          const editor = getActiveEditor();
          editor.dispatchCommand(SELECTION_CHANGE_COMMAND, void 0);
        }
        return;
      } else if (!isBackward && $isElementNode(possibleNode) && $isElementNode(anchorNode) && anchorNode.isEmpty()) {
        anchorNode.remove();
        possibleNode.selectStart();
        return;
      }
      this.modify("extend", isBackward, "character");
      if (!this.isCollapsed()) {
        const focusNode = focus2.type === "text" ? focus2.getNode() : null;
        anchorNode = anchor.type === "text" ? anchor.getNode() : null;
        if (focusNode !== null && focusNode.isSegmented()) {
          const offset5 = focus2.offset;
          const textContentSize = focusNode.getTextContentSize();
          if (focusNode.is(anchorNode) || isBackward && offset5 !== textContentSize || !isBackward && offset5 !== 0) {
            $removeSegment(focusNode, isBackward, offset5);
            return;
          }
        } else if (anchorNode !== null && anchorNode.isSegmented()) {
          const offset5 = anchor.offset;
          const textContentSize = anchorNode.getTextContentSize();
          if (anchorNode.is(focusNode) || isBackward && offset5 !== 0 || !isBackward && offset5 !== textContentSize) {
            $removeSegment(anchorNode, isBackward, offset5);
            return;
          }
        }
        $updateCaretSelectionForUnicodeCharacter(this, isBackward);
      } else if (isBackward && anchor.offset === 0) {
        const element2 = anchor.type === "element" ? anchor.getNode() : anchor.getNode().getParentOrThrow();
        if (element2.collapseAtStart(this)) {
          return;
        }
      }
    }
    this.removeText();
    if (isBackward && !wasCollapsed && this.isCollapsed() && this.anchor.type === "element" && this.anchor.offset === 0) {
      const anchorNode = this.anchor.getNode();
      if (anchorNode.isEmpty() && $isRootNode(anchorNode.getParent()) && anchorNode.getIndexWithinParent() === 0) {
        anchorNode.collapseAtStart(this);
      }
    }
  }
  /**
   * Performs one logical line deletion operation on the EditorState based on the current Selection.
   * Handles different node types.
   *
   * @param isBackward whether or not the selection is backwards.
   */
  deleteLine(isBackward) {
    if (this.isCollapsed()) {
      const anchorIsElement = this.anchor.type === "element";
      if (anchorIsElement) {
        this.insertText(" ");
      }
      this.modify("extend", isBackward, "lineboundary");
      if (this.isCollapsed() && this.anchor.offset === 0) {
        this.modify("extend", isBackward, "character");
      }
      if (anchorIsElement) {
        const startPoint = isBackward ? this.anchor : this.focus;
        startPoint.set(startPoint.key, startPoint.offset + 1, startPoint.type);
      }
    }
    this.removeText();
  }
  /**
   * Performs one logical word deletion operation on the EditorState based on the current Selection.
   * Handles different node types.
   *
   * @param isBackward whether or not the selection is backwards.
   */
  deleteWord(isBackward) {
    if (this.isCollapsed()) {
      const anchor = this.anchor;
      const anchorNode = anchor.getNode();
      if (this.forwardDeletion(anchor, anchorNode, isBackward)) {
        return;
      }
      this.modify("extend", isBackward, "word");
    }
    this.removeText();
  }
  /**
   * Returns whether the Selection is "backwards", meaning the focus
   * logically precedes the anchor in the EditorState.
   * @returns true if the Selection is backwards, false otherwise.
   */
  isBackward() {
    return this.focus.isBefore(this.anchor);
  }
  getStartEndPoints() {
    return [this.anchor, this.focus];
  }
};
function $isNodeSelection(x3) {
  return x3 instanceof NodeSelection;
}
function getCharacterOffset(point3) {
  const offset5 = point3.offset;
  if (point3.type === "text") {
    return offset5;
  }
  const parent = point3.getNode();
  return offset5 === parent.getChildrenSize() ? parent.getTextContent().length : 0;
}
function $getCharacterOffsets(selection2) {
  const anchorAndFocus = selection2.getStartEndPoints();
  if (anchorAndFocus === null) {
    return [0, 0];
  }
  const [anchor, focus2] = anchorAndFocus;
  if (anchor.type === "element" && focus2.type === "element" && anchor.key === focus2.key && anchor.offset === focus2.offset) {
    return [0, 0];
  }
  return [getCharacterOffset(anchor), getCharacterOffset(focus2)];
}
function $swapPoints(selection2) {
  const focus2 = selection2.focus;
  const anchor = selection2.anchor;
  const anchorKey = anchor.key;
  const anchorOffset = anchor.offset;
  const anchorType = anchor.type;
  $setPointValues(anchor, focus2.key, focus2.offset, focus2.type);
  $setPointValues(focus2, anchorKey, anchorOffset, anchorType);
  selection2._cachedNodes = null;
}
function moveNativeSelection(domSelection, alter, direction, granularity) {
  domSelection.modify(alter, direction, granularity);
}
function $updateCaretSelectionForUnicodeCharacter(selection2, isBackward) {
  const anchor = selection2.anchor;
  const focus2 = selection2.focus;
  const anchorNode = anchor.getNode();
  const focusNode = focus2.getNode();
  if (anchorNode === focusNode && anchor.type === "text" && focus2.type === "text") {
    const anchorOffset = anchor.offset;
    const focusOffset = focus2.offset;
    const isBefore = anchorOffset < focusOffset;
    const startOffset = isBefore ? anchorOffset : focusOffset;
    const endOffset = isBefore ? focusOffset : anchorOffset;
    const characterOffset = endOffset - 1;
    if (startOffset !== characterOffset) {
      const text4 = anchorNode.getTextContent().slice(startOffset, endOffset);
      if (!doesContainGrapheme(text4)) {
        if (isBackward) {
          focus2.offset = characterOffset;
        } else {
          anchor.offset = characterOffset;
        }
      }
    }
  }
}
function $removeSegment(node2, isBackward, offset5) {
  const textNode = node2;
  const textContent = textNode.getTextContent();
  const split = textContent.split(/(?=\s)/g);
  const splitLength = split.length;
  let segmentOffset = 0;
  let restoreOffset = 0;
  for (let i3 = 0; i3 < splitLength; i3++) {
    const text4 = split[i3];
    const isLast = i3 === splitLength - 1;
    restoreOffset = segmentOffset;
    segmentOffset += text4.length;
    if (isBackward && segmentOffset === offset5 || segmentOffset > offset5 || isLast) {
      split.splice(i3, 1);
      if (isLast) {
        restoreOffset = void 0;
      }
      break;
    }
  }
  const nextTextContent = split.join("").trim();
  if (nextTextContent === "") {
    textNode.remove();
  } else {
    textNode.setTextContent(nextTextContent);
    textNode.select(restoreOffset, restoreOffset);
  }
}
function shouldResolveAncestor(resolvedElement, resolvedOffset, lastPoint) {
  const parent = resolvedElement.getParent();
  return lastPoint === null || parent === null || !parent.canBeEmpty() || parent !== lastPoint.getNode();
}
function $internalResolveSelectionPoint(dom, offset5, lastPoint, editor) {
  let resolvedOffset = offset5;
  let resolvedNode;
  if (isHTMLElement(dom)) {
    let moveSelectionToEnd = false;
    const childNodes = dom.childNodes;
    const childNodesLength = childNodes.length;
    const blockCursorElement = editor._blockCursorElement;
    if (resolvedOffset === childNodesLength) {
      moveSelectionToEnd = true;
      resolvedOffset = childNodesLength - 1;
    }
    let childDOM = childNodes[resolvedOffset];
    let hasBlockCursor = false;
    if (childDOM === blockCursorElement) {
      childDOM = childNodes[resolvedOffset + 1];
      hasBlockCursor = true;
    } else if (blockCursorElement !== null) {
      const blockCursorElementParent = blockCursorElement.parentNode;
      if (dom === blockCursorElementParent) {
        const blockCursorOffset = Array.prototype.indexOf.call(blockCursorElementParent.children, blockCursorElement);
        if (offset5 > blockCursorOffset) {
          resolvedOffset--;
        }
      }
    }
    resolvedNode = $getNodeFromDOM(childDOM);
    if ($isTextNode(resolvedNode)) {
      resolvedOffset = getTextNodeOffset(resolvedNode, moveSelectionToEnd);
    } else {
      let resolvedElement = $getNodeFromDOM(dom);
      if (resolvedElement === null) {
        return null;
      }
      if ($isElementNode(resolvedElement)) {
        const elementDOM = editor.getElementByKey(resolvedElement.getKey());
        if (!(elementDOM !== null)) {
          throw Error(`$internalResolveSelectionPoint: node in DOM but not keyToDOMMap`);
        }
        const slot = resolvedElement.getDOMSlot(elementDOM);
        [resolvedElement, resolvedOffset] = slot.resolveChildIndex(resolvedElement, elementDOM, dom, offset5);
        if (!$isElementNode(resolvedElement)) {
          throw Error(`$internalResolveSelectionPoint: resolvedElement is not an ElementNode`);
        }
        if (moveSelectionToEnd && resolvedOffset >= resolvedElement.getChildrenSize()) {
          resolvedOffset = Math.max(0, resolvedElement.getChildrenSize() - 1);
        }
        let child = resolvedElement.getChildAtIndex(resolvedOffset);
        if ($isElementNode(child) && shouldResolveAncestor(child, resolvedOffset, lastPoint)) {
          const descendant = moveSelectionToEnd ? child.getLastDescendant() : child.getFirstDescendant();
          if (descendant === null) {
            resolvedElement = child;
          } else {
            child = descendant;
            resolvedElement = $isElementNode(child) ? child : child.getParentOrThrow();
          }
          resolvedOffset = 0;
        }
        if ($isTextNode(child)) {
          resolvedNode = child;
          resolvedElement = null;
          resolvedOffset = getTextNodeOffset(child, moveSelectionToEnd);
        } else if (child !== resolvedElement && moveSelectionToEnd && !hasBlockCursor) {
          if (!$isElementNode(resolvedElement)) {
            throw Error(`invariant`);
          }
          resolvedOffset = Math.min(resolvedElement.getChildrenSize(), resolvedOffset + 1);
        }
      } else {
        const index3 = resolvedElement.getIndexWithinParent();
        if (offset5 === 0 && $isDecoratorNode(resolvedElement) && $getNodeFromDOM(dom) === resolvedElement) {
          resolvedOffset = index3;
        } else {
          resolvedOffset = index3 + 1;
        }
        resolvedElement = resolvedElement.getParentOrThrow();
      }
      if ($isElementNode(resolvedElement)) {
        return $createPoint(resolvedElement.__key, resolvedOffset, "element");
      }
    }
  } else {
    resolvedNode = $getNodeFromDOM(dom);
  }
  if (!$isTextNode(resolvedNode)) {
    return null;
  }
  return $createPoint(resolvedNode.__key, resolvedOffset, "text");
}
function resolveSelectionPointOnBoundary(point3, isBackward, isCollapsed) {
  const offset5 = point3.offset;
  const node2 = point3.getNode();
  if (offset5 === 0) {
    const prevSibling = node2.getPreviousSibling();
    const parent = node2.getParent();
    if (!isBackward) {
      if ($isElementNode(prevSibling) && !isCollapsed && prevSibling.isInline()) {
        point3.key = prevSibling.__key;
        point3.offset = prevSibling.getChildrenSize();
        point3.type = "element";
      } else if ($isTextNode(prevSibling)) {
        point3.key = prevSibling.__key;
        point3.offset = prevSibling.getTextContent().length;
      }
    } else if ((isCollapsed || !isBackward) && prevSibling === null && $isElementNode(parent) && parent.isInline()) {
      const parentSibling = parent.getPreviousSibling();
      if ($isTextNode(parentSibling)) {
        point3.key = parentSibling.__key;
        point3.offset = parentSibling.getTextContent().length;
      }
    }
  } else if (offset5 === node2.getTextContent().length) {
    const nextSibling = node2.getNextSibling();
    const parent = node2.getParent();
    if (isBackward && $isElementNode(nextSibling) && nextSibling.isInline()) {
      point3.key = nextSibling.__key;
      point3.offset = 0;
      point3.type = "element";
    } else if ((isCollapsed || isBackward) && nextSibling === null && $isElementNode(parent) && parent.isInline() && !parent.canInsertTextAfter()) {
      const parentSibling = parent.getNextSibling();
      if ($isTextNode(parentSibling)) {
        point3.key = parentSibling.__key;
        point3.offset = 0;
      }
    }
  }
}
function $normalizeSelectionPointsForBoundaries(anchor, focus2, lastSelection) {
  if (anchor.type === "text" && focus2.type === "text") {
    const isBackward = anchor.isBefore(focus2);
    const isCollapsed = anchor.is(focus2);
    resolveSelectionPointOnBoundary(anchor, isBackward, isCollapsed);
    resolveSelectionPointOnBoundary(focus2, !isBackward, isCollapsed);
    if (isCollapsed) {
      focus2.key = anchor.key;
      focus2.offset = anchor.offset;
      focus2.type = anchor.type;
    }
    const editor = getActiveEditor();
    if (editor.isComposing() && editor._compositionKey !== anchor.key && $isRangeSelection(lastSelection)) {
      const lastAnchor = lastSelection.anchor;
      const lastFocus = lastSelection.focus;
      $setPointValues(anchor, lastAnchor.key, lastAnchor.offset, lastAnchor.type);
      $setPointValues(focus2, lastFocus.key, lastFocus.offset, lastFocus.type);
    }
  }
}
function $internalResolveSelectionPoints(anchorDOM, anchorOffset, focusDOM, focusOffset, editor, lastSelection) {
  if (anchorDOM === null || focusDOM === null || !isSelectionWithinEditor(editor, anchorDOM, focusDOM)) {
    return null;
  }
  const resolvedAnchorPoint = $internalResolveSelectionPoint(anchorDOM, anchorOffset, $isRangeSelection(lastSelection) ? lastSelection.anchor : null, editor);
  if (resolvedAnchorPoint === null) {
    return null;
  }
  {
    $validatePoint(editor, "anchor", resolvedAnchorPoint);
  }
  const resolvedFocusPoint = $internalResolveSelectionPoint(focusDOM, focusOffset, $isRangeSelection(lastSelection) ? lastSelection.focus : null, editor);
  if (resolvedFocusPoint === null) {
    return null;
  }
  {
    $validatePoint(editor, "focus", resolvedAnchorPoint);
  }
  if (resolvedAnchorPoint.type === "element" && resolvedFocusPoint.type === "element") {
    const anchorNode = $getNodeFromDOM(anchorDOM);
    const focusNode = $getNodeFromDOM(focusDOM);
    if ($isDecoratorNode(anchorNode) && $isDecoratorNode(focusNode)) {
      return null;
    }
  }
  $normalizeSelectionPointsForBoundaries(resolvedAnchorPoint, resolvedFocusPoint, lastSelection);
  return [resolvedAnchorPoint, resolvedFocusPoint];
}
function $isBlockElementNode(node2) {
  return $isElementNode(node2) && !node2.isInline();
}
function $internalMakeRangeSelection(anchorKey, anchorOffset, focusKey, focusOffset, anchorType, focusType) {
  const editorState = getActiveEditorState();
  const selection2 = new RangeSelection($createPoint(anchorKey, anchorOffset, anchorType), $createPoint(focusKey, focusOffset, focusType), 0, "");
  selection2.dirty = true;
  editorState._selection = selection2;
  return selection2;
}
function $createRangeSelection() {
  const anchor = $createPoint("root", 0, "element");
  const focus2 = $createPoint("root", 0, "element");
  return new RangeSelection(anchor, focus2, 0, "");
}
function $createNodeSelection() {
  return new NodeSelection(/* @__PURE__ */ new Set());
}
function $internalCreateSelection(editor) {
  const currentEditorState = editor.getEditorState();
  const lastSelection = currentEditorState._selection;
  const domSelection = getDOMSelection(editor._window);
  if ($isRangeSelection(lastSelection) || lastSelection == null) {
    return $internalCreateRangeSelection(lastSelection, domSelection, editor, null);
  }
  return lastSelection.clone();
}
function $internalCreateRangeSelection(lastSelection, domSelection, editor, event) {
  const windowObj = editor._window;
  if (windowObj === null) {
    return null;
  }
  const windowEvent = event || windowObj.event;
  const eventType = windowEvent ? windowEvent.type : void 0;
  const isSelectionChange = eventType === "selectionchange";
  const useDOMSelection = !getIsProcessingMutations() && (isSelectionChange || eventType === "beforeinput" || eventType === "compositionstart" || eventType === "compositionend" || eventType === "click" && windowEvent && windowEvent.detail === 3 || eventType === "drop" || eventType === void 0);
  let anchorDOM, focusDOM, anchorOffset, focusOffset;
  if (!$isRangeSelection(lastSelection) || useDOMSelection) {
    if (domSelection === null) {
      return null;
    }
    anchorDOM = domSelection.anchorNode;
    focusDOM = domSelection.focusNode;
    anchorOffset = domSelection.anchorOffset;
    focusOffset = domSelection.focusOffset;
    if (isSelectionChange && $isRangeSelection(lastSelection) && !isSelectionWithinEditor(editor, anchorDOM, focusDOM)) {
      return lastSelection.clone();
    }
  } else {
    return lastSelection.clone();
  }
  const resolvedSelectionPoints = $internalResolveSelectionPoints(anchorDOM, anchorOffset, focusDOM, focusOffset, editor, lastSelection);
  if (resolvedSelectionPoints === null) {
    return null;
  }
  const [resolvedAnchorPoint, resolvedFocusPoint] = resolvedSelectionPoints;
  return new RangeSelection(resolvedAnchorPoint, resolvedFocusPoint, !$isRangeSelection(lastSelection) ? 0 : lastSelection.format, !$isRangeSelection(lastSelection) ? "" : lastSelection.style);
}
function $validatePoint(editor, name2, point3) {
  const node2 = $getNodeByKey(point3.key);
  if (!(node2 !== void 0)) {
    throw Error(`$validatePoint: ${name2} key ${point3.key} not found in current editorState`);
  }
  if (point3.type === "text") {
    if (!$isTextNode(node2)) {
      throw Error(`$validatePoint: ${name2} key ${point3.key} is not a TextNode`);
    }
    const size4 = node2.getTextContentSize();
    if (!(point3.offset <= size4)) {
      throw Error(`$validatePoint: ${name2} point.offset > node.getTextContentSize() (${String(point3.offset)} > ${String(size4)})`);
    }
  } else {
    if (!$isElementNode(node2)) {
      throw Error(`$validatePoint: ${name2} key ${point3.key} is not an ElementNode`);
    }
    const size4 = node2.getChildrenSize();
    if (!(point3.offset <= size4)) {
      throw Error(`$validatePoint: ${name2} point.offset > node.getChildrenSize() (${String(point3.offset)} > ${String(size4)})`);
    }
  }
}
function $getSelection() {
  const editorState = getActiveEditorState();
  return editorState._selection;
}
function $getPreviousSelection() {
  const editor = getActiveEditor();
  return editor._editorState._selection;
}
function $updateElementSelectionOnCreateDeleteNode(selection2, parentNode, nodeOffset, times = 1) {
  const anchor = selection2.anchor;
  const focus2 = selection2.focus;
  const anchorNode = anchor.getNode();
  const focusNode = focus2.getNode();
  if (!parentNode.is(anchorNode) && !parentNode.is(focusNode)) {
    return;
  }
  const parentKey = parentNode.__key;
  if (selection2.isCollapsed()) {
    const selectionOffset = anchor.offset;
    if (nodeOffset <= selectionOffset && times > 0 || nodeOffset < selectionOffset && times < 0) {
      const newSelectionOffset = Math.max(0, selectionOffset + times);
      anchor.set(parentKey, newSelectionOffset, "element");
      focus2.set(parentKey, newSelectionOffset, "element");
      $updateSelectionResolveTextNodes(selection2);
    }
  } else {
    const isBackward = selection2.isBackward();
    const firstPoint = isBackward ? focus2 : anchor;
    const firstPointNode = firstPoint.getNode();
    const lastPoint = isBackward ? anchor : focus2;
    const lastPointNode = lastPoint.getNode();
    if (parentNode.is(firstPointNode)) {
      const firstPointOffset = firstPoint.offset;
      if (nodeOffset <= firstPointOffset && times > 0 || nodeOffset < firstPointOffset && times < 0) {
        firstPoint.set(parentKey, Math.max(0, firstPointOffset + times), "element");
      }
    }
    if (parentNode.is(lastPointNode)) {
      const lastPointOffset = lastPoint.offset;
      if (nodeOffset <= lastPointOffset && times > 0 || nodeOffset < lastPointOffset && times < 0) {
        lastPoint.set(parentKey, Math.max(0, lastPointOffset + times), "element");
      }
    }
  }
  $updateSelectionResolveTextNodes(selection2);
}
function $updateSelectionResolveTextNodes(selection2) {
  const anchor = selection2.anchor;
  const anchorOffset = anchor.offset;
  const focus2 = selection2.focus;
  const focusOffset = focus2.offset;
  const anchorNode = anchor.getNode();
  const focusNode = focus2.getNode();
  if (selection2.isCollapsed()) {
    if (!$isElementNode(anchorNode)) {
      return;
    }
    const childSize = anchorNode.getChildrenSize();
    const anchorOffsetAtEnd = anchorOffset >= childSize;
    const child = anchorOffsetAtEnd ? anchorNode.getChildAtIndex(childSize - 1) : anchorNode.getChildAtIndex(anchorOffset);
    if ($isTextNode(child)) {
      let newOffset = 0;
      if (anchorOffsetAtEnd) {
        newOffset = child.getTextContentSize();
      }
      anchor.set(child.__key, newOffset, "text");
      focus2.set(child.__key, newOffset, "text");
    }
    return;
  }
  if ($isElementNode(anchorNode)) {
    const childSize = anchorNode.getChildrenSize();
    const anchorOffsetAtEnd = anchorOffset >= childSize;
    const child = anchorOffsetAtEnd ? anchorNode.getChildAtIndex(childSize - 1) : anchorNode.getChildAtIndex(anchorOffset);
    if ($isTextNode(child)) {
      let newOffset = 0;
      if (anchorOffsetAtEnd) {
        newOffset = child.getTextContentSize();
      }
      anchor.set(child.__key, newOffset, "text");
    }
  }
  if ($isElementNode(focusNode)) {
    const childSize = focusNode.getChildrenSize();
    const focusOffsetAtEnd = focusOffset >= childSize;
    const child = focusOffsetAtEnd ? focusNode.getChildAtIndex(childSize - 1) : focusNode.getChildAtIndex(focusOffset);
    if ($isTextNode(child)) {
      let newOffset = 0;
      if (focusOffsetAtEnd) {
        newOffset = child.getTextContentSize();
      }
      focus2.set(child.__key, newOffset, "text");
    }
  }
}
function applySelectionTransforms(nextEditorState, editor) {
  const prevEditorState = editor.getEditorState();
  const prevSelection = prevEditorState._selection;
  const nextSelection = nextEditorState._selection;
  if ($isRangeSelection(nextSelection)) {
    const anchor = nextSelection.anchor;
    const focus2 = nextSelection.focus;
    let anchorNode;
    if (anchor.type === "text") {
      anchorNode = anchor.getNode();
      anchorNode.selectionTransform(prevSelection, nextSelection);
    }
    if (focus2.type === "text") {
      const focusNode = focus2.getNode();
      if (anchorNode !== focusNode) {
        focusNode.selectionTransform(prevSelection, nextSelection);
      }
    }
  }
}
function moveSelectionPointToSibling(point3, node2, parent, prevSibling, nextSibling) {
  let siblingKey = null;
  let offset5 = 0;
  let type2 = null;
  if (prevSibling !== null) {
    siblingKey = prevSibling.__key;
    if ($isTextNode(prevSibling)) {
      offset5 = prevSibling.getTextContentSize();
      type2 = "text";
    } else if ($isElementNode(prevSibling)) {
      offset5 = prevSibling.getChildrenSize();
      type2 = "element";
    }
  } else {
    if (nextSibling !== null) {
      siblingKey = nextSibling.__key;
      if ($isTextNode(nextSibling)) {
        type2 = "text";
      } else if ($isElementNode(nextSibling)) {
        type2 = "element";
      }
    }
  }
  if (siblingKey !== null && type2 !== null) {
    point3.set(siblingKey, offset5, type2);
  } else {
    offset5 = node2.getIndexWithinParent();
    if (offset5 === -1) {
      offset5 = parent.getChildrenSize();
    }
    point3.set(parent.__key, offset5, "element");
  }
}
function adjustPointOffsetForMergedSibling(point3, isBefore, key2, target, textLength) {
  if (point3.type === "text") {
    point3.key = key2;
    if (!isBefore) {
      point3.offset += textLength;
    }
  } else if (point3.offset > target.getIndexWithinParent()) {
    point3.offset -= 1;
  }
}
function updateDOMSelection(prevSelection, nextSelection, editor, domSelection, tags2, rootElement, nodeCount) {
  const anchorDOMNode = domSelection.anchorNode;
  const focusDOMNode = domSelection.focusNode;
  const anchorOffset = domSelection.anchorOffset;
  const focusOffset = domSelection.focusOffset;
  const activeElement = document.activeElement;
  if (tags2.has("collaboration") && activeElement !== rootElement || activeElement !== null && isSelectionCapturedInDecoratorInput(activeElement)) {
    return;
  }
  if (!$isRangeSelection(nextSelection)) {
    if (prevSelection !== null && isSelectionWithinEditor(editor, anchorDOMNode, focusDOMNode)) {
      domSelection.removeAllRanges();
    }
    return;
  }
  const anchor = nextSelection.anchor;
  const focus2 = nextSelection.focus;
  const anchorKey = anchor.key;
  const focusKey = focus2.key;
  const anchorDOM = getElementByKeyOrThrow(editor, anchorKey);
  const focusDOM = getElementByKeyOrThrow(editor, focusKey);
  const nextAnchorOffset = anchor.offset;
  const nextFocusOffset = focus2.offset;
  const nextFormat = nextSelection.format;
  const nextStyle = nextSelection.style;
  const isCollapsed = nextSelection.isCollapsed();
  let nextAnchorNode = anchorDOM;
  let nextFocusNode = focusDOM;
  let anchorFormatOrStyleChanged = false;
  if (anchor.type === "text") {
    nextAnchorNode = getDOMTextNode(anchorDOM);
    const anchorNode = anchor.getNode();
    anchorFormatOrStyleChanged = anchorNode.getFormat() !== nextFormat || anchorNode.getStyle() !== nextStyle;
  } else if ($isRangeSelection(prevSelection) && prevSelection.anchor.type === "text") {
    anchorFormatOrStyleChanged = true;
  }
  if (focus2.type === "text") {
    nextFocusNode = getDOMTextNode(focusDOM);
  }
  if (nextAnchorNode === null || nextFocusNode === null) {
    return;
  }
  if (isCollapsed && (prevSelection === null || anchorFormatOrStyleChanged || $isRangeSelection(prevSelection) && (prevSelection.format !== nextFormat || prevSelection.style !== nextStyle))) {
    markCollapsedSelectionFormat(nextFormat, nextStyle, nextAnchorOffset, anchorKey, performance.now());
  }
  if (anchorOffset === nextAnchorOffset && focusOffset === nextFocusOffset && anchorDOMNode === nextAnchorNode && focusDOMNode === nextFocusNode && // Badly interpreted range selection when collapsed - #1482
  !(domSelection.type === "Range" && isCollapsed)) {
    if (activeElement === null || !rootElement.contains(activeElement)) {
      rootElement.focus({
        preventScroll: true
      });
    }
    if (anchor.type !== "element") {
      return;
    }
  }
  try {
    domSelection.setBaseAndExtent(nextAnchorNode, nextAnchorOffset, nextFocusNode, nextFocusOffset);
  } catch (error) {
    {
      console.warn(error);
    }
  }
  if (!tags2.has("skip-scroll-into-view") && nextSelection.isCollapsed() && rootElement !== null && rootElement === document.activeElement) {
    const selectionTarget = $isRangeSelection(nextSelection) && nextSelection.anchor.type === "element" ? nextAnchorNode.childNodes[nextAnchorOffset] || null : domSelection.rangeCount > 0 ? domSelection.getRangeAt(0) : null;
    if (selectionTarget !== null) {
      let selectionRect;
      if (selectionTarget instanceof Text) {
        const range = document.createRange();
        range.selectNode(selectionTarget);
        selectionRect = range.getBoundingClientRect();
      } else {
        selectionRect = selectionTarget.getBoundingClientRect();
      }
      scrollIntoViewIfNeeded(editor, selectionRect, rootElement);
    }
  }
  markSelectionChangeFromDOMUpdate();
}
function $insertNodes(nodes) {
  let selection2 = $getSelection() || $getPreviousSelection();
  if (selection2 === null) {
    selection2 = $getRoot().selectEnd();
  }
  selection2.insertNodes(nodes);
}
function $removeTextAndSplitBlock(selection2) {
  let selection_ = selection2;
  if (!selection2.isCollapsed()) {
    selection_.removeText();
  }
  const newSelection = $getSelection();
  if ($isRangeSelection(newSelection)) {
    selection_ = newSelection;
  }
  if (!$isRangeSelection(selection_)) {
    throw Error(`Unexpected dirty selection to be null`);
  }
  const anchor = selection_.anchor;
  let node2 = anchor.getNode();
  let offset5 = anchor.offset;
  while (!INTERNAL_$isBlock(node2)) {
    [node2, offset5] = $splitNodeAtPoint(node2, offset5);
  }
  return offset5;
}
function $splitNodeAtPoint(node2, offset5) {
  const parent = node2.getParent();
  if (!parent) {
    const paragraph2 = $createParagraphNode();
    $getRoot().append(paragraph2);
    paragraph2.select();
    return [$getRoot(), 0];
  }
  if ($isTextNode(node2)) {
    const split = node2.splitText(offset5);
    if (split.length === 0) {
      return [parent, node2.getIndexWithinParent()];
    }
    const x3 = offset5 === 0 ? 0 : 1;
    const index3 = split[0].getIndexWithinParent() + x3;
    return [parent, index3];
  }
  if (!$isElementNode(node2) || offset5 === 0) {
    return [parent, node2.getIndexWithinParent()];
  }
  const firstToAppend = node2.getChildAtIndex(offset5);
  if (firstToAppend) {
    const insertPoint = new RangeSelection($createPoint(node2.__key, offset5, "element"), $createPoint(node2.__key, offset5, "element"), 0, "");
    const newElement = node2.insertNewAfter(insertPoint);
    if (newElement) {
      newElement.append(firstToAppend, ...firstToAppend.getNextSiblings());
    }
  }
  return [parent, node2.getIndexWithinParent() + 1];
}
function $wrapInlineNodes(nodes) {
  const virtualRoot = $createParagraphNode();
  let currentBlock = null;
  for (let i3 = 0; i3 < nodes.length; i3++) {
    const node2 = nodes[i3];
    const isLineBreakNode = $isLineBreakNode(node2);
    if (isLineBreakNode || $isDecoratorNode(node2) && node2.isInline() || $isElementNode(node2) && node2.isInline() || $isTextNode(node2) || node2.isParentRequired()) {
      if (currentBlock === null) {
        currentBlock = node2.createParentElementNode();
        virtualRoot.append(currentBlock);
        if (isLineBreakNode) {
          continue;
        }
      }
      if (currentBlock !== null) {
        currentBlock.append(node2);
      }
    } else {
      virtualRoot.append(node2);
      currentBlock = null;
    }
  }
  return virtualRoot;
}
var activeEditorState = null;
var activeEditor = null;
var isReadOnlyMode = false;
var isAttemptingToRecoverFromReconcilerError = false;
var infiniteTransformCount = 0;
var observerOptions = {
  characterData: true,
  childList: true,
  subtree: true
};
function isCurrentlyReadOnlyMode() {
  return isReadOnlyMode || activeEditorState !== null && activeEditorState._readOnly;
}
function errorOnReadOnly() {
  if (isReadOnlyMode) {
    {
      throw Error(`Cannot use method in read-only mode.`);
    }
  }
}
function errorOnInfiniteTransforms() {
  if (infiniteTransformCount > 99) {
    {
      throw Error(`One or more transforms are endlessly triggering additional transforms. May have encountered infinite recursion caused by transforms that have their preconditions too lose and/or conflict with each other.`);
    }
  }
}
function getActiveEditorState() {
  if (activeEditorState === null) {
    {
      throw Error(`Unable to find an active editor state. State helpers or node methods can only be used synchronously during the callback of editor.update(), editor.read(), or editorState.read().${collectBuildInformation()}`);
    }
  }
  return activeEditorState;
}
function getActiveEditor() {
  if (activeEditor === null) {
    {
      throw Error(`Unable to find an active editor. This method can only be used synchronously during the callback of editor.update() or editor.read().${collectBuildInformation()}`);
    }
  }
  return activeEditor;
}
function collectBuildInformation() {
  let compatibleEditors = 0;
  const incompatibleEditors = /* @__PURE__ */ new Set();
  const thisVersion = LexicalEditor.version;
  if (typeof window !== "undefined") {
    for (const node2 of document.querySelectorAll("[contenteditable]")) {
      const editor = getEditorPropertyFromDOMNode(node2);
      if (isLexicalEditor(editor)) {
        compatibleEditors++;
      } else if (editor) {
        let version2 = String(editor.constructor.version || "<0.17.1");
        if (version2 === thisVersion) {
          version2 += " (separately built, likely a bundler configuration issue)";
        }
        incompatibleEditors.add(version2);
      }
    }
  }
  let output = ` Detected on the page: ${compatibleEditors} compatible editor(s) with version ${thisVersion}`;
  if (incompatibleEditors.size) {
    output += ` and incompatible editors with versions ${Array.from(incompatibleEditors).join(", ")}`;
  }
  return output;
}
function internalGetActiveEditor() {
  return activeEditor;
}
function internalGetActiveEditorState() {
  return activeEditorState;
}
function $applyTransforms(editor, node2, transformsCache) {
  const type2 = node2.__type;
  const registeredNode = getRegisteredNodeOrThrow(editor, type2);
  let transformsArr = transformsCache.get(type2);
  if (transformsArr === void 0) {
    transformsArr = Array.from(registeredNode.transforms);
    transformsCache.set(type2, transformsArr);
  }
  const transformsArrLength = transformsArr.length;
  for (let i3 = 0; i3 < transformsArrLength; i3++) {
    transformsArr[i3](node2);
    if (!node2.isAttached()) {
      break;
    }
  }
}
function $isNodeValidForTransform(node2, compositionKey) {
  return node2 !== void 0 && // We don't want to transform nodes being composed
  node2.__key !== compositionKey && node2.isAttached();
}
function $normalizeAllDirtyTextNodes(editorState, editor) {
  const dirtyLeaves = editor._dirtyLeaves;
  const nodeMap = editorState._nodeMap;
  for (const nodeKey of dirtyLeaves) {
    const node2 = nodeMap.get(nodeKey);
    if ($isTextNode(node2) && node2.isAttached() && node2.isSimpleText() && !node2.isUnmergeable()) {
      $normalizeTextNode(node2);
    }
  }
}
function addTags(editor, tags2) {
  if (!tags2) {
    return;
  }
  const updateTags = editor._updateTags;
  let tags_ = tags2;
  if (!Array.isArray(tags2)) {
    tags_ = [tags2];
  }
  for (const tag of tags_) {
    updateTags.add(tag);
  }
}
function $applyAllTransforms(editorState, editor) {
  const dirtyLeaves = editor._dirtyLeaves;
  const dirtyElements = editor._dirtyElements;
  const nodeMap = editorState._nodeMap;
  const compositionKey = $getCompositionKey();
  const transformsCache = /* @__PURE__ */ new Map();
  let untransformedDirtyLeaves = dirtyLeaves;
  let untransformedDirtyLeavesLength = untransformedDirtyLeaves.size;
  let untransformedDirtyElements = dirtyElements;
  let untransformedDirtyElementsLength = untransformedDirtyElements.size;
  while (untransformedDirtyLeavesLength > 0 || untransformedDirtyElementsLength > 0) {
    if (untransformedDirtyLeavesLength > 0) {
      editor._dirtyLeaves = /* @__PURE__ */ new Set();
      for (const nodeKey of untransformedDirtyLeaves) {
        const node2 = nodeMap.get(nodeKey);
        if ($isTextNode(node2) && node2.isAttached() && node2.isSimpleText() && !node2.isUnmergeable()) {
          $normalizeTextNode(node2);
        }
        if (node2 !== void 0 && $isNodeValidForTransform(node2, compositionKey)) {
          $applyTransforms(editor, node2, transformsCache);
        }
        dirtyLeaves.add(nodeKey);
      }
      untransformedDirtyLeaves = editor._dirtyLeaves;
      untransformedDirtyLeavesLength = untransformedDirtyLeaves.size;
      if (untransformedDirtyLeavesLength > 0) {
        infiniteTransformCount++;
        continue;
      }
    }
    editor._dirtyLeaves = /* @__PURE__ */ new Set();
    editor._dirtyElements = /* @__PURE__ */ new Map();
    for (const currentUntransformedDirtyElement of untransformedDirtyElements) {
      const nodeKey = currentUntransformedDirtyElement[0];
      const intentionallyMarkedAsDirty = currentUntransformedDirtyElement[1];
      if (nodeKey !== "root" && !intentionallyMarkedAsDirty) {
        continue;
      }
      const node2 = nodeMap.get(nodeKey);
      if (node2 !== void 0 && $isNodeValidForTransform(node2, compositionKey)) {
        $applyTransforms(editor, node2, transformsCache);
      }
      dirtyElements.set(nodeKey, intentionallyMarkedAsDirty);
    }
    untransformedDirtyLeaves = editor._dirtyLeaves;
    untransformedDirtyLeavesLength = untransformedDirtyLeaves.size;
    untransformedDirtyElements = editor._dirtyElements;
    untransformedDirtyElementsLength = untransformedDirtyElements.size;
    infiniteTransformCount++;
  }
  editor._dirtyLeaves = dirtyLeaves;
  editor._dirtyElements = dirtyElements;
}
function $parseSerializedNode(serializedNode) {
  const internalSerializedNode = serializedNode;
  return $parseSerializedNodeImpl(internalSerializedNode, getActiveEditor()._nodes);
}
function $parseSerializedNodeImpl(serializedNode, registeredNodes) {
  const type2 = serializedNode.type;
  const registeredNode = registeredNodes.get(type2);
  if (registeredNode === void 0) {
    {
      throw Error(`parseEditorState: type "${type2}" + not found`);
    }
  }
  const nodeClass = registeredNode.klass;
  if (serializedNode.type !== nodeClass.getType()) {
    {
      throw Error(`LexicalNode: Node ${nodeClass.name} does not implement .importJSON().`);
    }
  }
  const node2 = nodeClass.importJSON(serializedNode);
  const children = serializedNode.children;
  if ($isElementNode(node2) && Array.isArray(children)) {
    for (let i3 = 0; i3 < children.length; i3++) {
      const serializedJSONChildNode = children[i3];
      const childNode = $parseSerializedNodeImpl(serializedJSONChildNode, registeredNodes);
      node2.append(childNode);
    }
  }
  return node2;
}
function parseEditorState(serializedEditorState, editor, updateFn) {
  const editorState = createEmptyEditorState();
  const previousActiveEditorState = activeEditorState;
  const previousReadOnlyMode = isReadOnlyMode;
  const previousActiveEditor = activeEditor;
  const previousDirtyElements = editor._dirtyElements;
  const previousDirtyLeaves = editor._dirtyLeaves;
  const previousCloneNotNeeded = editor._cloneNotNeeded;
  const previousDirtyType = editor._dirtyType;
  editor._dirtyElements = /* @__PURE__ */ new Map();
  editor._dirtyLeaves = /* @__PURE__ */ new Set();
  editor._cloneNotNeeded = /* @__PURE__ */ new Set();
  editor._dirtyType = 0;
  activeEditorState = editorState;
  isReadOnlyMode = false;
  activeEditor = editor;
  try {
    const registeredNodes = editor._nodes;
    const serializedNode = serializedEditorState.root;
    $parseSerializedNodeImpl(serializedNode, registeredNodes);
    if (updateFn) {
      updateFn();
    }
    editorState._readOnly = true;
    {
      handleDEVOnlyPendingUpdateGuarantees(editorState);
    }
  } catch (error) {
    if (error instanceof Error) {
      editor._onError(error);
    }
  } finally {
    editor._dirtyElements = previousDirtyElements;
    editor._dirtyLeaves = previousDirtyLeaves;
    editor._cloneNotNeeded = previousCloneNotNeeded;
    editor._dirtyType = previousDirtyType;
    activeEditorState = previousActiveEditorState;
    isReadOnlyMode = previousReadOnlyMode;
    activeEditor = previousActiveEditor;
  }
  return editorState;
}
function readEditorState(editor, editorState, callbackFn) {
  const previousActiveEditorState = activeEditorState;
  const previousReadOnlyMode = isReadOnlyMode;
  const previousActiveEditor = activeEditor;
  activeEditorState = editorState;
  isReadOnlyMode = true;
  activeEditor = editor;
  try {
    return callbackFn();
  } finally {
    activeEditorState = previousActiveEditorState;
    isReadOnlyMode = previousReadOnlyMode;
    activeEditor = previousActiveEditor;
  }
}
function handleDEVOnlyPendingUpdateGuarantees(pendingEditorState) {
  const nodeMap = pendingEditorState._nodeMap;
  nodeMap.set = () => {
    throw new Error("Cannot call set() on a frozen Lexical node map");
  };
  nodeMap.clear = () => {
    throw new Error("Cannot call clear() on a frozen Lexical node map");
  };
  nodeMap.delete = () => {
    throw new Error("Cannot call delete() on a frozen Lexical node map");
  };
}
function $commitPendingUpdates(editor, recoveryEditorState) {
  const pendingEditorState = editor._pendingEditorState;
  const rootElement = editor._rootElement;
  const shouldSkipDOM = editor._headless || rootElement === null;
  if (pendingEditorState === null) {
    return;
  }
  const currentEditorState = editor._editorState;
  const currentSelection = currentEditorState._selection;
  const pendingSelection = pendingEditorState._selection;
  const needsUpdate = editor._dirtyType !== NO_DIRTY_NODES;
  const previousActiveEditorState = activeEditorState;
  const previousReadOnlyMode = isReadOnlyMode;
  const previousActiveEditor = activeEditor;
  const previouslyUpdating = editor._updating;
  const observer = editor._observer;
  let mutatedNodes2 = null;
  editor._pendingEditorState = null;
  editor._editorState = pendingEditorState;
  if (!shouldSkipDOM && needsUpdate && observer !== null) {
    activeEditor = editor;
    activeEditorState = pendingEditorState;
    isReadOnlyMode = false;
    editor._updating = true;
    try {
      const dirtyType = editor._dirtyType;
      const dirtyElements2 = editor._dirtyElements;
      const dirtyLeaves2 = editor._dirtyLeaves;
      observer.disconnect();
      mutatedNodes2 = $reconcileRoot(currentEditorState, pendingEditorState, editor, dirtyType, dirtyElements2, dirtyLeaves2);
    } catch (error) {
      if (error instanceof Error) {
        editor._onError(error);
      }
      if (!isAttemptingToRecoverFromReconcilerError) {
        resetEditor(editor, null, rootElement, pendingEditorState);
        initMutationObserver(editor);
        editor._dirtyType = FULL_RECONCILE;
        isAttemptingToRecoverFromReconcilerError = true;
        $commitPendingUpdates(editor, currentEditorState);
        isAttemptingToRecoverFromReconcilerError = false;
      } else {
        throw error;
      }
      return;
    } finally {
      observer.observe(rootElement, observerOptions);
      editor._updating = previouslyUpdating;
      activeEditorState = previousActiveEditorState;
      isReadOnlyMode = previousReadOnlyMode;
      activeEditor = previousActiveEditor;
    }
  }
  if (!pendingEditorState._readOnly) {
    pendingEditorState._readOnly = true;
    {
      handleDEVOnlyPendingUpdateGuarantees(pendingEditorState);
      if ($isRangeSelection(pendingSelection)) {
        Object.freeze(pendingSelection.anchor);
        Object.freeze(pendingSelection.focus);
      }
      Object.freeze(pendingSelection);
    }
  }
  const dirtyLeaves = editor._dirtyLeaves;
  const dirtyElements = editor._dirtyElements;
  const normalizedNodes = editor._normalizedNodes;
  const tags2 = editor._updateTags;
  const deferred = editor._deferred;
  if (needsUpdate) {
    editor._dirtyType = NO_DIRTY_NODES;
    editor._cloneNotNeeded.clear();
    editor._dirtyLeaves = /* @__PURE__ */ new Set();
    editor._dirtyElements = /* @__PURE__ */ new Map();
    editor._normalizedNodes = /* @__PURE__ */ new Set();
    editor._updateTags = /* @__PURE__ */ new Set();
  }
  $garbageCollectDetachedDecorators(editor, pendingEditorState);
  const domSelection = shouldSkipDOM ? null : getDOMSelection(editor._window);
  if (editor._editable && // domSelection will be null in headless
  domSelection !== null && (needsUpdate || pendingSelection === null || pendingSelection.dirty) && rootElement !== null && !tags2.has("skip-dom-selection")) {
    activeEditor = editor;
    activeEditorState = pendingEditorState;
    try {
      if (observer !== null) {
        observer.disconnect();
      }
      if (needsUpdate || pendingSelection === null || pendingSelection.dirty) {
        const blockCursorElement = editor._blockCursorElement;
        if (blockCursorElement !== null) {
          removeDOMBlockCursorElement(blockCursorElement, editor, rootElement);
        }
        updateDOMSelection(currentSelection, pendingSelection, editor, domSelection, tags2, rootElement);
      }
      updateDOMBlockCursorElement(editor, rootElement, pendingSelection);
      if (observer !== null) {
        observer.observe(rootElement, observerOptions);
      }
    } finally {
      activeEditor = previousActiveEditor;
      activeEditorState = previousActiveEditorState;
    }
  }
  if (mutatedNodes2 !== null) {
    triggerMutationListeners(editor, mutatedNodes2, tags2, dirtyLeaves, currentEditorState);
  }
  if (!$isRangeSelection(pendingSelection) && pendingSelection !== null && (currentSelection === null || !currentSelection.is(pendingSelection))) {
    editor.dispatchCommand(SELECTION_CHANGE_COMMAND, void 0);
  }
  const pendingDecorators = editor._pendingDecorators;
  if (pendingDecorators !== null) {
    editor._decorators = pendingDecorators;
    editor._pendingDecorators = null;
    triggerListeners("decorator", editor, true, pendingDecorators);
  }
  triggerTextContentListeners(editor, recoveryEditorState || currentEditorState, pendingEditorState);
  triggerListeners("update", editor, true, {
    dirtyElements,
    dirtyLeaves,
    editorState: pendingEditorState,
    normalizedNodes,
    prevEditorState: recoveryEditorState || currentEditorState,
    tags: tags2
  });
  triggerDeferredUpdateCallbacks(editor, deferred);
  $triggerEnqueuedUpdates(editor);
}
function triggerTextContentListeners(editor, currentEditorState, pendingEditorState) {
  const currentTextContent = getEditorStateTextContent(currentEditorState);
  const latestTextContent = getEditorStateTextContent(pendingEditorState);
  if (currentTextContent !== latestTextContent) {
    triggerListeners("textcontent", editor, true, latestTextContent);
  }
}
function triggerMutationListeners(editor, mutatedNodes2, updateTags, dirtyLeaves, prevEditorState) {
  const listeners = Array.from(editor._listeners.mutation);
  const listenersLength = listeners.length;
  for (let i3 = 0; i3 < listenersLength; i3++) {
    const [listener, klass] = listeners[i3];
    const mutatedNodesByType = mutatedNodes2.get(klass);
    if (mutatedNodesByType !== void 0) {
      listener(mutatedNodesByType, {
        dirtyLeaves,
        prevEditorState,
        updateTags
      });
    }
  }
}
function triggerListeners(type2, editor, isCurrentlyEnqueuingUpdates, ...payload) {
  const previouslyUpdating = editor._updating;
  editor._updating = isCurrentlyEnqueuingUpdates;
  try {
    const listeners = Array.from(editor._listeners[type2]);
    for (let i3 = 0; i3 < listeners.length; i3++) {
      listeners[i3].apply(null, payload);
    }
  } finally {
    editor._updating = previouslyUpdating;
  }
}
function triggerCommandListeners(editor, type2, payload) {
  if (editor._updating === false || activeEditor !== editor) {
    let returnVal = false;
    editor.update(() => {
      returnVal = triggerCommandListeners(editor, type2, payload);
    });
    return returnVal;
  }
  const editors = getEditorsToPropagate(editor);
  for (let i3 = 4; i3 >= 0; i3--) {
    for (let e2 = 0; e2 < editors.length; e2++) {
      const currentEditor = editors[e2];
      const commandListeners = currentEditor._commands;
      const listenerInPriorityOrder = commandListeners.get(type2);
      if (listenerInPriorityOrder !== void 0) {
        const listenersSet = listenerInPriorityOrder[i3];
        if (listenersSet !== void 0) {
          const listeners = Array.from(listenersSet);
          const listenersLength = listeners.length;
          for (let j3 = 0; j3 < listenersLength; j3++) {
            if (listeners[j3](payload, editor) === true) {
              return true;
            }
          }
        }
      }
    }
  }
  return false;
}
function $triggerEnqueuedUpdates(editor) {
  const queuedUpdates = editor._updates;
  if (queuedUpdates.length !== 0) {
    const queuedUpdate = queuedUpdates.shift();
    if (queuedUpdate) {
      const [updateFn, options] = queuedUpdate;
      $beginUpdate(editor, updateFn, options);
    }
  }
}
function triggerDeferredUpdateCallbacks(editor, deferred) {
  editor._deferred = [];
  if (deferred.length !== 0) {
    const previouslyUpdating = editor._updating;
    editor._updating = true;
    try {
      for (let i3 = 0; i3 < deferred.length; i3++) {
        deferred[i3]();
      }
    } finally {
      editor._updating = previouslyUpdating;
    }
  }
}
function processNestedUpdates(editor, initialSkipTransforms) {
  const queuedUpdates = editor._updates;
  let skipTransforms = initialSkipTransforms || false;
  while (queuedUpdates.length !== 0) {
    const queuedUpdate = queuedUpdates.shift();
    if (queuedUpdate) {
      const [nextUpdateFn, options] = queuedUpdate;
      let onUpdate;
      if (options !== void 0) {
        onUpdate = options.onUpdate;
        if (options.skipTransforms) {
          skipTransforms = true;
        }
        if (options.discrete) {
          const pendingEditorState = editor._pendingEditorState;
          if (!(pendingEditorState !== null)) {
            throw Error(`Unexpected empty pending editor state on discrete nested update`);
          }
          pendingEditorState._flushSync = true;
        }
        if (onUpdate) {
          editor._deferred.push(onUpdate);
        }
        addTags(editor, options.tag);
      }
      nextUpdateFn();
    }
  }
  return skipTransforms;
}
function $beginUpdate(editor, updateFn, options) {
  const updateTags = editor._updateTags;
  let onUpdate;
  let skipTransforms = false;
  let discrete = false;
  if (options !== void 0) {
    onUpdate = options.onUpdate;
    addTags(editor, options.tag);
    skipTransforms = options.skipTransforms || false;
    discrete = options.discrete || false;
  }
  if (onUpdate) {
    editor._deferred.push(onUpdate);
  }
  const currentEditorState = editor._editorState;
  let pendingEditorState = editor._pendingEditorState;
  let editorStateWasCloned = false;
  if (pendingEditorState === null || pendingEditorState._readOnly) {
    pendingEditorState = editor._pendingEditorState = cloneEditorState(pendingEditorState || currentEditorState);
    editorStateWasCloned = true;
  }
  pendingEditorState._flushSync = discrete;
  const previousActiveEditorState = activeEditorState;
  const previousReadOnlyMode = isReadOnlyMode;
  const previousActiveEditor = activeEditor;
  const previouslyUpdating = editor._updating;
  activeEditorState = pendingEditorState;
  isReadOnlyMode = false;
  editor._updating = true;
  activeEditor = editor;
  try {
    if (editorStateWasCloned) {
      if (editor._headless) {
        if (currentEditorState._selection !== null) {
          pendingEditorState._selection = currentEditorState._selection.clone();
        }
      } else {
        pendingEditorState._selection = $internalCreateSelection(editor);
      }
    }
    const startingCompositionKey = editor._compositionKey;
    updateFn();
    skipTransforms = processNestedUpdates(editor, skipTransforms);
    applySelectionTransforms(pendingEditorState, editor);
    if (editor._dirtyType !== NO_DIRTY_NODES) {
      if (skipTransforms) {
        $normalizeAllDirtyTextNodes(pendingEditorState, editor);
      } else {
        $applyAllTransforms(pendingEditorState, editor);
      }
      processNestedUpdates(editor);
      $garbageCollectDetachedNodes(currentEditorState, pendingEditorState, editor._dirtyLeaves, editor._dirtyElements);
    }
    const endingCompositionKey = editor._compositionKey;
    if (startingCompositionKey !== endingCompositionKey) {
      pendingEditorState._flushSync = true;
    }
    const pendingSelection = pendingEditorState._selection;
    if ($isRangeSelection(pendingSelection)) {
      const pendingNodeMap = pendingEditorState._nodeMap;
      const anchorKey = pendingSelection.anchor.key;
      const focusKey = pendingSelection.focus.key;
      if (pendingNodeMap.get(anchorKey) === void 0 || pendingNodeMap.get(focusKey) === void 0) {
        {
          throw Error(`updateEditor: selection has been lost because the previously selected nodes have been removed and selection wasn't moved to another node. Ensure selection changes after removing/replacing a selected node.`);
        }
      }
    } else if ($isNodeSelection(pendingSelection)) {
      if (pendingSelection._nodes.size === 0) {
        pendingEditorState._selection = null;
      }
    }
  } catch (error) {
    if (error instanceof Error) {
      editor._onError(error);
    }
    editor._pendingEditorState = currentEditorState;
    editor._dirtyType = FULL_RECONCILE;
    editor._cloneNotNeeded.clear();
    editor._dirtyLeaves = /* @__PURE__ */ new Set();
    editor._dirtyElements.clear();
    $commitPendingUpdates(editor);
    return;
  } finally {
    activeEditorState = previousActiveEditorState;
    isReadOnlyMode = previousReadOnlyMode;
    activeEditor = previousActiveEditor;
    editor._updating = previouslyUpdating;
    infiniteTransformCount = 0;
  }
  const shouldUpdate = editor._dirtyType !== NO_DIRTY_NODES || editor._deferred.length > 0 || editorStateHasDirtySelection(pendingEditorState, editor);
  if (shouldUpdate) {
    if (pendingEditorState._flushSync) {
      pendingEditorState._flushSync = false;
      $commitPendingUpdates(editor);
    } else if (editorStateWasCloned) {
      scheduleMicroTask(() => {
        $commitPendingUpdates(editor);
      });
    }
  } else {
    pendingEditorState._flushSync = false;
    if (editorStateWasCloned) {
      updateTags.clear();
      editor._deferred = [];
      editor._pendingEditorState = null;
    }
  }
}
function updateEditor(editor, updateFn, options) {
  if (editor._updating) {
    editor._updates.push([updateFn, options]);
  } else {
    $beginUpdate(editor, updateFn, options);
  }
}
var ElementDOMSlot = class _ElementDOMSlot {
  constructor(element2, before, after) {
    this.element = element2;
    this.before = before || null;
    this.after = after || null;
  }
  /**
   * Return a new ElementDOMSlot where all managed children will be inserted before this node
   */
  withBefore(before) {
    return new _ElementDOMSlot(this.element, before, this.after);
  }
  /**
   * Return a new ElementDOMSlot where all managed children will be inserted after this node
   */
  withAfter(after) {
    return new _ElementDOMSlot(this.element, this.before, after);
  }
  /**
   * Return a new ElementDOMSlot with an updated root element
   */
  withElement(element2) {
    return new _ElementDOMSlot(element2, this.before, this.after);
  }
  /**
   * Insert the given child before this.before and any reconciler managed line break node,
   * or append it if this.before is not defined
   */
  insertChild(dom) {
    const before = this.before || this.getManagedLineBreak();
    if (!(before === null || before.parentElement === this.element)) {
      throw Error(`ElementDOMSlot.insertChild: before is not in element`);
    }
    this.element.insertBefore(dom, before);
    return this;
  }
  /**
   * Remove the managed child from this container, will throw if it was not already there
   */
  removeChild(dom) {
    if (!(dom.parentElement === this.element)) {
      throw Error(`ElementDOMSlot.removeChild: dom is not in element`);
    }
    this.element.removeChild(dom);
    return this;
  }
  /**
   * Replace managed child prevDom with dom. Will throw if prevDom is not a child
   *
   * @param dom The new node to replace prevDom
   * @param prevDom the node that will be replaced
   */
  replaceChild(dom, prevDom) {
    if (!(prevDom.parentElement === this.element)) {
      throw Error(`ElementDOMSlot.replaceChild: prevDom is not in element`);
    }
    this.element.replaceChild(dom, prevDom);
    return this;
  }
  /**
   * Returns the first managed child of this node,
   * which will either be this.after.nextSibling or this.element.firstChild,
   * and will never be this.before if it is defined.
   */
  getFirstChild() {
    const firstChild = this.after ? this.after.nextSibling : this.element.firstChild;
    return firstChild === this.before || firstChild === this.getManagedLineBreak() ? null : firstChild;
  }
  /**
   * @internal
   */
  getManagedLineBreak() {
    const element2 = this.element;
    return element2.__lexicalLineBreak || null;
  }
  /** @internal */
  setManagedLineBreak(lineBreakType) {
    if (lineBreakType === null) {
      this.removeManagedLineBreak();
    } else {
      const webkitHack = lineBreakType === "decorator" && (IS_IOS || IS_SAFARI);
      this.insertManagedLineBreak(webkitHack);
    }
  }
  /** @internal */
  removeManagedLineBreak() {
    const br = this.getManagedLineBreak();
    if (br) {
      const element2 = this.element;
      const sibling2 = br.nodeName === "IMG" ? br.nextSibling : null;
      if (sibling2) {
        element2.removeChild(sibling2);
      }
      element2.removeChild(br);
      element2.__lexicalLineBreak = void 0;
    }
  }
  /** @internal */
  insertManagedLineBreak(webkitHack) {
    const prevBreak = this.getManagedLineBreak();
    if (prevBreak) {
      if (webkitHack === (prevBreak.nodeName === "IMG")) {
        return;
      }
      this.removeManagedLineBreak();
    }
    const element2 = this.element;
    const before = this.before;
    const br = document.createElement("br");
    element2.insertBefore(br, before);
    if (webkitHack) {
      const img = document.createElement("img");
      img.setAttribute("data-lexical-linebreak", "true");
      img.style.cssText = "display: inline !important; border: 0px !important; margin: 0px !important;";
      img.alt = "";
      element2.insertBefore(img, br);
      element2.__lexicalLineBreak = img;
    } else {
      element2.__lexicalLineBreak = br;
    }
  }
  /**
   * @internal
   *
   * Returns the offset of the first child
   */
  getFirstChildOffset() {
    let i3 = 0;
    for (let node2 = this.after; node2 !== null; node2 = node2.previousSibling) {
      i3++;
    }
    return i3;
  }
  /**
   * @internal
   */
  resolveChildIndex(element2, elementDOM, initialDOM, initialOffset) {
    if (initialDOM === this.element) {
      const firstChildOffset = this.getFirstChildOffset();
      return [element2, Math.min(firstChildOffset + element2.getChildrenSize(), Math.max(firstChildOffset, initialOffset))];
    }
    const initialPath = indexPath(elementDOM, initialDOM);
    initialPath.push(initialOffset);
    const elementPath = indexPath(elementDOM, this.element);
    let offset5 = element2.getIndexWithinParent();
    for (let i3 = 0; i3 < elementPath.length; i3++) {
      const target = initialPath[i3];
      const source = elementPath[i3];
      if (target === void 0 || target < source) {
        break;
      } else if (target > source) {
        offset5 += 1;
        break;
      }
    }
    return [element2.getParentOrThrow(), offset5];
  }
};
function indexPath(root2, child) {
  const path = [];
  let node2 = child;
  for (; node2 !== root2 && node2 !== null; node2 = child.parentNode) {
    let i3 = 0;
    for (let sibling2 = node2.previousSibling; sibling2 !== null; sibling2 = node2.previousSibling) {
      i3++;
    }
    path.push(i3);
  }
  if (!(node2 === root2)) {
    throw Error(`indexPath: root is not a parent of child`);
  }
  return path.reverse();
}
var ElementNode = class extends LexicalNode {
  /** @internal */
  /** @internal */
  /** @internal */
  /** @internal */
  /** @internal */
  /** @internal */
  /** @internal */
  /** @internal */
  /** @internal */
  constructor(key2) {
    super(key2);
    this.__first = null;
    this.__last = null;
    this.__size = 0;
    this.__format = 0;
    this.__style = "";
    this.__indent = 0;
    this.__dir = null;
    this.__textFormat = 0;
    this.__textStyle = "";
  }
  afterCloneFrom(prevNode) {
    super.afterCloneFrom(prevNode);
    this.__first = prevNode.__first;
    this.__last = prevNode.__last;
    this.__size = prevNode.__size;
    this.__indent = prevNode.__indent;
    this.__format = prevNode.__format;
    this.__style = prevNode.__style;
    this.__dir = prevNode.__dir;
    this.__textFormat = prevNode.__textFormat;
    this.__textStyle = prevNode.__textStyle;
  }
  getFormat() {
    const self2 = this.getLatest();
    return self2.__format;
  }
  getFormatType() {
    const format = this.getFormat();
    return ELEMENT_FORMAT_TO_TYPE[format] || "";
  }
  getStyle() {
    const self2 = this.getLatest();
    return self2.__style;
  }
  getIndent() {
    const self2 = this.getLatest();
    return self2.__indent;
  }
  getChildren() {
    const children = [];
    let child = this.getFirstChild();
    while (child !== null) {
      children.push(child);
      child = child.getNextSibling();
    }
    return children;
  }
  getChildrenKeys() {
    const children = [];
    let child = this.getFirstChild();
    while (child !== null) {
      children.push(child.__key);
      child = child.getNextSibling();
    }
    return children;
  }
  getChildrenSize() {
    const self2 = this.getLatest();
    return self2.__size;
  }
  isEmpty() {
    return this.getChildrenSize() === 0;
  }
  isDirty() {
    const editor = getActiveEditor();
    const dirtyElements = editor._dirtyElements;
    return dirtyElements !== null && dirtyElements.has(this.__key);
  }
  isLastChild() {
    const self2 = this.getLatest();
    const parentLastChild = this.getParentOrThrow().getLastChild();
    return parentLastChild !== null && parentLastChild.is(self2);
  }
  getAllTextNodes() {
    const textNodes = [];
    let child = this.getFirstChild();
    while (child !== null) {
      if ($isTextNode(child)) {
        textNodes.push(child);
      }
      if ($isElementNode(child)) {
        const subChildrenNodes = child.getAllTextNodes();
        textNodes.push(...subChildrenNodes);
      }
      child = child.getNextSibling();
    }
    return textNodes;
  }
  getFirstDescendant() {
    let node2 = this.getFirstChild();
    while ($isElementNode(node2)) {
      const child = node2.getFirstChild();
      if (child === null) {
        break;
      }
      node2 = child;
    }
    return node2;
  }
  getLastDescendant() {
    let node2 = this.getLastChild();
    while ($isElementNode(node2)) {
      const child = node2.getLastChild();
      if (child === null) {
        break;
      }
      node2 = child;
    }
    return node2;
  }
  getDescendantByIndex(index3) {
    const children = this.getChildren();
    const childrenLength = children.length;
    if (index3 >= childrenLength) {
      const resolvedNode2 = children[childrenLength - 1];
      return $isElementNode(resolvedNode2) && resolvedNode2.getLastDescendant() || resolvedNode2 || null;
    }
    const resolvedNode = children[index3];
    return $isElementNode(resolvedNode) && resolvedNode.getFirstDescendant() || resolvedNode || null;
  }
  getFirstChild() {
    const self2 = this.getLatest();
    const firstKey = self2.__first;
    return firstKey === null ? null : $getNodeByKey(firstKey);
  }
  getFirstChildOrThrow() {
    const firstChild = this.getFirstChild();
    if (firstChild === null) {
      {
        throw Error(`Expected node ${this.__key} to have a first child.`);
      }
    }
    return firstChild;
  }
  getLastChild() {
    const self2 = this.getLatest();
    const lastKey = self2.__last;
    return lastKey === null ? null : $getNodeByKey(lastKey);
  }
  getLastChildOrThrow() {
    const lastChild = this.getLastChild();
    if (lastChild === null) {
      {
        throw Error(`Expected node ${this.__key} to have a last child.`);
      }
    }
    return lastChild;
  }
  getChildAtIndex(index3) {
    const size4 = this.getChildrenSize();
    let node2;
    let i3;
    if (index3 < size4 / 2) {
      node2 = this.getFirstChild();
      i3 = 0;
      while (node2 !== null && i3 <= index3) {
        if (i3 === index3) {
          return node2;
        }
        node2 = node2.getNextSibling();
        i3++;
      }
      return null;
    }
    node2 = this.getLastChild();
    i3 = size4 - 1;
    while (node2 !== null && i3 >= index3) {
      if (i3 === index3) {
        return node2;
      }
      node2 = node2.getPreviousSibling();
      i3--;
    }
    return null;
  }
  getTextContent() {
    let textContent = "";
    const children = this.getChildren();
    const childrenLength = children.length;
    for (let i3 = 0; i3 < childrenLength; i3++) {
      const child = children[i3];
      textContent += child.getTextContent();
      if ($isElementNode(child) && i3 !== childrenLength - 1 && !child.isInline()) {
        textContent += DOUBLE_LINE_BREAK;
      }
    }
    return textContent;
  }
  getTextContentSize() {
    let textContentSize = 0;
    const children = this.getChildren();
    const childrenLength = children.length;
    for (let i3 = 0; i3 < childrenLength; i3++) {
      const child = children[i3];
      textContentSize += child.getTextContentSize();
      if ($isElementNode(child) && i3 !== childrenLength - 1 && !child.isInline()) {
        textContentSize += DOUBLE_LINE_BREAK.length;
      }
    }
    return textContentSize;
  }
  getDirection() {
    const self2 = this.getLatest();
    return self2.__dir;
  }
  getTextFormat() {
    const self2 = this.getLatest();
    return self2.__textFormat;
  }
  hasFormat(type2) {
    if (type2 !== "") {
      const formatFlag = ELEMENT_TYPE_TO_FORMAT[type2];
      return (this.getFormat() & formatFlag) !== 0;
    }
    return false;
  }
  hasTextFormat(type2) {
    const formatFlag = TEXT_TYPE_TO_FORMAT[type2];
    return (this.getTextFormat() & formatFlag) !== 0;
  }
  /**
   * Returns the format flags applied to the node as a 32-bit integer.
   *
   * @returns a number representing the TextFormatTypes applied to the node.
   */
  getFormatFlags(type2, alignWithFormat) {
    const self2 = this.getLatest();
    const format = self2.__textFormat;
    return toggleTextFormatType(format, type2, alignWithFormat);
  }
  getTextStyle() {
    const self2 = this.getLatest();
    return self2.__textStyle;
  }
  // Mutators
  select(_anchorOffset, _focusOffset) {
    errorOnReadOnly();
    const selection2 = $getSelection();
    let anchorOffset = _anchorOffset;
    let focusOffset = _focusOffset;
    const childrenCount = this.getChildrenSize();
    if (!this.canBeEmpty()) {
      if (_anchorOffset === 0 && _focusOffset === 0) {
        const firstChild = this.getFirstChild();
        if ($isTextNode(firstChild) || $isElementNode(firstChild)) {
          return firstChild.select(0, 0);
        }
      } else if ((_anchorOffset === void 0 || _anchorOffset === childrenCount) && (_focusOffset === void 0 || _focusOffset === childrenCount)) {
        const lastChild = this.getLastChild();
        if ($isTextNode(lastChild) || $isElementNode(lastChild)) {
          return lastChild.select();
        }
      }
    }
    if (anchorOffset === void 0) {
      anchorOffset = childrenCount;
    }
    if (focusOffset === void 0) {
      focusOffset = childrenCount;
    }
    const key2 = this.__key;
    if (!$isRangeSelection(selection2)) {
      return $internalMakeRangeSelection(key2, anchorOffset, key2, focusOffset, "element", "element");
    } else {
      selection2.anchor.set(key2, anchorOffset, "element");
      selection2.focus.set(key2, focusOffset, "element");
      selection2.dirty = true;
    }
    return selection2;
  }
  selectStart() {
    const firstNode = this.getFirstDescendant();
    return firstNode ? firstNode.selectStart() : this.select();
  }
  selectEnd() {
    const lastNode = this.getLastDescendant();
    return lastNode ? lastNode.selectEnd() : this.select();
  }
  clear() {
    const writableSelf = this.getWritable();
    const children = this.getChildren();
    children.forEach((child) => child.remove());
    return writableSelf;
  }
  append(...nodesToAppend) {
    return this.splice(this.getChildrenSize(), 0, nodesToAppend);
  }
  setDirection(direction) {
    const self2 = this.getWritable();
    self2.__dir = direction;
    return self2;
  }
  setFormat(type2) {
    const self2 = this.getWritable();
    self2.__format = type2 !== "" ? ELEMENT_TYPE_TO_FORMAT[type2] : 0;
    return this;
  }
  setStyle(style) {
    const self2 = this.getWritable();
    self2.__style = style || "";
    return this;
  }
  setTextFormat(type2) {
    const self2 = this.getWritable();
    self2.__textFormat = type2;
    return self2;
  }
  setTextStyle(style) {
    const self2 = this.getWritable();
    self2.__textStyle = style;
    return self2;
  }
  setIndent(indentLevel) {
    const self2 = this.getWritable();
    self2.__indent = indentLevel;
    return this;
  }
  splice(start2, deleteCount, nodesToInsert) {
    const nodesToInsertLength = nodesToInsert.length;
    const oldSize = this.getChildrenSize();
    const writableSelf = this.getWritable();
    if (!(start2 + deleteCount <= oldSize)) {
      throw Error(`ElementNode.splice: start + deleteCount > oldSize (${String(start2)} + ${String(deleteCount)} > ${String(oldSize)})`);
    }
    const writableSelfKey = writableSelf.__key;
    const nodesToInsertKeys = [];
    const nodesToRemoveKeys = [];
    const nodeAfterRange = this.getChildAtIndex(start2 + deleteCount);
    let nodeBeforeRange = null;
    let newSize = oldSize - deleteCount + nodesToInsertLength;
    if (start2 !== 0) {
      if (start2 === oldSize) {
        nodeBeforeRange = this.getLastChild();
      } else {
        const node2 = this.getChildAtIndex(start2);
        if (node2 !== null) {
          nodeBeforeRange = node2.getPreviousSibling();
        }
      }
    }
    if (deleteCount > 0) {
      let nodeToDelete = nodeBeforeRange === null ? this.getFirstChild() : nodeBeforeRange.getNextSibling();
      for (let i3 = 0; i3 < deleteCount; i3++) {
        if (nodeToDelete === null) {
          {
            throw Error(`splice: sibling not found`);
          }
        }
        const nextSibling = nodeToDelete.getNextSibling();
        const nodeKeyToDelete = nodeToDelete.__key;
        const writableNodeToDelete = nodeToDelete.getWritable();
        removeFromParent(writableNodeToDelete);
        nodesToRemoveKeys.push(nodeKeyToDelete);
        nodeToDelete = nextSibling;
      }
    }
    let prevNode = nodeBeforeRange;
    for (let i3 = 0; i3 < nodesToInsertLength; i3++) {
      const nodeToInsert = nodesToInsert[i3];
      if (prevNode !== null && nodeToInsert.is(prevNode)) {
        nodeBeforeRange = prevNode = prevNode.getPreviousSibling();
      }
      const writableNodeToInsert = nodeToInsert.getWritable();
      if (writableNodeToInsert.__parent === writableSelfKey) {
        newSize--;
      }
      removeFromParent(writableNodeToInsert);
      const nodeKeyToInsert = nodeToInsert.__key;
      if (prevNode === null) {
        writableSelf.__first = nodeKeyToInsert;
        writableNodeToInsert.__prev = null;
      } else {
        const writablePrevNode = prevNode.getWritable();
        writablePrevNode.__next = nodeKeyToInsert;
        writableNodeToInsert.__prev = writablePrevNode.__key;
      }
      if (nodeToInsert.__key === writableSelfKey) {
        {
          throw Error(`append: attempting to append self`);
        }
      }
      writableNodeToInsert.__parent = writableSelfKey;
      nodesToInsertKeys.push(nodeKeyToInsert);
      prevNode = nodeToInsert;
    }
    if (start2 + deleteCount === oldSize) {
      if (prevNode !== null) {
        const writablePrevNode = prevNode.getWritable();
        writablePrevNode.__next = null;
        writableSelf.__last = prevNode.__key;
      }
    } else if (nodeAfterRange !== null) {
      const writableNodeAfterRange = nodeAfterRange.getWritable();
      if (prevNode !== null) {
        const writablePrevNode = prevNode.getWritable();
        writableNodeAfterRange.__prev = prevNode.__key;
        writablePrevNode.__next = nodeAfterRange.__key;
      } else {
        writableNodeAfterRange.__prev = null;
      }
    }
    writableSelf.__size = newSize;
    if (nodesToRemoveKeys.length) {
      const selection2 = $getSelection();
      if ($isRangeSelection(selection2)) {
        const nodesToRemoveKeySet = new Set(nodesToRemoveKeys);
        const nodesToInsertKeySet = new Set(nodesToInsertKeys);
        const {
          anchor,
          focus: focus2
        } = selection2;
        if (isPointRemoved(anchor, nodesToRemoveKeySet, nodesToInsertKeySet)) {
          moveSelectionPointToSibling(anchor, anchor.getNode(), this, nodeBeforeRange, nodeAfterRange);
        }
        if (isPointRemoved(focus2, nodesToRemoveKeySet, nodesToInsertKeySet)) {
          moveSelectionPointToSibling(focus2, focus2.getNode(), this, nodeBeforeRange, nodeAfterRange);
        }
        if (newSize === 0 && !this.canBeEmpty() && !$isRootOrShadowRoot(this)) {
          this.remove();
        }
      }
    }
    return writableSelf;
  }
  /**
   * @internal
   *
   * An experimental API that an ElementNode can override to control where its
   * children are inserted into the DOM, this is useful to add a wrapping node
   * or accessory nodes before or after the children. The root of the node returned
   * by createDOM must still be exactly one HTMLElement.
   */
  getDOMSlot(element2) {
    return new ElementDOMSlot(element2);
  }
  exportDOM(editor) {
    const {
      element: element2
    } = super.exportDOM(editor);
    if (isHTMLElement(element2)) {
      const indent2 = this.getIndent();
      if (indent2 > 0) {
        element2.style.paddingInlineStart = `${indent2 * 40}px`;
      }
    }
    return {
      element: element2
    };
  }
  // JSON serialization
  exportJSON() {
    const json2 = {
      children: [],
      direction: this.getDirection(),
      format: this.getFormatType(),
      indent: this.getIndent(),
      // As an exception here we invoke super at the end for historical reasons.
      // Namely, to preserve the order of the properties and not to break the tests
      // that use the serialized string representation.
      ...super.exportJSON()
    };
    const textFormat = this.getTextFormat();
    const textStyle = this.getTextStyle();
    if (textFormat !== 0) {
      json2.textFormat = textFormat;
    }
    if (textStyle !== "") {
      json2.textStyle = textStyle;
    }
    return json2;
  }
  updateFromJSON(serializedNode) {
    return super.updateFromJSON(serializedNode).setFormat(serializedNode.format).setIndent(serializedNode.indent).setDirection(serializedNode.direction).setTextFormat(serializedNode.textFormat || 0).setTextStyle(serializedNode.textStyle || "");
  }
  // These are intended to be extends for specific element heuristics.
  insertNewAfter(selection2, restoreSelection) {
    return null;
  }
  canIndent() {
    return true;
  }
  /*
   * This method controls the behavior of a the node during backwards
   * deletion (i.e., backspace) when selection is at the beginning of
   * the node (offset 0)
   */
  collapseAtStart(selection2) {
    return false;
  }
  excludeFromCopy(destination) {
    return false;
  }
  /** @deprecated @internal */
  canReplaceWith(replacement) {
    return true;
  }
  /** @deprecated @internal */
  canInsertAfter(node2) {
    return true;
  }
  canBeEmpty() {
    return true;
  }
  canInsertTextBefore() {
    return true;
  }
  canInsertTextAfter() {
    return true;
  }
  isInline() {
    return false;
  }
  // A shadow root is a Node that behaves like RootNode. The shadow root (and RootNode) mark the
  // end of the hiercharchy, most implementations should treat it as there's nothing (upwards)
  // beyond this point. For example, node.getTopLevelElement(), when performed inside a TableCellNode
  // will return the immediate first child underneath TableCellNode instead of RootNode.
  isShadowRoot() {
    return false;
  }
  /** @deprecated @internal */
  canMergeWith(node2) {
    return false;
  }
  extractWithChild(child, selection2, destination) {
    return false;
  }
  /**
   * Determines whether this node, when empty, can merge with a first block
   * of nodes being inserted.
   *
   * This method is specifically called in {@link RangeSelection.insertNodes}
   * to determine merging behavior during nodes insertion.
   *
   * @example
   * // In a ListItemNode or QuoteNode implementation:
   * canMergeWhenEmpty(): true {
   *  return true;
   * }
   */
  canMergeWhenEmpty() {
    return false;
  }
  /** @internal */
  reconcileObservedMutation(dom, editor) {
    const slot = this.getDOMSlot(dom);
    let currentDOM = slot.getFirstChild();
    for (let currentNode = this.getFirstChild(); currentNode; currentNode = currentNode.getNextSibling()) {
      const correctDOM = editor.getElementByKey(currentNode.getKey());
      if (correctDOM === null) {
        continue;
      }
      if (currentDOM == null) {
        slot.insertChild(correctDOM);
        currentDOM = correctDOM;
      } else if (currentDOM !== correctDOM) {
        slot.replaceChild(correctDOM, currentDOM);
      }
      currentDOM = currentDOM.nextSibling;
    }
  }
};
function $isElementNode(node2) {
  return node2 instanceof ElementNode;
}
function isPointRemoved(point3, nodesToRemoveKeySet, nodesToInsertKeySet) {
  let node2 = point3.getNode();
  while (node2) {
    const nodeKey = node2.__key;
    if (nodesToRemoveKeySet.has(nodeKey) && !nodesToInsertKeySet.has(nodeKey)) {
      return true;
    }
    node2 = node2.getParent();
  }
  return false;
}
var DecoratorNode = class extends LexicalNode {
  /**
   * The returned value is added to the LexicalEditor._decorators
   */
  decorate(editor, config) {
    {
      throw Error(`decorate: base method not extended`);
    }
  }
  isIsolated() {
    return false;
  }
  isInline() {
    return true;
  }
  isKeyboardSelectable() {
    return true;
  }
};
function $isDecoratorNode(node2) {
  return node2 instanceof DecoratorNode;
}
var RootNode = class _RootNode extends ElementNode {
  /** @internal */
  static getType() {
    return "root";
  }
  static clone() {
    return new _RootNode();
  }
  constructor() {
    super("root");
    this.__cachedText = null;
  }
  getTopLevelElementOrThrow() {
    {
      throw Error(`getTopLevelElementOrThrow: root nodes are not top level elements`);
    }
  }
  getTextContent() {
    const cachedText = this.__cachedText;
    if (isCurrentlyReadOnlyMode() || getActiveEditor()._dirtyType === NO_DIRTY_NODES) {
      if (cachedText !== null) {
        return cachedText;
      }
    }
    return super.getTextContent();
  }
  remove() {
    {
      throw Error(`remove: cannot be called on root nodes`);
    }
  }
  replace(node2) {
    {
      throw Error(`replace: cannot be called on root nodes`);
    }
  }
  insertBefore(nodeToInsert) {
    {
      throw Error(`insertBefore: cannot be called on root nodes`);
    }
  }
  insertAfter(nodeToInsert) {
    {
      throw Error(`insertAfter: cannot be called on root nodes`);
    }
  }
  // View
  updateDOM(prevNode, dom) {
    return false;
  }
  // Mutate
  append(...nodesToAppend) {
    for (let i3 = 0; i3 < nodesToAppend.length; i3++) {
      const node2 = nodesToAppend[i3];
      if (!$isElementNode(node2) && !$isDecoratorNode(node2)) {
        {
          throw Error(`rootNode.append: Only element or decorator nodes can be appended to the root node`);
        }
      }
    }
    return super.append(...nodesToAppend);
  }
  static importJSON(serializedNode) {
    return $getRoot().updateFromJSON(serializedNode);
  }
  collapseAtStart() {
    return true;
  }
};
function $createRootNode() {
  return new RootNode();
}
function $isRootNode(node2) {
  return node2 instanceof RootNode;
}
function editorStateHasDirtySelection(editorState, editor) {
  const currentSelection = editor.getEditorState()._selection;
  const pendingSelection = editorState._selection;
  if (pendingSelection !== null) {
    if (pendingSelection.dirty || !pendingSelection.is(currentSelection)) {
      return true;
    }
  } else if (currentSelection !== null) {
    return true;
  }
  return false;
}
function cloneEditorState(current2) {
  return new EditorState2(new Map(current2._nodeMap));
}
function createEmptyEditorState() {
  return new EditorState2(/* @__PURE__ */ new Map([["root", $createRootNode()]]));
}
function exportNodeToJSON(node2) {
  const serializedNode = node2.exportJSON();
  const nodeClass = node2.constructor;
  if (serializedNode.type !== nodeClass.getType()) {
    {
      throw Error(`LexicalNode: Node ${nodeClass.name} does not match the serialized type. Check if .exportJSON() is implemented and it is returning the correct type.`);
    }
  }
  if ($isElementNode(node2)) {
    const serializedChildren = serializedNode.children;
    if (!Array.isArray(serializedChildren)) {
      {
        throw Error(`LexicalNode: Node ${nodeClass.name} is an element but .exportJSON() does not have a children array.`);
      }
    }
    const children = node2.getChildren();
    for (let i3 = 0; i3 < children.length; i3++) {
      const child = children[i3];
      const serializedChildNode = exportNodeToJSON(child);
      serializedChildren.push(serializedChildNode);
    }
  }
  return serializedNode;
}
var EditorState2 = class _EditorState {
  constructor(nodeMap, selection2) {
    this._nodeMap = nodeMap;
    this._selection = selection2 || null;
    this._flushSync = false;
    this._readOnly = false;
  }
  isEmpty() {
    return this._nodeMap.size === 1 && this._selection === null;
  }
  read(callbackFn, options) {
    return readEditorState(options && options.editor || null, this, callbackFn);
  }
  clone(selection2) {
    const editorState = new _EditorState(this._nodeMap, selection2 === void 0 ? this._selection : selection2);
    editorState._readOnly = true;
    return editorState;
  }
  toJSON() {
    return readEditorState(null, this, () => ({
      root: exportNodeToJSON($getRoot())
    }));
  }
};
var ArtificialNode__DO_NOT_USE = class extends ElementNode {
  static getType() {
    return "artificial";
  }
  createDOM(config) {
    const dom = document.createElement("div");
    return dom;
  }
};
var ParagraphNode = class _ParagraphNode extends ElementNode {
  static getType() {
    return "paragraph";
  }
  static clone(node2) {
    return new _ParagraphNode(node2.__key);
  }
  // View
  createDOM(config) {
    const dom = document.createElement("p");
    const classNames14 = getCachedClassNameArray(config.theme, "paragraph");
    if (classNames14 !== void 0) {
      const domClassList = dom.classList;
      domClassList.add(...classNames14);
    }
    return dom;
  }
  updateDOM(prevNode, dom, config) {
    return false;
  }
  static importDOM() {
    return {
      p: (node2) => ({
        conversion: $convertParagraphElement,
        priority: 0
      })
    };
  }
  exportDOM(editor) {
    const {
      element: element2
    } = super.exportDOM(editor);
    if (isHTMLElement(element2)) {
      if (this.isEmpty()) {
        element2.append(document.createElement("br"));
      }
      const formatType = this.getFormatType();
      element2.style.textAlign = formatType;
      const direction = this.getDirection();
      if (direction) {
        element2.dir = direction;
      }
    }
    return {
      element: element2
    };
  }
  static importJSON(serializedNode) {
    return $createParagraphNode().updateFromJSON(serializedNode);
  }
  exportJSON() {
    return {
      ...super.exportJSON(),
      // These are included explicitly for backwards compatibility
      textFormat: this.getTextFormat(),
      textStyle: this.getTextStyle()
    };
  }
  // Mutation
  insertNewAfter(rangeSelection, restoreSelection) {
    const newElement = $createParagraphNode();
    newElement.setTextFormat(rangeSelection.format);
    newElement.setTextStyle(rangeSelection.style);
    const direction = this.getDirection();
    newElement.setDirection(direction);
    newElement.setFormat(this.getFormatType());
    newElement.setStyle(this.getTextStyle());
    this.insertAfter(newElement, restoreSelection);
    return newElement;
  }
  collapseAtStart() {
    const children = this.getChildren();
    if (children.length === 0 || $isTextNode(children[0]) && children[0].getTextContent().trim() === "") {
      const nextSibling = this.getNextSibling();
      if (nextSibling !== null) {
        this.selectNext();
        this.remove();
        return true;
      }
      const prevSibling = this.getPreviousSibling();
      if (prevSibling !== null) {
        this.selectPrevious();
        this.remove();
        return true;
      }
    }
    return false;
  }
};
function $convertParagraphElement(element2) {
  const node2 = $createParagraphNode();
  if (element2.style) {
    node2.setFormat(element2.style.textAlign);
    setNodeIndentFromDOM(element2, node2);
  }
  return {
    node: node2
  };
}
function $createParagraphNode() {
  return $applyNodeReplacement(new ParagraphNode());
}
function $isParagraphNode(node2) {
  return node2 instanceof ParagraphNode;
}
var DEFAULT_SKIP_INITIALIZATION = false;
var COMMAND_PRIORITY_EDITOR = 0;
var COMMAND_PRIORITY_LOW = 1;
var COMMAND_PRIORITY_HIGH = 3;
var COMMAND_PRIORITY_CRITICAL = 4;
function resetEditor(editor, prevRootElement, nextRootElement, pendingEditorState) {
  const keyNodeMap = editor._keyToDOMMap;
  keyNodeMap.clear();
  editor._editorState = createEmptyEditorState();
  editor._pendingEditorState = pendingEditorState;
  editor._compositionKey = null;
  editor._dirtyType = NO_DIRTY_NODES;
  editor._cloneNotNeeded.clear();
  editor._dirtyLeaves = /* @__PURE__ */ new Set();
  editor._dirtyElements.clear();
  editor._normalizedNodes = /* @__PURE__ */ new Set();
  editor._updateTags = /* @__PURE__ */ new Set();
  editor._updates = [];
  editor._blockCursorElement = null;
  const observer = editor._observer;
  if (observer !== null) {
    observer.disconnect();
    editor._observer = null;
  }
  if (prevRootElement !== null) {
    prevRootElement.textContent = "";
  }
  if (nextRootElement !== null) {
    nextRootElement.textContent = "";
    keyNodeMap.set("root", nextRootElement);
  }
}
function initializeConversionCache(nodes, additionalConversions) {
  const conversionCache = /* @__PURE__ */ new Map();
  const handledConversions = /* @__PURE__ */ new Set();
  const addConversionsToCache = (map5) => {
    Object.keys(map5).forEach((key2) => {
      let currentCache = conversionCache.get(key2);
      if (currentCache === void 0) {
        currentCache = [];
        conversionCache.set(key2, currentCache);
      }
      currentCache.push(map5[key2]);
    });
  };
  nodes.forEach((node2) => {
    const importDOM = node2.klass.importDOM;
    if (importDOM == null || handledConversions.has(importDOM)) {
      return;
    }
    handledConversions.add(importDOM);
    const map5 = importDOM.call(node2.klass);
    if (map5 !== null) {
      addConversionsToCache(map5);
    }
  });
  if (additionalConversions) {
    addConversionsToCache(additionalConversions);
  }
  return conversionCache;
}
function createEditor(editorConfig) {
  const config = editorConfig || {};
  const activeEditor2 = internalGetActiveEditor();
  const theme = config.theme || {};
  const parentEditor = editorConfig === void 0 ? activeEditor2 : config.parentEditor || null;
  const disableEvents = config.disableEvents || false;
  const editorState = createEmptyEditorState();
  const namespace = config.namespace || (parentEditor !== null ? parentEditor._config.namespace : createUID());
  const initialEditorState = config.editorState;
  const nodes = [RootNode, TextNode, LineBreakNode, TabNode, ParagraphNode, ArtificialNode__DO_NOT_USE, ...config.nodes || []];
  const {
    onError,
    html: html3
  } = config;
  const isEditable = config.editable !== void 0 ? config.editable : true;
  let registeredNodes;
  if (editorConfig === void 0 && activeEditor2 !== null) {
    registeredNodes = activeEditor2._nodes;
  } else {
    registeredNodes = /* @__PURE__ */ new Map();
    for (let i3 = 0; i3 < nodes.length; i3++) {
      let klass = nodes[i3];
      let replace2 = null;
      let replaceWithKlass = null;
      if (typeof klass !== "function") {
        const options = klass;
        klass = options.replace;
        replace2 = options.with;
        replaceWithKlass = options.withKlass || null;
      }
      {
        const nodeType = Object.prototype.hasOwnProperty.call(klass, "getType") && klass.getType();
        const name2 = klass.name;
        if (replaceWithKlass) {
          if (!(replaceWithKlass.prototype instanceof klass)) {
            throw Error(`${replaceWithKlass.name} doesn't extend the ${name2}`);
          }
        }
        if (name2 !== "RootNode" && nodeType !== "root" && nodeType !== "artificial") {
          const proto = klass.prototype;
          ["getType", "clone"].forEach((method) => {
            if (!klass.hasOwnProperty(method)) {
              console.warn(`${name2} must implement static "${method}" method`);
            }
          });
          if (
            // eslint-disable-next-line no-prototype-builtins
            !klass.hasOwnProperty("importDOM") && // eslint-disable-next-line no-prototype-builtins
            klass.hasOwnProperty("exportDOM")
          ) {
            console.warn(`${name2} should implement "importDOM" if using a custom "exportDOM" method to ensure HTML serialization (important for copy & paste) works as expected`);
          }
          if ($isDecoratorNode(proto)) {
            if (!proto.hasOwnProperty("decorate")) {
              console.warn(`${proto.constructor.name} must implement "decorate" method`);
            }
          }
          if (
            // eslint-disable-next-line no-prototype-builtins
            !klass.hasOwnProperty("importJSON")
          ) {
            console.warn(`${name2} should implement "importJSON" method to ensure JSON and default HTML serialization works as expected`);
          }
        }
      }
      const type2 = klass.getType();
      const transform = klass.transform();
      const transforms = /* @__PURE__ */ new Set();
      if (transform !== null) {
        transforms.add(transform);
      }
      registeredNodes.set(type2, {
        exportDOM: html3 && html3.export ? html3.export.get(klass) : void 0,
        klass,
        replace: replace2,
        replaceWithKlass,
        transforms
      });
    }
  }
  const editor = new LexicalEditor(editorState, parentEditor, registeredNodes, {
    disableEvents,
    namespace,
    theme
  }, onError ? onError : console.error, initializeConversionCache(registeredNodes, html3 ? html3.import : void 0), isEditable);
  if (initialEditorState !== void 0) {
    editor._pendingEditorState = initialEditorState;
    editor._dirtyType = FULL_RECONCILE;
  }
  return editor;
}
var LexicalEditor = class {
  /** The version with build identifiers for this editor (since 0.17.1) */
  /** @internal */
  /** @internal */
  /** @internal */
  /** @internal */
  /** @internal */
  /** @internal */
  /** @internal */
  /** @internal */
  /** @internal */
  /** @internal */
  /** @internal */
  /** @internal */
  /** @internal */
  /** @internal */
  /** @internal */
  /** @internal */
  /** @internal */
  /** @internal */
  /** @internal */
  /** @internal */
  /** @internal */
  /** @internal */
  /** @internal */
  /** @internal */
  /** @internal */
  /** @internal */
  /** @internal */
  /** @internal */
  /** @internal */
  /** @internal */
  constructor(editorState, parentEditor, nodes, config, onError, htmlConversions, editable) {
    this._parentEditor = parentEditor;
    this._rootElement = null;
    this._editorState = editorState;
    this._pendingEditorState = null;
    this._compositionKey = null;
    this._deferred = [];
    this._keyToDOMMap = /* @__PURE__ */ new Map();
    this._updates = [];
    this._updating = false;
    this._listeners = {
      decorator: /* @__PURE__ */ new Set(),
      editable: /* @__PURE__ */ new Set(),
      mutation: /* @__PURE__ */ new Map(),
      root: /* @__PURE__ */ new Set(),
      textcontent: /* @__PURE__ */ new Set(),
      update: /* @__PURE__ */ new Set()
    };
    this._commands = /* @__PURE__ */ new Map();
    this._config = config;
    this._nodes = nodes;
    this._decorators = {};
    this._pendingDecorators = null;
    this._dirtyType = NO_DIRTY_NODES;
    this._cloneNotNeeded = /* @__PURE__ */ new Set();
    this._dirtyLeaves = /* @__PURE__ */ new Set();
    this._dirtyElements = /* @__PURE__ */ new Map();
    this._normalizedNodes = /* @__PURE__ */ new Set();
    this._updateTags = /* @__PURE__ */ new Set();
    this._observer = null;
    this._key = createUID();
    this._onError = onError;
    this._htmlConversions = htmlConversions;
    this._editable = editable;
    this._headless = parentEditor !== null && parentEditor._headless;
    this._window = null;
    this._blockCursorElement = null;
  }
  /**
   *
   * @returns true if the editor is currently in "composition" mode due to receiving input
   * through an IME, or 3P extension, for example. Returns false otherwise.
   */
  isComposing() {
    return this._compositionKey != null;
  }
  /**
   * Registers a listener for Editor update event. Will trigger the provided callback
   * each time the editor goes through an update (via {@link LexicalEditor.update}) until the
   * teardown function is called.
   *
   * @returns a teardown function that can be used to cleanup the listener.
   */
  registerUpdateListener(listener) {
    const listenerSetOrMap = this._listeners.update;
    listenerSetOrMap.add(listener);
    return () => {
      listenerSetOrMap.delete(listener);
    };
  }
  /**
   * Registers a listener for for when the editor changes between editable and non-editable states.
   * Will trigger the provided callback each time the editor transitions between these states until the
   * teardown function is called.
   *
   * @returns a teardown function that can be used to cleanup the listener.
   */
  registerEditableListener(listener) {
    const listenerSetOrMap = this._listeners.editable;
    listenerSetOrMap.add(listener);
    return () => {
      listenerSetOrMap.delete(listener);
    };
  }
  /**
   * Registers a listener for when the editor's decorator object changes. The decorator object contains
   * all DecoratorNode keys -> their decorated value. This is primarily used with external UI frameworks.
   *
   * Will trigger the provided callback each time the editor transitions between these states until the
   * teardown function is called.
   *
   * @returns a teardown function that can be used to cleanup the listener.
   */
  registerDecoratorListener(listener) {
    const listenerSetOrMap = this._listeners.decorator;
    listenerSetOrMap.add(listener);
    return () => {
      listenerSetOrMap.delete(listener);
    };
  }
  /**
   * Registers a listener for when Lexical commits an update to the DOM and the text content of
   * the editor changes from the previous state of the editor. If the text content is the
   * same between updates, no notifications to the listeners will happen.
   *
   * Will trigger the provided callback each time the editor transitions between these states until the
   * teardown function is called.
   *
   * @returns a teardown function that can be used to cleanup the listener.
   */
  registerTextContentListener(listener) {
    const listenerSetOrMap = this._listeners.textcontent;
    listenerSetOrMap.add(listener);
    return () => {
      listenerSetOrMap.delete(listener);
    };
  }
  /**
   * Registers a listener for when the editor's root DOM element (the content editable
   * Lexical attaches to) changes. This is primarily used to attach event listeners to the root
   *  element. The root listener function is executed directly upon registration and then on
   * any subsequent update.
   *
   * Will trigger the provided callback each time the editor transitions between these states until the
   * teardown function is called.
   *
   * @returns a teardown function that can be used to cleanup the listener.
   */
  registerRootListener(listener) {
    const listenerSetOrMap = this._listeners.root;
    listener(this._rootElement, null);
    listenerSetOrMap.add(listener);
    return () => {
      listener(null, this._rootElement);
      listenerSetOrMap.delete(listener);
    };
  }
  /**
   * Registers a listener that will trigger anytime the provided command
   * is dispatched with {@link LexicalEditor.dispatch}, subject to priority.
   * Listeners that run at a higher priority can "intercept" commands and
   * prevent them from propagating to other handlers by returning true.
   *
   * Listeners are always invoked in an {@link LexicalEditor.update} and can
   * call dollar functions.
   *
   * Listeners registered at the same priority level will run
   * deterministically in the order of registration.
   *
   * @param command - the command that will trigger the callback.
   * @param listener - the function that will execute when the command is dispatched.
   * @param priority - the relative priority of the listener. 0 | 1 | 2 | 3 | 4
   *   (or {@link COMMAND_PRIORITY_EDITOR} |
   *     {@link COMMAND_PRIORITY_LOW} |
   *     {@link COMMAND_PRIORITY_NORMAL} |
   *     {@link COMMAND_PRIORITY_HIGH} |
   *     {@link COMMAND_PRIORITY_CRITICAL})
   * @returns a teardown function that can be used to cleanup the listener.
   */
  registerCommand(command2, listener, priority) {
    if (priority === void 0) {
      {
        throw Error(`Listener for type "command" requires a "priority".`);
      }
    }
    const commandsMap = this._commands;
    if (!commandsMap.has(command2)) {
      commandsMap.set(command2, [/* @__PURE__ */ new Set(), /* @__PURE__ */ new Set(), /* @__PURE__ */ new Set(), /* @__PURE__ */ new Set(), /* @__PURE__ */ new Set()]);
    }
    const listenersInPriorityOrder = commandsMap.get(command2);
    if (listenersInPriorityOrder === void 0) {
      {
        throw Error(`registerCommand: Command ${String(command2)} not found in command map`);
      }
    }
    const listeners = listenersInPriorityOrder[priority];
    listeners.add(listener);
    return () => {
      listeners.delete(listener);
      if (listenersInPriorityOrder.every((listenersSet) => listenersSet.size === 0)) {
        commandsMap.delete(command2);
      }
    };
  }
  /**
   * Registers a listener that will run when a Lexical node of the provided class is
   * mutated. The listener will receive a list of nodes along with the type of mutation
   * that was performed on each: created, destroyed, or updated.
   *
   * One common use case for this is to attach DOM event listeners to the underlying DOM nodes as Lexical nodes are created.
   * {@link LexicalEditor.getElementByKey} can be used for this.
   *
   * If any existing nodes are in the DOM, and skipInitialization is not true, the listener
   * will be called immediately with an updateTag of 'registerMutationListener' where all
   * nodes have the 'created' NodeMutation. This can be controlled with the skipInitialization option
   * (whose default was previously true for backwards compatibility with &lt;=0.16.1 but has been changed to false as of 0.21.0).
   *
   * @param klass - The class of the node that you want to listen to mutations on.
   * @param listener - The logic you want to run when the node is mutated.
   * @param options - see {@link MutationListenerOptions}
   * @returns a teardown function that can be used to cleanup the listener.
   */
  registerMutationListener(klass, listener, options) {
    const klassToMutate = this.resolveRegisteredNodeAfterReplacements(this.getRegisteredNode(klass)).klass;
    const mutations = this._listeners.mutation;
    mutations.set(listener, klassToMutate);
    const skipInitialization = options && options.skipInitialization;
    if (!(skipInitialization === void 0 ? DEFAULT_SKIP_INITIALIZATION : skipInitialization)) {
      this.initializeMutationListener(listener, klassToMutate);
    }
    return () => {
      mutations.delete(listener);
    };
  }
  /** @internal */
  getRegisteredNode(klass) {
    const registeredNode = this._nodes.get(klass.getType());
    if (registeredNode === void 0) {
      {
        throw Error(`Node ${klass.name} has not been registered. Ensure node has been passed to createEditor.`);
      }
    }
    return registeredNode;
  }
  /** @internal */
  resolveRegisteredNodeAfterReplacements(registeredNode) {
    while (registeredNode.replaceWithKlass) {
      registeredNode = this.getRegisteredNode(registeredNode.replaceWithKlass);
    }
    return registeredNode;
  }
  /** @internal */
  initializeMutationListener(listener, klass) {
    const prevEditorState = this._editorState;
    const nodeMap = getCachedTypeToNodeMap(prevEditorState).get(klass.getType());
    if (!nodeMap) {
      return;
    }
    const nodeMutationMap = /* @__PURE__ */ new Map();
    for (const k3 of nodeMap.keys()) {
      nodeMutationMap.set(k3, "created");
    }
    if (nodeMutationMap.size > 0) {
      listener(nodeMutationMap, {
        dirtyLeaves: /* @__PURE__ */ new Set(),
        prevEditorState,
        updateTags: /* @__PURE__ */ new Set(["registerMutationListener"])
      });
    }
  }
  /** @internal */
  registerNodeTransformToKlass(klass, listener) {
    const registeredNode = this.getRegisteredNode(klass);
    registeredNode.transforms.add(listener);
    return registeredNode;
  }
  /**
   * Registers a listener that will run when a Lexical node of the provided class is
   * marked dirty during an update. The listener will continue to run as long as the node
   * is marked dirty. There are no guarantees around the order of transform execution!
   *
   * Watch out for infinite loops. See [Node Transforms](https://lexical.dev/docs/concepts/transforms)
   * @param klass - The class of the node that you want to run transforms on.
   * @param listener - The logic you want to run when the node is updated.
   * @returns a teardown function that can be used to cleanup the listener.
   */
  registerNodeTransform(klass, listener) {
    const registeredNode = this.registerNodeTransformToKlass(klass, listener);
    const registeredNodes = [registeredNode];
    const replaceWithKlass = registeredNode.replaceWithKlass;
    if (replaceWithKlass != null) {
      const registeredReplaceWithNode = this.registerNodeTransformToKlass(replaceWithKlass, listener);
      registeredNodes.push(registeredReplaceWithNode);
    }
    markNodesWithTypesAsDirty(this, registeredNodes.map((node2) => node2.klass.getType()));
    return () => {
      registeredNodes.forEach((node2) => node2.transforms.delete(listener));
    };
  }
  /**
   * Used to assert that a certain node is registered, usually by plugins to ensure nodes that they
   * depend on have been registered.
   * @returns True if the editor has registered the provided node type, false otherwise.
   */
  hasNode(node2) {
    return this._nodes.has(node2.getType());
  }
  /**
   * Used to assert that certain nodes are registered, usually by plugins to ensure nodes that they
   * depend on have been registered.
   * @returns True if the editor has registered all of the provided node types, false otherwise.
   */
  hasNodes(nodes) {
    return nodes.every(this.hasNode.bind(this));
  }
  /**
   * Dispatches a command of the specified type with the specified payload.
   * This triggers all command listeners (set by {@link LexicalEditor.registerCommand})
   * for this type, passing them the provided payload. The command listeners
   * will be triggered in an implicit {@link LexicalEditor.update}, unless
   * this was invoked from inside an update in which case that update context
   * will be re-used (as if this was a dollar function itself).
   * @param type - the type of command listeners to trigger.
   * @param payload - the data to pass as an argument to the command listeners.
   */
  dispatchCommand(type2, payload) {
    return dispatchCommand(this, type2, payload);
  }
  /**
   * Gets a map of all decorators in the editor.
   * @returns A mapping of call decorator keys to their decorated content
   */
  getDecorators() {
    return this._decorators;
  }
  /**
   *
   * @returns the current root element of the editor. If you want to register
   * an event listener, do it via {@link LexicalEditor.registerRootListener}, since
   * this reference may not be stable.
   */
  getRootElement() {
    return this._rootElement;
  }
  /**
   * Gets the key of the editor
   * @returns The editor key
   */
  getKey() {
    return this._key;
  }
  /**
   * Imperatively set the root contenteditable element that Lexical listens
   * for events on.
   */
  setRootElement(nextRootElement) {
    const prevRootElement = this._rootElement;
    if (nextRootElement !== prevRootElement) {
      const classNames14 = getCachedClassNameArray(this._config.theme, "root");
      const pendingEditorState = this._pendingEditorState || this._editorState;
      this._rootElement = nextRootElement;
      resetEditor(this, prevRootElement, nextRootElement, pendingEditorState);
      if (prevRootElement !== null) {
        if (!this._config.disableEvents) {
          removeRootElementEvents(prevRootElement);
        }
        if (classNames14 != null) {
          prevRootElement.classList.remove(...classNames14);
        }
      }
      if (nextRootElement !== null) {
        const windowObj = getDefaultView(nextRootElement);
        const style = nextRootElement.style;
        style.userSelect = "text";
        style.whiteSpace = "pre-wrap";
        style.wordBreak = "break-word";
        nextRootElement.setAttribute("data-lexical-editor", "true");
        this._window = windowObj;
        this._dirtyType = FULL_RECONCILE;
        initMutationObserver(this);
        this._updateTags.add("history-merge");
        $commitPendingUpdates(this);
        if (!this._config.disableEvents) {
          addRootElementEvents(nextRootElement, this);
        }
        if (classNames14 != null) {
          nextRootElement.classList.add(...classNames14);
        }
        {
          const nextRootElementParent = nextRootElement.parentElement;
          if (nextRootElementParent != null && ["flex", "inline-flex"].includes(getComputedStyle(nextRootElementParent).display)) {
            console.warn(`When using "display: flex" or "display: inline-flex" on an element containing content editable, Chrome may have unwanted focusing behavior when clicking outside of it. Consider wrapping the content editable within a non-flex element.`);
          }
        }
      } else {
        this._window = null;
        this._updateTags.add("history-merge");
        $commitPendingUpdates(this);
      }
      triggerListeners("root", this, false, nextRootElement, prevRootElement);
    }
  }
  /**
   * Gets the underlying HTMLElement associated with the LexicalNode for the given key.
   * @returns the HTMLElement rendered by the LexicalNode associated with the key.
   * @param key - the key of the LexicalNode.
   */
  getElementByKey(key2) {
    return this._keyToDOMMap.get(key2) || null;
  }
  /**
   * Gets the active editor state.
   * @returns The editor state
   */
  getEditorState() {
    return this._editorState;
  }
  /**
   * Imperatively set the EditorState. Triggers reconciliation like an update.
   * @param editorState - the state to set the editor
   * @param options - options for the update.
   */
  setEditorState(editorState, options) {
    if (editorState.isEmpty()) {
      {
        throw Error(`setEditorState: the editor state is empty. Ensure the editor state's root node never becomes empty.`);
      }
    }
    let writableEditorState = editorState;
    if (writableEditorState._readOnly) {
      writableEditorState = cloneEditorState(editorState);
      writableEditorState._selection = editorState._selection ? editorState._selection.clone() : null;
    }
    $flushRootMutations(this);
    const pendingEditorState = this._pendingEditorState;
    const tags2 = this._updateTags;
    const tag = options !== void 0 ? options.tag : null;
    if (pendingEditorState !== null && !pendingEditorState.isEmpty()) {
      if (tag != null) {
        tags2.add(tag);
      }
      $commitPendingUpdates(this);
    }
    this._pendingEditorState = writableEditorState;
    this._dirtyType = FULL_RECONCILE;
    this._dirtyElements.set("root", false);
    this._compositionKey = null;
    if (tag != null) {
      tags2.add(tag);
    }
    if (!this._updating) {
      $commitPendingUpdates(this);
    }
  }
  /**
   * Parses a SerializedEditorState (usually produced by {@link EditorState.toJSON}) and returns
   * and EditorState object that can be, for example, passed to {@link LexicalEditor.setEditorState}. Typically,
   * deserialization from JSON stored in a database uses this method.
   * @param maybeStringifiedEditorState
   * @param updateFn
   * @returns
   */
  parseEditorState(maybeStringifiedEditorState, updateFn) {
    const serializedEditorState = typeof maybeStringifiedEditorState === "string" ? JSON.parse(maybeStringifiedEditorState) : maybeStringifiedEditorState;
    return parseEditorState(serializedEditorState, this, updateFn);
  }
  /**
   * Executes a read of the editor's state, with the
   * editor context available (useful for exporting and read-only DOM
   * operations). Much like update, but prevents any mutation of the
   * editor's state. Any pending updates will be flushed immediately before
   * the read.
   * @param callbackFn - A function that has access to read-only editor state.
   */
  read(callbackFn) {
    $commitPendingUpdates(this);
    return this.getEditorState().read(callbackFn, {
      editor: this
    });
  }
  /**
   * Executes an update to the editor state. The updateFn callback is the ONLY place
   * where Lexical editor state can be safely mutated.
   * @param updateFn - A function that has access to writable editor state.
   * @param options - A bag of options to control the behavior of the update.
   * @param options.onUpdate - A function to run once the update is complete.
   * Useful for synchronizing updates in some cases.
   * @param options.skipTransforms - Setting this to true will suppress all node
   * transforms for this update cycle.
   * @param options.tag - A tag to identify this update, in an update listener, for instance.
   * Some tags are reserved by the core and control update behavior in different ways.
   * @param options.discrete - If true, prevents this update from being batched, forcing it to
   * run synchronously.
   */
  update(updateFn, options) {
    updateEditor(this, updateFn, options);
  }
  /**
   * Focuses the editor
   * @param callbackFn - A function to run after the editor is focused.
   * @param options - A bag of options
   * @param options.defaultSelection - Where to move selection when the editor is
   * focused. Can be rootStart, rootEnd, or undefined. Defaults to rootEnd.
   */
  focus(callbackFn, options = {}) {
    const rootElement = this._rootElement;
    if (rootElement !== null) {
      rootElement.setAttribute("autocapitalize", "off");
      updateEditor(this, () => {
        const selection2 = $getSelection();
        const root2 = $getRoot();
        if (selection2 !== null) {
          selection2.dirty = true;
        } else if (root2.getChildrenSize() !== 0) {
          if (options.defaultSelection === "rootStart") {
            root2.selectStart();
          } else {
            root2.selectEnd();
          }
        }
      }, {
        onUpdate: () => {
          rootElement.removeAttribute("autocapitalize");
          if (callbackFn) {
            callbackFn();
          }
        },
        tag: "focus"
      });
      if (this._pendingEditorState === null) {
        rootElement.removeAttribute("autocapitalize");
      }
    }
  }
  /**
   * Removes focus from the editor.
   */
  blur() {
    const rootElement = this._rootElement;
    if (rootElement !== null) {
      rootElement.blur();
    }
    const domSelection = getDOMSelection(this._window);
    if (domSelection !== null) {
      domSelection.removeAllRanges();
    }
  }
  /**
   * Returns true if the editor is editable, false otherwise.
   * @returns True if the editor is editable, false otherwise.
   */
  isEditable() {
    return this._editable;
  }
  /**
   * Sets the editable property of the editor. When false, the
   * editor will not listen for user events on the underling contenteditable.
   * @param editable - the value to set the editable mode to.
   */
  setEditable(editable) {
    if (this._editable !== editable) {
      this._editable = editable;
      triggerListeners("editable", this, true, editable);
    }
  }
  /**
   * Returns a JSON-serializable javascript object NOT a JSON string.
   * You still must call JSON.stringify (or something else) to turn the
   * state into a string you can transfer over the wire and store in a database.
   *
   * See {@link LexicalNode.exportJSON}
   *
   * @returns A JSON-serializable javascript object
   */
  toJSON() {
    return {
      editorState: this._editorState.toJSON()
    };
  }
};
LexicalEditor.version = "0.23.1+dev.esm";

// node_modules/@lexical/selection/LexicalSelection.dev.mjs
var CSS_TO_STYLES = /* @__PURE__ */ new Map();
function getStyleObjectFromRawCSS(css3) {
  const styleObject = {};
  if (!css3) {
    return styleObject;
  }
  const styles2 = css3.split(";");
  for (const style of styles2) {
    if (style !== "") {
      const [key2, value2] = style.split(/:([^]+)/);
      if (key2 && value2) {
        styleObject[key2.trim()] = value2.trim();
      }
    }
  }
  return styleObject;
}
function $sliceSelectedTextNodeContent(selection2, textNode) {
  const anchorAndFocus = selection2.getStartEndPoints();
  if (textNode.isSelected(selection2) && !textNode.isSegmented() && !textNode.isToken() && anchorAndFocus !== null) {
    const [anchor, focus2] = anchorAndFocus;
    const isBackward = selection2.isBackward();
    const anchorNode = anchor.getNode();
    const focusNode = focus2.getNode();
    const isAnchor = textNode.is(anchorNode);
    const isFocus = textNode.is(focusNode);
    if (isAnchor || isFocus) {
      const [anchorOffset, focusOffset] = $getCharacterOffsets(selection2);
      const isSame = anchorNode.is(focusNode);
      const isFirst = textNode.is(isBackward ? focusNode : anchorNode);
      const isLast = textNode.is(isBackward ? anchorNode : focusNode);
      let startOffset = 0;
      let endOffset = void 0;
      if (isSame) {
        startOffset = anchorOffset > focusOffset ? focusOffset : anchorOffset;
        endOffset = anchorOffset > focusOffset ? anchorOffset : focusOffset;
      } else if (isFirst) {
        const offset5 = isBackward ? focusOffset : anchorOffset;
        startOffset = offset5;
        endOffset = void 0;
      } else if (isLast) {
        const offset5 = isBackward ? anchorOffset : focusOffset;
        startOffset = 0;
        endOffset = offset5;
      }
      textNode.__text = textNode.__text.slice(startOffset, endOffset);
      return textNode;
    }
  }
  return textNode;
}
function $isAtNodeEnd(point3) {
  if (point3.type === "text") {
    return point3.offset === point3.getNode().getTextContentSize();
  }
  const node2 = point3.getNode();
  if (!$isElementNode(node2)) {
    throw Error(`isAtNodeEnd: node must be a TextNode or ElementNode`);
  }
  return point3.offset === node2.getChildrenSize();
}
function $trimTextContentFromAnchor(editor, anchor, delCount) {
  let currentNode = anchor.getNode();
  let remaining = delCount;
  if ($isElementNode(currentNode)) {
    const descendantNode = currentNode.getDescendantByIndex(anchor.offset);
    if (descendantNode !== null) {
      currentNode = descendantNode;
    }
  }
  while (remaining > 0 && currentNode !== null) {
    if ($isElementNode(currentNode)) {
      const lastDescendant = currentNode.getLastDescendant();
      if (lastDescendant !== null) {
        currentNode = lastDescendant;
      }
    }
    let nextNode = currentNode.getPreviousSibling();
    let additionalElementWhitespace = 0;
    if (nextNode === null) {
      let parent = currentNode.getParentOrThrow();
      let parentSibling = parent.getPreviousSibling();
      while (parentSibling === null) {
        parent = parent.getParent();
        if (parent === null) {
          nextNode = null;
          break;
        }
        parentSibling = parent.getPreviousSibling();
      }
      if (parent !== null) {
        additionalElementWhitespace = parent.isInline() ? 0 : 2;
        nextNode = parentSibling;
      }
    }
    let text4 = currentNode.getTextContent();
    if (text4 === "" && $isElementNode(currentNode) && !currentNode.isInline()) {
      text4 = "\n\n";
    }
    const currentNodeSize = text4.length;
    if (!$isTextNode(currentNode) || remaining >= currentNodeSize) {
      const parent = currentNode.getParent();
      currentNode.remove();
      if (parent != null && parent.getChildrenSize() === 0 && !$isRootNode(parent)) {
        parent.remove();
      }
      remaining -= currentNodeSize + additionalElementWhitespace;
      currentNode = nextNode;
    } else {
      const key2 = currentNode.getKey();
      const prevTextContent = editor.getEditorState().read(() => {
        const prevNode = $getNodeByKey(key2);
        if ($isTextNode(prevNode) && prevNode.isSimpleText()) {
          return prevNode.getTextContent();
        }
        return null;
      });
      const offset5 = currentNodeSize - remaining;
      const slicedText = text4.slice(0, offset5);
      if (prevTextContent !== null && prevTextContent !== text4) {
        const prevSelection = $getPreviousSelection();
        let target = currentNode;
        if (!currentNode.isSimpleText()) {
          const textNode = $createTextNode(prevTextContent);
          currentNode.replace(textNode);
          target = textNode;
        } else {
          currentNode.setTextContent(prevTextContent);
        }
        if ($isRangeSelection(prevSelection) && prevSelection.isCollapsed()) {
          const prevOffset = prevSelection.anchor.offset;
          target.select(prevOffset, prevOffset);
        }
      } else if (currentNode.isSimpleText()) {
        const isSelected = anchor.key === key2;
        let anchorOffset = anchor.offset;
        if (anchorOffset < remaining) {
          anchorOffset = currentNodeSize;
        }
        const splitStart = isSelected ? anchorOffset - remaining : 0;
        const splitEnd = isSelected ? anchorOffset : offset5;
        if (isSelected && splitStart === 0) {
          const [excessNode] = currentNode.splitText(splitStart, splitEnd);
          excessNode.remove();
        } else {
          const [, excessNode] = currentNode.splitText(splitStart, splitEnd);
          excessNode.remove();
        }
      } else {
        const textNode = $createTextNode(slicedText);
        currentNode.replace(textNode);
      }
      remaining = 0;
    }
  }
}
function $addNodeStyle(node2) {
  const CSSText = node2.getStyle();
  const styles2 = getStyleObjectFromRawCSS(CSSText);
  CSS_TO_STYLES.set(CSSText, styles2);
}
function $setBlocksType(selection2, createElement12) {
  if (selection2 === null) {
    return;
  }
  const anchorAndFocus = selection2.getStartEndPoints();
  const anchor = anchorAndFocus ? anchorAndFocus[0] : null;
  if (anchor !== null && anchor.key === "root") {
    const element2 = createElement12();
    const root2 = $getRoot();
    const firstChild = root2.getFirstChild();
    if (firstChild) {
      firstChild.replace(element2, true);
    } else {
      root2.append(element2);
    }
    return;
  }
  const nodes = selection2.getNodes();
  const firstSelectedBlock = anchor !== null ? $getAncestor2(anchor.getNode(), INTERNAL_$isBlock2) : false;
  if (firstSelectedBlock && nodes.indexOf(firstSelectedBlock) === -1) {
    nodes.push(firstSelectedBlock);
  }
  for (let i3 = 0; i3 < nodes.length; i3++) {
    const node2 = nodes[i3];
    if (!INTERNAL_$isBlock2(node2)) {
      continue;
    }
    if (!$isElementNode(node2)) {
      throw Error(`Expected block node to be an ElementNode`);
    }
    const targetElement = createElement12();
    targetElement.setFormat(node2.getFormatType());
    targetElement.setIndent(node2.getIndent());
    node2.replace(targetElement, true);
  }
}
function $shouldOverrideDefaultCharacterSelection(selection2, isBackward) {
  const possibleNode = $getAdjacentNode(selection2.focus, isBackward);
  return $isDecoratorNode(possibleNode) && !possibleNode.isIsolated() || $isElementNode(possibleNode) && !possibleNode.isInline() && !possibleNode.canBeEmpty();
}
function $moveCaretSelection(selection2, isHoldingShift, isBackward, granularity) {
  selection2.modify(isHoldingShift ? "extend" : "move", isBackward, granularity);
}
function $isParentElementRTL(selection2) {
  const anchorNode = selection2.anchor.getNode();
  const parent = $isRootNode(anchorNode) ? anchorNode : anchorNode.getParentOrThrow();
  return parent.getDirection() === "rtl";
}
function $moveCharacter(selection2, isHoldingShift, isBackward) {
  const isRTL2 = $isParentElementRTL(selection2);
  $moveCaretSelection(selection2, isHoldingShift, isBackward ? !isRTL2 : isRTL2, "character");
}
function INTERNAL_$isBlock2(node2) {
  if ($isDecoratorNode(node2)) {
    return false;
  }
  if (!$isElementNode(node2) || $isRootOrShadowRoot(node2)) {
    return false;
  }
  const firstChild = node2.getFirstChild();
  const isLeafElement = firstChild === null || $isLineBreakNode(firstChild) || $isTextNode(firstChild) || firstChild.isInline();
  return !node2.isInline() && node2.canBeEmpty() !== false && isLeafElement;
}
function $getAncestor2(node2, predicate) {
  let parent = node2;
  while (parent !== null && parent.getParent() !== null && !predicate(parent)) {
    parent = parent.getParentOrThrow();
  }
  return predicate(parent) ? parent : null;
}
var trimTextContentFromAnchor = $trimTextContentFromAnchor;

// node_modules/@lexical/utils/LexicalUtils.dev.mjs
var CAN_USE_DOM$1 = typeof window !== "undefined" && typeof window.document !== "undefined" && typeof window.document.createElement !== "undefined";
var documentMode2 = CAN_USE_DOM$1 && "documentMode" in document ? document.documentMode : null;
var IS_APPLE$1 = CAN_USE_DOM$1 && /Mac|iPod|iPhone|iPad/.test(navigator.platform);
var IS_FIREFOX$1 = CAN_USE_DOM$1 && /^(?!.*Seamonkey)(?=.*Firefox).*/i.test(navigator.userAgent);
var CAN_USE_BEFORE_INPUT$1 = CAN_USE_DOM$1 && "InputEvent" in window && !documentMode2 ? "getTargetRanges" in new window.InputEvent("input") : false;
var IS_SAFARI$1 = CAN_USE_DOM$1 && /Version\/[\d.]+.*Safari/.test(navigator.userAgent);
var IS_IOS$1 = CAN_USE_DOM$1 && /iPad|iPhone|iPod/.test(navigator.userAgent) && !window.MSStream;
var IS_ANDROID$1 = CAN_USE_DOM$1 && /Android/.test(navigator.userAgent);
var IS_CHROME$1 = CAN_USE_DOM$1 && /^(?=.*Chrome).*/i.test(navigator.userAgent);
var IS_APPLE_WEBKIT$1 = CAN_USE_DOM$1 && /AppleWebKit\/[\d.]+/.test(navigator.userAgent) && !IS_CHROME$1;
function normalizeClassNames2(...classNames14) {
  const rval = [];
  for (const className of classNames14) {
    if (className && typeof className === "string") {
      for (const [s2] of className.matchAll(/\S+/g)) {
        rval.push(s2);
      }
    }
  }
  return rval;
}
function mergeRegister(...func) {
  return () => {
    for (let i3 = func.length - 1; i3 >= 0; i3--) {
      func[i3]();
    }
    func.length = 0;
  };
}
var CAN_USE_DOM2 = CAN_USE_DOM$1;
var IS_FIREFOX2 = IS_FIREFOX$1;
function addClassNamesToElement(element2, ...classNames14) {
  const classesToAdd = normalizeClassNames2(...classNames14);
  if (classesToAdd.length > 0) {
    element2.classList.add(...classesToAdd);
  }
}
function removeClassNamesFromElement(element2, ...classNames14) {
  const classesToRemove = normalizeClassNames2(...classNames14);
  if (classesToRemove.length > 0) {
    element2.classList.remove(...classesToRemove);
  }
}
function $getNearestNodeOfType(node2, klass) {
  let parent = node2;
  while (parent != null) {
    if (parent instanceof klass) {
      return parent;
    }
    parent = parent.getParent();
  }
  return null;
}
function $getNearestBlockElementAncestorOrThrow(startNode) {
  const blockNode = $findMatchingParent(startNode, (node2) => $isElementNode(node2) && !node2.isInline());
  if (!$isElementNode(blockNode)) {
    {
      throw Error(`Expected node ${startNode.__key} to have closest block element node.`);
    }
  }
  return blockNode;
}
var $findMatchingParent = (startingNode, findFn) => {
  let curr = startingNode;
  while (curr !== $getRoot() && curr != null) {
    if (findFn(curr)) {
      return curr;
    }
    curr = curr.getParent();
  }
  return null;
};
function $restoreEditorState(editor, editorState) {
  const FULL_RECONCILE2 = 2;
  const nodeMap = /* @__PURE__ */ new Map();
  const activeEditorState2 = editor._pendingEditorState;
  for (const [key2, node2] of editorState._nodeMap) {
    nodeMap.set(key2, $cloneWithProperties(node2));
  }
  if (activeEditorState2) {
    activeEditorState2._nodeMap = nodeMap;
  }
  editor._dirtyType = FULL_RECONCILE2;
  const selection2 = editorState._selection;
  $setSelection(selection2 === null ? null : selection2.clone());
}
function $insertNodeToNearestRoot(node2) {
  const selection2 = $getSelection() || $getPreviousSelection();
  if ($isRangeSelection(selection2)) {
    const {
      focus: focus2
    } = selection2;
    const focusNode = focus2.getNode();
    const focusOffset = focus2.offset;
    if ($isRootOrShadowRoot(focusNode)) {
      const focusChild = focusNode.getChildAtIndex(focusOffset);
      if (focusChild == null) {
        focusNode.append(node2);
      } else {
        focusChild.insertBefore(node2);
      }
      node2.selectNext();
    } else {
      let splitNode;
      let splitOffset;
      if ($isTextNode(focusNode)) {
        splitNode = focusNode.getParentOrThrow();
        splitOffset = focusNode.getIndexWithinParent();
        if (focusOffset > 0) {
          splitOffset += 1;
          focusNode.splitText(focusOffset);
        }
      } else {
        splitNode = focusNode;
        splitOffset = focusOffset;
      }
      const [, rightTree] = $splitNode(splitNode, splitOffset);
      rightTree.insertBefore(node2);
      rightTree.selectStart();
    }
  } else {
    if (selection2 != null) {
      const nodes = selection2.getNodes();
      nodes[nodes.length - 1].getTopLevelElementOrThrow().insertAfter(node2);
    } else {
      const root2 = $getRoot();
      root2.append(node2);
    }
    const paragraphNode = $createParagraphNode();
    node2.insertAfter(paragraphNode);
    paragraphNode.select();
  }
  return node2.getLatest();
}
function $wrapNodeInElement(node2, createElementNode) {
  const elementNode = createElementNode();
  node2.replace(elementNode);
  elementNode.append(node2);
  return elementNode;
}
function objectKlassEquals(object, objectClass) {
  return object !== null ? Object.getPrototypeOf(object).constructor.name === objectClass.name : false;
}
function $filter(nodes, filterFn) {
  const result = [];
  for (let i3 = 0; i3 < nodes.length; i3++) {
    const node2 = filterFn(nodes[i3]);
    if (node2 !== null) {
      result.push(node2);
    }
  }
  return result;
}
var NEEDS_MANUAL_ZOOM = IS_FIREFOX2 || !CAN_USE_DOM2 ? false : void 0;
function needsManualZoom() {
  if (NEEDS_MANUAL_ZOOM === void 0) {
    const div = document.createElement("div");
    div.style.cssText = "position: absolute; opacity: 0; width: 100px; left: -1000px;";
    document.body.appendChild(div);
    const noZoom = div.getBoundingClientRect();
    div.style.setProperty("zoom", "2");
    NEEDS_MANUAL_ZOOM = div.getBoundingClientRect().width === noZoom.width;
    document.body.removeChild(div);
  }
  return NEEDS_MANUAL_ZOOM;
}
function calculateZoomLevel(element2) {
  let zoom = 1;
  if (needsManualZoom()) {
    while (element2) {
      zoom *= Number(window.getComputedStyle(element2).getPropertyValue("zoom"));
      element2 = element2.parentElement;
    }
  }
  return zoom;
}

// node_modules/@lexical/history/LexicalHistory.dev.mjs
var HISTORY_MERGE = 0;
var HISTORY_PUSH = 1;
var DISCARD_HISTORY_CANDIDATE = 2;
var OTHER = 0;
var COMPOSING_CHARACTER = 1;
var INSERT_CHARACTER_AFTER_SELECTION = 2;
var DELETE_CHARACTER_BEFORE_SELECTION = 3;
var DELETE_CHARACTER_AFTER_SELECTION = 4;
function getDirtyNodes(editorState, dirtyLeaves, dirtyElements) {
  const nodeMap = editorState._nodeMap;
  const nodes = [];
  for (const dirtyLeafKey of dirtyLeaves) {
    const dirtyLeaf = nodeMap.get(dirtyLeafKey);
    if (dirtyLeaf !== void 0) {
      nodes.push(dirtyLeaf);
    }
  }
  for (const [dirtyElementKey, intentionallyMarkedAsDirty] of dirtyElements) {
    if (!intentionallyMarkedAsDirty) {
      continue;
    }
    const dirtyElement = nodeMap.get(dirtyElementKey);
    if (dirtyElement !== void 0 && !$isRootNode(dirtyElement)) {
      nodes.push(dirtyElement);
    }
  }
  return nodes;
}
function getChangeType(prevEditorState, nextEditorState, dirtyLeavesSet, dirtyElementsSet, isComposing) {
  if (prevEditorState === null || dirtyLeavesSet.size === 0 && dirtyElementsSet.size === 0 && !isComposing) {
    return OTHER;
  }
  const nextSelection = nextEditorState._selection;
  const prevSelection = prevEditorState._selection;
  if (isComposing) {
    return COMPOSING_CHARACTER;
  }
  if (!$isRangeSelection(nextSelection) || !$isRangeSelection(prevSelection) || !prevSelection.isCollapsed() || !nextSelection.isCollapsed()) {
    return OTHER;
  }
  const dirtyNodes = getDirtyNodes(nextEditorState, dirtyLeavesSet, dirtyElementsSet);
  if (dirtyNodes.length === 0) {
    return OTHER;
  }
  if (dirtyNodes.length > 1) {
    const nextNodeMap = nextEditorState._nodeMap;
    const nextAnchorNode = nextNodeMap.get(nextSelection.anchor.key);
    const prevAnchorNode = nextNodeMap.get(prevSelection.anchor.key);
    if (nextAnchorNode && prevAnchorNode && !prevEditorState._nodeMap.has(nextAnchorNode.__key) && $isTextNode(nextAnchorNode) && nextAnchorNode.__text.length === 1 && nextSelection.anchor.offset === 1) {
      return INSERT_CHARACTER_AFTER_SELECTION;
    }
    return OTHER;
  }
  const nextDirtyNode = dirtyNodes[0];
  const prevDirtyNode = prevEditorState._nodeMap.get(nextDirtyNode.__key);
  if (!$isTextNode(prevDirtyNode) || !$isTextNode(nextDirtyNode) || prevDirtyNode.__mode !== nextDirtyNode.__mode) {
    return OTHER;
  }
  const prevText = prevDirtyNode.__text;
  const nextText = nextDirtyNode.__text;
  if (prevText === nextText) {
    return OTHER;
  }
  const nextAnchor = nextSelection.anchor;
  const prevAnchor = prevSelection.anchor;
  if (nextAnchor.key !== prevAnchor.key || nextAnchor.type !== "text") {
    return OTHER;
  }
  const nextAnchorOffset = nextAnchor.offset;
  const prevAnchorOffset = prevAnchor.offset;
  const textDiff = nextText.length - prevText.length;
  if (textDiff === 1 && prevAnchorOffset === nextAnchorOffset - 1) {
    return INSERT_CHARACTER_AFTER_SELECTION;
  }
  if (textDiff === -1 && prevAnchorOffset === nextAnchorOffset + 1) {
    return DELETE_CHARACTER_BEFORE_SELECTION;
  }
  if (textDiff === -1 && prevAnchorOffset === nextAnchorOffset) {
    return DELETE_CHARACTER_AFTER_SELECTION;
  }
  return OTHER;
}
function isTextNodeUnchanged(key2, prevEditorState, nextEditorState) {
  const prevNode = prevEditorState._nodeMap.get(key2);
  const nextNode = nextEditorState._nodeMap.get(key2);
  const prevSelection = prevEditorState._selection;
  const nextSelection = nextEditorState._selection;
  const isDeletingLine = $isRangeSelection(prevSelection) && $isRangeSelection(nextSelection) && prevSelection.anchor.type === "element" && prevSelection.focus.type === "element" && nextSelection.anchor.type === "text" && nextSelection.focus.type === "text";
  if (!isDeletingLine && $isTextNode(prevNode) && $isTextNode(nextNode) && prevNode.__parent === nextNode.__parent) {
    return JSON.stringify(prevEditorState.read(() => prevNode.exportJSON())) === JSON.stringify(nextEditorState.read(() => nextNode.exportJSON()));
  }
  return false;
}
function createMergeActionGetter(editor, delay) {
  let prevChangeTime = Date.now();
  let prevChangeType = OTHER;
  return (prevEditorState, nextEditorState, currentHistoryEntry, dirtyLeaves, dirtyElements, tags2) => {
    const changeTime = Date.now();
    if (tags2.has("historic")) {
      prevChangeType = OTHER;
      prevChangeTime = changeTime;
      return DISCARD_HISTORY_CANDIDATE;
    }
    const changeType = getChangeType(prevEditorState, nextEditorState, dirtyLeaves, dirtyElements, editor.isComposing());
    const mergeAction = (() => {
      const isSameEditor = currentHistoryEntry === null || currentHistoryEntry.editor === editor;
      const shouldPushHistory = tags2.has("history-push");
      const shouldMergeHistory = !shouldPushHistory && isSameEditor && tags2.has("history-merge");
      if (shouldMergeHistory) {
        return HISTORY_MERGE;
      }
      if (prevEditorState === null) {
        return HISTORY_PUSH;
      }
      const selection2 = nextEditorState._selection;
      const hasDirtyNodes = dirtyLeaves.size > 0 || dirtyElements.size > 0;
      if (!hasDirtyNodes) {
        if (selection2 !== null) {
          return HISTORY_MERGE;
        }
        return DISCARD_HISTORY_CANDIDATE;
      }
      if (shouldPushHistory === false && changeType !== OTHER && changeType === prevChangeType && changeTime < prevChangeTime + delay && isSameEditor) {
        return HISTORY_MERGE;
      }
      if (dirtyLeaves.size === 1) {
        const dirtyLeafKey = Array.from(dirtyLeaves)[0];
        if (isTextNodeUnchanged(dirtyLeafKey, prevEditorState, nextEditorState)) {
          return HISTORY_MERGE;
        }
      }
      return HISTORY_PUSH;
    })();
    prevChangeTime = changeTime;
    prevChangeType = changeType;
    return mergeAction;
  };
}
function redo(editor, historyState) {
  const redoStack = historyState.redoStack;
  const undoStack = historyState.undoStack;
  if (redoStack.length !== 0) {
    const current2 = historyState.current;
    if (current2 !== null) {
      undoStack.push(current2);
      editor.dispatchCommand(CAN_UNDO_COMMAND, true);
    }
    const historyStateEntry = redoStack.pop();
    if (redoStack.length === 0) {
      editor.dispatchCommand(CAN_REDO_COMMAND, false);
    }
    historyState.current = historyStateEntry || null;
    if (historyStateEntry) {
      historyStateEntry.editor.setEditorState(historyStateEntry.editorState, {
        tag: "historic"
      });
    }
  }
}
function undo(editor, historyState) {
  const redoStack = historyState.redoStack;
  const undoStack = historyState.undoStack;
  const undoStackLength = undoStack.length;
  if (undoStackLength !== 0) {
    const current2 = historyState.current;
    const historyStateEntry = undoStack.pop();
    if (current2 !== null) {
      redoStack.push(current2);
      editor.dispatchCommand(CAN_REDO_COMMAND, true);
    }
    if (undoStack.length === 0) {
      editor.dispatchCommand(CAN_UNDO_COMMAND, false);
    }
    historyState.current = historyStateEntry || null;
    if (historyStateEntry) {
      historyStateEntry.editor.setEditorState(historyStateEntry.editorState, {
        tag: "historic"
      });
    }
  }
}
function clearHistory(historyState) {
  historyState.undoStack = [];
  historyState.redoStack = [];
  historyState.current = null;
}
function registerHistory(editor, historyState, delay) {
  const getMergeAction = createMergeActionGetter(editor, delay);
  const applyChange = ({
    editorState,
    prevEditorState,
    dirtyLeaves,
    dirtyElements,
    tags: tags2
  }) => {
    const current2 = historyState.current;
    const redoStack = historyState.redoStack;
    const undoStack = historyState.undoStack;
    const currentEditorState = current2 === null ? null : current2.editorState;
    if (current2 !== null && editorState === currentEditorState) {
      return;
    }
    const mergeAction = getMergeAction(prevEditorState, editorState, current2, dirtyLeaves, dirtyElements, tags2);
    if (mergeAction === HISTORY_PUSH) {
      if (redoStack.length !== 0) {
        historyState.redoStack = [];
        editor.dispatchCommand(CAN_REDO_COMMAND, false);
      }
      if (current2 !== null) {
        undoStack.push({
          ...current2
        });
        editor.dispatchCommand(CAN_UNDO_COMMAND, true);
      }
    } else if (mergeAction === DISCARD_HISTORY_CANDIDATE) {
      return;
    }
    historyState.current = {
      editor,
      editorState
    };
  };
  const unregister = mergeRegister(editor.registerCommand(UNDO_COMMAND, () => {
    undo(editor, historyState);
    return true;
  }, COMMAND_PRIORITY_EDITOR), editor.registerCommand(REDO_COMMAND, () => {
    redo(editor, historyState);
    return true;
  }, COMMAND_PRIORITY_EDITOR), editor.registerCommand(CLEAR_EDITOR_COMMAND, () => {
    clearHistory(historyState);
    return false;
  }, COMMAND_PRIORITY_EDITOR), editor.registerCommand(CLEAR_HISTORY_COMMAND, () => {
    clearHistory(historyState);
    editor.dispatchCommand(CAN_REDO_COMMAND, false);
    editor.dispatchCommand(CAN_UNDO_COMMAND, false);
    return true;
  }, COMMAND_PRIORITY_EDITOR), editor.registerUpdateListener(applyChange));
  return unregister;
}
function createEmptyHistoryState() {
  return {
    current: null,
    redoStack: [],
    undoStack: []
  };
}

// node_modules/@lexical/react/LexicalHistoryPlugin.dev.mjs
var import_react3 = __toESM(require_react(), 1);
function useHistory(editor, externalHistoryState, delay = 1e3) {
  const historyState = (0, import_react3.useMemo)(() => externalHistoryState || createEmptyHistoryState(), [externalHistoryState]);
  (0, import_react3.useEffect)(() => {
    return registerHistory(editor, historyState, delay);
  }, [delay, editor, historyState]);
}
function HistoryPlugin({
  delay,
  externalHistoryState
}) {
  const [editor] = useLexicalComposerContext();
  useHistory(editor, externalHistoryState, delay);
  return null;
}

// node_modules/@lexical/html/LexicalHtml.dev.mjs
function $generateNodesFromDOM(editor, dom) {
  const elements = dom.body ? dom.body.childNodes : [];
  let lexicalNodes = [];
  const allArtificialNodes = [];
  for (let i3 = 0; i3 < elements.length; i3++) {
    const element2 = elements[i3];
    if (!IGNORE_TAGS.has(element2.nodeName)) {
      const lexicalNode = $createNodesFromDOM(element2, editor, allArtificialNodes, false);
      if (lexicalNode !== null) {
        lexicalNodes = lexicalNodes.concat(lexicalNode);
      }
    }
  }
  $unwrapArtificalNodes(allArtificialNodes);
  return lexicalNodes;
}
function $generateHtmlFromNodes(editor, selection2) {
  if (typeof document === "undefined" || typeof window === "undefined" && typeof global.window === "undefined") {
    throw new Error("To use $generateHtmlFromNodes in headless mode please initialize a headless browser implementation such as JSDom before calling this function.");
  }
  const container = document.createElement("div");
  const root2 = $getRoot();
  const topLevelChildren = root2.getChildren();
  for (let i3 = 0; i3 < topLevelChildren.length; i3++) {
    const topLevelNode = topLevelChildren[i3];
    $appendNodesToHTML(editor, topLevelNode, container, selection2);
  }
  return container.innerHTML;
}
function $appendNodesToHTML(editor, currentNode, parentElement, selection2 = null) {
  let shouldInclude = selection2 !== null ? currentNode.isSelected(selection2) : true;
  const shouldExclude = $isElementNode(currentNode) && currentNode.excludeFromCopy("html");
  let target = currentNode;
  if (selection2 !== null) {
    let clone = $cloneWithProperties(currentNode);
    clone = $isTextNode(clone) && selection2 !== null ? $sliceSelectedTextNodeContent(selection2, clone) : clone;
    target = clone;
  }
  const children = $isElementNode(target) ? target.getChildren() : [];
  const registeredNode = editor._nodes.get(target.getType());
  let exportOutput;
  if (registeredNode && registeredNode.exportDOM !== void 0) {
    exportOutput = registeredNode.exportDOM(editor, target);
  } else {
    exportOutput = target.exportDOM(editor);
  }
  const {
    element: element2,
    after
  } = exportOutput;
  if (!element2) {
    return false;
  }
  const fragment = document.createDocumentFragment();
  for (let i3 = 0; i3 < children.length; i3++) {
    const childNode = children[i3];
    const shouldIncludeChild = $appendNodesToHTML(editor, childNode, fragment, selection2);
    if (!shouldInclude && $isElementNode(currentNode) && shouldIncludeChild && currentNode.extractWithChild(childNode, selection2, "html")) {
      shouldInclude = true;
    }
  }
  if (shouldInclude && !shouldExclude) {
    if (isHTMLElement(element2) || isDocumentFragment(element2)) {
      element2.append(fragment);
    }
    parentElement.append(element2);
    if (after) {
      const newElement = after.call(target, element2);
      if (newElement) {
        if (isDocumentFragment(element2)) {
          element2.replaceChildren(newElement);
        } else {
          element2.replaceWith(newElement);
        }
      }
    }
  } else {
    parentElement.append(fragment);
  }
  return shouldInclude;
}
function getConversionFunction(domNode, editor) {
  const {
    nodeName
  } = domNode;
  const cachedConversions = editor._htmlConversions.get(nodeName.toLowerCase());
  let currentConversion = null;
  if (cachedConversions !== void 0) {
    for (const cachedConversion of cachedConversions) {
      const domConversion = cachedConversion(domNode);
      if (domConversion !== null && (currentConversion === null || // Given equal priority, prefer the last registered importer
      // which is typically an application custom node or HTMLConfig['import']
      (currentConversion.priority || 0) <= (domConversion.priority || 0))) {
        currentConversion = domConversion;
      }
    }
  }
  return currentConversion !== null ? currentConversion.conversion : null;
}
var IGNORE_TAGS = /* @__PURE__ */ new Set(["STYLE", "SCRIPT"]);
function $createNodesFromDOM(node2, editor, allArtificialNodes, hasBlockAncestorLexicalNode, forChildMap = /* @__PURE__ */ new Map(), parentLexicalNode) {
  let lexicalNodes = [];
  if (IGNORE_TAGS.has(node2.nodeName)) {
    return lexicalNodes;
  }
  let currentLexicalNode = null;
  const transformFunction = getConversionFunction(node2, editor);
  const transformOutput = transformFunction ? transformFunction(node2) : null;
  let postTransform = null;
  if (transformOutput !== null) {
    postTransform = transformOutput.after;
    const transformNodes = transformOutput.node;
    currentLexicalNode = Array.isArray(transformNodes) ? transformNodes[transformNodes.length - 1] : transformNodes;
    if (currentLexicalNode !== null) {
      for (const [, forChildFunction] of forChildMap) {
        currentLexicalNode = forChildFunction(currentLexicalNode, parentLexicalNode);
        if (!currentLexicalNode) {
          break;
        }
      }
      if (currentLexicalNode) {
        lexicalNodes.push(...Array.isArray(transformNodes) ? transformNodes : [currentLexicalNode]);
      }
    }
    if (transformOutput.forChild != null) {
      forChildMap.set(node2.nodeName, transformOutput.forChild);
    }
  }
  const children = node2.childNodes;
  let childLexicalNodes = [];
  const hasBlockAncestorLexicalNodeForChildren = currentLexicalNode != null && $isRootOrShadowRoot(currentLexicalNode) ? false : currentLexicalNode != null && $isBlockElementNode(currentLexicalNode) || hasBlockAncestorLexicalNode;
  for (let i3 = 0; i3 < children.length; i3++) {
    childLexicalNodes.push(...$createNodesFromDOM(children[i3], editor, allArtificialNodes, hasBlockAncestorLexicalNodeForChildren, new Map(forChildMap), currentLexicalNode));
  }
  if (postTransform != null) {
    childLexicalNodes = postTransform(childLexicalNodes);
  }
  if (isBlockDomNode(node2)) {
    if (!hasBlockAncestorLexicalNodeForChildren) {
      childLexicalNodes = wrapContinuousInlines(node2, childLexicalNodes, $createParagraphNode);
    } else {
      childLexicalNodes = wrapContinuousInlines(node2, childLexicalNodes, () => {
        const artificialNode = new ArtificialNode__DO_NOT_USE();
        allArtificialNodes.push(artificialNode);
        return artificialNode;
      });
    }
  }
  if (currentLexicalNode == null) {
    if (childLexicalNodes.length > 0) {
      lexicalNodes = lexicalNodes.concat(childLexicalNodes);
    } else {
      if (isBlockDomNode(node2) && isDomNodeBetweenTwoInlineNodes(node2)) {
        lexicalNodes = lexicalNodes.concat($createLineBreakNode());
      }
    }
  } else {
    if ($isElementNode(currentLexicalNode)) {
      currentLexicalNode.append(...childLexicalNodes);
    }
  }
  return lexicalNodes;
}
function wrapContinuousInlines(domNode, nodes, createWrapperFn) {
  const textAlign = domNode.style.textAlign;
  const out = [];
  let continuousInlines = [];
  for (let i3 = 0; i3 < nodes.length; i3++) {
    const node2 = nodes[i3];
    if ($isBlockElementNode(node2)) {
      if (textAlign && !node2.getFormat()) {
        node2.setFormat(textAlign);
      }
      out.push(node2);
    } else {
      continuousInlines.push(node2);
      if (i3 === nodes.length - 1 || i3 < nodes.length - 1 && $isBlockElementNode(nodes[i3 + 1])) {
        const wrapper = createWrapperFn();
        wrapper.setFormat(textAlign);
        wrapper.append(...continuousInlines);
        out.push(wrapper);
        continuousInlines = [];
      }
    }
  }
  return out;
}
function $unwrapArtificalNodes(allArtificialNodes) {
  for (const node2 of allArtificialNodes) {
    if (node2.getNextSibling() instanceof ArtificialNode__DO_NOT_USE) {
      node2.insertAfter($createLineBreakNode());
    }
  }
  for (const node2 of allArtificialNodes) {
    const children = node2.getChildren();
    for (const child of children) {
      node2.insertBefore(child);
    }
    node2.remove();
  }
}
function isDomNodeBetweenTwoInlineNodes(node2) {
  if (node2.nextSibling == null || node2.previousSibling == null) {
    return false;
  }
  return isInlineDomNode(node2.nextSibling) && isInlineDomNode(node2.previousSibling);
}

// node_modules/@lexical/clipboard/LexicalClipboard.dev.mjs
function $getHtmlContent(editor, selection2 = $getSelection()) {
  if (selection2 == null) {
    {
      throw Error(`Expected valid LexicalSelection`);
    }
  }
  if ($isRangeSelection(selection2) && selection2.isCollapsed() || selection2.getNodes().length === 0) {
    return "";
  }
  return $generateHtmlFromNodes(editor, selection2);
}
function $getLexicalContent(editor, selection2 = $getSelection()) {
  if (selection2 == null) {
    {
      throw Error(`Expected valid LexicalSelection`);
    }
  }
  if ($isRangeSelection(selection2) && selection2.isCollapsed() || selection2.getNodes().length === 0) {
    return null;
  }
  return JSON.stringify($generateJSONFromSelectedNodes(editor, selection2));
}
function $insertDataTransferForRichText(dataTransfer, selection2, editor) {
  const lexicalString = dataTransfer.getData("application/x-lexical-editor");
  if (lexicalString) {
    try {
      const payload = JSON.parse(lexicalString);
      if (payload.namespace === editor._config.namespace && Array.isArray(payload.nodes)) {
        const nodes = $generateNodesFromSerializedNodes(payload.nodes);
        return $insertGeneratedNodes(editor, nodes, selection2);
      }
    } catch (_unused) {
    }
  }
  const htmlString = dataTransfer.getData("text/html");
  if (htmlString) {
    try {
      const parser = new DOMParser();
      const dom = parser.parseFromString(trustHTML(htmlString), "text/html");
      const nodes = $generateNodesFromDOM(editor, dom);
      return $insertGeneratedNodes(editor, nodes, selection2);
    } catch (_unused2) {
    }
  }
  const text4 = dataTransfer.getData("text/plain") || dataTransfer.getData("text/uri-list");
  if (text4 != null) {
    if ($isRangeSelection(selection2)) {
      const parts = text4.split(/(\r?\n|\t)/);
      if (parts[parts.length - 1] === "") {
        parts.pop();
      }
      for (let i3 = 0; i3 < parts.length; i3++) {
        const currentSelection = $getSelection();
        if ($isRangeSelection(currentSelection)) {
          const part = parts[i3];
          if (part === "\n" || part === "\r\n") {
            currentSelection.insertParagraph();
          } else if (part === "	") {
            currentSelection.insertNodes([$createTabNode()]);
          } else {
            currentSelection.insertText(part);
          }
        }
      }
    } else {
      selection2.insertRawText(text4);
    }
  }
}
function trustHTML(html3) {
  if (window.trustedTypes && window.trustedTypes.createPolicy) {
    const policy = window.trustedTypes.createPolicy("lexical", {
      createHTML: (input) => input
    });
    return policy.createHTML(html3);
  }
  return html3;
}
function $insertGeneratedNodes(editor, nodes, selection2) {
  if (!editor.dispatchCommand(SELECTION_INSERT_CLIPBOARD_NODES_COMMAND, {
    nodes,
    selection: selection2
  })) {
    selection2.insertNodes(nodes);
  }
  return;
}
function exportNodeToJSON2(node2) {
  const serializedNode = node2.exportJSON();
  const nodeClass = node2.constructor;
  if (serializedNode.type !== nodeClass.getType()) {
    {
      throw Error(`LexicalNode: Node ${nodeClass.name} does not implement .exportJSON().`);
    }
  }
  if ($isElementNode(node2)) {
    const serializedChildren = serializedNode.children;
    if (!Array.isArray(serializedChildren)) {
      {
        throw Error(`LexicalNode: Node ${nodeClass.name} is an element but .exportJSON() does not have a children array.`);
      }
    }
  }
  return serializedNode;
}
function $appendNodesToJSON(editor, selection2, currentNode, targetArray = []) {
  let shouldInclude = selection2 !== null ? currentNode.isSelected(selection2) : true;
  const shouldExclude = $isElementNode(currentNode) && currentNode.excludeFromCopy("html");
  let target = currentNode;
  if (selection2 !== null) {
    let clone = $cloneWithProperties(currentNode);
    clone = $isTextNode(clone) && selection2 !== null ? $sliceSelectedTextNodeContent(selection2, clone) : clone;
    target = clone;
  }
  const children = $isElementNode(target) ? target.getChildren() : [];
  const serializedNode = exportNodeToJSON2(target);
  if ($isTextNode(target)) {
    const text4 = target.__text;
    if (text4.length > 0) {
      serializedNode.text = text4;
    } else {
      shouldInclude = false;
    }
  }
  for (let i3 = 0; i3 < children.length; i3++) {
    const childNode = children[i3];
    const shouldIncludeChild = $appendNodesToJSON(editor, selection2, childNode, serializedNode.children);
    if (!shouldInclude && $isElementNode(currentNode) && shouldIncludeChild && currentNode.extractWithChild(childNode, selection2, "clone")) {
      shouldInclude = true;
    }
  }
  if (shouldInclude && !shouldExclude) {
    targetArray.push(serializedNode);
  } else if (Array.isArray(serializedNode.children)) {
    for (let i3 = 0; i3 < serializedNode.children.length; i3++) {
      const serializedChildNode = serializedNode.children[i3];
      targetArray.push(serializedChildNode);
    }
  }
  return shouldInclude;
}
function $generateJSONFromSelectedNodes(editor, selection2) {
  const nodes = [];
  const root2 = $getRoot();
  const topLevelChildren = root2.getChildren();
  for (let i3 = 0; i3 < topLevelChildren.length; i3++) {
    const topLevelNode = topLevelChildren[i3];
    $appendNodesToJSON(editor, selection2, topLevelNode, nodes);
  }
  return {
    namespace: editor._config.namespace,
    nodes
  };
}
function $generateNodesFromSerializedNodes(serializedNodes) {
  const nodes = [];
  for (let i3 = 0; i3 < serializedNodes.length; i3++) {
    const serializedNode = serializedNodes[i3];
    const node2 = $parseSerializedNode(serializedNode);
    if ($isTextNode(node2)) {
      $addNodeStyle(node2);
    }
    nodes.push(node2);
  }
  return nodes;
}
var EVENT_LATENCY = 50;
var clipboardEventTimeout = null;
async function copyToClipboard(editor, event, data2) {
  if (clipboardEventTimeout !== null) {
    return false;
  }
  if (event !== null) {
    return new Promise((resolve, reject) => {
      editor.update(() => {
        resolve($copyToClipboardEvent(editor, event, data2));
      });
    });
  }
  const rootElement = editor.getRootElement();
  const windowDocument = editor._window == null ? window.document : editor._window.document;
  const domSelection = getDOMSelection(editor._window);
  if (rootElement === null || domSelection === null) {
    return false;
  }
  const element2 = windowDocument.createElement("span");
  element2.style.cssText = "position: fixed; top: -1000px;";
  element2.append(windowDocument.createTextNode("#"));
  rootElement.append(element2);
  const range = new Range();
  range.setStart(element2, 0);
  range.setEnd(element2, 1);
  domSelection.removeAllRanges();
  domSelection.addRange(range);
  return new Promise((resolve, reject) => {
    const removeListener = editor.registerCommand(COPY_COMMAND, (secondEvent) => {
      if (objectKlassEquals(secondEvent, ClipboardEvent)) {
        removeListener();
        if (clipboardEventTimeout !== null) {
          window.clearTimeout(clipboardEventTimeout);
          clipboardEventTimeout = null;
        }
        resolve($copyToClipboardEvent(editor, secondEvent, data2));
      }
      return true;
    }, COMMAND_PRIORITY_CRITICAL);
    clipboardEventTimeout = window.setTimeout(() => {
      removeListener();
      clipboardEventTimeout = null;
      resolve(false);
    }, EVENT_LATENCY);
    windowDocument.execCommand("copy");
    element2.remove();
  });
}
function $copyToClipboardEvent(editor, event, data2) {
  if (data2 === void 0) {
    const domSelection = getDOMSelection(editor._window);
    if (!domSelection) {
      return false;
    }
    const anchorDOM = domSelection.anchorNode;
    const focusDOM = domSelection.focusNode;
    if (anchorDOM !== null && focusDOM !== null && !isSelectionWithinEditor(editor, anchorDOM, focusDOM)) {
      return false;
    }
    const selection2 = $getSelection();
    if (selection2 === null) {
      return false;
    }
    data2 = $getClipboardDataFromSelection(selection2);
  }
  event.preventDefault();
  const clipboardData = event.clipboardData;
  if (clipboardData === null) {
    return false;
  }
  setLexicalClipboardDataTransfer(clipboardData, data2);
  return true;
}
var clipboardDataFunctions = [["text/html", $getHtmlContent], ["application/x-lexical-editor", $getLexicalContent]];
function $getClipboardDataFromSelection(selection2 = $getSelection()) {
  const clipboardData = {
    "text/plain": selection2 ? selection2.getTextContent() : ""
  };
  if (selection2) {
    const editor = $getEditor();
    for (const [mimeType, $editorFn] of clipboardDataFunctions) {
      const v3 = $editorFn(editor, selection2);
      if (v3 !== null) {
        clipboardData[mimeType] = v3;
      }
    }
  }
  return clipboardData;
}
function setLexicalClipboardDataTransfer(clipboardData, data2) {
  for (const k3 in data2) {
    const v3 = data2[k3];
    if (v3 !== void 0) {
      clipboardData.setData(k3, v3);
    }
  }
}

// node_modules/@lexical/rich-text/LexicalRichText.dev.mjs
function caretFromPoint(x3, y2) {
  if (typeof document.caretRangeFromPoint !== "undefined") {
    const range = document.caretRangeFromPoint(x3, y2);
    if (range === null) {
      return null;
    }
    return {
      node: range.startContainer,
      offset: range.startOffset
    };
  } else if (document.caretPositionFromPoint !== "undefined") {
    const range = document.caretPositionFromPoint(x3, y2);
    if (range === null) {
      return null;
    }
    return {
      node: range.offsetNode,
      offset: range.offset
    };
  } else {
    return null;
  }
}
var CAN_USE_DOM3 = typeof window !== "undefined" && typeof window.document !== "undefined" && typeof window.document.createElement !== "undefined";
var documentMode3 = CAN_USE_DOM3 && "documentMode" in document ? document.documentMode : null;
var CAN_USE_BEFORE_INPUT2 = CAN_USE_DOM3 && "InputEvent" in window && !documentMode3 ? "getTargetRanges" in new window.InputEvent("input") : false;
var IS_SAFARI2 = CAN_USE_DOM3 && /Version\/[\d.]+.*Safari/.test(navigator.userAgent);
var IS_IOS2 = CAN_USE_DOM3 && /iPad|iPhone|iPod/.test(navigator.userAgent) && !window.MSStream;
var IS_CHROME2 = CAN_USE_DOM3 && /^(?=.*Chrome).*/i.test(navigator.userAgent);
var IS_APPLE_WEBKIT2 = CAN_USE_DOM3 && /AppleWebKit\/[\d.]+/.test(navigator.userAgent) && !IS_CHROME2;
var DRAG_DROP_PASTE = createCommand("DRAG_DROP_PASTE_FILE");
var QuoteNode = class _QuoteNode extends ElementNode {
  static getType() {
    return "quote";
  }
  static clone(node2) {
    return new _QuoteNode(node2.__key);
  }
  // View
  createDOM(config) {
    const element2 = document.createElement("blockquote");
    addClassNamesToElement(element2, config.theme.quote);
    return element2;
  }
  updateDOM(prevNode, dom) {
    return false;
  }
  static importDOM() {
    return {
      blockquote: (node2) => ({
        conversion: $convertBlockquoteElement,
        priority: 0
      })
    };
  }
  exportDOM(editor) {
    const {
      element: element2
    } = super.exportDOM(editor);
    if (isHTMLElement(element2)) {
      if (this.isEmpty()) {
        element2.append(document.createElement("br"));
      }
      const formatType = this.getFormatType();
      element2.style.textAlign = formatType;
      const direction = this.getDirection();
      if (direction) {
        element2.dir = direction;
      }
    }
    return {
      element: element2
    };
  }
  static importJSON(serializedNode) {
    return $createQuoteNode().updateFromJSON(serializedNode);
  }
  // Mutation
  insertNewAfter(_2, restoreSelection) {
    const newBlock = $createParagraphNode();
    const direction = this.getDirection();
    newBlock.setDirection(direction);
    this.insertAfter(newBlock, restoreSelection);
    return newBlock;
  }
  collapseAtStart() {
    const paragraph2 = $createParagraphNode();
    const children = this.getChildren();
    children.forEach((child) => paragraph2.append(child));
    this.replace(paragraph2);
    return true;
  }
  canMergeWhenEmpty() {
    return true;
  }
};
function $createQuoteNode() {
  return $applyNodeReplacement(new QuoteNode());
}
function $isQuoteNode(node2) {
  return node2 instanceof QuoteNode;
}
var HeadingNode = class _HeadingNode extends ElementNode {
  /** @internal */
  static getType() {
    return "heading";
  }
  static clone(node2) {
    return new _HeadingNode(node2.__tag, node2.__key);
  }
  constructor(tag, key2) {
    super(key2);
    this.__tag = tag;
  }
  getTag() {
    return this.__tag;
  }
  setTag(tag) {
    const self2 = this.getWritable();
    this.__tag = tag;
    return self2;
  }
  // View
  createDOM(config) {
    const tag = this.__tag;
    const element2 = document.createElement(tag);
    const theme = config.theme;
    const classNames14 = theme.heading;
    if (classNames14 !== void 0) {
      const className = classNames14[tag];
      addClassNamesToElement(element2, className);
    }
    return element2;
  }
  updateDOM(prevNode, dom, config) {
    return prevNode.__tag !== this.__tag;
  }
  static importDOM() {
    return {
      h1: (node2) => ({
        conversion: $convertHeadingElement,
        priority: 0
      }),
      h2: (node2) => ({
        conversion: $convertHeadingElement,
        priority: 0
      }),
      h3: (node2) => ({
        conversion: $convertHeadingElement,
        priority: 0
      }),
      h4: (node2) => ({
        conversion: $convertHeadingElement,
        priority: 0
      }),
      h5: (node2) => ({
        conversion: $convertHeadingElement,
        priority: 0
      }),
      h6: (node2) => ({
        conversion: $convertHeadingElement,
        priority: 0
      }),
      p: (node2) => {
        const paragraph2 = node2;
        const firstChild = paragraph2.firstChild;
        if (firstChild !== null && isGoogleDocsTitle(firstChild)) {
          return {
            conversion: () => ({
              node: null
            }),
            priority: 3
          };
        }
        return null;
      },
      span: (node2) => {
        if (isGoogleDocsTitle(node2)) {
          return {
            conversion: (domNode) => {
              return {
                node: $createHeadingNode("h1")
              };
            },
            priority: 3
          };
        }
        return null;
      }
    };
  }
  exportDOM(editor) {
    const {
      element: element2
    } = super.exportDOM(editor);
    if (isHTMLElement(element2)) {
      if (this.isEmpty()) {
        element2.append(document.createElement("br"));
      }
      const formatType = this.getFormatType();
      element2.style.textAlign = formatType;
      const direction = this.getDirection();
      if (direction) {
        element2.dir = direction;
      }
    }
    return {
      element: element2
    };
  }
  static importJSON(serializedNode) {
    return $createHeadingNode(serializedNode.tag).updateFromJSON(serializedNode);
  }
  updateFromJSON(serializedNode) {
    return super.updateFromJSON(serializedNode).setTag(serializedNode.tag);
  }
  exportJSON() {
    return {
      ...super.exportJSON(),
      tag: this.getTag()
    };
  }
  // Mutation
  insertNewAfter(selection2, restoreSelection = true) {
    const anchorOffet = selection2 ? selection2.anchor.offset : 0;
    const lastDesc = this.getLastDescendant();
    const isAtEnd = !lastDesc || selection2 && selection2.anchor.key === lastDesc.getKey() && anchorOffet === lastDesc.getTextContentSize();
    const newElement = isAtEnd || !selection2 ? $createParagraphNode() : $createHeadingNode(this.getTag());
    const direction = this.getDirection();
    newElement.setDirection(direction);
    this.insertAfter(newElement, restoreSelection);
    if (anchorOffet === 0 && !this.isEmpty() && selection2) {
      const paragraph2 = $createParagraphNode();
      paragraph2.select();
      this.replace(paragraph2, true);
    }
    return newElement;
  }
  collapseAtStart() {
    const newElement = !this.isEmpty() ? $createHeadingNode(this.getTag()) : $createParagraphNode();
    const children = this.getChildren();
    children.forEach((child) => newElement.append(child));
    this.replace(newElement);
    return true;
  }
  extractWithChild() {
    return true;
  }
};
function isGoogleDocsTitle(domNode) {
  if (domNode.nodeName.toLowerCase() === "span") {
    return domNode.style.fontSize === "26pt";
  }
  return false;
}
function $convertHeadingElement(element2) {
  const nodeName = element2.nodeName.toLowerCase();
  let node2 = null;
  if (nodeName === "h1" || nodeName === "h2" || nodeName === "h3" || nodeName === "h4" || nodeName === "h5" || nodeName === "h6") {
    node2 = $createHeadingNode(nodeName);
    if (element2.style !== null) {
      setNodeIndentFromDOM(element2, node2);
      node2.setFormat(element2.style.textAlign);
    }
  }
  return {
    node: node2
  };
}
function $convertBlockquoteElement(element2) {
  const node2 = $createQuoteNode();
  if (element2.style !== null) {
    node2.setFormat(element2.style.textAlign);
    setNodeIndentFromDOM(element2, node2);
  }
  return {
    node: node2
  };
}
function $createHeadingNode(headingTag = "h1") {
  return $applyNodeReplacement(new HeadingNode(headingTag));
}
function $isHeadingNode(node2) {
  return node2 instanceof HeadingNode;
}
function onPasteForRichText(event, editor) {
  event.preventDefault();
  editor.update(() => {
    const selection2 = $getSelection();
    const clipboardData = objectKlassEquals(event, InputEvent) || objectKlassEquals(event, KeyboardEvent) ? null : event.clipboardData;
    if (clipboardData != null && selection2 !== null) {
      $insertDataTransferForRichText(clipboardData, selection2, editor);
    }
  }, {
    tag: "paste"
  });
}
async function onCutForRichText(event, editor) {
  await copyToClipboard(editor, objectKlassEquals(event, ClipboardEvent) ? event : null);
  editor.update(() => {
    const selection2 = $getSelection();
    if ($isRangeSelection(selection2)) {
      selection2.removeText();
    } else if ($isNodeSelection(selection2)) {
      selection2.getNodes().forEach((node2) => node2.remove());
    }
  });
}
function eventFiles(event) {
  let dataTransfer = null;
  if (objectKlassEquals(event, DragEvent)) {
    dataTransfer = event.dataTransfer;
  } else if (objectKlassEquals(event, ClipboardEvent)) {
    dataTransfer = event.clipboardData;
  }
  if (dataTransfer === null) {
    return [false, [], false];
  }
  const types4 = dataTransfer.types;
  const hasFiles = types4.includes("Files");
  const hasContent = types4.includes("text/html") || types4.includes("text/plain");
  return [hasFiles, Array.from(dataTransfer.files), hasContent];
}
function $handleIndentAndOutdent(indentOrOutdent) {
  const selection2 = $getSelection();
  if (!$isRangeSelection(selection2)) {
    return false;
  }
  const alreadyHandled = /* @__PURE__ */ new Set();
  const nodes = selection2.getNodes();
  for (let i3 = 0; i3 < nodes.length; i3++) {
    const node2 = nodes[i3];
    const key2 = node2.getKey();
    if (alreadyHandled.has(key2)) {
      continue;
    }
    const parentBlock = $findMatchingParent(node2, (parentNode) => $isElementNode(parentNode) && !parentNode.isInline());
    if (parentBlock === null) {
      continue;
    }
    const parentKey = parentBlock.getKey();
    if (parentBlock.canIndent() && !alreadyHandled.has(parentKey)) {
      alreadyHandled.add(parentKey);
      indentOrOutdent(parentBlock);
    }
  }
  return alreadyHandled.size > 0;
}
function $isTargetWithinDecorator(target) {
  const node2 = $getNearestNodeFromDOMNode(target);
  return $isDecoratorNode(node2);
}
function $isSelectionAtEndOfRoot(selection2) {
  const focus2 = selection2.focus;
  return focus2.key === "root" && focus2.offset === $getRoot().getChildrenSize();
}
function $resetCapitalization(selection2) {
  for (const format of ["lowercase", "uppercase", "capitalize"]) {
    if (selection2.hasFormat(format)) {
      selection2.toggleFormat(format);
    }
  }
}
function registerRichText(editor) {
  const removeListener = mergeRegister(editor.registerCommand(CLICK_COMMAND, (payload) => {
    const selection2 = $getSelection();
    if ($isNodeSelection(selection2)) {
      selection2.clear();
      return true;
    }
    return false;
  }, 0), editor.registerCommand(DELETE_CHARACTER_COMMAND, (isBackward) => {
    const selection2 = $getSelection();
    if (!$isRangeSelection(selection2)) {
      return false;
    }
    selection2.deleteCharacter(isBackward);
    return true;
  }, COMMAND_PRIORITY_EDITOR), editor.registerCommand(DELETE_WORD_COMMAND, (isBackward) => {
    const selection2 = $getSelection();
    if (!$isRangeSelection(selection2)) {
      return false;
    }
    selection2.deleteWord(isBackward);
    return true;
  }, COMMAND_PRIORITY_EDITOR), editor.registerCommand(DELETE_LINE_COMMAND, (isBackward) => {
    const selection2 = $getSelection();
    if (!$isRangeSelection(selection2)) {
      return false;
    }
    selection2.deleteLine(isBackward);
    return true;
  }, COMMAND_PRIORITY_EDITOR), editor.registerCommand(CONTROLLED_TEXT_INSERTION_COMMAND, (eventOrText) => {
    const selection2 = $getSelection();
    if (typeof eventOrText === "string") {
      if (selection2 !== null) {
        selection2.insertText(eventOrText);
      }
    } else {
      if (selection2 === null) {
        return false;
      }
      const dataTransfer = eventOrText.dataTransfer;
      if (dataTransfer != null) {
        $insertDataTransferForRichText(dataTransfer, selection2, editor);
      } else if ($isRangeSelection(selection2)) {
        const data2 = eventOrText.data;
        if (data2) {
          selection2.insertText(data2);
        }
        return true;
      }
    }
    return true;
  }, COMMAND_PRIORITY_EDITOR), editor.registerCommand(REMOVE_TEXT_COMMAND, () => {
    const selection2 = $getSelection();
    if (!$isRangeSelection(selection2)) {
      return false;
    }
    selection2.removeText();
    return true;
  }, COMMAND_PRIORITY_EDITOR), editor.registerCommand(FORMAT_TEXT_COMMAND, (format) => {
    const selection2 = $getSelection();
    if (!$isRangeSelection(selection2)) {
      return false;
    }
    selection2.formatText(format);
    return true;
  }, COMMAND_PRIORITY_EDITOR), editor.registerCommand(FORMAT_ELEMENT_COMMAND, (format) => {
    const selection2 = $getSelection();
    if (!$isRangeSelection(selection2) && !$isNodeSelection(selection2)) {
      return false;
    }
    const nodes = selection2.getNodes();
    for (const node2 of nodes) {
      const element2 = $findMatchingParent(node2, (parentNode) => $isElementNode(parentNode) && !parentNode.isInline());
      if (element2 !== null) {
        element2.setFormat(format);
      }
    }
    return true;
  }, COMMAND_PRIORITY_EDITOR), editor.registerCommand(INSERT_LINE_BREAK_COMMAND, (selectStart) => {
    const selection2 = $getSelection();
    if (!$isRangeSelection(selection2)) {
      return false;
    }
    selection2.insertLineBreak(selectStart);
    return true;
  }, COMMAND_PRIORITY_EDITOR), editor.registerCommand(INSERT_PARAGRAPH_COMMAND, () => {
    const selection2 = $getSelection();
    if (!$isRangeSelection(selection2)) {
      return false;
    }
    selection2.insertParagraph();
    return true;
  }, COMMAND_PRIORITY_EDITOR), editor.registerCommand(INSERT_TAB_COMMAND, () => {
    $insertNodes([$createTabNode()]);
    return true;
  }, COMMAND_PRIORITY_EDITOR), editor.registerCommand(INDENT_CONTENT_COMMAND, () => {
    return $handleIndentAndOutdent((block) => {
      const indent2 = block.getIndent();
      block.setIndent(indent2 + 1);
    });
  }, COMMAND_PRIORITY_EDITOR), editor.registerCommand(OUTDENT_CONTENT_COMMAND, () => {
    return $handleIndentAndOutdent((block) => {
      const indent2 = block.getIndent();
      if (indent2 > 0) {
        block.setIndent(indent2 - 1);
      }
    });
  }, COMMAND_PRIORITY_EDITOR), editor.registerCommand(KEY_ARROW_UP_COMMAND, (event) => {
    const selection2 = $getSelection();
    if ($isNodeSelection(selection2) && !$isTargetWithinDecorator(event.target)) {
      const nodes = selection2.getNodes();
      if (nodes.length > 0) {
        nodes[0].selectPrevious();
        return true;
      }
    } else if ($isRangeSelection(selection2)) {
      const possibleNode = $getAdjacentNode(selection2.focus, true);
      if (!event.shiftKey && $isDecoratorNode(possibleNode) && !possibleNode.isIsolated() && !possibleNode.isInline()) {
        possibleNode.selectPrevious();
        event.preventDefault();
        return true;
      }
    }
    return false;
  }, COMMAND_PRIORITY_EDITOR), editor.registerCommand(KEY_ARROW_DOWN_COMMAND, (event) => {
    const selection2 = $getSelection();
    if ($isNodeSelection(selection2)) {
      const nodes = selection2.getNodes();
      if (nodes.length > 0) {
        nodes[0].selectNext(0, 0);
        return true;
      }
    } else if ($isRangeSelection(selection2)) {
      if ($isSelectionAtEndOfRoot(selection2)) {
        event.preventDefault();
        return true;
      }
      const possibleNode = $getAdjacentNode(selection2.focus, false);
      if (!event.shiftKey && $isDecoratorNode(possibleNode) && !possibleNode.isIsolated() && !possibleNode.isInline()) {
        possibleNode.selectNext();
        event.preventDefault();
        return true;
      }
    }
    return false;
  }, COMMAND_PRIORITY_EDITOR), editor.registerCommand(KEY_ARROW_LEFT_COMMAND, (event) => {
    const selection2 = $getSelection();
    if ($isNodeSelection(selection2)) {
      const nodes = selection2.getNodes();
      if (nodes.length > 0) {
        event.preventDefault();
        nodes[0].selectPrevious();
        return true;
      }
    }
    if (!$isRangeSelection(selection2)) {
      return false;
    }
    if ($shouldOverrideDefaultCharacterSelection(selection2, true)) {
      const isHoldingShift = event.shiftKey;
      event.preventDefault();
      $moveCharacter(selection2, isHoldingShift, true);
      return true;
    }
    return false;
  }, COMMAND_PRIORITY_EDITOR), editor.registerCommand(KEY_ARROW_RIGHT_COMMAND, (event) => {
    const selection2 = $getSelection();
    if ($isNodeSelection(selection2) && !$isTargetWithinDecorator(event.target)) {
      const nodes = selection2.getNodes();
      if (nodes.length > 0) {
        event.preventDefault();
        nodes[0].selectNext(0, 0);
        return true;
      }
    }
    if (!$isRangeSelection(selection2)) {
      return false;
    }
    const isHoldingShift = event.shiftKey;
    if ($shouldOverrideDefaultCharacterSelection(selection2, false)) {
      event.preventDefault();
      $moveCharacter(selection2, isHoldingShift, false);
      return true;
    }
    return false;
  }, COMMAND_PRIORITY_EDITOR), editor.registerCommand(KEY_BACKSPACE_COMMAND, (event) => {
    if ($isTargetWithinDecorator(event.target)) {
      return false;
    }
    const selection2 = $getSelection();
    if (!$isRangeSelection(selection2)) {
      return false;
    }
    const {
      anchor
    } = selection2;
    const anchorNode = anchor.getNode();
    if (selection2.isCollapsed() && anchor.offset === 0 && !$isRootNode(anchorNode)) {
      const element2 = $getNearestBlockElementAncestorOrThrow(anchorNode);
      if (element2.getIndent() > 0) {
        event.preventDefault();
        return editor.dispatchCommand(OUTDENT_CONTENT_COMMAND, void 0);
      }
    }
    if (IS_IOS2 && navigator.language === "ko-KR") {
      return false;
    }
    event.preventDefault();
    return editor.dispatchCommand(DELETE_CHARACTER_COMMAND, true);
  }, COMMAND_PRIORITY_EDITOR), editor.registerCommand(KEY_DELETE_COMMAND, (event) => {
    if ($isTargetWithinDecorator(event.target)) {
      return false;
    }
    const selection2 = $getSelection();
    if (!$isRangeSelection(selection2)) {
      return false;
    }
    event.preventDefault();
    return editor.dispatchCommand(DELETE_CHARACTER_COMMAND, false);
  }, COMMAND_PRIORITY_EDITOR), editor.registerCommand(KEY_ENTER_COMMAND, (event) => {
    const selection2 = $getSelection();
    if (!$isRangeSelection(selection2)) {
      return false;
    }
    $resetCapitalization(selection2);
    if (event !== null) {
      if ((IS_IOS2 || IS_SAFARI2 || IS_APPLE_WEBKIT2) && CAN_USE_BEFORE_INPUT2) {
        return false;
      }
      event.preventDefault();
      if (event.shiftKey) {
        return editor.dispatchCommand(INSERT_LINE_BREAK_COMMAND, false);
      }
    }
    return editor.dispatchCommand(INSERT_PARAGRAPH_COMMAND, void 0);
  }, COMMAND_PRIORITY_EDITOR), editor.registerCommand(KEY_ESCAPE_COMMAND, () => {
    const selection2 = $getSelection();
    if (!$isRangeSelection(selection2)) {
      return false;
    }
    editor.blur();
    return true;
  }, COMMAND_PRIORITY_EDITOR), editor.registerCommand(DROP_COMMAND, (event) => {
    const [, files] = eventFiles(event);
    if (files.length > 0) {
      const x3 = event.clientX;
      const y2 = event.clientY;
      const eventRange = caretFromPoint(x3, y2);
      if (eventRange !== null) {
        const {
          offset: domOffset,
          node: domNode
        } = eventRange;
        const node2 = $getNearestNodeFromDOMNode(domNode);
        if (node2 !== null) {
          const selection3 = $createRangeSelection();
          if ($isTextNode(node2)) {
            selection3.anchor.set(node2.getKey(), domOffset, "text");
            selection3.focus.set(node2.getKey(), domOffset, "text");
          } else {
            const parentKey = node2.getParentOrThrow().getKey();
            const offset5 = node2.getIndexWithinParent() + 1;
            selection3.anchor.set(parentKey, offset5, "element");
            selection3.focus.set(parentKey, offset5, "element");
          }
          const normalizedSelection = $normalizeSelection(selection3);
          $setSelection(normalizedSelection);
        }
        editor.dispatchCommand(DRAG_DROP_PASTE, files);
      }
      event.preventDefault();
      return true;
    }
    const selection2 = $getSelection();
    if ($isRangeSelection(selection2)) {
      return true;
    }
    return false;
  }, COMMAND_PRIORITY_EDITOR), editor.registerCommand(DRAGSTART_COMMAND, (event) => {
    const [isFileTransfer] = eventFiles(event);
    const selection2 = $getSelection();
    if (isFileTransfer && !$isRangeSelection(selection2)) {
      return false;
    }
    return true;
  }, COMMAND_PRIORITY_EDITOR), editor.registerCommand(DRAGOVER_COMMAND, (event) => {
    const [isFileTransfer] = eventFiles(event);
    const selection2 = $getSelection();
    if (isFileTransfer && !$isRangeSelection(selection2)) {
      return false;
    }
    const x3 = event.clientX;
    const y2 = event.clientY;
    const eventRange = caretFromPoint(x3, y2);
    if (eventRange !== null) {
      const node2 = $getNearestNodeFromDOMNode(eventRange.node);
      if ($isDecoratorNode(node2)) {
        event.preventDefault();
      }
    }
    return true;
  }, COMMAND_PRIORITY_EDITOR), editor.registerCommand(SELECT_ALL_COMMAND, () => {
    $selectAll();
    return true;
  }, COMMAND_PRIORITY_EDITOR), editor.registerCommand(COPY_COMMAND, (event) => {
    copyToClipboard(editor, objectKlassEquals(event, ClipboardEvent) ? event : null);
    return true;
  }, COMMAND_PRIORITY_EDITOR), editor.registerCommand(CUT_COMMAND, (event) => {
    onCutForRichText(event, editor);
    return true;
  }, COMMAND_PRIORITY_EDITOR), editor.registerCommand(PASTE_COMMAND, (event) => {
    const [, files, hasTextContent] = eventFiles(event);
    if (files.length > 0 && !hasTextContent) {
      editor.dispatchCommand(DRAG_DROP_PASTE, files);
      return true;
    }
    if (isDOMNode(event.target) && isSelectionCapturedInDecoratorInput(event.target)) {
      return false;
    }
    const selection2 = $getSelection();
    if (selection2 !== null) {
      onPasteForRichText(event, editor);
      return true;
    }
    return false;
  }, COMMAND_PRIORITY_EDITOR), editor.registerCommand(KEY_SPACE_COMMAND, (_2) => {
    const selection2 = $getSelection();
    if ($isRangeSelection(selection2)) {
      $resetCapitalization(selection2);
    }
    return false;
  }, COMMAND_PRIORITY_EDITOR), editor.registerCommand(KEY_TAB_COMMAND, (_2) => {
    const selection2 = $getSelection();
    if ($isRangeSelection(selection2)) {
      $resetCapitalization(selection2);
    }
    return false;
  }, COMMAND_PRIORITY_EDITOR));
  return removeListener;
}

// node_modules/devlop/lib/development.js
var AssertionError = class extends Error {
  /**
   * Create an assertion error.
   *
   * @param {string} message
   *   Message explaining error.
   * @param {unknown} actual
   *   Value.
   * @param {unknown} expected
   *   Baseline.
   * @param {string} operator
   *   Name of equality operation.
   * @param {boolean} generated
   *   Whether `message` is a custom message or not
   * @returns
   *   Instance.
   */
  // eslint-disable-next-line max-params
  constructor(message, actual, expected, operator, generated) {
    super(message);
    __publicField(
      this,
      "name",
      /** @type {const} */
      "Assertion"
    );
    __publicField(
      this,
      "code",
      /** @type {const} */
      "ERR_ASSERTION"
    );
    if (Error.captureStackTrace) {
      Error.captureStackTrace(this, this.constructor);
    }
    this.actual = actual;
    this.expected = expected;
    this.generated = generated;
    this.operator = operator;
  }
};
function ok(value2, message) {
  assert(
    Boolean(value2),
    false,
    true,
    "ok",
    "Expected value to be truthy",
    message
  );
}
function assert(bool2, actual, expected, operator, defaultMessage, userMessage) {
  if (!bool2) {
    throw userMessage instanceof Error ? userMessage : new AssertionError(
      userMessage || defaultMessage,
      actual,
      expected,
      operator,
      !userMessage
    );
  }
}

// node_modules/micromark-util-symbol/lib/codes.js
var codes = (
  /** @type {const} */
  {
    carriageReturn: -5,
    lineFeed: -4,
    carriageReturnLineFeed: -3,
    horizontalTab: -2,
    virtualSpace: -1,
    eof: null,
    nul: 0,
    soh: 1,
    stx: 2,
    etx: 3,
    eot: 4,
    enq: 5,
    ack: 6,
    bel: 7,
    bs: 8,
    ht: 9,
    // `\t`
    lf: 10,
    // `\n`
    vt: 11,
    // `\v`
    ff: 12,
    // `\f`
    cr: 13,
    // `\r`
    so: 14,
    si: 15,
    dle: 16,
    dc1: 17,
    dc2: 18,
    dc3: 19,
    dc4: 20,
    nak: 21,
    syn: 22,
    etb: 23,
    can: 24,
    em: 25,
    sub: 26,
    esc: 27,
    fs: 28,
    gs: 29,
    rs: 30,
    us: 31,
    space: 32,
    exclamationMark: 33,
    // `!`
    quotationMark: 34,
    // `"`
    numberSign: 35,
    // `#`
    dollarSign: 36,
    // `$`
    percentSign: 37,
    // `%`
    ampersand: 38,
    // `&`
    apostrophe: 39,
    // `'`
    leftParenthesis: 40,
    // `(`
    rightParenthesis: 41,
    // `)`
    asterisk: 42,
    // `*`
    plusSign: 43,
    // `+`
    comma: 44,
    // `,`
    dash: 45,
    // `-`
    dot: 46,
    // `.`
    slash: 47,
    // `/`
    digit0: 48,
    // `0`
    digit1: 49,
    // `1`
    digit2: 50,
    // `2`
    digit3: 51,
    // `3`
    digit4: 52,
    // `4`
    digit5: 53,
    // `5`
    digit6: 54,
    // `6`
    digit7: 55,
    // `7`
    digit8: 56,
    // `8`
    digit9: 57,
    // `9`
    colon: 58,
    // `:`
    semicolon: 59,
    // `;`
    lessThan: 60,
    // `<`
    equalsTo: 61,
    // `=`
    greaterThan: 62,
    // `>`
    questionMark: 63,
    // `?`
    atSign: 64,
    // `@`
    uppercaseA: 65,
    // `A`
    uppercaseB: 66,
    // `B`
    uppercaseC: 67,
    // `C`
    uppercaseD: 68,
    // `D`
    uppercaseE: 69,
    // `E`
    uppercaseF: 70,
    // `F`
    uppercaseG: 71,
    // `G`
    uppercaseH: 72,
    // `H`
    uppercaseI: 73,
    // `I`
    uppercaseJ: 74,
    // `J`
    uppercaseK: 75,
    // `K`
    uppercaseL: 76,
    // `L`
    uppercaseM: 77,
    // `M`
    uppercaseN: 78,
    // `N`
    uppercaseO: 79,
    // `O`
    uppercaseP: 80,
    // `P`
    uppercaseQ: 81,
    // `Q`
    uppercaseR: 82,
    // `R`
    uppercaseS: 83,
    // `S`
    uppercaseT: 84,
    // `T`
    uppercaseU: 85,
    // `U`
    uppercaseV: 86,
    // `V`
    uppercaseW: 87,
    // `W`
    uppercaseX: 88,
    // `X`
    uppercaseY: 89,
    // `Y`
    uppercaseZ: 90,
    // `Z`
    leftSquareBracket: 91,
    // `[`
    backslash: 92,
    // `\`
    rightSquareBracket: 93,
    // `]`
    caret: 94,
    // `^`
    underscore: 95,
    // `_`
    graveAccent: 96,
    // `` ` ``
    lowercaseA: 97,
    // `a`
    lowercaseB: 98,
    // `b`
    lowercaseC: 99,
    // `c`
    lowercaseD: 100,
    // `d`
    lowercaseE: 101,
    // `e`
    lowercaseF: 102,
    // `f`
    lowercaseG: 103,
    // `g`
    lowercaseH: 104,
    // `h`
    lowercaseI: 105,
    // `i`
    lowercaseJ: 106,
    // `j`
    lowercaseK: 107,
    // `k`
    lowercaseL: 108,
    // `l`
    lowercaseM: 109,
    // `m`
    lowercaseN: 110,
    // `n`
    lowercaseO: 111,
    // `o`
    lowercaseP: 112,
    // `p`
    lowercaseQ: 113,
    // `q`
    lowercaseR: 114,
    // `r`
    lowercaseS: 115,
    // `s`
    lowercaseT: 116,
    // `t`
    lowercaseU: 117,
    // `u`
    lowercaseV: 118,
    // `v`
    lowercaseW: 119,
    // `w`
    lowercaseX: 120,
    // `x`
    lowercaseY: 121,
    // `y`
    lowercaseZ: 122,
    // `z`
    leftCurlyBrace: 123,
    // `{`
    verticalBar: 124,
    // `|`
    rightCurlyBrace: 125,
    // `}`
    tilde: 126,
    // `~`
    del: 127,
    // Unicode Specials block.
    byteOrderMarker: 65279,
    // Unicode Specials block.
    replacementCharacter: 65533
    // `�`
  }
);

// node_modules/micromark-util-symbol/lib/constants.js
var constants = (
  /** @type {const} */
  {
    attentionSideAfter: 2,
    // Symbol to mark an attention sequence as after content: `a*`
    attentionSideBefore: 1,
    // Symbol to mark an attention sequence as before content: `*a`
    atxHeadingOpeningFenceSizeMax: 6,
    // 6 number signs is fine, 7 isn’t.
    autolinkDomainSizeMax: 63,
    // 63 characters is fine, 64 is too many.
    autolinkSchemeSizeMax: 32,
    // 32 characters is fine, 33 is too many.
    cdataOpeningString: "CDATA[",
    // And preceded by `<![`.
    characterGroupPunctuation: 2,
    // Symbol used to indicate a character is punctuation
    characterGroupWhitespace: 1,
    // Symbol used to indicate a character is whitespace
    characterReferenceDecimalSizeMax: 7,
    // `&#9999999;`.
    characterReferenceHexadecimalSizeMax: 6,
    // `&#xff9999;`.
    characterReferenceNamedSizeMax: 31,
    // `&CounterClockwiseContourIntegral;`.
    codeFencedSequenceSizeMin: 3,
    // At least 3 ticks or tildes are needed.
    contentTypeContent: "content",
    contentTypeDocument: "document",
    contentTypeFlow: "flow",
    contentTypeString: "string",
    contentTypeText: "text",
    hardBreakPrefixSizeMin: 2,
    // At least 2 trailing spaces are needed.
    htmlBasic: 6,
    // Symbol for `<div`
    htmlCdata: 5,
    // Symbol for `<![CDATA[]]>`
    htmlComment: 2,
    // Symbol for `<!---->`
    htmlComplete: 7,
    // Symbol for `<x>`
    htmlDeclaration: 4,
    // Symbol for `<!doctype>`
    htmlInstruction: 3,
    // Symbol for `<?php?>`
    htmlRawSizeMax: 8,
    // Length of `textarea`.
    htmlRaw: 1,
    // Symbol for `<script>`
    linkResourceDestinationBalanceMax: 32,
    // See: <https://spec.commonmark.org/0.30/#link-destination>, <https://github.com/remarkjs/react-markdown/issues/658#issuecomment-984345577>
    linkReferenceSizeMax: 999,
    // See: <https://spec.commonmark.org/0.30/#link-label>
    listItemValueSizeMax: 10,
    // See: <https://spec.commonmark.org/0.30/#ordered-list-marker>
    numericBaseDecimal: 10,
    numericBaseHexadecimal: 16,
    tabSize: 4,
    // Tabs have a hard-coded size of 4, per CommonMark.
    thematicBreakMarkerCountMin: 3,
    // At least 3 asterisks, dashes, or underscores are needed.
    v8MaxSafeChunkSize: 1e4
    // V8 (and potentially others) have problems injecting giant arrays into other arrays, hence we operate in chunks.
  }
);

// node_modules/micromark-util-symbol/lib/types.js
var types = (
  /** @type {const} */
  {
    // Generic type for data, such as in a title, a destination, etc.
    data: "data",
    // Generic type for syntactic whitespace (tabs, virtual spaces, spaces).
    // Such as, between a fenced code fence and an info string.
    whitespace: "whitespace",
    // Generic type for line endings (line feed, carriage return, carriage return +
    // line feed).
    lineEnding: "lineEnding",
    // A line ending, but ending a blank line.
    lineEndingBlank: "lineEndingBlank",
    // Generic type for whitespace (tabs, virtual spaces, spaces) at the start of a
    // line.
    linePrefix: "linePrefix",
    // Generic type for whitespace (tabs, virtual spaces, spaces) at the end of a
    // line.
    lineSuffix: "lineSuffix",
    // Whole ATX heading:
    //
    // ```markdown
    // #
    // ## Alpha
    // ### Bravo ###
    // ```
    //
    // Includes `atxHeadingSequence`, `whitespace`, `atxHeadingText`.
    atxHeading: "atxHeading",
    // Sequence of number signs in an ATX heading (`###`).
    atxHeadingSequence: "atxHeadingSequence",
    // Content in an ATX heading (`alpha`).
    // Includes text.
    atxHeadingText: "atxHeadingText",
    // Whole autolink (`<https://example.com>` or `<admin@example.com>`)
    // Includes `autolinkMarker` and `autolinkProtocol` or `autolinkEmail`.
    autolink: "autolink",
    // Email autolink w/o markers (`admin@example.com`)
    autolinkEmail: "autolinkEmail",
    // Marker around an `autolinkProtocol` or `autolinkEmail` (`<` or `>`).
    autolinkMarker: "autolinkMarker",
    // Protocol autolink w/o markers (`https://example.com`)
    autolinkProtocol: "autolinkProtocol",
    // A whole character escape (`\-`).
    // Includes `escapeMarker` and `characterEscapeValue`.
    characterEscape: "characterEscape",
    // The escaped character (`-`).
    characterEscapeValue: "characterEscapeValue",
    // A whole character reference (`&amp;`, `&#8800;`, or `&#x1D306;`).
    // Includes `characterReferenceMarker`, an optional
    // `characterReferenceMarkerNumeric`, in which case an optional
    // `characterReferenceMarkerHexadecimal`, and a `characterReferenceValue`.
    characterReference: "characterReference",
    // The start or end marker (`&` or `;`).
    characterReferenceMarker: "characterReferenceMarker",
    // Mark reference as numeric (`#`).
    characterReferenceMarkerNumeric: "characterReferenceMarkerNumeric",
    // Mark reference as numeric (`x` or `X`).
    characterReferenceMarkerHexadecimal: "characterReferenceMarkerHexadecimal",
    // Value of character reference w/o markers (`amp`, `8800`, or `1D306`).
    characterReferenceValue: "characterReferenceValue",
    // Whole fenced code:
    //
    // ````markdown
    // ```js
    // alert(1)
    // ```
    // ````
    codeFenced: "codeFenced",
    // A fenced code fence, including whitespace, sequence, info, and meta
    // (` ```js `).
    codeFencedFence: "codeFencedFence",
    // Sequence of grave accent or tilde characters (` ``` `) in a fence.
    codeFencedFenceSequence: "codeFencedFenceSequence",
    // Info word (`js`) in a fence.
    // Includes string.
    codeFencedFenceInfo: "codeFencedFenceInfo",
    // Meta words (`highlight="1"`) in a fence.
    // Includes string.
    codeFencedFenceMeta: "codeFencedFenceMeta",
    // A line of code.
    codeFlowValue: "codeFlowValue",
    // Whole indented code:
    //
    // ```markdown
    //     alert(1)
    // ```
    //
    // Includes `lineEnding`, `linePrefix`, and `codeFlowValue`.
    codeIndented: "codeIndented",
    // A text code (``` `alpha` ```).
    // Includes `codeTextSequence`, `codeTextData`, `lineEnding`, and can include
    // `codeTextPadding`.
    codeText: "codeText",
    codeTextData: "codeTextData",
    // A space or line ending right after or before a tick.
    codeTextPadding: "codeTextPadding",
    // A text code fence (` `` `).
    codeTextSequence: "codeTextSequence",
    // Whole content:
    //
    // ```markdown
    // [a]: b
    // c
    // =
    // d
    // ```
    //
    // Includes `paragraph` and `definition`.
    content: "content",
    // Whole definition:
    //
    // ```markdown
    // [micromark]: https://github.com/micromark/micromark
    // ```
    //
    // Includes `definitionLabel`, `definitionMarker`, `whitespace`,
    // `definitionDestination`, and optionally `lineEnding` and `definitionTitle`.
    definition: "definition",
    // Destination of a definition (`https://github.com/micromark/micromark` or
    // `<https://github.com/micromark/micromark>`).
    // Includes `definitionDestinationLiteral` or `definitionDestinationRaw`.
    definitionDestination: "definitionDestination",
    // Enclosed destination of a definition
    // (`<https://github.com/micromark/micromark>`).
    // Includes `definitionDestinationLiteralMarker` and optionally
    // `definitionDestinationString`.
    definitionDestinationLiteral: "definitionDestinationLiteral",
    // Markers of an enclosed definition destination (`<` or `>`).
    definitionDestinationLiteralMarker: "definitionDestinationLiteralMarker",
    // Unenclosed destination of a definition
    // (`https://github.com/micromark/micromark`).
    // Includes `definitionDestinationString`.
    definitionDestinationRaw: "definitionDestinationRaw",
    // Text in an destination (`https://github.com/micromark/micromark`).
    // Includes string.
    definitionDestinationString: "definitionDestinationString",
    // Label of a definition (`[micromark]`).
    // Includes `definitionLabelMarker` and `definitionLabelString`.
    definitionLabel: "definitionLabel",
    // Markers of a definition label (`[` or `]`).
    definitionLabelMarker: "definitionLabelMarker",
    // Value of a definition label (`micromark`).
    // Includes string.
    definitionLabelString: "definitionLabelString",
    // Marker between a label and a destination (`:`).
    definitionMarker: "definitionMarker",
    // Title of a definition (`"x"`, `'y'`, or `(z)`).
    // Includes `definitionTitleMarker` and optionally `definitionTitleString`.
    definitionTitle: "definitionTitle",
    // Marker around a title of a definition (`"`, `'`, `(`, or `)`).
    definitionTitleMarker: "definitionTitleMarker",
    // Data without markers in a title (`z`).
    // Includes string.
    definitionTitleString: "definitionTitleString",
    // Emphasis (`*alpha*`).
    // Includes `emphasisSequence` and `emphasisText`.
    emphasis: "emphasis",
    // Sequence of emphasis markers (`*` or `_`).
    emphasisSequence: "emphasisSequence",
    // Emphasis text (`alpha`).
    // Includes text.
    emphasisText: "emphasisText",
    // The character escape marker (`\`).
    escapeMarker: "escapeMarker",
    // A hard break created with a backslash (`\\n`).
    // Note: does not include the line ending.
    hardBreakEscape: "hardBreakEscape",
    // A hard break created with trailing spaces (`  \n`).
    // Does not include the line ending.
    hardBreakTrailing: "hardBreakTrailing",
    // Flow HTML:
    //
    // ```markdown
    // <div
    // ```
    //
    // Inlcudes `lineEnding`, `htmlFlowData`.
    htmlFlow: "htmlFlow",
    htmlFlowData: "htmlFlowData",
    // HTML in text (the tag in `a <i> b`).
    // Includes `lineEnding`, `htmlTextData`.
    htmlText: "htmlText",
    htmlTextData: "htmlTextData",
    // Whole image (`![alpha](bravo)`, `![alpha][bravo]`, `![alpha][]`, or
    // `![alpha]`).
    // Includes `label` and an optional `resource` or `reference`.
    image: "image",
    // Whole link label (`[*alpha*]`).
    // Includes `labelLink` or `labelImage`, `labelText`, and `labelEnd`.
    label: "label",
    // Text in an label (`*alpha*`).
    // Includes text.
    labelText: "labelText",
    // Start a link label (`[`).
    // Includes a `labelMarker`.
    labelLink: "labelLink",
    // Start an image label (`![`).
    // Includes `labelImageMarker` and `labelMarker`.
    labelImage: "labelImage",
    // Marker of a label (`[` or `]`).
    labelMarker: "labelMarker",
    // Marker to start an image (`!`).
    labelImageMarker: "labelImageMarker",
    // End a label (`]`).
    // Includes `labelMarker`.
    labelEnd: "labelEnd",
    // Whole link (`[alpha](bravo)`, `[alpha][bravo]`, `[alpha][]`, or `[alpha]`).
    // Includes `label` and an optional `resource` or `reference`.
    link: "link",
    // Whole paragraph:
    //
    // ```markdown
    // alpha
    // bravo.
    // ```
    //
    // Includes text.
    paragraph: "paragraph",
    // A reference (`[alpha]` or `[]`).
    // Includes `referenceMarker` and an optional `referenceString`.
    reference: "reference",
    // A reference marker (`[` or `]`).
    referenceMarker: "referenceMarker",
    // Reference text (`alpha`).
    // Includes string.
    referenceString: "referenceString",
    // A resource (`(https://example.com "alpha")`).
    // Includes `resourceMarker`, an optional `resourceDestination` with an optional
    // `whitespace` and `resourceTitle`.
    resource: "resource",
    // A resource destination (`https://example.com`).
    // Includes `resourceDestinationLiteral` or `resourceDestinationRaw`.
    resourceDestination: "resourceDestination",
    // A literal resource destination (`<https://example.com>`).
    // Includes `resourceDestinationLiteralMarker` and optionally
    // `resourceDestinationString`.
    resourceDestinationLiteral: "resourceDestinationLiteral",
    // A resource destination marker (`<` or `>`).
    resourceDestinationLiteralMarker: "resourceDestinationLiteralMarker",
    // A raw resource destination (`https://example.com`).
    // Includes `resourceDestinationString`.
    resourceDestinationRaw: "resourceDestinationRaw",
    // Resource destination text (`https://example.com`).
    // Includes string.
    resourceDestinationString: "resourceDestinationString",
    // A resource marker (`(` or `)`).
    resourceMarker: "resourceMarker",
    // A resource title (`"alpha"`, `'alpha'`, or `(alpha)`).
    // Includes `resourceTitleMarker` and optionally `resourceTitleString`.
    resourceTitle: "resourceTitle",
    // A resource title marker (`"`, `'`, `(`, or `)`).
    resourceTitleMarker: "resourceTitleMarker",
    // Resource destination title (`alpha`).
    // Includes string.
    resourceTitleString: "resourceTitleString",
    // Whole setext heading:
    //
    // ```markdown
    // alpha
    // bravo
    // =====
    // ```
    //
    // Includes `setextHeadingText`, `lineEnding`, `linePrefix`, and
    // `setextHeadingLine`.
    setextHeading: "setextHeading",
    // Content in a setext heading (`alpha\nbravo`).
    // Includes text.
    setextHeadingText: "setextHeadingText",
    // Underline in a setext heading, including whitespace suffix (`==`).
    // Includes `setextHeadingLineSequence`.
    setextHeadingLine: "setextHeadingLine",
    // Sequence of equals or dash characters in underline in a setext heading (`-`).
    setextHeadingLineSequence: "setextHeadingLineSequence",
    // Strong (`**alpha**`).
    // Includes `strongSequence` and `strongText`.
    strong: "strong",
    // Sequence of strong markers (`**` or `__`).
    strongSequence: "strongSequence",
    // Strong text (`alpha`).
    // Includes text.
    strongText: "strongText",
    // Whole thematic break:
    //
    // ```markdown
    // * * *
    // ```
    //
    // Includes `thematicBreakSequence` and `whitespace`.
    thematicBreak: "thematicBreak",
    // A sequence of one or more thematic break markers (`***`).
    thematicBreakSequence: "thematicBreakSequence",
    // Whole block quote:
    //
    // ```markdown
    // > a
    // >
    // > b
    // ```
    //
    // Includes `blockQuotePrefix` and flow.
    blockQuote: "blockQuote",
    // The `>` or `> ` of a block quote.
    blockQuotePrefix: "blockQuotePrefix",
    // The `>` of a block quote prefix.
    blockQuoteMarker: "blockQuoteMarker",
    // The optional ` ` of a block quote prefix.
    blockQuotePrefixWhitespace: "blockQuotePrefixWhitespace",
    // Whole ordered list:
    //
    // ```markdown
    // 1. a
    //    b
    // ```
    //
    // Includes `listItemPrefix`, flow, and optionally  `listItemIndent` on further
    // lines.
    listOrdered: "listOrdered",
    // Whole unordered list:
    //
    // ```markdown
    // - a
    //   b
    // ```
    //
    // Includes `listItemPrefix`, flow, and optionally  `listItemIndent` on further
    // lines.
    listUnordered: "listUnordered",
    // The indent of further list item lines.
    listItemIndent: "listItemIndent",
    // A marker, as in, `*`, `+`, `-`, `.`, or `)`.
    listItemMarker: "listItemMarker",
    // The thing that starts a list item, such as `1. `.
    // Includes `listItemValue` if ordered, `listItemMarker`, and
    // `listItemPrefixWhitespace` (unless followed by a line ending).
    listItemPrefix: "listItemPrefix",
    // The whitespace after a marker.
    listItemPrefixWhitespace: "listItemPrefixWhitespace",
    // The numerical value of an ordered item.
    listItemValue: "listItemValue",
    // Internal types used for subtokenizers, compiled away
    chunkDocument: "chunkDocument",
    chunkContent: "chunkContent",
    chunkFlow: "chunkFlow",
    chunkText: "chunkText",
    chunkString: "chunkString"
  }
);

// node_modules/micromark-util-symbol/lib/values.js
var values = (
  /** @type {const} */
  {
    ht: "	",
    lf: "\n",
    cr: "\r",
    space: " ",
    exclamationMark: "!",
    quotationMark: '"',
    numberSign: "#",
    dollarSign: "$",
    percentSign: "%",
    ampersand: "&",
    apostrophe: "'",
    leftParenthesis: "(",
    rightParenthesis: ")",
    asterisk: "*",
    plusSign: "+",
    comma: ",",
    dash: "-",
    dot: ".",
    slash: "/",
    digit0: "0",
    digit1: "1",
    digit2: "2",
    digit3: "3",
    digit4: "4",
    digit5: "5",
    digit6: "6",
    digit7: "7",
    digit8: "8",
    digit9: "9",
    colon: ":",
    semicolon: ";",
    lessThan: "<",
    equalsTo: "=",
    greaterThan: ">",
    questionMark: "?",
    atSign: "@",
    uppercaseA: "A",
    uppercaseB: "B",
    uppercaseC: "C",
    uppercaseD: "D",
    uppercaseE: "E",
    uppercaseF: "F",
    uppercaseG: "G",
    uppercaseH: "H",
    uppercaseI: "I",
    uppercaseJ: "J",
    uppercaseK: "K",
    uppercaseL: "L",
    uppercaseM: "M",
    uppercaseN: "N",
    uppercaseO: "O",
    uppercaseP: "P",
    uppercaseQ: "Q",
    uppercaseR: "R",
    uppercaseS: "S",
    uppercaseT: "T",
    uppercaseU: "U",
    uppercaseV: "V",
    uppercaseW: "W",
    uppercaseX: "X",
    uppercaseY: "Y",
    uppercaseZ: "Z",
    leftSquareBracket: "[",
    backslash: "\\",
    rightSquareBracket: "]",
    caret: "^",
    underscore: "_",
    graveAccent: "`",
    lowercaseA: "a",
    lowercaseB: "b",
    lowercaseC: "c",
    lowercaseD: "d",
    lowercaseE: "e",
    lowercaseF: "f",
    lowercaseG: "g",
    lowercaseH: "h",
    lowercaseI: "i",
    lowercaseJ: "j",
    lowercaseK: "k",
    lowercaseL: "l",
    lowercaseM: "m",
    lowercaseN: "n",
    lowercaseO: "o",
    lowercaseP: "p",
    lowercaseQ: "q",
    lowercaseR: "r",
    lowercaseS: "s",
    lowercaseT: "t",
    lowercaseU: "u",
    lowercaseV: "v",
    lowercaseW: "w",
    lowercaseX: "x",
    lowercaseY: "y",
    lowercaseZ: "z",
    leftCurlyBrace: "{",
    verticalBar: "|",
    rightCurlyBrace: "}",
    tilde: "~",
    replacementCharacter: "�"
  }
);

// node_modules/micromark-util-chunked/dev/index.js
function splice(list4, start2, remove, items) {
  const end = list4.length;
  let chunkStart = 0;
  let parameters;
  if (start2 < 0) {
    start2 = -start2 > end ? 0 : end + start2;
  } else {
    start2 = start2 > end ? end : start2;
  }
  remove = remove > 0 ? remove : 0;
  if (items.length < constants.v8MaxSafeChunkSize) {
    parameters = Array.from(items);
    parameters.unshift(start2, remove);
    list4.splice(...parameters);
  } else {
    if (remove) list4.splice(start2, remove);
    while (chunkStart < items.length) {
      parameters = items.slice(
        chunkStart,
        chunkStart + constants.v8MaxSafeChunkSize
      );
      parameters.unshift(start2, 0);
      list4.splice(...parameters);
      chunkStart += constants.v8MaxSafeChunkSize;
      start2 += constants.v8MaxSafeChunkSize;
    }
  }
}
function push(list4, items) {
  if (list4.length > 0) {
    splice(list4, list4.length, 0, items);
    return list4;
  }
  return items;
}

// node_modules/micromark-util-character/dev/index.js
var asciiAlpha = regexCheck(/[A-Za-z]/);
var asciiAlphanumeric = regexCheck(/[\dA-Za-z]/);
var asciiAtext = regexCheck(/[#-'*+\--9=?A-Z^-~]/);
function asciiControl(code3) {
  return (
    // Special whitespace codes (which have negative values), C0 and Control
    // character DEL
    code3 !== null && (code3 < codes.space || code3 === codes.del)
  );
}
var asciiDigit = regexCheck(/\d/);
var asciiHexDigit = regexCheck(/[\dA-Fa-f]/);
var asciiPunctuation = regexCheck(/[!-/:-@[-`{-~]/);
function markdownLineEnding(code3) {
  return code3 !== null && code3 < codes.horizontalTab;
}
function markdownLineEndingOrSpace(code3) {
  return code3 !== null && (code3 < codes.nul || code3 === codes.space);
}
function markdownSpace(code3) {
  return code3 === codes.horizontalTab || code3 === codes.virtualSpace || code3 === codes.space;
}
var unicodePunctuation = regexCheck(new RegExp("\\p{P}|\\p{S}", "u"));
var unicodeWhitespace = regexCheck(/\s/);
function regexCheck(regex) {
  return check;
  function check(code3) {
    return code3 !== null && code3 > -1 && regex.test(String.fromCharCode(code3));
  }
}

// node_modules/micromark-util-classify-character/dev/index.js
function classifyCharacter(code3) {
  if (code3 === codes.eof || markdownLineEndingOrSpace(code3) || unicodeWhitespace(code3)) {
    return constants.characterGroupWhitespace;
  }
  if (unicodePunctuation(code3)) {
    return constants.characterGroupPunctuation;
  }
}

// node_modules/micromark-util-resolve-all/index.js
function resolveAll(constructs2, events, context) {
  const called = [];
  let index3 = -1;
  while (++index3 < constructs2.length) {
    const resolve = constructs2[index3].resolveAll;
    if (resolve && !called.includes(resolve)) {
      events = resolve(events, context);
      called.push(resolve);
    }
  }
  return events;
}

// node_modules/micromark-extension-gfm-strikethrough/dev/lib/syntax.js
function gfmStrikethrough(options) {
  const options_ = options || {};
  let single = options_.singleTilde;
  const tokenizer2 = {
    name: "strikethrough",
    tokenize: tokenizeStrikethrough,
    resolveAll: resolveAllStrikethrough
  };
  if (single === null || single === void 0) {
    single = true;
  }
  return {
    text: { [codes.tilde]: tokenizer2 },
    insideSpan: { null: [tokenizer2] },
    attentionMarkers: { null: [codes.tilde] }
  };
  function resolveAllStrikethrough(events, context) {
    let index3 = -1;
    while (++index3 < events.length) {
      if (events[index3][0] === "enter" && events[index3][1].type === "strikethroughSequenceTemporary" && events[index3][1]._close) {
        let open = index3;
        while (open--) {
          if (events[open][0] === "exit" && events[open][1].type === "strikethroughSequenceTemporary" && events[open][1]._open && // If the sizes are the same:
          events[index3][1].end.offset - events[index3][1].start.offset === events[open][1].end.offset - events[open][1].start.offset) {
            events[index3][1].type = "strikethroughSequence";
            events[open][1].type = "strikethroughSequence";
            const strikethrough2 = {
              type: "strikethrough",
              start: Object.assign({}, events[open][1].start),
              end: Object.assign({}, events[index3][1].end)
            };
            const text4 = {
              type: "strikethroughText",
              start: Object.assign({}, events[open][1].end),
              end: Object.assign({}, events[index3][1].start)
            };
            const nextEvents = [
              ["enter", strikethrough2, context],
              ["enter", events[open][1], context],
              ["exit", events[open][1], context],
              ["enter", text4, context]
            ];
            const insideSpan2 = context.parser.constructs.insideSpan.null;
            if (insideSpan2) {
              splice(
                nextEvents,
                nextEvents.length,
                0,
                resolveAll(insideSpan2, events.slice(open + 1, index3), context)
              );
            }
            splice(nextEvents, nextEvents.length, 0, [
              ["exit", text4, context],
              ["enter", events[index3][1], context],
              ["exit", events[index3][1], context],
              ["exit", strikethrough2, context]
            ]);
            splice(events, open - 1, index3 - open + 3, nextEvents);
            index3 = open + nextEvents.length - 2;
            break;
          }
        }
      }
    }
    index3 = -1;
    while (++index3 < events.length) {
      if (events[index3][1].type === "strikethroughSequenceTemporary") {
        events[index3][1].type = types.data;
      }
    }
    return events;
  }
  function tokenizeStrikethrough(effects, ok3, nok) {
    const previous3 = this.previous;
    const events = this.events;
    let size4 = 0;
    return start2;
    function start2(code3) {
      ok(code3 === codes.tilde, "expected `~`");
      if (previous3 === codes.tilde && events[events.length - 1][1].type !== types.characterEscape) {
        return nok(code3);
      }
      effects.enter("strikethroughSequenceTemporary");
      return more(code3);
    }
    function more(code3) {
      const before = classifyCharacter(previous3);
      if (code3 === codes.tilde) {
        if (size4 > 1) return nok(code3);
        effects.consume(code3);
        size4++;
        return more;
      }
      if (size4 < 2 && !single) return nok(code3);
      const token = effects.exit("strikethroughSequenceTemporary");
      const after = classifyCharacter(code3);
      token._open = !after || after === constants.attentionSideAfter && Boolean(before);
      token._close = !before || before === constants.attentionSideAfter && Boolean(after);
      return ok3(code3);
    }
  }
}

// node_modules/mdast-util-gfm-strikethrough/lib/index.js
var constructsWithoutStrikethrough = [
  "autolink",
  "destinationLiteral",
  "destinationRaw",
  "reference",
  "titleQuote",
  "titleApostrophe"
];
handleDelete.peek = peekDelete;
function gfmStrikethroughFromMarkdown() {
  return {
    canContainEols: ["delete"],
    enter: { strikethrough: enterStrikethrough },
    exit: { strikethrough: exitStrikethrough }
  };
}
function gfmStrikethroughToMarkdown() {
  return {
    unsafe: [
      {
        character: "~",
        inConstruct: "phrasing",
        notInConstruct: constructsWithoutStrikethrough
      }
    ],
    handlers: { delete: handleDelete }
  };
}
function enterStrikethrough(token) {
  this.enter({ type: "delete", children: [] }, token);
}
function exitStrikethrough(token) {
  this.exit(token);
}
function handleDelete(node2, _2, state, info) {
  const tracker = state.createTracker(info);
  const exit4 = state.enter("strikethrough");
  let value2 = tracker.move("~~");
  value2 += state.containerPhrasing(node2, {
    ...tracker.current(),
    before: value2,
    after: "~"
  });
  value2 += tracker.move("~~");
  exit4();
  return value2;
}
function peekDelete() {
  return "~";
}

// node_modules/ccount/index.js
function ccount(value2, character) {
  const source = String(value2);
  if (typeof character !== "string") {
    throw new TypeError("Expected character");
  }
  let count3 = 0;
  let index3 = source.indexOf(character);
  while (index3 !== -1) {
    count3++;
    index3 = source.indexOf(character, index3 + character.length);
  }
  return count3;
}

// node_modules/character-entities-legacy/index.js
var characterEntitiesLegacy = [
  "AElig",
  "AMP",
  "Aacute",
  "Acirc",
  "Agrave",
  "Aring",
  "Atilde",
  "Auml",
  "COPY",
  "Ccedil",
  "ETH",
  "Eacute",
  "Ecirc",
  "Egrave",
  "Euml",
  "GT",
  "Iacute",
  "Icirc",
  "Igrave",
  "Iuml",
  "LT",
  "Ntilde",
  "Oacute",
  "Ocirc",
  "Ograve",
  "Oslash",
  "Otilde",
  "Ouml",
  "QUOT",
  "REG",
  "THORN",
  "Uacute",
  "Ucirc",
  "Ugrave",
  "Uuml",
  "Yacute",
  "aacute",
  "acirc",
  "acute",
  "aelig",
  "agrave",
  "amp",
  "aring",
  "atilde",
  "auml",
  "brvbar",
  "ccedil",
  "cedil",
  "cent",
  "copy",
  "curren",
  "deg",
  "divide",
  "eacute",
  "ecirc",
  "egrave",
  "eth",
  "euml",
  "frac12",
  "frac14",
  "frac34",
  "gt",
  "iacute",
  "icirc",
  "iexcl",
  "igrave",
  "iquest",
  "iuml",
  "laquo",
  "lt",
  "macr",
  "micro",
  "middot",
  "nbsp",
  "not",
  "ntilde",
  "oacute",
  "ocirc",
  "ograve",
  "ordf",
  "ordm",
  "oslash",
  "otilde",
  "ouml",
  "para",
  "plusmn",
  "pound",
  "quot",
  "raquo",
  "reg",
  "sect",
  "shy",
  "sup1",
  "sup2",
  "sup3",
  "szlig",
  "thorn",
  "times",
  "uacute",
  "ucirc",
  "ugrave",
  "uml",
  "uuml",
  "yacute",
  "yen",
  "yuml"
];

// node_modules/character-reference-invalid/index.js
var characterReferenceInvalid = {
  0: "�",
  128: "€",
  130: "‚",
  131: "ƒ",
  132: "„",
  133: "…",
  134: "†",
  135: "‡",
  136: "ˆ",
  137: "‰",
  138: "Š",
  139: "‹",
  140: "Œ",
  142: "Ž",
  145: "‘",
  146: "’",
  147: "“",
  148: "”",
  149: "•",
  150: "–",
  151: "—",
  152: "˜",
  153: "™",
  154: "š",
  155: "›",
  156: "œ",
  158: "ž",
  159: "Ÿ"
};

// node_modules/is-decimal/index.js
function isDecimal(character) {
  const code3 = typeof character === "string" ? character.charCodeAt(0) : character;
  return code3 >= 48 && code3 <= 57;
}

// node_modules/is-hexadecimal/index.js
function isHexadecimal(character) {
  const code3 = typeof character === "string" ? character.charCodeAt(0) : character;
  return code3 >= 97 && code3 <= 102 || code3 >= 65 && code3 <= 70 || code3 >= 48 && code3 <= 57;
}

// node_modules/is-alphabetical/index.js
function isAlphabetical(character) {
  const code3 = typeof character === "string" ? character.charCodeAt(0) : character;
  return code3 >= 97 && code3 <= 122 || code3 >= 65 && code3 <= 90;
}

// node_modules/is-alphanumerical/index.js
function isAlphanumerical(character) {
  return isAlphabetical(character) || isDecimal(character);
}

// node_modules/decode-named-character-reference/index.dom.js
var element = document.createElement("i");
function decodeNamedCharacterReference(value2) {
  const characterReference2 = "&" + value2 + ";";
  element.innerHTML = characterReference2;
  const char = element.textContent;
  if (char.charCodeAt(char.length - 1) === 59 && value2 !== "semi") {
    return false;
  }
  return char === characterReference2 ? false : char;
}

// node_modules/parse-entities/lib/index.js
var messages = [
  "",
  /* 1: Non terminated (named) */
  "Named character references must be terminated by a semicolon",
  /* 2: Non terminated (numeric) */
  "Numeric character references must be terminated by a semicolon",
  /* 3: Empty (named) */
  "Named character references cannot be empty",
  /* 4: Empty (numeric) */
  "Numeric character references cannot be empty",
  /* 5: Unknown (named) */
  "Named character references must be known",
  /* 6: Disallowed (numeric) */
  "Numeric character references cannot be disallowed",
  /* 7: Prohibited (numeric) */
  "Numeric character references cannot be outside the permissible Unicode range"
];
function parseEntities(value2, options) {
  const settings = options || {};
  const additional = typeof settings.additional === "string" ? settings.additional.charCodeAt(0) : settings.additional;
  const result = [];
  let index3 = 0;
  let lines = -1;
  let queue = "";
  let point3;
  let indent2;
  if (settings.position) {
    if ("start" in settings.position || "indent" in settings.position) {
      indent2 = settings.position.indent;
      point3 = settings.position.start;
    } else {
      point3 = settings.position;
    }
  }
  let line = (point3 ? point3.line : 0) || 1;
  let column = (point3 ? point3.column : 0) || 1;
  let previous3 = now();
  let character;
  index3--;
  while (++index3 <= value2.length) {
    if (character === 10) {
      column = (indent2 ? indent2[lines] : 0) || 1;
    }
    character = value2.charCodeAt(index3);
    if (character === 38) {
      const following = value2.charCodeAt(index3 + 1);
      if (following === 9 || following === 10 || following === 12 || following === 32 || following === 38 || following === 60 || Number.isNaN(following) || additional && following === additional) {
        queue += String.fromCharCode(character);
        column++;
        continue;
      }
      const start2 = index3 + 1;
      let begin = start2;
      let end = start2;
      let type2;
      if (following === 35) {
        end = ++begin;
        const following2 = value2.charCodeAt(end);
        if (following2 === 88 || following2 === 120) {
          type2 = "hexadecimal";
          end = ++begin;
        } else {
          type2 = "decimal";
        }
      } else {
        type2 = "named";
      }
      let characterReferenceCharacters = "";
      let characterReference2 = "";
      let characters2 = "";
      const test = type2 === "named" ? isAlphanumerical : type2 === "decimal" ? isDecimal : isHexadecimal;
      end--;
      while (++end <= value2.length) {
        const following2 = value2.charCodeAt(end);
        if (!test(following2)) {
          break;
        }
        characters2 += String.fromCharCode(following2);
        if (type2 === "named" && characterEntitiesLegacy.includes(characters2)) {
          characterReferenceCharacters = characters2;
          characterReference2 = decodeNamedCharacterReference(characters2);
        }
      }
      let terminated = value2.charCodeAt(end) === 59;
      if (terminated) {
        end++;
        const namedReference = type2 === "named" ? decodeNamedCharacterReference(characters2) : false;
        if (namedReference) {
          characterReferenceCharacters = characters2;
          characterReference2 = namedReference;
        }
      }
      let diff2 = 1 + end - start2;
      let reference = "";
      if (!terminated && settings.nonTerminated === false) {
      } else if (!characters2) {
        if (type2 !== "named") {
          warning(4, diff2);
        }
      } else if (type2 === "named") {
        if (terminated && !characterReference2) {
          warning(5, 1);
        } else {
          if (characterReferenceCharacters !== characters2) {
            end = begin + characterReferenceCharacters.length;
            diff2 = 1 + end - begin;
            terminated = false;
          }
          if (!terminated) {
            const reason = characterReferenceCharacters ? 1 : 3;
            if (settings.attribute) {
              const following2 = value2.charCodeAt(end);
              if (following2 === 61) {
                warning(reason, diff2);
                characterReference2 = "";
              } else if (isAlphanumerical(following2)) {
                characterReference2 = "";
              } else {
                warning(reason, diff2);
              }
            } else {
              warning(reason, diff2);
            }
          }
        }
        reference = characterReference2;
      } else {
        if (!terminated) {
          warning(2, diff2);
        }
        let referenceCode = Number.parseInt(
          characters2,
          type2 === "hexadecimal" ? 16 : 10
        );
        if (prohibited(referenceCode)) {
          warning(7, diff2);
          reference = String.fromCharCode(
            65533
            /* `�` */
          );
        } else if (referenceCode in characterReferenceInvalid) {
          warning(6, diff2);
          reference = characterReferenceInvalid[referenceCode];
        } else {
          let output = "";
          if (disallowed(referenceCode)) {
            warning(6, diff2);
          }
          if (referenceCode > 65535) {
            referenceCode -= 65536;
            output += String.fromCharCode(
              referenceCode >>> (10 & 1023) | 55296
            );
            referenceCode = 56320 | referenceCode & 1023;
          }
          reference = output + String.fromCharCode(referenceCode);
        }
      }
      if (reference) {
        flush();
        previous3 = now();
        index3 = end - 1;
        column += end - start2 + 1;
        result.push(reference);
        const next = now();
        next.offset++;
        if (settings.reference) {
          settings.reference.call(
            settings.referenceContext || void 0,
            reference,
            { start: previous3, end: next },
            value2.slice(start2 - 1, end)
          );
        }
        previous3 = next;
      } else {
        characters2 = value2.slice(start2 - 1, end);
        queue += characters2;
        column += characters2.length;
        index3 = end - 1;
      }
    } else {
      if (character === 10) {
        line++;
        lines++;
        column = 0;
      }
      if (Number.isNaN(character)) {
        flush();
      } else {
        queue += String.fromCharCode(character);
        column++;
      }
    }
  }
  return result.join("");
  function now() {
    return {
      line,
      column,
      offset: index3 + ((point3 ? point3.offset : 0) || 0)
    };
  }
  function warning(code3, offset5) {
    let position2;
    if (settings.warning) {
      position2 = now();
      position2.column += offset5;
      position2.offset += offset5;
      settings.warning.call(
        settings.warningContext || void 0,
        messages[code3],
        position2,
        code3
      );
    }
  }
  function flush() {
    if (queue) {
      result.push(queue);
      if (settings.text) {
        settings.text.call(settings.textContext || void 0, queue, {
          start: previous3,
          end: now()
        });
      }
      queue = "";
    }
  }
}
function prohibited(code3) {
  return code3 >= 55296 && code3 <= 57343 || code3 > 1114111;
}
function disallowed(code3) {
  return code3 >= 1 && code3 <= 8 || code3 === 11 || code3 >= 13 && code3 <= 31 || code3 >= 127 && code3 <= 159 || code3 >= 64976 && code3 <= 65007 || (code3 & 65535) === 65535 || (code3 & 65535) === 65534;
}

// node_modules/stringify-entities/lib/core.js
var defaultSubsetRegex = /["&'<>`]/g;
var surrogatePairsRegex = /[\uD800-\uDBFF][\uDC00-\uDFFF]/g;
var controlCharactersRegex = (
  // eslint-disable-next-line no-control-regex, unicorn/no-hex-escape
  /[\x01-\t\v\f\x0E-\x1F\x7F\x81\x8D\x8F\x90\x9D\xA0-\uFFFF]/g
);
var regexEscapeRegex = /[|\\{}()[\]^$+*?.]/g;
var subsetToRegexCache = /* @__PURE__ */ new WeakMap();
function core(value2, options) {
  value2 = value2.replace(
    options.subset ? charactersToExpressionCached(options.subset) : defaultSubsetRegex,
    basic
  );
  if (options.subset || options.escapeOnly) {
    return value2;
  }
  return value2.replace(surrogatePairsRegex, surrogate).replace(controlCharactersRegex, basic);
  function surrogate(pair, index3, all2) {
    return options.format(
      (pair.charCodeAt(0) - 55296) * 1024 + pair.charCodeAt(1) - 56320 + 65536,
      all2.charCodeAt(index3 + 2),
      options
    );
  }
  function basic(character, index3, all2) {
    return options.format(
      character.charCodeAt(0),
      all2.charCodeAt(index3 + 1),
      options
    );
  }
}
function charactersToExpressionCached(subset) {
  let cached = subsetToRegexCache.get(subset);
  if (!cached) {
    cached = charactersToExpression(subset);
    subsetToRegexCache.set(subset, cached);
  }
  return cached;
}
function charactersToExpression(subset) {
  const groups = [];
  let index3 = -1;
  while (++index3 < subset.length) {
    groups.push(subset[index3].replace(regexEscapeRegex, "\\$&"));
  }
  return new RegExp("(?:" + groups.join("|") + ")", "g");
}

// node_modules/character-entities-html4/index.js
var characterEntitiesHtml4 = {
  nbsp: " ",
  iexcl: "¡",
  cent: "¢",
  pound: "£",
  curren: "¤",
  yen: "¥",
  brvbar: "¦",
  sect: "§",
  uml: "¨",
  copy: "©",
  ordf: "ª",
  laquo: "«",
  not: "¬",
  shy: "­",
  reg: "®",
  macr: "¯",
  deg: "°",
  plusmn: "±",
  sup2: "²",
  sup3: "³",
  acute: "´",
  micro: "µ",
  para: "¶",
  middot: "·",
  cedil: "¸",
  sup1: "¹",
  ordm: "º",
  raquo: "»",
  frac14: "¼",
  frac12: "½",
  frac34: "¾",
  iquest: "¿",
  Agrave: "À",
  Aacute: "Á",
  Acirc: "Â",
  Atilde: "Ã",
  Auml: "Ä",
  Aring: "Å",
  AElig: "Æ",
  Ccedil: "Ç",
  Egrave: "È",
  Eacute: "É",
  Ecirc: "Ê",
  Euml: "Ë",
  Igrave: "Ì",
  Iacute: "Í",
  Icirc: "Î",
  Iuml: "Ï",
  ETH: "Ð",
  Ntilde: "Ñ",
  Ograve: "Ò",
  Oacute: "Ó",
  Ocirc: "Ô",
  Otilde: "Õ",
  Ouml: "Ö",
  times: "×",
  Oslash: "Ø",
  Ugrave: "Ù",
  Uacute: "Ú",
  Ucirc: "Û",
  Uuml: "Ü",
  Yacute: "Ý",
  THORN: "Þ",
  szlig: "ß",
  agrave: "à",
  aacute: "á",
  acirc: "â",
  atilde: "ã",
  auml: "ä",
  aring: "å",
  aelig: "æ",
  ccedil: "ç",
  egrave: "è",
  eacute: "é",
  ecirc: "ê",
  euml: "ë",
  igrave: "ì",
  iacute: "í",
  icirc: "î",
  iuml: "ï",
  eth: "ð",
  ntilde: "ñ",
  ograve: "ò",
  oacute: "ó",
  ocirc: "ô",
  otilde: "õ",
  ouml: "ö",
  divide: "÷",
  oslash: "ø",
  ugrave: "ù",
  uacute: "ú",
  ucirc: "û",
  uuml: "ü",
  yacute: "ý",
  thorn: "þ",
  yuml: "ÿ",
  fnof: "ƒ",
  Alpha: "Α",
  Beta: "Β",
  Gamma: "Γ",
  Delta: "Δ",
  Epsilon: "Ε",
  Zeta: "Ζ",
  Eta: "Η",
  Theta: "Θ",
  Iota: "Ι",
  Kappa: "Κ",
  Lambda: "Λ",
  Mu: "Μ",
  Nu: "Ν",
  Xi: "Ξ",
  Omicron: "Ο",
  Pi: "Π",
  Rho: "Ρ",
  Sigma: "Σ",
  Tau: "Τ",
  Upsilon: "Υ",
  Phi: "Φ",
  Chi: "Χ",
  Psi: "Ψ",
  Omega: "Ω",
  alpha: "α",
  beta: "β",
  gamma: "γ",
  delta: "δ",
  epsilon: "ε",
  zeta: "ζ",
  eta: "η",
  theta: "θ",
  iota: "ι",
  kappa: "κ",
  lambda: "λ",
  mu: "μ",
  nu: "ν",
  xi: "ξ",
  omicron: "ο",
  pi: "π",
  rho: "ρ",
  sigmaf: "ς",
  sigma: "σ",
  tau: "τ",
  upsilon: "υ",
  phi: "φ",
  chi: "χ",
  psi: "ψ",
  omega: "ω",
  thetasym: "ϑ",
  upsih: "ϒ",
  piv: "ϖ",
  bull: "•",
  hellip: "…",
  prime: "′",
  Prime: "″",
  oline: "‾",
  frasl: "⁄",
  weierp: "℘",
  image: "ℑ",
  real: "ℜ",
  trade: "™",
  alefsym: "ℵ",
  larr: "←",
  uarr: "↑",
  rarr: "→",
  darr: "↓",
  harr: "↔",
  crarr: "↵",
  lArr: "⇐",
  uArr: "⇑",
  rArr: "⇒",
  dArr: "⇓",
  hArr: "⇔",
  forall: "∀",
  part: "∂",
  exist: "∃",
  empty: "∅",
  nabla: "∇",
  isin: "∈",
  notin: "∉",
  ni: "∋",
  prod: "∏",
  sum: "∑",
  minus: "−",
  lowast: "∗",
  radic: "√",
  prop: "∝",
  infin: "∞",
  ang: "∠",
  and: "∧",
  or: "∨",
  cap: "∩",
  cup: "∪",
  int: "∫",
  there4: "∴",
  sim: "∼",
  cong: "≅",
  asymp: "≈",
  ne: "≠",
  equiv: "≡",
  le: "≤",
  ge: "≥",
  sub: "⊂",
  sup: "⊃",
  nsub: "⊄",
  sube: "⊆",
  supe: "⊇",
  oplus: "⊕",
  otimes: "⊗",
  perp: "⊥",
  sdot: "⋅",
  lceil: "⌈",
  rceil: "⌉",
  lfloor: "⌊",
  rfloor: "⌋",
  lang: "〈",
  rang: "〉",
  loz: "◊",
  spades: "♠",
  clubs: "♣",
  hearts: "♥",
  diams: "♦",
  quot: '"',
  amp: "&",
  lt: "<",
  gt: ">",
  OElig: "Œ",
  oelig: "œ",
  Scaron: "Š",
  scaron: "š",
  Yuml: "Ÿ",
  circ: "ˆ",
  tilde: "˜",
  ensp: " ",
  emsp: " ",
  thinsp: " ",
  zwnj: "‌",
  zwj: "‍",
  lrm: "‎",
  rlm: "‏",
  ndash: "–",
  mdash: "—",
  lsquo: "‘",
  rsquo: "’",
  sbquo: "‚",
  ldquo: "“",
  rdquo: "”",
  bdquo: "„",
  dagger: "†",
  Dagger: "‡",
  permil: "‰",
  lsaquo: "‹",
  rsaquo: "›",
  euro: "€"
};

// node_modules/stringify-entities/lib/util/to-named.js
var own = {}.hasOwnProperty;
var characters = {};
var key;
for (key in characterEntitiesHtml4) {
  if (own.call(characterEntitiesHtml4, key)) {
    characters[characterEntitiesHtml4[key]] = key;
  }
}

// node_modules/stringify-entities/lib/util/format-basic.js
function formatBasic(code3) {
  return "&#x" + code3.toString(16).toUpperCase() + ";";
}

// node_modules/stringify-entities/lib/index.js
function stringifyEntitiesLight(value2, options) {
  return core(value2, Object.assign({ format: formatBasic }, options));
}

// node_modules/unist-util-stringify-position/lib/index.js
function stringifyPosition(value2) {
  if (!value2 || typeof value2 !== "object") {
    return "";
  }
  if ("position" in value2 || "type" in value2) {
    return position(value2.position);
  }
  if ("start" in value2 || "end" in value2) {
    return position(value2);
  }
  if ("line" in value2 || "column" in value2) {
    return point(value2);
  }
  return "";
}
function point(point3) {
  return index(point3 && point3.line) + ":" + index(point3 && point3.column);
}
function position(pos) {
  return point(pos && pos.start) + "-" + point(pos && pos.end);
}
function index(value2) {
  return value2 && typeof value2 === "number" ? value2 : 1;
}

// node_modules/vfile-message/lib/index.js
var VFileMessage = class extends Error {
  /**
   * Create a message for `reason`.
   *
   * > 🪦 **Note**: also has obsolete signatures.
   *
   * @overload
   * @param {string} reason
   * @param {Options | null | undefined} [options]
   * @returns
   *
   * @overload
   * @param {string} reason
   * @param {Node | NodeLike | null | undefined} parent
   * @param {string | null | undefined} [origin]
   * @returns
   *
   * @overload
   * @param {string} reason
   * @param {Point | Position | null | undefined} place
   * @param {string | null | undefined} [origin]
   * @returns
   *
   * @overload
   * @param {string} reason
   * @param {string | null | undefined} [origin]
   * @returns
   *
   * @overload
   * @param {Error | VFileMessage} cause
   * @param {Node | NodeLike | null | undefined} parent
   * @param {string | null | undefined} [origin]
   * @returns
   *
   * @overload
   * @param {Error | VFileMessage} cause
   * @param {Point | Position | null | undefined} place
   * @param {string | null | undefined} [origin]
   * @returns
   *
   * @overload
   * @param {Error | VFileMessage} cause
   * @param {string | null | undefined} [origin]
   * @returns
   *
   * @param {Error | VFileMessage | string} causeOrReason
   *   Reason for message, should use markdown.
   * @param {Node | NodeLike | Options | Point | Position | string | null | undefined} [optionsOrParentOrPlace]
   *   Configuration (optional).
   * @param {string | null | undefined} [origin]
   *   Place in code where the message originates (example:
   *   `'my-package:my-rule'` or `'my-rule'`).
   * @returns
   *   Instance of `VFileMessage`.
   */
  // eslint-disable-next-line complexity
  constructor(causeOrReason, optionsOrParentOrPlace, origin) {
    super();
    if (typeof optionsOrParentOrPlace === "string") {
      origin = optionsOrParentOrPlace;
      optionsOrParentOrPlace = void 0;
    }
    let reason = "";
    let options = {};
    let legacyCause = false;
    if (optionsOrParentOrPlace) {
      if ("line" in optionsOrParentOrPlace && "column" in optionsOrParentOrPlace) {
        options = { place: optionsOrParentOrPlace };
      } else if ("start" in optionsOrParentOrPlace && "end" in optionsOrParentOrPlace) {
        options = { place: optionsOrParentOrPlace };
      } else if ("type" in optionsOrParentOrPlace) {
        options = {
          ancestors: [optionsOrParentOrPlace],
          place: optionsOrParentOrPlace.position
        };
      } else {
        options = { ...optionsOrParentOrPlace };
      }
    }
    if (typeof causeOrReason === "string") {
      reason = causeOrReason;
    } else if (!options.cause && causeOrReason) {
      legacyCause = true;
      reason = causeOrReason.message;
      options.cause = causeOrReason;
    }
    if (!options.ruleId && !options.source && typeof origin === "string") {
      const index3 = origin.indexOf(":");
      if (index3 === -1) {
        options.ruleId = origin;
      } else {
        options.source = origin.slice(0, index3);
        options.ruleId = origin.slice(index3 + 1);
      }
    }
    if (!options.place && options.ancestors && options.ancestors) {
      const parent = options.ancestors[options.ancestors.length - 1];
      if (parent) {
        options.place = parent.position;
      }
    }
    const start2 = options.place && "start" in options.place ? options.place.start : options.place;
    this.ancestors = options.ancestors || void 0;
    this.cause = options.cause || void 0;
    this.column = start2 ? start2.column : void 0;
    this.fatal = void 0;
    this.file;
    this.message = reason;
    this.line = start2 ? start2.line : void 0;
    this.name = stringifyPosition(options.place) || "1:1";
    this.place = options.place || void 0;
    this.reason = this.message;
    this.ruleId = options.ruleId || void 0;
    this.source = options.source || void 0;
    this.stack = legacyCause && options.cause && typeof options.cause.stack === "string" ? options.cause.stack : "";
    this.actual;
    this.expected;
    this.note;
    this.url;
  }
};
VFileMessage.prototype.file = "";
VFileMessage.prototype.name = "";
VFileMessage.prototype.reason = "";
VFileMessage.prototype.message = "";
VFileMessage.prototype.stack = "";
VFileMessage.prototype.column = void 0;
VFileMessage.prototype.line = void 0;
VFileMessage.prototype.ancestors = void 0;
VFileMessage.prototype.cause = void 0;
VFileMessage.prototype.fatal = void 0;
VFileMessage.prototype.place = void 0;
VFileMessage.prototype.ruleId = void 0;
VFileMessage.prototype.source = void 0;

// node_modules/mdast-util-mdx-jsx/lib/index.js
var indent = "  ";
function mdxJsxFromMarkdown() {
  return {
    canContainEols: ["mdxJsxTextElement"],
    enter: {
      mdxJsxFlowTag: enterMdxJsxTag,
      mdxJsxFlowTagClosingMarker: enterMdxJsxTagClosingMarker,
      mdxJsxFlowTagAttribute: enterMdxJsxTagAttribute,
      mdxJsxFlowTagExpressionAttribute: enterMdxJsxTagExpressionAttribute,
      mdxJsxFlowTagAttributeValueLiteral: buffer,
      mdxJsxFlowTagAttributeValueExpression: buffer,
      mdxJsxFlowTagSelfClosingMarker: enterMdxJsxTagSelfClosingMarker,
      mdxJsxTextTag: enterMdxJsxTag,
      mdxJsxTextTagClosingMarker: enterMdxJsxTagClosingMarker,
      mdxJsxTextTagAttribute: enterMdxJsxTagAttribute,
      mdxJsxTextTagExpressionAttribute: enterMdxJsxTagExpressionAttribute,
      mdxJsxTextTagAttributeValueLiteral: buffer,
      mdxJsxTextTagAttributeValueExpression: buffer,
      mdxJsxTextTagSelfClosingMarker: enterMdxJsxTagSelfClosingMarker
    },
    exit: {
      mdxJsxFlowTagClosingMarker: exitMdxJsxTagClosingMarker,
      mdxJsxFlowTagNamePrimary: exitMdxJsxTagNamePrimary,
      mdxJsxFlowTagNameMember: exitMdxJsxTagNameMember,
      mdxJsxFlowTagNameLocal: exitMdxJsxTagNameLocal,
      mdxJsxFlowTagExpressionAttribute: exitMdxJsxTagExpressionAttribute,
      mdxJsxFlowTagExpressionAttributeValue: data2,
      mdxJsxFlowTagAttributeNamePrimary: exitMdxJsxTagAttributeNamePrimary,
      mdxJsxFlowTagAttributeNameLocal: exitMdxJsxTagAttributeNameLocal,
      mdxJsxFlowTagAttributeValueLiteral: exitMdxJsxTagAttributeValueLiteral,
      mdxJsxFlowTagAttributeValueLiteralValue: data2,
      mdxJsxFlowTagAttributeValueExpression: exitMdxJsxTagAttributeValueExpression,
      mdxJsxFlowTagAttributeValueExpressionValue: data2,
      mdxJsxFlowTagSelfClosingMarker: exitMdxJsxTagSelfClosingMarker,
      mdxJsxFlowTag: exitMdxJsxTag,
      mdxJsxTextTagClosingMarker: exitMdxJsxTagClosingMarker,
      mdxJsxTextTagNamePrimary: exitMdxJsxTagNamePrimary,
      mdxJsxTextTagNameMember: exitMdxJsxTagNameMember,
      mdxJsxTextTagNameLocal: exitMdxJsxTagNameLocal,
      mdxJsxTextTagExpressionAttribute: exitMdxJsxTagExpressionAttribute,
      mdxJsxTextTagExpressionAttributeValue: data2,
      mdxJsxTextTagAttributeNamePrimary: exitMdxJsxTagAttributeNamePrimary,
      mdxJsxTextTagAttributeNameLocal: exitMdxJsxTagAttributeNameLocal,
      mdxJsxTextTagAttributeValueLiteral: exitMdxJsxTagAttributeValueLiteral,
      mdxJsxTextTagAttributeValueLiteralValue: data2,
      mdxJsxTextTagAttributeValueExpression: exitMdxJsxTagAttributeValueExpression,
      mdxJsxTextTagAttributeValueExpressionValue: data2,
      mdxJsxTextTagSelfClosingMarker: exitMdxJsxTagSelfClosingMarker,
      mdxJsxTextTag: exitMdxJsxTag
    }
  };
  function buffer() {
    this.buffer();
  }
  function point3(d3) {
    return { line: d3.line, column: d3.column, offset: d3.offset };
  }
  function data2(token) {
    this.config.enter.data.call(this, token);
    this.config.exit.data.call(this, token);
  }
  function enterMdxJsxTag(token) {
    const tag = {
      name: void 0,
      attributes: [],
      close: false,
      selfClosing: false,
      start: token.start,
      end: token.end
    };
    if (!this.data.mdxJsxTagStack) this.data.mdxJsxTagStack = [];
    this.data.mdxJsxTag = tag;
    this.buffer();
  }
  function enterMdxJsxTagClosingMarker(token) {
    const stack = this.data.mdxJsxTagStack;
    ok(stack, "expected `mdxJsxTagStack`");
    if (stack.length === 0) {
      throw new VFileMessage(
        "Unexpected closing slash `/` in tag, expected an open tag first",
        { start: token.start, end: token.end },
        "mdast-util-mdx-jsx:unexpected-closing-slash"
      );
    }
  }
  function enterMdxJsxTagAnyAttribute(token) {
    const tag = this.data.mdxJsxTag;
    ok(tag, "expected `mdxJsxTag`");
    if (tag.close) {
      throw new VFileMessage(
        "Unexpected attribute in closing tag, expected the end of the tag",
        { start: token.start, end: token.end },
        "mdast-util-mdx-jsx:unexpected-attribute"
      );
    }
  }
  function enterMdxJsxTagSelfClosingMarker(token) {
    const tag = this.data.mdxJsxTag;
    ok(tag, "expected `mdxJsxTag`");
    if (tag.close) {
      throw new VFileMessage(
        "Unexpected self-closing slash `/` in closing tag, expected the end of the tag",
        { start: token.start, end: token.end },
        "mdast-util-mdx-jsx:unexpected-self-closing-slash"
      );
    }
  }
  function exitMdxJsxTagClosingMarker() {
    const tag = this.data.mdxJsxTag;
    ok(tag, "expected `mdxJsxTag`");
    tag.close = true;
  }
  function exitMdxJsxTagNamePrimary(token) {
    const tag = this.data.mdxJsxTag;
    ok(tag, "expected `mdxJsxTag`");
    tag.name = this.sliceSerialize(token);
  }
  function exitMdxJsxTagNameMember(token) {
    const tag = this.data.mdxJsxTag;
    ok(tag, "expected `mdxJsxTag`");
    tag.name += "." + this.sliceSerialize(token);
  }
  function exitMdxJsxTagNameLocal(token) {
    const tag = this.data.mdxJsxTag;
    ok(tag, "expected `mdxJsxTag`");
    tag.name += ":" + this.sliceSerialize(token);
  }
  function enterMdxJsxTagAttribute(token) {
    const tag = this.data.mdxJsxTag;
    ok(tag, "expected `mdxJsxTag`");
    enterMdxJsxTagAnyAttribute.call(this, token);
    tag.attributes.push({
      type: "mdxJsxAttribute",
      name: "",
      value: null,
      position: {
        start: point3(token.start),
        // @ts-expect-error: `end` will be patched later.
        end: void 0
      }
    });
  }
  function enterMdxJsxTagExpressionAttribute(token) {
    const tag = this.data.mdxJsxTag;
    ok(tag, "expected `mdxJsxTag`");
    enterMdxJsxTagAnyAttribute.call(this, token);
    tag.attributes.push({
      type: "mdxJsxExpressionAttribute",
      value: "",
      position: {
        start: point3(token.start),
        // @ts-expect-error: `end` will be patched later.
        end: void 0
      }
    });
    this.buffer();
  }
  function exitMdxJsxTagExpressionAttribute(token) {
    const tag = this.data.mdxJsxTag;
    ok(tag, "expected `mdxJsxTag`");
    const tail = tag.attributes[tag.attributes.length - 1];
    ok(tail.type === "mdxJsxExpressionAttribute");
    const estree = token.estree;
    tail.value = this.resume();
    ok(tail.position !== void 0);
    tail.position.end = point3(token.end);
    if (estree) {
      tail.data = { estree };
    }
  }
  function exitMdxJsxTagAttributeNamePrimary(token) {
    const tag = this.data.mdxJsxTag;
    ok(tag, "expected `mdxJsxTag`");
    const node2 = tag.attributes[tag.attributes.length - 1];
    ok(node2.type === "mdxJsxAttribute");
    node2.name = this.sliceSerialize(token);
    ok(node2.position !== void 0);
    node2.position.end = point3(token.end);
  }
  function exitMdxJsxTagAttributeNameLocal(token) {
    const tag = this.data.mdxJsxTag;
    ok(tag, "expected `mdxJsxTag`");
    const node2 = tag.attributes[tag.attributes.length - 1];
    ok(node2.type === "mdxJsxAttribute");
    node2.name += ":" + this.sliceSerialize(token);
    ok(node2.position !== void 0);
    node2.position.end = point3(token.end);
  }
  function exitMdxJsxTagAttributeValueLiteral(token) {
    const tag = this.data.mdxJsxTag;
    ok(tag, "expected `mdxJsxTag`");
    const node2 = tag.attributes[tag.attributes.length - 1];
    node2.value = parseEntities(this.resume(), { nonTerminated: false });
    ok(node2.position !== void 0);
    node2.position.end = point3(token.end);
  }
  function exitMdxJsxTagAttributeValueExpression(token) {
    const tag = this.data.mdxJsxTag;
    ok(tag, "expected `mdxJsxTag`");
    const tail = tag.attributes[tag.attributes.length - 1];
    ok(tail.type === "mdxJsxAttribute");
    const node2 = { type: "mdxJsxAttributeValueExpression", value: this.resume() };
    const estree = token.estree;
    if (estree) {
      node2.data = { estree };
    }
    tail.value = node2;
    ok(tail.position !== void 0);
    tail.position.end = point3(token.end);
  }
  function exitMdxJsxTagSelfClosingMarker() {
    const tag = this.data.mdxJsxTag;
    ok(tag, "expected `mdxJsxTag`");
    tag.selfClosing = true;
  }
  function exitMdxJsxTag(token) {
    const tag = this.data.mdxJsxTag;
    ok(tag, "expected `mdxJsxTag`");
    const stack = this.data.mdxJsxTagStack;
    ok(stack, "expected `mdxJsxTagStack`");
    const tail = stack[stack.length - 1];
    if (tag.close && tail.name !== tag.name) {
      throw new VFileMessage(
        "Unexpected closing tag `" + serializeAbbreviatedTag(tag) + "`, expected corresponding closing tag for `" + serializeAbbreviatedTag(tail) + "` (" + stringifyPosition(tail) + ")",
        { start: token.start, end: token.end },
        "mdast-util-mdx-jsx:end-tag-mismatch"
      );
    }
    this.resume();
    if (tag.close) {
      stack.pop();
    } else {
      this.enter(
        {
          type: token.type === "mdxJsxTextTag" ? "mdxJsxTextElement" : "mdxJsxFlowElement",
          name: tag.name || null,
          attributes: tag.attributes,
          children: []
        },
        token,
        onErrorRightIsTag
      );
    }
    if (tag.selfClosing || tag.close) {
      this.exit(token, onErrorLeftIsTag);
    } else {
      stack.push(tag);
    }
  }
  function onErrorRightIsTag(closing, open) {
    const stack = this.data.mdxJsxTagStack;
    ok(stack, "expected `mdxJsxTagStack`");
    const tag = stack[stack.length - 1];
    ok(tag, "expected `mdxJsxTag`");
    const place = closing ? " before the end of `" + closing.type + "`" : "";
    const position2 = closing ? { start: closing.start, end: closing.end } : void 0;
    throw new VFileMessage(
      "Expected a closing tag for `" + serializeAbbreviatedTag(tag) + "` (" + stringifyPosition({ start: open.start, end: open.end }) + ")" + place,
      position2,
      "mdast-util-mdx-jsx:end-tag-mismatch"
    );
  }
  function onErrorLeftIsTag(a2, b3) {
    const tag = this.data.mdxJsxTag;
    ok(tag, "expected `mdxJsxTag`");
    throw new VFileMessage(
      "Expected the closing tag `" + serializeAbbreviatedTag(tag) + "` either after the end of `" + b3.type + "` (" + stringifyPosition(b3.end) + ") or another opening tag after the start of `" + b3.type + "` (" + stringifyPosition(b3.start) + ")",
      { start: a2.start, end: a2.end },
      "mdast-util-mdx-jsx:end-tag-mismatch"
    );
  }
  function serializeAbbreviatedTag(tag) {
    return "<" + (tag.close ? "/" : "") + (tag.name || "") + ">";
  }
}
function mdxJsxToMarkdown(options) {
  const options_ = options || {};
  const quote = options_.quote || '"';
  const quoteSmart = options_.quoteSmart || false;
  const tightSelfClosing = options_.tightSelfClosing || false;
  const printWidth = options_.printWidth || Number.POSITIVE_INFINITY;
  const alternative = quote === '"' ? "'" : '"';
  if (quote !== '"' && quote !== "'") {
    throw new Error(
      "Cannot serialize attribute values with `" + quote + "` for `options.quote`, expected `\"`, or `'`"
    );
  }
  mdxElement.peek = peekElement;
  return {
    handlers: {
      mdxJsxFlowElement: mdxElement,
      mdxJsxTextElement: mdxElement
    },
    unsafe: [
      { character: "<", inConstruct: ["phrasing"] },
      { atBreak: true, character: "<" }
    ],
    // Always generate fenced code (never indented code).
    fences: true,
    // Always generate links with resources (never autolinks).
    resourceLink: true
  };
  function mdxElement(node2, _2, state, info) {
    const flow3 = node2.type === "mdxJsxFlowElement";
    const selfClosing = node2.name ? !node2.children || node2.children.length === 0 : false;
    const depth2 = inferDepth(state);
    const currentIndent = createIndent(depth2);
    const trackerOneLine = state.createTracker(info);
    const trackerMultiLine = state.createTracker(info);
    const serializedAttributes = [];
    const prefix = (flow3 ? currentIndent : "") + "<" + (node2.name || "");
    const exit4 = state.enter(node2.type);
    trackerOneLine.move(prefix);
    trackerMultiLine.move(prefix);
    if (node2.attributes && node2.attributes.length > 0) {
      if (!node2.name) {
        throw new Error("Cannot serialize fragment w/ attributes");
      }
      let index3 = -1;
      while (++index3 < node2.attributes.length) {
        const attribute = node2.attributes[index3];
        let result;
        if (attribute.type === "mdxJsxExpressionAttribute") {
          result = "{" + (attribute.value || "") + "}";
        } else {
          if (!attribute.name) {
            throw new Error("Cannot serialize attribute w/o name");
          }
          const value3 = attribute.value;
          const left = attribute.name;
          let right = "";
          if (value3 === null || value3 === void 0) {
          } else if (typeof value3 === "object") {
            right = "{" + (value3.value || "") + "}";
          } else {
            const appliedQuote = quoteSmart && ccount(value3, quote) > ccount(value3, alternative) ? alternative : quote;
            right = appliedQuote + stringifyEntitiesLight(value3, { subset: [appliedQuote] }) + appliedQuote;
          }
          result = left + (right ? "=" : "") + right;
        }
        serializedAttributes.push(result);
      }
    }
    let attributesOnTheirOwnLine = false;
    const attributesOnOneLine = serializedAttributes.join(" ");
    if (
      // Block:
      flow3 && // Including a line ending (expressions).
      (/\r?\n|\r/.test(attributesOnOneLine) || // Current position (including `<tag`).
      trackerOneLine.current().now.column + // -1 because columns, +1 for ` ` before attributes.
      // Attributes joined by spaces.
      attributesOnOneLine.length + // ` />`.
      (selfClosing ? tightSelfClosing ? 2 : 3 : 1) > printWidth)
    ) {
      attributesOnTheirOwnLine = true;
    }
    let tracker = trackerOneLine;
    let value2 = prefix;
    if (attributesOnTheirOwnLine) {
      tracker = trackerMultiLine;
      let index3 = -1;
      while (++index3 < serializedAttributes.length) {
        serializedAttributes[index3] = currentIndent + indent + serializedAttributes[index3];
      }
      value2 += tracker.move(
        "\n" + serializedAttributes.join("\n") + "\n" + currentIndent
      );
    } else if (attributesOnOneLine) {
      value2 += tracker.move(" " + attributesOnOneLine);
    }
    if (selfClosing) {
      value2 += tracker.move(
        (tightSelfClosing || attributesOnTheirOwnLine ? "" : " ") + "/"
      );
    }
    value2 += tracker.move(">");
    if (node2.children && node2.children.length > 0) {
      if (node2.type === "mdxJsxTextElement") {
        value2 += tracker.move(
          state.containerPhrasing(node2, {
            ...tracker.current(),
            before: ">",
            after: "<"
          })
        );
      } else {
        tracker.shift(2);
        value2 += tracker.move("\n");
        value2 += tracker.move(containerFlow(node2, state, tracker.current()));
        value2 += tracker.move("\n");
      }
    }
    if (!selfClosing) {
      value2 += tracker.move(
        (flow3 ? currentIndent : "") + "</" + (node2.name || "") + ">"
      );
    }
    exit4();
    return value2;
  }
}
function containerFlow(parent, state, info) {
  const indexStack = state.indexStack;
  const children = parent.children;
  const tracker = state.createTracker(info);
  const currentIndent = createIndent(inferDepth(state));
  const results = [];
  let index3 = -1;
  indexStack.push(-1);
  while (++index3 < children.length) {
    const child = children[index3];
    indexStack[indexStack.length - 1] = index3;
    const childInfo = { before: "\n", after: "\n", ...tracker.current() };
    const result = state.handle(child, parent, state, childInfo);
    const serializedChild = child.type === "mdxJsxFlowElement" ? result : state.indentLines(result, function(line, _2, blank) {
      return (blank ? "" : currentIndent) + line;
    });
    results.push(tracker.move(serializedChild));
    if (child.type !== "list") {
      state.bulletLastUsed = void 0;
    }
    if (index3 < children.length - 1) {
      results.push(tracker.move("\n\n"));
    }
  }
  indexStack.pop();
  return results.join("");
}
function inferDepth(state) {
  let depth2 = 0;
  let index3 = state.stack.length;
  while (--index3 > -1) {
    const name2 = state.stack[index3];
    if (name2 === "blockquote" || name2 === "listItem") break;
    if (name2 === "mdxJsxFlowElement") depth2++;
  }
  return depth2;
}
function createIndent(depth2) {
  return indent.repeat(depth2);
}
function peekElement() {
  return "<";
}

// node_modules/estree-util-is-identifier-name/lib/index.js
var startRe = /[$_\p{ID_Start}]/u;
var contRe = /[$_\u{200C}\u{200D}\p{ID_Continue}]/u;
var contReJsx = /[-$_\u{200C}\u{200D}\p{ID_Continue}]/u;
var emptyOptions = {};
function start(code3) {
  return code3 ? startRe.test(String.fromCodePoint(code3)) : false;
}
function cont(code3, options) {
  const settings = options || emptyOptions;
  const re = settings.jsx ? contReJsx : contRe;
  return code3 ? re.test(String.fromCodePoint(code3)) : false;
}

// node_modules/micromark-factory-space/dev/index.js
function factorySpace(effects, ok3, type2, max2) {
  const limit = max2 ? max2 - 1 : Number.POSITIVE_INFINITY;
  let size4 = 0;
  return start2;
  function start2(code3) {
    if (markdownSpace(code3)) {
      effects.enter(type2);
      return prefix(code3);
    }
    return ok3(code3);
  }
  function prefix(code3) {
    if (markdownSpace(code3) && size4++ < limit) {
      effects.consume(code3);
      return prefix;
    }
    effects.exit(type2);
    return ok3(code3);
  }
}

// node_modules/estree-util-visit/lib/color.default.js
function color(d3) {
  return d3;
}

// node_modules/estree-util-visit/lib/index.js
var own2 = {}.hasOwnProperty;
var CONTINUE = Symbol("continue");
var EXIT = Symbol("exit");
var SKIP = Symbol("skip");
function visit(tree, visitor) {
  let enter2;
  let leave;
  if (typeof visitor === "function") {
    enter2 = visitor;
  } else if (visitor && typeof visitor === "object") {
    if (visitor.enter) enter2 = visitor.enter;
    if (visitor.leave) leave = visitor.leave;
  }
  build(tree, void 0, void 0, [])();
  function build(node2, key2, index3, parents) {
    if (nodelike(node2)) {
      visit3.displayName = "node (" + color(node2.type) + ")";
    }
    return visit3;
    function visit3() {
      const result = enter2 ? toResult(enter2(node2, key2, index3, parents)) : [];
      if (result[0] === EXIT) {
        return result;
      }
      if (result[0] !== SKIP) {
        let cKey;
        for (cKey in node2) {
          if (own2.call(node2, cKey) && node2[cKey] && typeof node2[cKey] === "object" && // @ts-expect-error: custom esast extension.
          cKey !== "data" && // @ts-expect-error: custom esast extension.
          cKey !== "position") {
            const grandparents = parents.concat(node2);
            const value2 = node2[cKey];
            if (Array.isArray(value2)) {
              const nodes = (
                /** @type {Array<unknown>} */
                value2
              );
              let cIndex = 0;
              while (cIndex > -1 && cIndex < nodes.length) {
                const subvalue = nodes[cIndex];
                if (nodelike(subvalue)) {
                  const subresult = build(
                    subvalue,
                    cKey,
                    cIndex,
                    grandparents
                  )();
                  if (subresult[0] === EXIT) return subresult;
                  cIndex = typeof subresult[1] === "number" ? subresult[1] : cIndex + 1;
                } else {
                  cIndex++;
                }
              }
            } else if (nodelike(value2)) {
              const subresult = build(value2, cKey, void 0, grandparents)();
              if (subresult[0] === EXIT) return subresult;
            }
          }
        }
      }
      return leave ? toResult(leave(node2, key2, index3, parents)) : result;
    }
  }
}
function toResult(value2) {
  if (Array.isArray(value2)) {
    return value2;
  }
  if (typeof value2 === "number") {
    return [CONTINUE, value2];
  }
  return [value2];
}
function nodelike(value2) {
  return Boolean(
    value2 && typeof value2 === "object" && "type" in value2 && typeof value2.type === "string" && value2.type.length > 0
  );
}

// node_modules/micromark-util-events-to-acorn/dev/index.js
function eventsToAcorn(events, options) {
  const prefix = options.prefix || "";
  const suffix = options.suffix || "";
  const acornOptions = Object.assign({}, options.acornOptions);
  const comments = [];
  const tokens = [];
  const onComment = acornOptions.onComment;
  const onToken = acornOptions.onToken;
  let swallow = false;
  let estree;
  let exception2;
  const acornConfig = Object.assign({}, acornOptions, {
    onComment: comments,
    preserveParens: true
  });
  if (onToken) {
    acornConfig.onToken = tokens;
  }
  const collection = collect(events, options.tokenTypes);
  const source = collection.value;
  const value2 = prefix + source + suffix;
  const isEmptyExpression = options.expression && empty(source);
  if (isEmptyExpression && !options.allowEmpty) {
    throw new VFileMessage("Unexpected empty expression", {
      place: parseOffsetToUnistPoint(0),
      ruleId: "unexpected-empty-expression",
      source: "micromark-extension-mdx-expression"
    });
  }
  try {
    estree = options.expression && !isEmptyExpression ? options.acorn.parseExpressionAt(value2, 0, acornConfig) : options.acorn.parse(value2, acornConfig);
  } catch (error_) {
    const error = (
      /** @type {AcornError} */
      error_
    );
    const point3 = parseOffsetToUnistPoint(error.pos);
    error.message = String(error.message).replace(/ \(\d+:\d+\)$/, "");
    ok(point3.offset !== void 0, "expected `offset`");
    error.pos = point3.offset;
    error.loc = { line: point3.line, column: point3.column - 1 };
    exception2 = error;
    swallow = error.raisedAt >= prefix.length + source.length || // Broken comments are raised at their start, not their end.
    error.message === "Unterminated comment";
  }
  if (estree && options.expression && !isEmptyExpression) {
    if (empty(value2.slice(estree.end, value2.length - suffix.length))) {
      estree = {
        type: "Program",
        start: 0,
        end: prefix.length + source.length,
        // @ts-expect-error: It’s good.
        body: [
          {
            type: "ExpressionStatement",
            expression: estree,
            start: 0,
            end: prefix.length + source.length
          }
        ],
        sourceType: "module",
        comments: []
      };
    } else {
      const point3 = parseOffsetToUnistPoint(estree.end);
      const error = (
        /** @type {AcornError} */
        new Error("Unexpected content after expression")
      );
      ok(point3.offset !== void 0, "expected `offset`");
      error.pos = point3.offset;
      error.loc = { line: point3.line, column: point3.column - 1 };
      exception2 = error;
      estree = void 0;
    }
  }
  if (estree) {
    estree.comments = comments;
    visit(estree, function(esnode, field, index3, parents) {
      let context = (
        /** @type {AcornNode | Array<AcornNode>} */
        parents[parents.length - 1]
      );
      let prop2 = field;
      if (esnode.type === "ParenthesizedExpression" && context && prop2) {
        if (typeof index3 === "number") {
          context = context[prop2];
          prop2 = index3;
        }
        context[prop2] = esnode.expression;
      }
      fixPosition(esnode);
    });
    if (Array.isArray(onComment)) {
      onComment.push(...comments);
    } else if (typeof onComment === "function") {
      for (const comment2 of comments) {
        ok(comment2.loc, "expected `loc` on comment");
        onComment(
          comment2.type === "Block",
          comment2.value,
          comment2.start,
          comment2.end,
          comment2.loc.start,
          comment2.loc.end
        );
      }
    }
    for (const token of tokens) {
      if (token.end <= prefix.length || token.start - prefix.length >= source.length) {
        continue;
      }
      fixPosition(token);
      if (Array.isArray(onToken)) {
        onToken.push(token);
      } else {
        ok(typeof onToken === "function", "expected function");
        onToken(token);
      }
    }
  }
  return { estree, error: exception2, swallow };
  function fixPosition(nodeOrToken) {
    ok(
      "start" in nodeOrToken,
      "expected `start` in node or token from acorn"
    );
    ok("end" in nodeOrToken, "expected `end` in node or token from acorn");
    const pointStart = parseOffsetToUnistPoint(nodeOrToken.start);
    const pointEnd = parseOffsetToUnistPoint(nodeOrToken.end);
    ok(pointStart.offset !== void 0, "expected `offset`");
    ok(pointEnd.offset !== void 0, "expected `offset`");
    nodeOrToken.start = pointStart.offset;
    nodeOrToken.end = pointEnd.offset;
    nodeOrToken.loc = {
      start: {
        line: pointStart.line,
        column: pointStart.column - 1,
        offset: pointStart.offset
      },
      end: {
        line: pointEnd.line,
        column: pointEnd.column - 1,
        offset: pointEnd.offset
      }
    };
    nodeOrToken.range = [nodeOrToken.start, nodeOrToken.end];
  }
  function parseOffsetToUnistPoint(acornOffset) {
    let sourceOffset = acornOffset - prefix.length;
    if (sourceOffset < 0) {
      sourceOffset = 0;
    } else if (sourceOffset > source.length) {
      sourceOffset = source.length;
    }
    let point3 = relativeToPoint(collection.stops, sourceOffset);
    if (!point3) {
      ok(
        options.start,
        "empty expressions are need `options.start` being passed"
      );
      point3 = {
        line: options.start.line,
        column: options.start.column,
        offset: options.start.offset
      };
    }
    return point3;
  }
}
function empty(value2) {
  return /^\s*$/.test(
    value2.replace(/\/\*[\s\S]*?\*\//g, "").replace(/\/\/[^\r\n]*(\r\n|\n|\r)/g, "")
  );
}
function collect(events, tokenTypes) {
  const result = { value: "", stops: [] };
  let index3 = -1;
  while (++index3 < events.length) {
    const event = events[index3];
    if (event[0] === "enter") {
      const type2 = event[1].type;
      if (type2 === types.lineEnding || tokenTypes.includes(type2)) {
        const chunks = event[2].sliceStream(event[1]);
        while (chunks.length > 0 && chunks[0] === codes.virtualSpace) {
          chunks.shift();
        }
        const value2 = serializeChunks(chunks);
        result.stops.push([result.value.length, event[1].start]);
        result.value += value2;
        result.stops.push([result.value.length, event[1].end]);
      }
    }
  }
  return result;
}
function relativeToPoint(stops, relative) {
  let index3 = 0;
  while (index3 < stops.length && stops[index3][0] <= relative) {
    index3 += 1;
  }
  if (index3 === 0) {
    return void 0;
  }
  const [stopRelative, stopAbsolute] = stops[index3 - 1];
  const rest = relative - stopRelative;
  return {
    line: stopAbsolute.line,
    column: stopAbsolute.column + rest,
    offset: stopAbsolute.offset + rest
  };
}
function serializeChunks(chunks) {
  let index3 = -1;
  const result = [];
  let atTab;
  while (++index3 < chunks.length) {
    const chunk = chunks[index3];
    let value2;
    if (typeof chunk === "string") {
      value2 = chunk;
    } else
      switch (chunk) {
        case codes.carriageReturn: {
          value2 = values.cr;
          break;
        }
        case codes.lineFeed: {
          value2 = values.lf;
          break;
        }
        case codes.carriageReturnLineFeed: {
          value2 = values.cr + values.lf;
          break;
        }
        case codes.horizontalTab: {
          value2 = values.ht;
          break;
        }
        case codes.virtualSpace: {
          if (atTab) continue;
          value2 = values.space;
          break;
        }
        default: {
          ok(typeof chunk === "number", "expected number");
          value2 = String.fromCharCode(chunk);
        }
      }
    atTab = chunk === codes.horizontalTab;
    result.push(value2);
  }
  return result.join("");
}

// node_modules/unist-util-position-from-estree/lib/index.js
function positionFromEstree(node2) {
  const nodeLike = node2 || {};
  const loc = nodeLike.loc || {};
  const range = nodeLike.range || [void 0, void 0];
  const start2 = pointOrUndefined(loc.start, range[0] || nodeLike.start);
  const end = pointOrUndefined(loc.end, range[1] || nodeLike.end);
  if (start2 && end) {
    return { start: start2, end };
  }
}
function pointOrUndefined(estreePoint, estreeOffset) {
  if (estreePoint && typeof estreePoint === "object") {
    const line = "line" in estreePoint ? numberOrUndefined(estreePoint.line) : void 0;
    const column = "column" in estreePoint ? numberOrUndefined(estreePoint.column) : void 0;
    if (line && column !== void 0) {
      return {
        line,
        column: column + 1,
        offset: numberOrUndefined(estreeOffset)
      };
    }
  }
}
function numberOrUndefined(value2) {
  return typeof value2 === "number" && value2 > -1 ? value2 : void 0;
}

// node_modules/micromark-factory-mdx-expression/dev/index.js
var indentSize = 2;
var trouble = "https://github.com/micromark/micromark-extension-mdx-expression/tree/main/packages/micromark-extension-mdx-expression";
var unexpectedEndOfFileHash = "#unexpected-end-of-file-in-expression-expected-a-corresponding-closing-brace-for-";
var unexpectedLazyHash = "#unexpected-lazy-line-in-expression-in-container-expected-line-to-be-prefixed";
var nonSpreadHash = "#unexpected-type-in-code-expected-an-object-spread-spread";
var spreadExtraHash = "#unexpected-extra-content-in-spread-only-a-single-spread-is-supported";
var acornHash = "#could-not-parse-expression-with-acorn";
function factoryMdxExpression(effects, ok3, type2, markerType, chunkType, acorn, acornOptions, addResult, spread, allowEmpty, allowLazy) {
  const self2 = this;
  const eventStart = this.events.length + 3;
  let size4 = 0;
  let pointStart;
  let lastCrash;
  return start2;
  function start2(code3) {
    ok(code3 === codes.leftCurlyBrace, "expected `{`");
    effects.enter(type2);
    effects.enter(markerType);
    effects.consume(code3);
    effects.exit(markerType);
    pointStart = self2.now();
    return before;
  }
  function before(code3) {
    if (code3 === codes.eof) {
      if (lastCrash) throw lastCrash;
      const error = new VFileMessage(
        "Unexpected end of file in expression, expected a corresponding closing brace for `{`",
        {
          place: self2.now(),
          ruleId: "unexpected-eof",
          source: "micromark-extension-mdx-expression"
        }
      );
      error.url = trouble + unexpectedEndOfFileHash;
      throw error;
    }
    if (markdownLineEnding(code3)) {
      effects.enter(types.lineEnding);
      effects.consume(code3);
      effects.exit(types.lineEnding);
      return eolAfter;
    }
    if (code3 === codes.rightCurlyBrace && size4 === 0) {
      const next = acorn ? mdxExpressionParse.call(
        self2,
        acorn,
        acornOptions,
        chunkType,
        eventStart,
        pointStart,
        allowEmpty || false,
        spread || false
      ) : { type: "ok", estree: void 0 };
      if (next.type === "ok") {
        effects.enter(markerType);
        effects.consume(code3);
        effects.exit(markerType);
        const token = effects.exit(type2);
        if (addResult && next.estree) {
          Object.assign(token, { estree: next.estree });
        }
        return ok3;
      }
      lastCrash = next.message;
      effects.enter(chunkType);
      effects.consume(code3);
      return inside;
    }
    effects.enter(chunkType);
    return inside(code3);
  }
  function inside(code3) {
    if (code3 === codes.rightCurlyBrace && size4 === 0 || code3 === codes.eof || markdownLineEnding(code3)) {
      effects.exit(chunkType);
      return before(code3);
    }
    if (code3 === codes.leftCurlyBrace && !acorn) {
      size4 += 1;
    } else if (code3 === codes.rightCurlyBrace) {
      size4 -= 1;
    }
    effects.consume(code3);
    return inside;
  }
  function eolAfter(code3) {
    const now = self2.now();
    if (now.line !== pointStart.line && !allowLazy && self2.parser.lazy[now.line]) {
      const error = new VFileMessage(
        "Unexpected lazy line in expression in container, expected line to be prefixed with `>` when in a block quote, whitespace when in a list, etc",
        {
          place: self2.now(),
          ruleId: "unexpected-lazy",
          source: "micromark-extension-mdx-expression"
        }
      );
      error.url = trouble + unexpectedLazyHash;
      throw error;
    }
    if (markdownSpace(code3)) {
      return factorySpace(
        effects,
        before,
        types.linePrefix,
        indentSize + 1
      )(code3);
    }
    return before(code3);
  }
}
function mdxExpressionParse(acorn, acornOptions, chunkType, eventStart, pointStart, allowEmpty, spread) {
  const result = eventsToAcorn(this.events.slice(eventStart), {
    acorn,
    tokenTypes: [chunkType],
    acornOptions,
    start: pointStart,
    expression: true,
    allowEmpty,
    prefix: spread ? "({" : "",
    suffix: spread ? "})" : ""
  });
  const estree = result.estree;
  if (spread && estree) {
    ok(estree.type === "Program", "expected program");
    const head = estree.body[0];
    ok(head, "expected body");
    if (head.type !== "ExpressionStatement" || head.expression.type !== "ObjectExpression") {
      const place = positionFromEstree(head);
      ok(place, "expected position");
      const error = new VFileMessage(
        "Unexpected `" + head.type + "` in code: expected an object spread (`{...spread}`)",
        {
          place: place.start,
          ruleId: "non-spread",
          source: "micromark-extension-mdx-expression"
        }
      );
      error.url = trouble + nonSpreadHash;
      throw error;
    }
    if (head.expression.properties[1]) {
      const place = positionFromEstree(head.expression.properties[1]);
      ok(place, "expected position");
      const error = new VFileMessage(
        "Unexpected extra content in spread: only a single spread is supported",
        {
          place: place.start,
          ruleId: "spread-extra",
          source: "micromark-extension-mdx-expression"
        }
      );
      error.url = trouble + spreadExtraHash;
      throw error;
    }
    if (head.expression.properties[0] && head.expression.properties[0].type !== "SpreadElement") {
      const place = positionFromEstree(head.expression.properties[0]);
      ok(place, "expected position");
      const error = new VFileMessage(
        "Unexpected `" + head.expression.properties[0].type + "` in code: only spread elements are supported",
        {
          place: place.start,
          ruleId: "non-spread",
          source: "micromark-extension-mdx-expression"
        }
      );
      error.url = trouble + nonSpreadHash;
      throw error;
    }
  }
  if (result.error) {
    const error = new VFileMessage("Could not parse expression with acorn", {
      cause: result.error,
      place: {
        line: result.error.loc.line,
        column: result.error.loc.column + 1,
        offset: result.error.pos
      },
      ruleId: "acorn",
      source: "micromark-extension-mdx-expression"
    });
    error.url = trouble + acornHash;
    return { type: "nok", message: error };
  }
  return { type: "ok", estree };
}

// node_modules/micromark-extension-mdx-jsx/dev/lib/factory-tag.js
var trouble2 = "https://github.com/micromark/micromark-extension-mdx-jsx";
function factoryTag(effects, ok3, nok, acorn, acornOptions, addResult, allowLazy, tagType, tagMarkerType, tagClosingMarkerType, tagSelfClosingMarker, tagNameType, tagNamePrimaryType, tagNameMemberMarkerType, tagNameMemberType, tagNamePrefixMarkerType, tagNameLocalType, tagExpressionAttributeType, tagExpressionAttributeMarkerType, tagExpressionAttributeValueType, tagAttributeType, tagAttributeNameType, tagAttributeNamePrimaryType, tagAttributeNamePrefixMarkerType, tagAttributeNameLocalType, tagAttributeInitializerMarkerType, tagAttributeValueLiteralType, tagAttributeValueLiteralMarkerType, tagAttributeValueLiteralValueType, tagAttributeValueExpressionType, tagAttributeValueExpressionMarkerType, tagAttributeValueExpressionValueType) {
  const self2 = this;
  let returnState;
  let marker;
  return start2;
  function start2(code3) {
    ok(code3 === codes.lessThan, "expected `<`");
    effects.enter(tagType);
    effects.enter(tagMarkerType);
    effects.consume(code3);
    effects.exit(tagMarkerType);
    return startAfter;
  }
  function startAfter(code3) {
    if (markdownLineEndingOrSpace(code3)) {
      return nok(code3);
    }
    returnState = nameBefore;
    return esWhitespaceStart(code3);
  }
  function nameBefore(code3) {
    if (code3 === codes.slash) {
      effects.enter(tagClosingMarkerType);
      effects.consume(code3);
      effects.exit(tagClosingMarkerType);
      returnState = closingTagNameBefore;
      return esWhitespaceStart;
    }
    if (code3 === codes.greaterThan) {
      return tagEnd(code3);
    }
    if (code3 !== codes.eof && code3 >= 0 && start(code3)) {
      effects.enter(tagNameType);
      effects.enter(tagNamePrimaryType);
      effects.consume(code3);
      return primaryName;
    }
    crash(
      code3,
      "before name",
      "a character that can start a name, such as a letter, `$`, or `_`" + (code3 === codes.exclamationMark ? " (note: to create a comment in MDX, use `{/* text */}`)" : "")
    );
  }
  function closingTagNameBefore(code3) {
    if (code3 === codes.greaterThan) {
      return tagEnd(code3);
    }
    if (code3 !== codes.eof && code3 >= 0 && start(code3)) {
      effects.enter(tagNameType);
      effects.enter(tagNamePrimaryType);
      effects.consume(code3);
      return primaryName;
    }
    crash(
      code3,
      "before name",
      "a character that can start a name, such as a letter, `$`, or `_`" + (code3 === codes.asterisk || code3 === codes.slash ? " (note: JS comments in JSX tags are not supported in MDX)" : "")
    );
  }
  function primaryName(code3) {
    if (code3 !== codes.eof && code3 >= 0 && cont(code3, { jsx: true })) {
      effects.consume(code3);
      return primaryName;
    }
    if (code3 === codes.dot || code3 === codes.slash || code3 === codes.colon || code3 === codes.greaterThan || code3 === codes.leftCurlyBrace || markdownLineEndingOrSpace(code3) || unicodeWhitespace(code3)) {
      effects.exit(tagNamePrimaryType);
      returnState = primaryNameAfter;
      return esWhitespaceStart(code3);
    }
    crash(
      code3,
      "in name",
      "a name character such as letters, digits, `$`, or `_`; whitespace before attributes; or the end of the tag" + (code3 === codes.atSign ? " (note: to create a link in MDX, use `[text](url)`)" : "")
    );
  }
  function primaryNameAfter(code3) {
    if (code3 === codes.dot) {
      effects.enter(tagNameMemberMarkerType);
      effects.consume(code3);
      effects.exit(tagNameMemberMarkerType);
      returnState = memberNameBefore;
      return esWhitespaceStart;
    }
    if (code3 === codes.colon) {
      effects.enter(tagNamePrefixMarkerType);
      effects.consume(code3);
      effects.exit(tagNamePrefixMarkerType);
      returnState = localNameBefore;
      return esWhitespaceStart;
    }
    if (code3 === codes.slash || code3 === codes.greaterThan || code3 === codes.leftCurlyBrace || code3 !== codes.eof && code3 >= 0 && start(code3)) {
      effects.exit(tagNameType);
      return attributeBefore(code3);
    }
    crash(
      code3,
      "after name",
      "a character that can start an attribute name, such as a letter, `$`, or `_`; whitespace before attributes; or the end of the tag"
    );
  }
  function memberNameBefore(code3) {
    if (code3 !== codes.eof && code3 >= 0 && start(code3)) {
      effects.enter(tagNameMemberType);
      effects.consume(code3);
      return memberName;
    }
    crash(
      code3,
      "before member name",
      "a character that can start an attribute name, such as a letter, `$`, or `_`; whitespace before attributes; or the end of the tag"
    );
  }
  function memberName(code3) {
    if (code3 !== codes.eof && code3 >= 0 && cont(code3, { jsx: true })) {
      effects.consume(code3);
      return memberName;
    }
    if (code3 === codes.dot || code3 === codes.slash || code3 === codes.greaterThan || code3 === codes.leftCurlyBrace || markdownLineEndingOrSpace(code3) || unicodeWhitespace(code3)) {
      effects.exit(tagNameMemberType);
      returnState = memberNameAfter;
      return esWhitespaceStart(code3);
    }
    crash(
      code3,
      "in member name",
      "a name character such as letters, digits, `$`, or `_`; whitespace before attributes; or the end of the tag" + (code3 === codes.atSign ? " (note: to create a link in MDX, use `[text](url)`)" : "")
    );
  }
  function memberNameAfter(code3) {
    if (code3 === codes.dot) {
      effects.enter(tagNameMemberMarkerType);
      effects.consume(code3);
      effects.exit(tagNameMemberMarkerType);
      returnState = memberNameBefore;
      return esWhitespaceStart;
    }
    if (code3 === codes.slash || code3 === codes.greaterThan || code3 === codes.leftCurlyBrace || code3 !== codes.eof && code3 >= 0 && start(code3)) {
      effects.exit(tagNameType);
      return attributeBefore(code3);
    }
    crash(
      code3,
      "after member name",
      "a character that can start an attribute name, such as a letter, `$`, or `_`; whitespace before attributes; or the end of the tag"
    );
  }
  function localNameBefore(code3) {
    if (code3 !== codes.eof && code3 >= 0 && start(code3)) {
      effects.enter(tagNameLocalType);
      effects.consume(code3);
      return localName;
    }
    crash(
      code3,
      "before local name",
      "a character that can start a name, such as a letter, `$`, or `_`" + (code3 === codes.plusSign || code3 !== null && code3 > codes.dot && code3 < codes.colon ? " (note: to create a link in MDX, use `[text](url)`)" : "")
    );
  }
  function localName(code3) {
    if (code3 !== codes.eof && code3 >= 0 && cont(code3, { jsx: true })) {
      effects.consume(code3);
      return localName;
    }
    if (code3 === codes.slash || code3 === codes.greaterThan || code3 === codes.leftCurlyBrace || markdownLineEndingOrSpace(code3) || unicodeWhitespace(code3)) {
      effects.exit(tagNameLocalType);
      returnState = localNameAfter;
      return esWhitespaceStart(code3);
    }
    crash(
      code3,
      "in local name",
      "a name character such as letters, digits, `$`, or `_`; whitespace before attributes; or the end of the tag"
    );
  }
  function localNameAfter(code3) {
    if (code3 === codes.slash || code3 === codes.greaterThan || code3 === codes.leftCurlyBrace || code3 !== codes.eof && code3 >= 0 && start(code3)) {
      effects.exit(tagNameType);
      return attributeBefore(code3);
    }
    crash(
      code3,
      "after local name",
      "a character that can start an attribute name, such as a letter, `$`, or `_`; whitespace before attributes; or the end of the tag"
    );
  }
  function attributeBefore(code3) {
    if (code3 === codes.slash) {
      effects.enter(tagSelfClosingMarker);
      effects.consume(code3);
      effects.exit(tagSelfClosingMarker);
      returnState = selfClosing;
      return esWhitespaceStart;
    }
    if (code3 === codes.greaterThan) {
      return tagEnd(code3);
    }
    if (code3 === codes.leftCurlyBrace) {
      return factoryMdxExpression.call(
        self2,
        effects,
        attributeExpressionAfter,
        tagExpressionAttributeType,
        tagExpressionAttributeMarkerType,
        tagExpressionAttributeValueType,
        acorn,
        acornOptions,
        addResult,
        true,
        false,
        allowLazy
      )(code3);
    }
    if (code3 !== codes.eof && code3 >= 0 && start(code3)) {
      effects.enter(tagAttributeType);
      effects.enter(tagAttributeNameType);
      effects.enter(tagAttributeNamePrimaryType);
      effects.consume(code3);
      return attributePrimaryName;
    }
    crash(
      code3,
      "before attribute name",
      "a character that can start an attribute name, such as a letter, `$`, or `_`; whitespace before attributes; or the end of the tag"
    );
  }
  function attributeExpressionAfter(code3) {
    returnState = attributeBefore;
    return esWhitespaceStart(code3);
  }
  function attributePrimaryName(code3) {
    if (code3 !== codes.eof && code3 >= 0 && cont(code3, { jsx: true })) {
      effects.consume(code3);
      return attributePrimaryName;
    }
    if (code3 === codes.slash || code3 === codes.colon || code3 === codes.equalsTo || code3 === codes.greaterThan || code3 === codes.leftCurlyBrace || markdownLineEndingOrSpace(code3) || unicodeWhitespace(code3)) {
      effects.exit(tagAttributeNamePrimaryType);
      returnState = attributePrimaryNameAfter;
      return esWhitespaceStart(code3);
    }
    crash(
      code3,
      "in attribute name",
      "an attribute name character such as letters, digits, `$`, or `_`; `=` to initialize a value; whitespace before attributes; or the end of the tag"
    );
  }
  function attributePrimaryNameAfter(code3) {
    if (code3 === codes.colon) {
      effects.enter(tagAttributeNamePrefixMarkerType);
      effects.consume(code3);
      effects.exit(tagAttributeNamePrefixMarkerType);
      returnState = attributeLocalNameBefore;
      return esWhitespaceStart;
    }
    if (code3 === codes.equalsTo) {
      effects.exit(tagAttributeNameType);
      effects.enter(tagAttributeInitializerMarkerType);
      effects.consume(code3);
      effects.exit(tagAttributeInitializerMarkerType);
      returnState = attributeValueBefore;
      return esWhitespaceStart;
    }
    if (code3 === codes.slash || code3 === codes.greaterThan || code3 === codes.leftCurlyBrace || markdownLineEndingOrSpace(code3) || unicodeWhitespace(code3) || code3 !== codes.eof && code3 >= 0 && start(code3)) {
      effects.exit(tagAttributeNameType);
      effects.exit(tagAttributeType);
      returnState = attributeBefore;
      return esWhitespaceStart(code3);
    }
    crash(
      code3,
      "after attribute name",
      "a character that can start an attribute name, such as a letter, `$`, or `_`; `=` to initialize a value; or the end of the tag"
    );
  }
  function attributeLocalNameBefore(code3) {
    if (code3 !== codes.eof && code3 >= 0 && start(code3)) {
      effects.enter(tagAttributeNameLocalType);
      effects.consume(code3);
      return attributeLocalName;
    }
    crash(
      code3,
      "before local attribute name",
      "a character that can start an attribute name, such as a letter, `$`, or `_`; `=` to initialize a value; or the end of the tag"
    );
  }
  function attributeLocalName(code3) {
    if (code3 !== codes.eof && code3 >= 0 && cont(code3, { jsx: true })) {
      effects.consume(code3);
      return attributeLocalName;
    }
    if (code3 === codes.slash || code3 === codes.equalsTo || code3 === codes.greaterThan || code3 === codes.leftCurlyBrace || markdownLineEndingOrSpace(code3) || unicodeWhitespace(code3)) {
      effects.exit(tagAttributeNameLocalType);
      effects.exit(tagAttributeNameType);
      returnState = attributeLocalNameAfter;
      return esWhitespaceStart(code3);
    }
    crash(
      code3,
      "in local attribute name",
      "an attribute name character such as letters, digits, `$`, or `_`; `=` to initialize a value; whitespace before attributes; or the end of the tag"
    );
  }
  function attributeLocalNameAfter(code3) {
    if (code3 === codes.equalsTo) {
      effects.enter(tagAttributeInitializerMarkerType);
      effects.consume(code3);
      effects.exit(tagAttributeInitializerMarkerType);
      returnState = attributeValueBefore;
      return esWhitespaceStart;
    }
    if (code3 === codes.slash || code3 === codes.greaterThan || code3 === codes.leftCurlyBrace || code3 !== codes.eof && code3 >= 0 && start(code3)) {
      effects.exit(tagAttributeType);
      return attributeBefore(code3);
    }
    crash(
      code3,
      "after local attribute name",
      "a character that can start an attribute name, such as a letter, `$`, or `_`; `=` to initialize a value; or the end of the tag"
    );
  }
  function attributeValueBefore(code3) {
    if (code3 === codes.quotationMark || code3 === codes.apostrophe) {
      effects.enter(tagAttributeValueLiteralType);
      effects.enter(tagAttributeValueLiteralMarkerType);
      effects.consume(code3);
      effects.exit(tagAttributeValueLiteralMarkerType);
      marker = code3;
      return attributeValueQuotedStart;
    }
    if (code3 === codes.leftCurlyBrace) {
      return factoryMdxExpression.call(
        self2,
        effects,
        attributeValueExpressionAfter,
        tagAttributeValueExpressionType,
        tagAttributeValueExpressionMarkerType,
        tagAttributeValueExpressionValueType,
        acorn,
        acornOptions,
        addResult,
        false,
        false,
        allowLazy
      )(code3);
    }
    crash(
      code3,
      "before attribute value",
      "a character that can start an attribute value, such as `\"`, `'`, or `{`" + (code3 === codes.lessThan ? " (note: to use an element or fragment as a prop value in MDX, use `{<element />}`)" : "")
    );
  }
  function attributeValueExpressionAfter(code3) {
    effects.exit(tagAttributeType);
    returnState = attributeBefore;
    return esWhitespaceStart(code3);
  }
  function attributeValueQuotedStart(code3) {
    ok(marker !== void 0, "expected `marker` to be defined");
    if (code3 === codes.eof) {
      crash(
        code3,
        "in attribute value",
        "a corresponding closing quote `" + String.fromCodePoint(marker) + "`"
      );
    }
    if (code3 === marker) {
      effects.enter(tagAttributeValueLiteralMarkerType);
      effects.consume(code3);
      effects.exit(tagAttributeValueLiteralMarkerType);
      effects.exit(tagAttributeValueLiteralType);
      effects.exit(tagAttributeType);
      marker = void 0;
      returnState = attributeBefore;
      return esWhitespaceStart;
    }
    if (markdownLineEnding(code3)) {
      returnState = attributeValueQuotedStart;
      return esWhitespaceStart(code3);
    }
    effects.enter(tagAttributeValueLiteralValueType);
    return attributeValueQuoted(code3);
  }
  function attributeValueQuoted(code3) {
    if (code3 === codes.eof || code3 === marker || markdownLineEnding(code3)) {
      effects.exit(tagAttributeValueLiteralValueType);
      return attributeValueQuotedStart(code3);
    }
    effects.consume(code3);
    return attributeValueQuoted;
  }
  function selfClosing(code3) {
    if (code3 === codes.greaterThan) {
      return tagEnd(code3);
    }
    crash(
      code3,
      "after self-closing slash",
      "`>` to end the tag" + (code3 === codes.asterisk || code3 === codes.slash ? " (note: JS comments in JSX tags are not supported in MDX)" : "")
    );
  }
  function tagEnd(code3) {
    ok(code3 === codes.greaterThan, "expected `>`");
    effects.enter(tagMarkerType);
    effects.consume(code3);
    effects.exit(tagMarkerType);
    effects.exit(tagType);
    return ok3;
  }
  function esWhitespaceStart(code3) {
    if (markdownLineEnding(code3)) {
      effects.enter(types.lineEnding);
      effects.consume(code3);
      effects.exit(types.lineEnding);
      return esWhitespaceEolAfter;
    }
    if (markdownSpace(code3) || unicodeWhitespace(code3)) {
      effects.enter("esWhitespace");
      return esWhitespaceInside(code3);
    }
    return returnState(code3);
  }
  function esWhitespaceInside(code3) {
    if (markdownLineEnding(code3)) {
      effects.exit("esWhitespace");
      return esWhitespaceStart(code3);
    }
    if (markdownSpace(code3) || unicodeWhitespace(code3)) {
      effects.consume(code3);
      return esWhitespaceInside;
    }
    effects.exit("esWhitespace");
    return returnState(code3);
  }
  function esWhitespaceEolAfter(code3) {
    if (!allowLazy && self2.parser.lazy[self2.now().line]) {
      const error = new VFileMessage(
        "Unexpected lazy line in container, expected line to be prefixed with `>` when in a block quote, whitespace when in a list, etc",
        self2.now(),
        "micromark-extension-mdx-jsx:unexpected-lazy"
      );
      error.url = trouble2 + "#unexpected-lazy-line-in-container-expected-line-to-be";
      throw error;
    }
    return esWhitespaceStart(code3);
  }
  function crash(code3, at3, expect) {
    const error = new VFileMessage(
      "Unexpected " + (code3 === codes.eof ? "end of file" : "character `" + (code3 === codes.graveAccent ? "` ` `" : String.fromCodePoint(code3)) + "` (" + serializeCharCode(code3) + ")") + " " + at3 + ", expected " + expect,
      self2.now(),
      "micromark-extension-mdx-jsx:unexpected-" + (code3 === codes.eof ? "eof" : "character")
    );
    error.url = trouble2 + (code3 === codes.eof ? "#unexpected-end-of-file-at-expected-expect" : "#unexpected-character-at-expected-expect");
    throw error;
  }
}
function serializeCharCode(code3) {
  return "U+" + code3.toString(constants.numericBaseHexadecimal).toUpperCase().padStart(4, "0");
}

// node_modules/micromark-extension-mdx-jsx/dev/lib/jsx-text.js
function jsxText(acorn, options) {
  return { name: "mdxJsxTextTag", tokenize: tokenizeJsxText };
  function tokenizeJsxText(effects, ok3, nok) {
    return factoryTag.call(
      this,
      effects,
      ok3,
      nok,
      acorn,
      options.acornOptions,
      options.addResult,
      true,
      "mdxJsxTextTag",
      "mdxJsxTextTagMarker",
      "mdxJsxTextTagClosingMarker",
      "mdxJsxTextTagSelfClosingMarker",
      "mdxJsxTextTagName",
      "mdxJsxTextTagNamePrimary",
      "mdxJsxTextTagNameMemberMarker",
      "mdxJsxTextTagNameMember",
      "mdxJsxTextTagNamePrefixMarker",
      "mdxJsxTextTagNameLocal",
      "mdxJsxTextTagExpressionAttribute",
      "mdxJsxTextTagExpressionAttributeMarker",
      "mdxJsxTextTagExpressionAttributeValue",
      "mdxJsxTextTagAttribute",
      "mdxJsxTextTagAttributeName",
      "mdxJsxTextTagAttributeNamePrimary",
      "mdxJsxTextTagAttributeNamePrefixMarker",
      "mdxJsxTextTagAttributeNameLocal",
      "mdxJsxTextTagAttributeInitializerMarker",
      "mdxJsxTextTagAttributeValueLiteral",
      "mdxJsxTextTagAttributeValueLiteralMarker",
      "mdxJsxTextTagAttributeValueLiteralValue",
      "mdxJsxTextTagAttributeValueExpression",
      "mdxJsxTextTagAttributeValueExpressionMarker",
      "mdxJsxTextTagAttributeValueExpressionValue"
    );
  }
}

// node_modules/micromark-extension-mdx-jsx/dev/lib/jsx-flow.js
function jsxFlow(acorn, options) {
  return { name: "mdxJsxFlowTag", tokenize: tokenizeJsxFlow, concrete: true };
  function tokenizeJsxFlow(effects, ok3, nok) {
    const self2 = this;
    return start2;
    function start2(code3) {
      ok(code3 === codes.lessThan, "expected `<`");
      return before(code3);
    }
    function before(code3) {
      return factoryTag.call(
        self2,
        effects,
        after,
        nok,
        acorn,
        options.acornOptions,
        options.addResult,
        false,
        "mdxJsxFlowTag",
        "mdxJsxFlowTagMarker",
        "mdxJsxFlowTagClosingMarker",
        "mdxJsxFlowTagSelfClosingMarker",
        "mdxJsxFlowTagName",
        "mdxJsxFlowTagNamePrimary",
        "mdxJsxFlowTagNameMemberMarker",
        "mdxJsxFlowTagNameMember",
        "mdxJsxFlowTagNamePrefixMarker",
        "mdxJsxFlowTagNameLocal",
        "mdxJsxFlowTagExpressionAttribute",
        "mdxJsxFlowTagExpressionAttributeMarker",
        "mdxJsxFlowTagExpressionAttributeValue",
        "mdxJsxFlowTagAttribute",
        "mdxJsxFlowTagAttributeName",
        "mdxJsxFlowTagAttributeNamePrimary",
        "mdxJsxFlowTagAttributeNamePrefixMarker",
        "mdxJsxFlowTagAttributeNameLocal",
        "mdxJsxFlowTagAttributeInitializerMarker",
        "mdxJsxFlowTagAttributeValueLiteral",
        "mdxJsxFlowTagAttributeValueLiteralMarker",
        "mdxJsxFlowTagAttributeValueLiteralValue",
        "mdxJsxFlowTagAttributeValueExpression",
        "mdxJsxFlowTagAttributeValueExpressionMarker",
        "mdxJsxFlowTagAttributeValueExpressionValue"
      )(code3);
    }
    function after(code3) {
      return markdownSpace(code3) ? factorySpace(effects, end, types.whitespace)(code3) : end(code3);
    }
    function end(code3) {
      const leftBraceValue = self2.parser.constructs.flow[codes.leftCurlyBrace];
      const constructs2 = Array.isArray(leftBraceValue) ? leftBraceValue : leftBraceValue ? [leftBraceValue] : [];
      const expression = constructs2.find((d3) => d3.name === "mdxFlowExpression");
      return code3 === codes.lessThan ? (
        // We can’t just say: fine. Lines of blocks have to be parsed until an eol/eof.
        start2(code3)
      ) : code3 === codes.leftCurlyBrace && expression ? effects.attempt(expression, end, nok)(code3) : code3 === codes.eof || markdownLineEnding(code3) ? ok3(code3) : nok(code3);
    }
  }
}

// node_modules/micromark-extension-mdx-jsx/dev/lib/syntax.js
function mdxJsx(options) {
  const settings = options || {};
  const acorn = settings.acorn;
  let acornOptions;
  if (acorn) {
    if (!acorn.parse || !acorn.parseExpressionAt) {
      throw new Error(
        "Expected a proper `acorn` instance passed in as `options.acorn`"
      );
    }
    acornOptions = Object.assign(
      { ecmaVersion: 2024, sourceType: "module" },
      settings.acornOptions,
      { locations: true }
    );
  } else if (settings.acornOptions || settings.addResult) {
    throw new Error("Expected an `acorn` instance passed in as `options.acorn`");
  }
  return {
    flow: {
      [codes.lessThan]: jsxFlow(acorn || void 0, {
        acornOptions,
        addResult: settings.addResult || void 0
      })
    },
    text: {
      [codes.lessThan]: jsxText(acorn || void 0, {
        acornOptions,
        addResult: settings.addResult || void 0
      })
    }
  };
}

// node_modules/micromark-extension-mdx-md/index.js
function mdxMd() {
  return {
    disable: { null: ["autolink", "codeIndented", "htmlFlow", "htmlText"] }
  };
}

// node_modules/zwitch/index.js
var own3 = {}.hasOwnProperty;
function zwitch(key2, options) {
  const settings = options || {};
  function one2(value2, ...parameters) {
    let fn = one2.invalid;
    const handlers = one2.handlers;
    if (value2 && own3.call(value2, key2)) {
      const id = String(value2[key2]);
      fn = own3.call(handlers, id) ? handlers[id] : one2.unknown;
    }
    if (fn) {
      return fn.call(this, value2, ...parameters);
    }
  }
  one2.handlers = settings.handlers || {};
  one2.invalid = settings.invalid;
  one2.unknown = settings.unknown;
  return one2;
}

// node_modules/mdast-util-to-markdown/lib/configure.js
var own4 = {}.hasOwnProperty;
function configure(base, extension2) {
  let index3 = -1;
  let key2;
  if (extension2.extensions) {
    while (++index3 < extension2.extensions.length) {
      configure(base, extension2.extensions[index3]);
    }
  }
  for (key2 in extension2) {
    if (own4.call(extension2, key2)) {
      switch (key2) {
        case "extensions": {
          break;
        }
        case "unsafe": {
          list(base[key2], extension2[key2]);
          break;
        }
        case "join": {
          list(base[key2], extension2[key2]);
          break;
        }
        case "handlers": {
          map(base[key2], extension2[key2]);
          break;
        }
        default: {
          base.options[key2] = extension2[key2];
        }
      }
    }
  }
  return base;
}
function list(left, right) {
  if (right) {
    left.push(...right);
  }
}
function map(left, right) {
  if (right) {
    Object.assign(left, right);
  }
}

// node_modules/mdast-util-to-markdown/lib/handle/blockquote.js
function blockquote(node2, _2, state, info) {
  const exit4 = state.enter("blockquote");
  const tracker = state.createTracker(info);
  tracker.move("> ");
  tracker.shift(2);
  const value2 = state.indentLines(
    state.containerFlow(node2, tracker.current()),
    map2
  );
  exit4();
  return value2;
}
function map2(line, _2, blank) {
  return ">" + (blank ? "" : " ") + line;
}

// node_modules/mdast-util-to-markdown/lib/util/pattern-in-scope.js
function patternInScope(stack, pattern) {
  return listInScope(stack, pattern.inConstruct, true) && !listInScope(stack, pattern.notInConstruct, false);
}
function listInScope(stack, list4, none2) {
  if (typeof list4 === "string") {
    list4 = [list4];
  }
  if (!list4 || list4.length === 0) {
    return none2;
  }
  let index3 = -1;
  while (++index3 < list4.length) {
    if (stack.includes(list4[index3])) {
      return true;
    }
  }
  return false;
}

// node_modules/mdast-util-to-markdown/lib/handle/break.js
function hardBreak(_2, _1, state, info) {
  let index3 = -1;
  while (++index3 < state.unsafe.length) {
    if (state.unsafe[index3].character === "\n" && patternInScope(state.stack, state.unsafe[index3])) {
      return /[ \t]/.test(info.before) ? "" : " ";
    }
  }
  return "\\\n";
}

// node_modules/longest-streak/index.js
function longestStreak(value2, substring) {
  const source = String(value2);
  let index3 = source.indexOf(substring);
  let expected = index3;
  let count3 = 0;
  let max2 = 0;
  if (typeof substring !== "string") {
    throw new TypeError("Expected substring");
  }
  while (index3 !== -1) {
    if (index3 === expected) {
      if (++count3 > max2) {
        max2 = count3;
      }
    } else {
      count3 = 1;
    }
    expected = index3 + substring.length;
    index3 = source.indexOf(substring, expected);
  }
  return max2;
}

// node_modules/mdast-util-to-markdown/lib/util/format-code-as-indented.js
function formatCodeAsIndented(node2, state) {
  return Boolean(
    state.options.fences === false && node2.value && // If there’s no info…
    !node2.lang && // And there’s a non-whitespace character…
    /[^ \r\n]/.test(node2.value) && // And the value doesn’t start or end in a blank…
    !/^[\t ]*(?:[\r\n]|$)|(?:^|[\r\n])[\t ]*$/.test(node2.value)
  );
}

// node_modules/mdast-util-to-markdown/lib/util/check-fence.js
function checkFence(state) {
  const marker = state.options.fence || "`";
  if (marker !== "`" && marker !== "~") {
    throw new Error(
      "Cannot serialize code with `" + marker + "` for `options.fence`, expected `` ` `` or `~`"
    );
  }
  return marker;
}

// node_modules/mdast-util-to-markdown/lib/handle/code.js
function code(node2, _2, state, info) {
  const marker = checkFence(state);
  const raw = node2.value || "";
  const suffix = marker === "`" ? "GraveAccent" : "Tilde";
  if (formatCodeAsIndented(node2, state)) {
    const exit5 = state.enter("codeIndented");
    const value3 = state.indentLines(raw, map3);
    exit5();
    return value3;
  }
  const tracker = state.createTracker(info);
  const sequence = marker.repeat(Math.max(longestStreak(raw, marker) + 1, 3));
  const exit4 = state.enter("codeFenced");
  let value2 = tracker.move(sequence);
  if (node2.lang) {
    const subexit = state.enter(`codeFencedLang${suffix}`);
    value2 += tracker.move(
      state.safe(node2.lang, {
        before: value2,
        after: " ",
        encode: ["`"],
        ...tracker.current()
      })
    );
    subexit();
  }
  if (node2.lang && node2.meta) {
    const subexit = state.enter(`codeFencedMeta${suffix}`);
    value2 += tracker.move(" ");
    value2 += tracker.move(
      state.safe(node2.meta, {
        before: value2,
        after: "\n",
        encode: ["`"],
        ...tracker.current()
      })
    );
    subexit();
  }
  value2 += tracker.move("\n");
  if (raw) {
    value2 += tracker.move(raw + "\n");
  }
  value2 += tracker.move(sequence);
  exit4();
  return value2;
}
function map3(line, _2, blank) {
  return (blank ? "" : "    ") + line;
}

// node_modules/mdast-util-to-markdown/lib/util/check-quote.js
function checkQuote(state) {
  const marker = state.options.quote || '"';
  if (marker !== '"' && marker !== "'") {
    throw new Error(
      "Cannot serialize title with `" + marker + "` for `options.quote`, expected `\"`, or `'`"
    );
  }
  return marker;
}

// node_modules/mdast-util-to-markdown/lib/handle/definition.js
function definition(node2, _2, state, info) {
  const quote = checkQuote(state);
  const suffix = quote === '"' ? "Quote" : "Apostrophe";
  const exit4 = state.enter("definition");
  let subexit = state.enter("label");
  const tracker = state.createTracker(info);
  let value2 = tracker.move("[");
  value2 += tracker.move(
    state.safe(state.associationId(node2), {
      before: value2,
      after: "]",
      ...tracker.current()
    })
  );
  value2 += tracker.move("]: ");
  subexit();
  if (
    // If there’s no url, or…
    !node2.url || // If there are control characters or whitespace.
    /[\0- \u007F]/.test(node2.url)
  ) {
    subexit = state.enter("destinationLiteral");
    value2 += tracker.move("<");
    value2 += tracker.move(
      state.safe(node2.url, { before: value2, after: ">", ...tracker.current() })
    );
    value2 += tracker.move(">");
  } else {
    subexit = state.enter("destinationRaw");
    value2 += tracker.move(
      state.safe(node2.url, {
        before: value2,
        after: node2.title ? " " : "\n",
        ...tracker.current()
      })
    );
  }
  subexit();
  if (node2.title) {
    subexit = state.enter(`title${suffix}`);
    value2 += tracker.move(" " + quote);
    value2 += tracker.move(
      state.safe(node2.title, {
        before: value2,
        after: quote,
        ...tracker.current()
      })
    );
    value2 += tracker.move(quote);
    subexit();
  }
  exit4();
  return value2;
}

// node_modules/mdast-util-to-markdown/lib/util/check-emphasis.js
function checkEmphasis(state) {
  const marker = state.options.emphasis || "*";
  if (marker !== "*" && marker !== "_") {
    throw new Error(
      "Cannot serialize emphasis with `" + marker + "` for `options.emphasis`, expected `*`, or `_`"
    );
  }
  return marker;
}

// node_modules/mdast-util-to-markdown/lib/util/encode-character-reference.js
function encodeCharacterReference(code3) {
  return "&#x" + code3.toString(16).toUpperCase() + ";";
}

// node_modules/mdast-util-to-markdown/lib/util/encode-info.js
function encodeInfo(outside, inside, marker) {
  const outsideKind = classifyCharacter(outside);
  const insideKind = classifyCharacter(inside);
  if (outsideKind === void 0) {
    return insideKind === void 0 ? (
      // Letter inside:
      // we have to encode *both* letters for `_` as it is looser.
      // it already forms for `*` (and GFMs `~`).
      marker === "_" ? { inside: true, outside: true } : { inside: false, outside: false }
    ) : insideKind === 1 ? (
      // Whitespace inside: encode both (letter, whitespace).
      { inside: true, outside: true }
    ) : (
      // Punctuation inside: encode outer (letter)
      { inside: false, outside: true }
    );
  }
  if (outsideKind === 1) {
    return insideKind === void 0 ? (
      // Letter inside: already forms.
      { inside: false, outside: false }
    ) : insideKind === 1 ? (
      // Whitespace inside: encode both (whitespace).
      { inside: true, outside: true }
    ) : (
      // Punctuation inside: already forms.
      { inside: false, outside: false }
    );
  }
  return insideKind === void 0 ? (
    // Letter inside: already forms.
    { inside: false, outside: false }
  ) : insideKind === 1 ? (
    // Whitespace inside: encode inner (whitespace).
    { inside: true, outside: false }
  ) : (
    // Punctuation inside: already forms.
    { inside: false, outside: false }
  );
}

// node_modules/mdast-util-to-markdown/lib/handle/emphasis.js
emphasis.peek = emphasisPeek;
function emphasis(node2, _2, state, info) {
  const marker = checkEmphasis(state);
  const exit4 = state.enter("emphasis");
  const tracker = state.createTracker(info);
  const before = tracker.move(marker);
  let between2 = tracker.move(
    state.containerPhrasing(node2, {
      after: marker,
      before,
      ...tracker.current()
    })
  );
  const betweenHead = between2.charCodeAt(0);
  const open = encodeInfo(
    info.before.charCodeAt(info.before.length - 1),
    betweenHead,
    marker
  );
  if (open.inside) {
    between2 = encodeCharacterReference(betweenHead) + between2.slice(1);
  }
  const betweenTail = between2.charCodeAt(between2.length - 1);
  const close2 = encodeInfo(info.after.charCodeAt(0), betweenTail, marker);
  if (close2.inside) {
    between2 = between2.slice(0, -1) + encodeCharacterReference(betweenTail);
  }
  const after = tracker.move(marker);
  exit4();
  state.attentionEncodeSurroundingInfo = {
    after: close2.outside,
    before: open.outside
  };
  return before + between2 + after;
}
function emphasisPeek(_2, _1, state) {
  return state.options.emphasis || "*";
}

// node_modules/unist-util-is/lib/index.js
var convert = (
  // Note: overloads in JSDoc can’t yet use different `@template`s.
  /**
   * @type {(
   *   (<Condition extends string>(test: Condition) => (node: unknown, index?: number | null | undefined, parent?: Parent | null | undefined, context?: unknown) => node is Node & {type: Condition}) &
   *   (<Condition extends Props>(test: Condition) => (node: unknown, index?: number | null | undefined, parent?: Parent | null | undefined, context?: unknown) => node is Node & Condition) &
   *   (<Condition extends TestFunction>(test: Condition) => (node: unknown, index?: number | null | undefined, parent?: Parent | null | undefined, context?: unknown) => node is Node & Predicate<Condition, Node>) &
   *   ((test?: null | undefined) => (node?: unknown, index?: number | null | undefined, parent?: Parent | null | undefined, context?: unknown) => node is Node) &
   *   ((test?: Test) => Check)
   * )}
   */
  /**
   * @param {Test} [test]
   * @returns {Check}
   */
  function(test) {
    if (test === null || test === void 0) {
      return ok2;
    }
    if (typeof test === "function") {
      return castFactory(test);
    }
    if (typeof test === "object") {
      return Array.isArray(test) ? anyFactory(test) : propsFactory(test);
    }
    if (typeof test === "string") {
      return typeFactory(test);
    }
    throw new Error("Expected function, string, or object as test");
  }
);
function anyFactory(tests) {
  const checks = [];
  let index3 = -1;
  while (++index3 < tests.length) {
    checks[index3] = convert(tests[index3]);
  }
  return castFactory(any);
  function any(...parameters) {
    let index4 = -1;
    while (++index4 < checks.length) {
      if (checks[index4].apply(this, parameters)) return true;
    }
    return false;
  }
}
function propsFactory(check) {
  const checkAsRecord = (
    /** @type {Record<string, unknown>} */
    check
  );
  return castFactory(all2);
  function all2(node2) {
    const nodeAsRecord = (
      /** @type {Record<string, unknown>} */
      /** @type {unknown} */
      node2
    );
    let key2;
    for (key2 in check) {
      if (nodeAsRecord[key2] !== checkAsRecord[key2]) return false;
    }
    return true;
  }
}
function typeFactory(check) {
  return castFactory(type2);
  function type2(node2) {
    return node2 && node2.type === check;
  }
}
function castFactory(testFunction) {
  return check;
  function check(value2, index3, parent) {
    return Boolean(
      looksLikeANode(value2) && testFunction.call(
        this,
        value2,
        typeof index3 === "number" ? index3 : void 0,
        parent || void 0
      )
    );
  }
}
function ok2() {
  return true;
}
function looksLikeANode(value2) {
  return value2 !== null && typeof value2 === "object" && "type" in value2;
}

// node_modules/unist-util-visit-parents/lib/color.js
function color2(d3) {
  return d3;
}

// node_modules/unist-util-visit-parents/lib/index.js
var empty2 = [];
var CONTINUE2 = true;
var EXIT2 = false;
var SKIP2 = "skip";
function visitParents(tree, test, visitor, reverse) {
  let check;
  if (typeof test === "function" && typeof visitor !== "function") {
    reverse = visitor;
    visitor = test;
  } else {
    check = test;
  }
  const is2 = convert(check);
  const step = reverse ? -1 : 1;
  factory(tree, void 0, [])();
  function factory(node2, index3, parents) {
    const value2 = (
      /** @type {Record<string, unknown>} */
      node2 && typeof node2 === "object" ? node2 : {}
    );
    if (typeof value2.type === "string") {
      const name2 = (
        // `hast`
        typeof value2.tagName === "string" ? value2.tagName : (
          // `xast`
          typeof value2.name === "string" ? value2.name : void 0
        )
      );
      Object.defineProperty(visit3, "name", {
        value: "node (" + color2(node2.type + (name2 ? "<" + name2 + ">" : "")) + ")"
      });
    }
    return visit3;
    function visit3() {
      let result = empty2;
      let subresult;
      let offset5;
      let grandparents;
      if (!test || is2(node2, index3, parents[parents.length - 1] || void 0)) {
        result = toResult2(visitor(node2, parents));
        if (result[0] === EXIT2) {
          return result;
        }
      }
      if ("children" in node2 && node2.children) {
        const nodeAsParent = (
          /** @type {UnistParent} */
          node2
        );
        if (nodeAsParent.children && result[0] !== SKIP2) {
          offset5 = (reverse ? nodeAsParent.children.length : -1) + step;
          grandparents = parents.concat(nodeAsParent);
          while (offset5 > -1 && offset5 < nodeAsParent.children.length) {
            const child = nodeAsParent.children[offset5];
            subresult = factory(child, offset5, grandparents)();
            if (subresult[0] === EXIT2) {
              return subresult;
            }
            offset5 = typeof subresult[1] === "number" ? subresult[1] : offset5 + step;
          }
        }
      }
      return result;
    }
  }
}
function toResult2(value2) {
  if (Array.isArray(value2)) {
    return value2;
  }
  if (typeof value2 === "number") {
    return [CONTINUE2, value2];
  }
  return value2 === null || value2 === void 0 ? empty2 : [value2];
}

// node_modules/unist-util-visit/lib/index.js
function visit2(tree, testOrVisitor, visitorOrReverse, maybeReverse) {
  let reverse;
  let test;
  let visitor;
  if (typeof testOrVisitor === "function" && typeof visitorOrReverse !== "function") {
    test = void 0;
    visitor = testOrVisitor;
    reverse = visitorOrReverse;
  } else {
    test = testOrVisitor;
    visitor = visitorOrReverse;
    reverse = maybeReverse;
  }
  visitParents(tree, test, overload, reverse);
  function overload(node2, parents) {
    const parent = parents[parents.length - 1];
    const index3 = parent ? parent.children.indexOf(node2) : void 0;
    return visitor(node2, index3, parent);
  }
}

// node_modules/mdast-util-to-string/lib/index.js
var emptyOptions2 = {};
function toString(value2, options) {
  const settings = options || emptyOptions2;
  const includeImageAlt = typeof settings.includeImageAlt === "boolean" ? settings.includeImageAlt : true;
  const includeHtml = typeof settings.includeHtml === "boolean" ? settings.includeHtml : true;
  return one(value2, includeImageAlt, includeHtml);
}
function one(value2, includeImageAlt, includeHtml) {
  if (node(value2)) {
    if ("value" in value2) {
      return value2.type === "html" && !includeHtml ? "" : value2.value;
    }
    if (includeImageAlt && "alt" in value2 && value2.alt) {
      return value2.alt;
    }
    if ("children" in value2) {
      return all(value2.children, includeImageAlt, includeHtml);
    }
  }
  if (Array.isArray(value2)) {
    return all(value2, includeImageAlt, includeHtml);
  }
  return "";
}
function all(values2, includeImageAlt, includeHtml) {
  const result = [];
  let index3 = -1;
  while (++index3 < values2.length) {
    result[index3] = one(values2[index3], includeImageAlt, includeHtml);
  }
  return result.join("");
}
function node(value2) {
  return Boolean(value2 && typeof value2 === "object");
}

// node_modules/mdast-util-to-markdown/lib/util/format-heading-as-setext.js
function formatHeadingAsSetext(node2, state) {
  let literalWithBreak = false;
  visit2(node2, function(node3) {
    if ("value" in node3 && /\r?\n|\r/.test(node3.value) || node3.type === "break") {
      literalWithBreak = true;
      return EXIT2;
    }
  });
  return Boolean(
    (!node2.depth || node2.depth < 3) && toString(node2) && (state.options.setext || literalWithBreak)
  );
}

// node_modules/mdast-util-to-markdown/lib/handle/heading.js
function heading(node2, _2, state, info) {
  const rank = Math.max(Math.min(6, node2.depth || 1), 1);
  const tracker = state.createTracker(info);
  if (formatHeadingAsSetext(node2, state)) {
    const exit5 = state.enter("headingSetext");
    const subexit2 = state.enter("phrasing");
    const value3 = state.containerPhrasing(node2, {
      ...tracker.current(),
      before: "\n",
      after: "\n"
    });
    subexit2();
    exit5();
    return value3 + "\n" + (rank === 1 ? "=" : "-").repeat(
      // The whole size…
      value3.length - // Minus the position of the character after the last EOL (or
      // 0 if there is none)…
      (Math.max(value3.lastIndexOf("\r"), value3.lastIndexOf("\n")) + 1)
    );
  }
  const sequence = "#".repeat(rank);
  const exit4 = state.enter("headingAtx");
  const subexit = state.enter("phrasing");
  tracker.move(sequence + " ");
  let value2 = state.containerPhrasing(node2, {
    before: "# ",
    after: "\n",
    ...tracker.current()
  });
  if (/^[\t ]/.test(value2)) {
    value2 = encodeCharacterReference(value2.charCodeAt(0)) + value2.slice(1);
  }
  value2 = value2 ? sequence + " " + value2 : sequence;
  if (state.options.closeAtx) {
    value2 += " " + sequence;
  }
  subexit();
  exit4();
  return value2;
}

// node_modules/mdast-util-to-markdown/lib/handle/html.js
html2.peek = htmlPeek;
function html2(node2) {
  return node2.value || "";
}
function htmlPeek() {
  return "<";
}

// node_modules/mdast-util-to-markdown/lib/handle/image.js
image.peek = imagePeek;
function image(node2, _2, state, info) {
  const quote = checkQuote(state);
  const suffix = quote === '"' ? "Quote" : "Apostrophe";
  const exit4 = state.enter("image");
  let subexit = state.enter("label");
  const tracker = state.createTracker(info);
  let value2 = tracker.move("![");
  value2 += tracker.move(
    state.safe(node2.alt, { before: value2, after: "]", ...tracker.current() })
  );
  value2 += tracker.move("](");
  subexit();
  if (
    // If there’s no url but there is a title…
    !node2.url && node2.title || // If there are control characters or whitespace.
    /[\0- \u007F]/.test(node2.url)
  ) {
    subexit = state.enter("destinationLiteral");
    value2 += tracker.move("<");
    value2 += tracker.move(
      state.safe(node2.url, { before: value2, after: ">", ...tracker.current() })
    );
    value2 += tracker.move(">");
  } else {
    subexit = state.enter("destinationRaw");
    value2 += tracker.move(
      state.safe(node2.url, {
        before: value2,
        after: node2.title ? " " : ")",
        ...tracker.current()
      })
    );
  }
  subexit();
  if (node2.title) {
    subexit = state.enter(`title${suffix}`);
    value2 += tracker.move(" " + quote);
    value2 += tracker.move(
      state.safe(node2.title, {
        before: value2,
        after: quote,
        ...tracker.current()
      })
    );
    value2 += tracker.move(quote);
    subexit();
  }
  value2 += tracker.move(")");
  exit4();
  return value2;
}
function imagePeek() {
  return "!";
}

// node_modules/mdast-util-to-markdown/lib/handle/image-reference.js
imageReference.peek = imageReferencePeek;
function imageReference(node2, _2, state, info) {
  const type2 = node2.referenceType;
  const exit4 = state.enter("imageReference");
  let subexit = state.enter("label");
  const tracker = state.createTracker(info);
  let value2 = tracker.move("![");
  const alt = state.safe(node2.alt, {
    before: value2,
    after: "]",
    ...tracker.current()
  });
  value2 += tracker.move(alt + "][");
  subexit();
  const stack = state.stack;
  state.stack = [];
  subexit = state.enter("reference");
  const reference = state.safe(state.associationId(node2), {
    before: value2,
    after: "]",
    ...tracker.current()
  });
  subexit();
  state.stack = stack;
  exit4();
  if (type2 === "full" || !alt || alt !== reference) {
    value2 += tracker.move(reference + "]");
  } else if (type2 === "shortcut") {
    value2 = value2.slice(0, -1);
  } else {
    value2 += tracker.move("]");
  }
  return value2;
}
function imageReferencePeek() {
  return "!";
}

// node_modules/mdast-util-to-markdown/lib/handle/inline-code.js
inlineCode.peek = inlineCodePeek;
function inlineCode(node2, _2, state) {
  let value2 = node2.value || "";
  let sequence = "`";
  let index3 = -1;
  while (new RegExp("(^|[^`])" + sequence + "([^`]|$)").test(value2)) {
    sequence += "`";
  }
  if (/[^ \r\n]/.test(value2) && (/^[ \r\n]/.test(value2) && /[ \r\n]$/.test(value2) || /^`|`$/.test(value2))) {
    value2 = " " + value2 + " ";
  }
  while (++index3 < state.unsafe.length) {
    const pattern = state.unsafe[index3];
    const expression = state.compilePattern(pattern);
    let match;
    if (!pattern.atBreak) continue;
    while (match = expression.exec(value2)) {
      let position2 = match.index;
      if (value2.charCodeAt(position2) === 10 && value2.charCodeAt(position2 - 1) === 13) {
        position2--;
      }
      value2 = value2.slice(0, position2) + " " + value2.slice(match.index + 1);
    }
  }
  return sequence + value2 + sequence;
}
function inlineCodePeek() {
  return "`";
}

// node_modules/mdast-util-to-markdown/lib/util/format-link-as-autolink.js
function formatLinkAsAutolink(node2, state) {
  const raw = toString(node2);
  return Boolean(
    !state.options.resourceLink && // If there’s a url…
    node2.url && // And there’s a no title…
    !node2.title && // And the content of `node` is a single text node…
    node2.children && node2.children.length === 1 && node2.children[0].type === "text" && // And if the url is the same as the content…
    (raw === node2.url || "mailto:" + raw === node2.url) && // And that starts w/ a protocol…
    /^[a-z][a-z+.-]+:/i.test(node2.url) && // And that doesn’t contain ASCII control codes (character escapes and
    // references don’t work), space, or angle brackets…
    !/[\0- <>\u007F]/.test(node2.url)
  );
}

// node_modules/mdast-util-to-markdown/lib/handle/link.js
link.peek = linkPeek;
function link(node2, _2, state, info) {
  const quote = checkQuote(state);
  const suffix = quote === '"' ? "Quote" : "Apostrophe";
  const tracker = state.createTracker(info);
  let exit4;
  let subexit;
  if (formatLinkAsAutolink(node2, state)) {
    const stack = state.stack;
    state.stack = [];
    exit4 = state.enter("autolink");
    let value3 = tracker.move("<");
    value3 += tracker.move(
      state.containerPhrasing(node2, {
        before: value3,
        after: ">",
        ...tracker.current()
      })
    );
    value3 += tracker.move(">");
    exit4();
    state.stack = stack;
    return value3;
  }
  exit4 = state.enter("link");
  subexit = state.enter("label");
  let value2 = tracker.move("[");
  value2 += tracker.move(
    state.containerPhrasing(node2, {
      before: value2,
      after: "](",
      ...tracker.current()
    })
  );
  value2 += tracker.move("](");
  subexit();
  if (
    // If there’s no url but there is a title…
    !node2.url && node2.title || // If there are control characters or whitespace.
    /[\0- \u007F]/.test(node2.url)
  ) {
    subexit = state.enter("destinationLiteral");
    value2 += tracker.move("<");
    value2 += tracker.move(
      state.safe(node2.url, { before: value2, after: ">", ...tracker.current() })
    );
    value2 += tracker.move(">");
  } else {
    subexit = state.enter("destinationRaw");
    value2 += tracker.move(
      state.safe(node2.url, {
        before: value2,
        after: node2.title ? " " : ")",
        ...tracker.current()
      })
    );
  }
  subexit();
  if (node2.title) {
    subexit = state.enter(`title${suffix}`);
    value2 += tracker.move(" " + quote);
    value2 += tracker.move(
      state.safe(node2.title, {
        before: value2,
        after: quote,
        ...tracker.current()
      })
    );
    value2 += tracker.move(quote);
    subexit();
  }
  value2 += tracker.move(")");
  exit4();
  return value2;
}
function linkPeek(node2, _2, state) {
  return formatLinkAsAutolink(node2, state) ? "<" : "[";
}

// node_modules/mdast-util-to-markdown/lib/handle/link-reference.js
linkReference.peek = linkReferencePeek;
function linkReference(node2, _2, state, info) {
  const type2 = node2.referenceType;
  const exit4 = state.enter("linkReference");
  let subexit = state.enter("label");
  const tracker = state.createTracker(info);
  let value2 = tracker.move("[");
  const text4 = state.containerPhrasing(node2, {
    before: value2,
    after: "]",
    ...tracker.current()
  });
  value2 += tracker.move(text4 + "][");
  subexit();
  const stack = state.stack;
  state.stack = [];
  subexit = state.enter("reference");
  const reference = state.safe(state.associationId(node2), {
    before: value2,
    after: "]",
    ...tracker.current()
  });
  subexit();
  state.stack = stack;
  exit4();
  if (type2 === "full" || !text4 || text4 !== reference) {
    value2 += tracker.move(reference + "]");
  } else if (type2 === "shortcut") {
    value2 = value2.slice(0, -1);
  } else {
    value2 += tracker.move("]");
  }
  return value2;
}
function linkReferencePeek() {
  return "[";
}

// node_modules/mdast-util-to-markdown/lib/util/check-bullet.js
function checkBullet(state) {
  const marker = state.options.bullet || "*";
  if (marker !== "*" && marker !== "+" && marker !== "-") {
    throw new Error(
      "Cannot serialize items with `" + marker + "` for `options.bullet`, expected `*`, `+`, or `-`"
    );
  }
  return marker;
}

// node_modules/mdast-util-to-markdown/lib/util/check-bullet-other.js
function checkBulletOther(state) {
  const bullet = checkBullet(state);
  const bulletOther = state.options.bulletOther;
  if (!bulletOther) {
    return bullet === "*" ? "-" : "*";
  }
  if (bulletOther !== "*" && bulletOther !== "+" && bulletOther !== "-") {
    throw new Error(
      "Cannot serialize items with `" + bulletOther + "` for `options.bulletOther`, expected `*`, `+`, or `-`"
    );
  }
  if (bulletOther === bullet) {
    throw new Error(
      "Expected `bullet` (`" + bullet + "`) and `bulletOther` (`" + bulletOther + "`) to be different"
    );
  }
  return bulletOther;
}

// node_modules/mdast-util-to-markdown/lib/util/check-bullet-ordered.js
function checkBulletOrdered(state) {
  const marker = state.options.bulletOrdered || ".";
  if (marker !== "." && marker !== ")") {
    throw new Error(
      "Cannot serialize items with `" + marker + "` for `options.bulletOrdered`, expected `.` or `)`"
    );
  }
  return marker;
}

// node_modules/mdast-util-to-markdown/lib/util/check-rule.js
function checkRule(state) {
  const marker = state.options.rule || "*";
  if (marker !== "*" && marker !== "-" && marker !== "_") {
    throw new Error(
      "Cannot serialize rules with `" + marker + "` for `options.rule`, expected `*`, `-`, or `_`"
    );
  }
  return marker;
}

// node_modules/mdast-util-to-markdown/lib/handle/list.js
function list2(node2, parent, state, info) {
  const exit4 = state.enter("list");
  const bulletCurrent = state.bulletCurrent;
  let bullet = node2.ordered ? checkBulletOrdered(state) : checkBullet(state);
  const bulletOther = node2.ordered ? bullet === "." ? ")" : "." : checkBulletOther(state);
  let useDifferentMarker = parent && state.bulletLastUsed ? bullet === state.bulletLastUsed : false;
  if (!node2.ordered) {
    const firstListItem = node2.children ? node2.children[0] : void 0;
    if (
      // Bullet could be used as a thematic break marker:
      (bullet === "*" || bullet === "-") && // Empty first list item:
      firstListItem && (!firstListItem.children || !firstListItem.children[0]) && // Directly in two other list items:
      state.stack[state.stack.length - 1] === "list" && state.stack[state.stack.length - 2] === "listItem" && state.stack[state.stack.length - 3] === "list" && state.stack[state.stack.length - 4] === "listItem" && // That are each the first child.
      state.indexStack[state.indexStack.length - 1] === 0 && state.indexStack[state.indexStack.length - 2] === 0 && state.indexStack[state.indexStack.length - 3] === 0
    ) {
      useDifferentMarker = true;
    }
    if (checkRule(state) === bullet && firstListItem) {
      let index3 = -1;
      while (++index3 < node2.children.length) {
        const item = node2.children[index3];
        if (item && item.type === "listItem" && item.children && item.children[0] && item.children[0].type === "thematicBreak") {
          useDifferentMarker = true;
          break;
        }
      }
    }
  }
  if (useDifferentMarker) {
    bullet = bulletOther;
  }
  state.bulletCurrent = bullet;
  const value2 = state.containerFlow(node2, info);
  state.bulletLastUsed = bullet;
  state.bulletCurrent = bulletCurrent;
  exit4();
  return value2;
}

// node_modules/mdast-util-to-markdown/lib/util/check-list-item-indent.js
function checkListItemIndent(state) {
  const style = state.options.listItemIndent || "one";
  if (style !== "tab" && style !== "one" && style !== "mixed") {
    throw new Error(
      "Cannot serialize items with `" + style + "` for `options.listItemIndent`, expected `tab`, `one`, or `mixed`"
    );
  }
  return style;
}

// node_modules/mdast-util-to-markdown/lib/handle/list-item.js
function listItem(node2, parent, state, info) {
  const listItemIndent = checkListItemIndent(state);
  let bullet = state.bulletCurrent || checkBullet(state);
  if (parent && parent.type === "list" && parent.ordered) {
    bullet = (typeof parent.start === "number" && parent.start > -1 ? parent.start : 1) + (state.options.incrementListMarker === false ? 0 : parent.children.indexOf(node2)) + bullet;
  }
  let size4 = bullet.length + 1;
  if (listItemIndent === "tab" || listItemIndent === "mixed" && (parent && parent.type === "list" && parent.spread || node2.spread)) {
    size4 = Math.ceil(size4 / 4) * 4;
  }
  const tracker = state.createTracker(info);
  tracker.move(bullet + " ".repeat(size4 - bullet.length));
  tracker.shift(size4);
  const exit4 = state.enter("listItem");
  const value2 = state.indentLines(
    state.containerFlow(node2, tracker.current()),
    map5
  );
  exit4();
  return value2;
  function map5(line, index3, blank) {
    if (index3) {
      return (blank ? "" : " ".repeat(size4)) + line;
    }
    return (blank ? bullet : bullet + " ".repeat(size4 - bullet.length)) + line;
  }
}

// node_modules/mdast-util-to-markdown/lib/handle/paragraph.js
function paragraph(node2, _2, state, info) {
  const exit4 = state.enter("paragraph");
  const subexit = state.enter("phrasing");
  const value2 = state.containerPhrasing(node2, info);
  subexit();
  exit4();
  return value2;
}

// node_modules/mdast-util-phrasing/lib/index.js
var phrasing = (
  /** @type {(node?: unknown) => node is Exclude<PhrasingContent, Html>} */
  convert([
    "break",
    "delete",
    "emphasis",
    // To do: next major: removed since footnotes were added to GFM.
    "footnote",
    "footnoteReference",
    "image",
    "imageReference",
    "inlineCode",
    // Enabled by `mdast-util-math`:
    "inlineMath",
    "link",
    "linkReference",
    // Enabled by `mdast-util-mdx`:
    "mdxJsxTextElement",
    // Enabled by `mdast-util-mdx`:
    "mdxTextExpression",
    "strong",
    "text",
    // Enabled by `mdast-util-directive`:
    "textDirective"
  ])
);

// node_modules/mdast-util-to-markdown/lib/handle/root.js
function root(node2, _2, state, info) {
  const hasPhrasing = node2.children.some(function(d3) {
    return phrasing(d3);
  });
  const container = hasPhrasing ? state.containerPhrasing : state.containerFlow;
  return container.call(state, node2, info);
}

// node_modules/mdast-util-to-markdown/lib/util/check-strong.js
function checkStrong(state) {
  const marker = state.options.strong || "*";
  if (marker !== "*" && marker !== "_") {
    throw new Error(
      "Cannot serialize strong with `" + marker + "` for `options.strong`, expected `*`, or `_`"
    );
  }
  return marker;
}

// node_modules/mdast-util-to-markdown/lib/handle/strong.js
strong.peek = strongPeek;
function strong(node2, _2, state, info) {
  const marker = checkStrong(state);
  const exit4 = state.enter("strong");
  const tracker = state.createTracker(info);
  const before = tracker.move(marker + marker);
  let between2 = tracker.move(
    state.containerPhrasing(node2, {
      after: marker,
      before,
      ...tracker.current()
    })
  );
  const betweenHead = between2.charCodeAt(0);
  const open = encodeInfo(
    info.before.charCodeAt(info.before.length - 1),
    betweenHead,
    marker
  );
  if (open.inside) {
    between2 = encodeCharacterReference(betweenHead) + between2.slice(1);
  }
  const betweenTail = between2.charCodeAt(between2.length - 1);
  const close2 = encodeInfo(info.after.charCodeAt(0), betweenTail, marker);
  if (close2.inside) {
    between2 = between2.slice(0, -1) + encodeCharacterReference(betweenTail);
  }
  const after = tracker.move(marker + marker);
  exit4();
  state.attentionEncodeSurroundingInfo = {
    after: close2.outside,
    before: open.outside
  };
  return before + between2 + after;
}
function strongPeek(_2, _1, state) {
  return state.options.strong || "*";
}

// node_modules/mdast-util-to-markdown/lib/handle/text.js
function text(node2, _2, state, info) {
  return state.safe(node2.value, info);
}

// node_modules/mdast-util-to-markdown/lib/util/check-rule-repetition.js
function checkRuleRepetition(state) {
  const repetition = state.options.ruleRepetition || 3;
  if (repetition < 3) {
    throw new Error(
      "Cannot serialize rules with repetition `" + repetition + "` for `options.ruleRepetition`, expected `3` or more"
    );
  }
  return repetition;
}

// node_modules/mdast-util-to-markdown/lib/handle/thematic-break.js
function thematicBreak(_2, _1, state) {
  const value2 = (checkRule(state) + (state.options.ruleSpaces ? " " : "")).repeat(checkRuleRepetition(state));
  return state.options.ruleSpaces ? value2.slice(0, -1) : value2;
}

// node_modules/mdast-util-to-markdown/lib/handle/index.js
var handle = {
  blockquote,
  break: hardBreak,
  code,
  definition,
  emphasis,
  hardBreak,
  heading,
  html: html2,
  image,
  imageReference,
  inlineCode,
  link,
  linkReference,
  list: list2,
  listItem,
  paragraph,
  root,
  strong,
  text,
  thematicBreak
};

// node_modules/mdast-util-to-markdown/lib/join.js
var join = [joinDefaults];
function joinDefaults(left, right, parent, state) {
  if (right.type === "code" && formatCodeAsIndented(right, state) && (left.type === "list" || left.type === right.type && formatCodeAsIndented(left, state))) {
    return false;
  }
  if ("spread" in parent && typeof parent.spread === "boolean") {
    if (left.type === "paragraph" && // Two paragraphs.
    (left.type === right.type || right.type === "definition" || // Paragraph followed by a setext heading.
    right.type === "heading" && formatHeadingAsSetext(right, state))) {
      return;
    }
    return parent.spread ? 1 : 0;
  }
}

// node_modules/mdast-util-to-markdown/lib/unsafe.js
var fullPhrasingSpans = [
  "autolink",
  "destinationLiteral",
  "destinationRaw",
  "reference",
  "titleQuote",
  "titleApostrophe"
];
var unsafe = [
  { character: "	", after: "[\\r\\n]", inConstruct: "phrasing" },
  { character: "	", before: "[\\r\\n]", inConstruct: "phrasing" },
  {
    character: "	",
    inConstruct: ["codeFencedLangGraveAccent", "codeFencedLangTilde"]
  },
  {
    character: "\r",
    inConstruct: [
      "codeFencedLangGraveAccent",
      "codeFencedLangTilde",
      "codeFencedMetaGraveAccent",
      "codeFencedMetaTilde",
      "destinationLiteral",
      "headingAtx"
    ]
  },
  {
    character: "\n",
    inConstruct: [
      "codeFencedLangGraveAccent",
      "codeFencedLangTilde",
      "codeFencedMetaGraveAccent",
      "codeFencedMetaTilde",
      "destinationLiteral",
      "headingAtx"
    ]
  },
  { character: " ", after: "[\\r\\n]", inConstruct: "phrasing" },
  { character: " ", before: "[\\r\\n]", inConstruct: "phrasing" },
  {
    character: " ",
    inConstruct: ["codeFencedLangGraveAccent", "codeFencedLangTilde"]
  },
  // An exclamation mark can start an image, if it is followed by a link or
  // a link reference.
  {
    character: "!",
    after: "\\[",
    inConstruct: "phrasing",
    notInConstruct: fullPhrasingSpans
  },
  // A quote can break out of a title.
  { character: '"', inConstruct: "titleQuote" },
  // A number sign could start an ATX heading if it starts a line.
  { atBreak: true, character: "#" },
  { character: "#", inConstruct: "headingAtx", after: "(?:[\r\n]|$)" },
  // Dollar sign and percentage are not used in markdown.
  // An ampersand could start a character reference.
  { character: "&", after: "[#A-Za-z]", inConstruct: "phrasing" },
  // An apostrophe can break out of a title.
  { character: "'", inConstruct: "titleApostrophe" },
  // A left paren could break out of a destination raw.
  { character: "(", inConstruct: "destinationRaw" },
  // A left paren followed by `]` could make something into a link or image.
  {
    before: "\\]",
    character: "(",
    inConstruct: "phrasing",
    notInConstruct: fullPhrasingSpans
  },
  // A right paren could start a list item or break out of a destination
  // raw.
  { atBreak: true, before: "\\d+", character: ")" },
  { character: ")", inConstruct: "destinationRaw" },
  // An asterisk can start thematic breaks, list items, emphasis, strong.
  { atBreak: true, character: "*", after: "(?:[ 	\r\n*])" },
  { character: "*", inConstruct: "phrasing", notInConstruct: fullPhrasingSpans },
  // A plus sign could start a list item.
  { atBreak: true, character: "+", after: "(?:[ 	\r\n])" },
  // A dash can start thematic breaks, list items, and setext heading
  // underlines.
  { atBreak: true, character: "-", after: "(?:[ 	\r\n-])" },
  // A dot could start a list item.
  { atBreak: true, before: "\\d+", character: ".", after: "(?:[ 	\r\n]|$)" },
  // Slash, colon, and semicolon are not used in markdown for constructs.
  // A less than can start html (flow or text) or an autolink.
  // HTML could start with an exclamation mark (declaration, cdata, comment),
  // slash (closing tag), question mark (instruction), or a letter (tag).
  // An autolink also starts with a letter.
  // Finally, it could break out of a destination literal.
  { atBreak: true, character: "<", after: "[!/?A-Za-z]" },
  {
    character: "<",
    after: "[!/?A-Za-z]",
    inConstruct: "phrasing",
    notInConstruct: fullPhrasingSpans
  },
  { character: "<", inConstruct: "destinationLiteral" },
  // An equals to can start setext heading underlines.
  { atBreak: true, character: "=" },
  // A greater than can start block quotes and it can break out of a
  // destination literal.
  { atBreak: true, character: ">" },
  { character: ">", inConstruct: "destinationLiteral" },
  // Question mark and at sign are not used in markdown for constructs.
  // A left bracket can start definitions, references, labels,
  { atBreak: true, character: "[" },
  { character: "[", inConstruct: "phrasing", notInConstruct: fullPhrasingSpans },
  { character: "[", inConstruct: ["label", "reference"] },
  // A backslash can start an escape (when followed by punctuation) or a
  // hard break (when followed by an eol).
  // Note: typical escapes are handled in `safe`!
  { character: "\\", after: "[\\r\\n]", inConstruct: "phrasing" },
  // A right bracket can exit labels.
  { character: "]", inConstruct: ["label", "reference"] },
  // Caret is not used in markdown for constructs.
  // An underscore can start emphasis, strong, or a thematic break.
  { atBreak: true, character: "_" },
  { character: "_", inConstruct: "phrasing", notInConstruct: fullPhrasingSpans },
  // A grave accent can start code (fenced or text), or it can break out of
  // a grave accent code fence.
  { atBreak: true, character: "`" },
  {
    character: "`",
    inConstruct: ["codeFencedLangGraveAccent", "codeFencedMetaGraveAccent"]
  },
  { character: "`", inConstruct: "phrasing", notInConstruct: fullPhrasingSpans },
  // Left brace, vertical bar, right brace are not used in markdown for
  // constructs.
  // A tilde can start code (fenced).
  { atBreak: true, character: "~" }
];

// node_modules/micromark-util-decode-numeric-character-reference/dev/index.js
function decodeNumericCharacterReference(value2, base) {
  const code3 = Number.parseInt(value2, base);
  if (
    // C0 except for HT, LF, FF, CR, space.
    code3 < codes.ht || code3 === codes.vt || code3 > codes.cr && code3 < codes.space || // Control character (DEL) of C0, and C1 controls.
    code3 > codes.tilde && code3 < 160 || // Lone high surrogates and low surrogates.
    code3 > 55295 && code3 < 57344 || // Noncharacters.
    code3 > 64975 && code3 < 65008 || /* eslint-disable no-bitwise */
    (code3 & 65535) === 65535 || (code3 & 65535) === 65534 || /* eslint-enable no-bitwise */
    // Out of range
    code3 > 1114111
  ) {
    return values.replacementCharacter;
  }
  return String.fromCodePoint(code3);
}

// node_modules/micromark-util-decode-string/dev/index.js
var characterEscapeOrReference = /\\([!-/:-@[-`{-~])|&(#(?:\d{1,7}|x[\da-f]{1,6})|[\da-z]{1,31});/gi;
function decodeString(value2) {
  return value2.replace(characterEscapeOrReference, decode);
}
function decode($0, $1, $22) {
  if ($1) {
    return $1;
  }
  const head = $22.charCodeAt(0);
  if (head === codes.numberSign) {
    const head2 = $22.charCodeAt(1);
    const hex = head2 === codes.lowercaseX || head2 === codes.uppercaseX;
    return decodeNumericCharacterReference(
      $22.slice(hex ? 2 : 1),
      hex ? constants.numericBaseHexadecimal : constants.numericBaseDecimal
    );
  }
  return decodeNamedCharacterReference($22) || $0;
}

// node_modules/mdast-util-to-markdown/lib/util/association.js
function association(node2) {
  if (node2.label || !node2.identifier) {
    return node2.label || "";
  }
  return decodeString(node2.identifier);
}

// node_modules/mdast-util-to-markdown/lib/util/compile-pattern.js
function compilePattern(pattern) {
  if (!pattern._compiled) {
    const before = (pattern.atBreak ? "[\\r\\n][\\t ]*" : "") + (pattern.before ? "(?:" + pattern.before + ")" : "");
    pattern._compiled = new RegExp(
      (before ? "(" + before + ")" : "") + (/[|\\{}()[\]^$+*?.-]/.test(pattern.character) ? "\\" : "") + pattern.character + (pattern.after ? "(?:" + pattern.after + ")" : ""),
      "g"
    );
  }
  return pattern._compiled;
}

// node_modules/mdast-util-to-markdown/lib/util/container-phrasing.js
function containerPhrasing(parent, state, info) {
  const indexStack = state.indexStack;
  const children = parent.children || [];
  const results = [];
  let index3 = -1;
  let before = info.before;
  let encodeAfter;
  indexStack.push(-1);
  let tracker = state.createTracker(info);
  while (++index3 < children.length) {
    const child = children[index3];
    let after;
    indexStack[indexStack.length - 1] = index3;
    if (index3 + 1 < children.length) {
      let handle2 = state.handle.handlers[children[index3 + 1].type];
      if (handle2 && handle2.peek) handle2 = handle2.peek;
      after = handle2 ? handle2(children[index3 + 1], parent, state, {
        before: "",
        after: "",
        ...tracker.current()
      }).charAt(0) : "";
    } else {
      after = info.after;
    }
    if (results.length > 0 && (before === "\r" || before === "\n") && child.type === "html") {
      results[results.length - 1] = results[results.length - 1].replace(
        /(\r?\n|\r)$/,
        " "
      );
      before = " ";
      tracker = state.createTracker(info);
      tracker.move(results.join(""));
    }
    let value2 = state.handle(child, parent, state, {
      ...tracker.current(),
      after,
      before
    });
    if (encodeAfter && encodeAfter === value2.slice(0, 1)) {
      value2 = encodeCharacterReference(encodeAfter.charCodeAt(0)) + value2.slice(1);
    }
    const encodingInfo = state.attentionEncodeSurroundingInfo;
    state.attentionEncodeSurroundingInfo = void 0;
    encodeAfter = void 0;
    if (encodingInfo) {
      if (results.length > 0 && encodingInfo.before && before === results[results.length - 1].slice(-1)) {
        results[results.length - 1] = results[results.length - 1].slice(0, -1) + encodeCharacterReference(before.charCodeAt(0));
      }
      if (encodingInfo.after) encodeAfter = after;
    }
    tracker.move(value2);
    results.push(value2);
    before = value2.slice(-1);
  }
  indexStack.pop();
  return results.join("");
}

// node_modules/mdast-util-to-markdown/lib/util/container-flow.js
function containerFlow2(parent, state, info) {
  const indexStack = state.indexStack;
  const children = parent.children || [];
  const tracker = state.createTracker(info);
  const results = [];
  let index3 = -1;
  indexStack.push(-1);
  while (++index3 < children.length) {
    const child = children[index3];
    indexStack[indexStack.length - 1] = index3;
    results.push(
      tracker.move(
        state.handle(child, parent, state, {
          before: "\n",
          after: "\n",
          ...tracker.current()
        })
      )
    );
    if (child.type !== "list") {
      state.bulletLastUsed = void 0;
    }
    if (index3 < children.length - 1) {
      results.push(
        tracker.move(between(child, children[index3 + 1], parent, state))
      );
    }
  }
  indexStack.pop();
  return results.join("");
}
function between(left, right, parent, state) {
  let index3 = state.join.length;
  while (index3--) {
    const result = state.join[index3](left, right, parent, state);
    if (result === true || result === 1) {
      break;
    }
    if (typeof result === "number") {
      return "\n".repeat(1 + result);
    }
    if (result === false) {
      return "\n\n<!---->\n\n";
    }
  }
  return "\n\n";
}

// node_modules/mdast-util-to-markdown/lib/util/indent-lines.js
var eol = /\r?\n|\r/g;
function indentLines(value2, map5) {
  const result = [];
  let start2 = 0;
  let line = 0;
  let match;
  while (match = eol.exec(value2)) {
    one2(value2.slice(start2, match.index));
    result.push(match[0]);
    start2 = match.index + match[0].length;
    line++;
  }
  one2(value2.slice(start2));
  return result.join("");
  function one2(value3) {
    result.push(map5(value3, line, !value3));
  }
}

// node_modules/mdast-util-to-markdown/lib/util/safe.js
function safe(state, input, config) {
  const value2 = (config.before || "") + (input || "") + (config.after || "");
  const positions = [];
  const result = [];
  const infos = {};
  let index3 = -1;
  while (++index3 < state.unsafe.length) {
    const pattern = state.unsafe[index3];
    if (!patternInScope(state.stack, pattern)) {
      continue;
    }
    const expression = state.compilePattern(pattern);
    let match;
    while (match = expression.exec(value2)) {
      const before = "before" in pattern || Boolean(pattern.atBreak);
      const after = "after" in pattern;
      const position2 = match.index + (before ? match[1].length : 0);
      if (positions.includes(position2)) {
        if (infos[position2].before && !before) {
          infos[position2].before = false;
        }
        if (infos[position2].after && !after) {
          infos[position2].after = false;
        }
      } else {
        positions.push(position2);
        infos[position2] = { before, after };
      }
    }
  }
  positions.sort(numerical);
  let start2 = config.before ? config.before.length : 0;
  const end = value2.length - (config.after ? config.after.length : 0);
  index3 = -1;
  while (++index3 < positions.length) {
    const position2 = positions[index3];
    if (position2 < start2 || position2 >= end) {
      continue;
    }
    if (position2 + 1 < end && positions[index3 + 1] === position2 + 1 && infos[position2].after && !infos[position2 + 1].before && !infos[position2 + 1].after || positions[index3 - 1] === position2 - 1 && infos[position2].before && !infos[position2 - 1].before && !infos[position2 - 1].after) {
      continue;
    }
    if (start2 !== position2) {
      result.push(escapeBackslashes(value2.slice(start2, position2), "\\"));
    }
    start2 = position2;
    if (/[!-/:-@[-`{-~]/.test(value2.charAt(position2)) && (!config.encode || !config.encode.includes(value2.charAt(position2)))) {
      result.push("\\");
    } else {
      result.push(encodeCharacterReference(value2.charCodeAt(position2)));
      start2++;
    }
  }
  result.push(escapeBackslashes(value2.slice(start2, end), config.after));
  return result.join("");
}
function numerical(a2, b3) {
  return a2 - b3;
}
function escapeBackslashes(value2, after) {
  const expression = /\\(?=[!-/:-@[-`{-~])/g;
  const positions = [];
  const results = [];
  const whole = value2 + after;
  let index3 = -1;
  let start2 = 0;
  let match;
  while (match = expression.exec(whole)) {
    positions.push(match.index);
  }
  while (++index3 < positions.length) {
    if (start2 !== positions[index3]) {
      results.push(value2.slice(start2, positions[index3]));
    }
    results.push("\\");
    start2 = positions[index3];
  }
  results.push(value2.slice(start2));
  return results.join("");
}

// node_modules/mdast-util-to-markdown/lib/util/track.js
function track(config) {
  const options = config || {};
  const now = options.now || {};
  let lineShift = options.lineShift || 0;
  let line = now.line || 1;
  let column = now.column || 1;
  return { move, current: current2, shift: shift4 };
  function current2() {
    return { now: { line, column }, lineShift };
  }
  function shift4(value2) {
    lineShift += value2;
  }
  function move(input) {
    const value2 = input || "";
    const chunks = value2.split(/\r?\n|\r/g);
    const tail = chunks[chunks.length - 1];
    line += chunks.length - 1;
    column = chunks.length === 1 ? column + tail.length : 1 + tail.length + lineShift;
    return value2;
  }
}

// node_modules/mdast-util-to-markdown/lib/index.js
function toMarkdown(tree, options) {
  const settings = options || {};
  const state = {
    associationId: association,
    containerPhrasing: containerPhrasingBound,
    containerFlow: containerFlowBound,
    createTracker: track,
    compilePattern,
    enter: enter2,
    // @ts-expect-error: GFM / frontmatter are typed in `mdast` but not defined
    // here.
    handlers: { ...handle },
    // @ts-expect-error: add `handle` in a second.
    handle: void 0,
    indentLines,
    indexStack: [],
    join: [...join],
    options: {},
    safe: safeBound,
    stack: [],
    unsafe: [...unsafe]
  };
  configure(state, settings);
  if (state.options.tightDefinitions) {
    state.join.push(joinDefinition);
  }
  state.handle = zwitch("type", {
    invalid,
    unknown,
    handlers: state.handlers
  });
  let result = state.handle(tree, void 0, state, {
    before: "\n",
    after: "\n",
    now: { line: 1, column: 1 },
    lineShift: 0
  });
  if (result && result.charCodeAt(result.length - 1) !== 10 && result.charCodeAt(result.length - 1) !== 13) {
    result += "\n";
  }
  return result;
  function enter2(name2) {
    state.stack.push(name2);
    return exit4;
    function exit4() {
      state.stack.pop();
    }
  }
}
function invalid(value2) {
  throw new Error("Cannot handle value `" + value2 + "`, expected node");
}
function unknown(value2) {
  const node2 = (
    /** @type {Nodes} */
    value2
  );
  throw new Error("Cannot handle unknown node `" + node2.type + "`");
}
function joinDefinition(left, right) {
  if (left.type === "definition" && left.type === right.type) {
    return 0;
  }
}
function containerPhrasingBound(parent, info) {
  return containerPhrasing(parent, this, info);
}
function containerFlowBound(parent, info) {
  return containerFlow2(parent, this, info);
}
function safeBound(value2, config) {
  return safe(this, value2, config);
}

// node_modules/@mdxeditor/editor/dist/plugins/core/MdastHTMLNode.js
var MDX_NODE_TYPES = ["mdxJsxTextElement", "mdxJsxFlowElement"];
function isMdastHTMLNode(node2) {
  return MDX_NODE_TYPES.includes(node2.type) && htmlTags.includes(node2.name.toLowerCase());
}
var htmlTags = [
  "a",
  "abbr",
  "address",
  "area",
  "article",
  "aside",
  "audio",
  "b",
  "base",
  "bdi",
  "bdo",
  "blockquote",
  "body",
  "br",
  "button",
  "canvas",
  "caption",
  "cite",
  "code",
  "col",
  "colgroup",
  "data",
  "datalist",
  "dd",
  "del",
  "details",
  "dfn",
  "dialog",
  "div",
  "dl",
  "dt",
  "em",
  "embed",
  "fieldset",
  "figcaption",
  "figure",
  "footer",
  "form",
  "h1",
  "h2",
  "h3",
  "h4",
  "h5",
  "h6",
  "head",
  "header",
  "hgroup",
  "hr",
  "html",
  "i",
  "iframe",
  // 'img',
  "input",
  "ins",
  "kbd",
  "label",
  "legend",
  "li",
  "link",
  "main",
  "map",
  "mark",
  "meta",
  "meter",
  "nav",
  "noscript",
  "object",
  "ol",
  "optgroup",
  "option",
  "output",
  "p",
  "param",
  "picture",
  "pre",
  "progress",
  "q",
  "rp",
  "rt",
  "ruby",
  "s",
  "samp",
  "script",
  "section",
  "select",
  "small",
  "source",
  "span",
  "strong",
  "style",
  "sub",
  "summary",
  "sup",
  "table",
  "tbody",
  "td",
  "template",
  "textarea",
  "tfoot",
  "th",
  "thead",
  "time",
  "title",
  "tr",
  "track",
  "u",
  "ul",
  "var",
  "video",
  "wbr"
];

// node_modules/@mdxeditor/editor/dist/utils/mergeStyleAttributes.js
function mergeStyleAttributes(style1, style2) {
  const styleObject1 = styleToObject(style1);
  const styleObject2 = styleToObject(style2);
  const mergedStyleObject = { ...styleObject1, ...styleObject2 };
  const mergedStyleString = objectToStyle(mergedStyleObject);
  return mergedStyleString;
}
function styleToObject(style) {
  const styleObject = {};
  const stylePairs = style.split(";").filter((pair) => pair.trim() !== "");
  stylePairs.forEach((pair) => {
    const [key2, value2] = pair.split(":").map((part) => part.trim());
    styleObject[key2] = value2;
  });
  return styleObject;
}
function objectToStyle(styleObject) {
  return Object.entries(styleObject).map(([key2, value2]) => `${key2}: ${value2}`).join("; ");
}

// node_modules/@mdxeditor/editor/dist/exportMarkdownFromLexical.js
function isParent(node2) {
  return node2.children instanceof Array;
}
function exportLexicalTreeToMdast({
  root: root2,
  visitors,
  jsxComponentDescriptors,
  jsxIsAvailable,
  addImportStatements = true
}) {
  let unistRoot = null;
  const referredComponents = /* @__PURE__ */ new Set();
  visitors = visitors.sort((a2, b3) => (b3.priority ?? 0) - (a2.priority ?? 0));
  visit3(root2, null);
  function registerReferredComponent(componentName) {
    referredComponents.add(componentName);
  }
  function appendToParent(parentNode, node2) {
    if (unistRoot === null) {
      unistRoot = node2;
      return unistRoot;
    }
    if (!isParent(parentNode)) {
      throw new Error("Attempting to append children to a non-parent");
    }
    const siblings = parentNode.children;
    const prevSibling = siblings.at(-1);
    if (prevSibling) {
      const joinVisitor = visitors.find((visitor) => {
        var _a2;
        return (_a2 = visitor.shouldJoin) == null ? void 0 : _a2.call(visitor, prevSibling, node2);
      });
      if (joinVisitor) {
        const joinedNode = joinVisitor.join(prevSibling, node2);
        siblings.splice(siblings.length - 1, 1, joinedNode);
        return joinedNode;
      }
    }
    siblings.push(node2);
    return node2;
  }
  function visitChildren(lexicalNode, parentNode) {
    lexicalNode.getChildren().forEach((lexicalChild) => {
      visit3(lexicalChild, parentNode);
    });
  }
  function visit3(lexicalNode, mdastParent) {
    var _a2;
    const visitor = visitors.find((visitor2) => {
      var _a22;
      return (_a22 = visitor2.testLexicalNode) == null ? void 0 : _a22.call(visitor2, lexicalNode);
    });
    if (!visitor) {
      throw new Error(`no lexical visitor found for ${lexicalNode.getType()}`, {
        cause: lexicalNode
      });
    }
    (_a2 = visitor.visitLexicalNode) == null ? void 0 : _a2.call(visitor, {
      lexicalNode,
      mdastParent,
      actions: {
        addAndStepInto(type2, props = {}, hasChildren = true) {
          const newNode = {
            type: type2,
            ...props,
            ...hasChildren ? { children: [] } : {}
          };
          appendToParent(mdastParent, newNode);
          if ($isElementNode(lexicalNode) && hasChildren) {
            visitChildren(lexicalNode, newNode);
          }
        },
        appendToParent,
        visitChildren,
        visit: visit3,
        registerReferredComponent
      }
    });
  }
  if (unistRoot === null) {
    throw new Error("traversal ended with no root element");
  }
  const importsMap = /* @__PURE__ */ new Map();
  const defaultImportsMap = /* @__PURE__ */ new Map();
  for (const componentName of referredComponents) {
    const descriptor = jsxComponentDescriptors.find((descriptor2) => descriptor2.name === componentName) ?? jsxComponentDescriptors.find((descriptor2) => descriptor2.name === "*");
    if (!descriptor) {
      throw new Error(`Component ${componentName} is used but not imported`);
    }
    if (!descriptor.source) {
      continue;
    }
    if (descriptor.defaultExport) {
      defaultImportsMap.set(componentName, descriptor.source);
    } else {
      const { source } = descriptor;
      const existing = importsMap.get(source);
      if (existing) {
        existing.push(componentName);
      } else {
        importsMap.set(source, [componentName]);
      }
    }
  }
  const imports = Array.from(importsMap).map(([source, componentNames]) => {
    return {
      type: "mdxjsEsm",
      value: `import { ${componentNames.join(", ")} } from '${source}'`
    };
  });
  imports.push(
    ...Array.from(defaultImportsMap).map(([componentName, source]) => {
      return {
        type: "mdxjsEsm",
        value: `import ${componentName} from '${source}'`
      };
    })
  );
  const typedRoot = unistRoot;
  const frontmatter2 = typedRoot.children.find((child) => child.type === "yaml");
  if (addImportStatements) {
    if (frontmatter2) {
      typedRoot.children.splice(typedRoot.children.indexOf(frontmatter2) + 1, 0, ...imports);
    } else {
      typedRoot.children.unshift(...imports);
    }
  }
  fixWrappingWhitespace(typedRoot, []);
  collapseNestedHtmlTags(typedRoot);
  if (!jsxIsAvailable) {
    convertUnderlineJsxToHtml(typedRoot);
  }
  return typedRoot;
}
function collapseNestedHtmlTags(node2) {
  if ("children" in node2 && node2.children.length > 0) {
    if (isMdastHTMLNode(node2) && node2.children.length === 1) {
      const onlyChild = node2.children[0];
      if (onlyChild.type === "mdxJsxTextElement" && onlyChild.name === "span") {
        onlyChild.attributes.forEach((attribute) => {
          if (attribute.type === "mdxJsxAttribute") {
            const parentAttribute = node2.attributes.find((attr) => attr.type === "mdxJsxAttribute" && attr.name === attribute.name);
            if (parentAttribute) {
              if (attribute.name === "className") {
                const mergedClassesSet = /* @__PURE__ */ new Set([
                  ...parentAttribute.value.split(" "),
                  ...attribute.value.split(" ")
                ]);
                parentAttribute.value = Array.from(mergedClassesSet).join(" ");
              } else if (attribute.name === "style") {
                parentAttribute.value = mergeStyleAttributes(parentAttribute.value, attribute.value);
              }
            } else {
              node2.attributes.push(attribute);
            }
          }
        });
        node2.children = onlyChild.children;
      }
    }
    node2.children.forEach((child) => {
      collapseNestedHtmlTags(child);
    });
  }
}
function convertUnderlineJsxToHtml(node2) {
  if (Object.hasOwn(node2, "children")) {
    const nodeAsParent = node2;
    const newChildren = [];
    nodeAsParent.children.forEach((child) => {
      if (child.type === "mdxJsxTextElement" && child.name === "u") {
        newChildren.push(...[{ type: "html", value: "<u>" }, ...child.children, { type: "html", value: "</u>" }]);
      } else {
        newChildren.push(child);
        convertUnderlineJsxToHtml(child);
      }
    });
    nodeAsParent.children = newChildren;
  }
}
var TRAILING_WHITESPACE_REGEXP = /\s+$/;
var LEADING_WHITESPACE_REGEXP = /^\s+/;
function fixWrappingWhitespace(node2, parentChain) {
  if (node2.type === "strong" || node2.type === "emphasis") {
    const lastChild = node2.children.at(-1);
    if ((lastChild == null ? void 0 : lastChild.type) === "text") {
      const trailingWhitespace = lastChild.value.match(TRAILING_WHITESPACE_REGEXP);
      if (trailingWhitespace) {
        lastChild.value = lastChild.value.replace(TRAILING_WHITESPACE_REGEXP, "");
        const parent = parentChain.at(-1);
        if (parent) {
          parent.children.splice(parent.children.indexOf(node2) + 1, 0, {
            type: "text",
            value: trailingWhitespace[0]
          });
          fixWrappingWhitespace(parent, parentChain.slice(0, -1));
        }
      }
    }
    const firstChild = node2.children.at(0);
    if ((firstChild == null ? void 0 : firstChild.type) === "text") {
      const leadingWhitespace = firstChild.value.match(LEADING_WHITESPACE_REGEXP);
      if (leadingWhitespace) {
        firstChild.value = firstChild.value.replace(LEADING_WHITESPACE_REGEXP, "");
        const parent = parentChain.at(-1);
        if (parent) {
          parent.children.splice(parent.children.indexOf(node2), 0, {
            type: "text",
            value: leadingWhitespace[0]
          });
          fixWrappingWhitespace(parent, parentChain.slice(0, -1));
        }
      }
    }
  }
  if ("children" in node2 && node2.children.length > 0) {
    const nodeAsParent = node2;
    nodeAsParent.children.forEach((child) => {
      fixWrappingWhitespace(child, [...parentChain, nodeAsParent]);
    });
  }
}
function exportMarkdownFromLexical({
  root: root2,
  toMarkdownOptions,
  toMarkdownExtensions,
  visitors,
  jsxComponentDescriptors,
  jsxIsAvailable
}) {
  return toMarkdown(exportLexicalTreeToMdast({ root: root2, visitors, jsxComponentDescriptors, jsxIsAvailable }), {
    extensions: toMarkdownExtensions,
    ...toMarkdownOptions
  }) + "\n";
}

// node_modules/micromark-util-combine-extensions/index.js
var hasOwnProperty = {}.hasOwnProperty;
function combineExtensions(extensions) {
  const all2 = {};
  let index3 = -1;
  while (++index3 < extensions.length) {
    syntaxExtension(all2, extensions[index3]);
  }
  return all2;
}
function syntaxExtension(all2, extension2) {
  let hook;
  for (hook in extension2) {
    const maybe = hasOwnProperty.call(all2, hook) ? all2[hook] : void 0;
    const left = maybe || (all2[hook] = {});
    const right = extension2[hook];
    let code3;
    if (right) {
      for (code3 in right) {
        if (!hasOwnProperty.call(left, code3)) left[code3] = [];
        const value2 = right[code3];
        constructs(
          // @ts-expect-error Looks like a list.
          left[code3],
          Array.isArray(value2) ? value2 : value2 ? [value2] : []
        );
      }
    }
  }
}
function constructs(existing, list4) {
  let index3 = -1;
  const before = [];
  while (++index3 < list4.length) {
    ;
    (list4[index3].add === "after" ? existing : before).push(list4[index3]);
  }
  splice(existing, 0, 0, before);
}

// node_modules/micromark-util-normalize-identifier/dev/index.js
function normalizeIdentifier(value2) {
  return value2.replace(/[\t\n\r ]+/g, values.space).replace(/^ | $/g, "").toLowerCase().toUpperCase();
}

// node_modules/micromark/dev/lib/compile.js
var hasOwnProperty2 = {}.hasOwnProperty;

// node_modules/micromark/dev/lib/initialize/content.js
var content = { tokenize: initializeContent };
function initializeContent(effects) {
  const contentStart = effects.attempt(
    this.parser.constructs.contentInitial,
    afterContentStartConstruct,
    paragraphInitial
  );
  let previous3;
  return contentStart;
  function afterContentStartConstruct(code3) {
    ok(
      code3 === codes.eof || markdownLineEnding(code3),
      "expected eol or eof"
    );
    if (code3 === codes.eof) {
      effects.consume(code3);
      return;
    }
    effects.enter(types.lineEnding);
    effects.consume(code3);
    effects.exit(types.lineEnding);
    return factorySpace(effects, contentStart, types.linePrefix);
  }
  function paragraphInitial(code3) {
    ok(
      code3 !== codes.eof && !markdownLineEnding(code3),
      "expected anything other than a line ending or EOF"
    );
    effects.enter(types.paragraph);
    return lineStart(code3);
  }
  function lineStart(code3) {
    const token = effects.enter(types.chunkText, {
      contentType: constants.contentTypeText,
      previous: previous3
    });
    if (previous3) {
      previous3.next = token;
    }
    previous3 = token;
    return data2(code3);
  }
  function data2(code3) {
    if (code3 === codes.eof) {
      effects.exit(types.chunkText);
      effects.exit(types.paragraph);
      effects.consume(code3);
      return;
    }
    if (markdownLineEnding(code3)) {
      effects.consume(code3);
      effects.exit(types.chunkText);
      return lineStart;
    }
    effects.consume(code3);
    return data2;
  }
}

// node_modules/micromark/dev/lib/initialize/document.js
var document2 = { tokenize: initializeDocument };
var containerConstruct = { tokenize: tokenizeContainer };
function initializeDocument(effects) {
  const self2 = this;
  const stack = [];
  let continued = 0;
  let childFlow;
  let childToken;
  let lineStartOffset;
  return start2;
  function start2(code3) {
    if (continued < stack.length) {
      const item = stack[continued];
      self2.containerState = item[1];
      ok(
        item[0].continuation,
        "expected `continuation` to be defined on container construct"
      );
      return effects.attempt(
        item[0].continuation,
        documentContinue,
        checkNewContainers
      )(code3);
    }
    return checkNewContainers(code3);
  }
  function documentContinue(code3) {
    ok(
      self2.containerState,
      "expected `containerState` to be defined after continuation"
    );
    continued++;
    if (self2.containerState._closeFlow) {
      self2.containerState._closeFlow = void 0;
      if (childFlow) {
        closeFlow();
      }
      const indexBeforeExits = self2.events.length;
      let indexBeforeFlow = indexBeforeExits;
      let point3;
      while (indexBeforeFlow--) {
        if (self2.events[indexBeforeFlow][0] === "exit" && self2.events[indexBeforeFlow][1].type === types.chunkFlow) {
          point3 = self2.events[indexBeforeFlow][1].end;
          break;
        }
      }
      ok(point3, "could not find previous flow chunk");
      exitContainers(continued);
      let index3 = indexBeforeExits;
      while (index3 < self2.events.length) {
        self2.events[index3][1].end = { ...point3 };
        index3++;
      }
      splice(
        self2.events,
        indexBeforeFlow + 1,
        0,
        self2.events.slice(indexBeforeExits)
      );
      self2.events.length = index3;
      return checkNewContainers(code3);
    }
    return start2(code3);
  }
  function checkNewContainers(code3) {
    if (continued === stack.length) {
      if (!childFlow) {
        return documentContinued(code3);
      }
      if (childFlow.currentConstruct && childFlow.currentConstruct.concrete) {
        return flowStart(code3);
      }
      self2.interrupt = Boolean(
        childFlow.currentConstruct && !childFlow._gfmTableDynamicInterruptHack
      );
    }
    self2.containerState = {};
    return effects.check(
      containerConstruct,
      thereIsANewContainer,
      thereIsNoNewContainer
    )(code3);
  }
  function thereIsANewContainer(code3) {
    if (childFlow) closeFlow();
    exitContainers(continued);
    return documentContinued(code3);
  }
  function thereIsNoNewContainer(code3) {
    self2.parser.lazy[self2.now().line] = continued !== stack.length;
    lineStartOffset = self2.now().offset;
    return flowStart(code3);
  }
  function documentContinued(code3) {
    self2.containerState = {};
    return effects.attempt(
      containerConstruct,
      containerContinue,
      flowStart
    )(code3);
  }
  function containerContinue(code3) {
    ok(
      self2.currentConstruct,
      "expected `currentConstruct` to be defined on tokenizer"
    );
    ok(
      self2.containerState,
      "expected `containerState` to be defined on tokenizer"
    );
    continued++;
    stack.push([self2.currentConstruct, self2.containerState]);
    return documentContinued(code3);
  }
  function flowStart(code3) {
    if (code3 === codes.eof) {
      if (childFlow) closeFlow();
      exitContainers(0);
      effects.consume(code3);
      return;
    }
    childFlow = childFlow || self2.parser.flow(self2.now());
    effects.enter(types.chunkFlow, {
      _tokenizer: childFlow,
      contentType: constants.contentTypeFlow,
      previous: childToken
    });
    return flowContinue(code3);
  }
  function flowContinue(code3) {
    if (code3 === codes.eof) {
      writeToChild(effects.exit(types.chunkFlow), true);
      exitContainers(0);
      effects.consume(code3);
      return;
    }
    if (markdownLineEnding(code3)) {
      effects.consume(code3);
      writeToChild(effects.exit(types.chunkFlow));
      continued = 0;
      self2.interrupt = void 0;
      return start2;
    }
    effects.consume(code3);
    return flowContinue;
  }
  function writeToChild(token, endOfFile) {
    ok(childFlow, "expected `childFlow` to be defined when continuing");
    const stream = self2.sliceStream(token);
    if (endOfFile) stream.push(null);
    token.previous = childToken;
    if (childToken) childToken.next = token;
    childToken = token;
    childFlow.defineSkip(token.start);
    childFlow.write(stream);
    if (self2.parser.lazy[token.start.line]) {
      let index3 = childFlow.events.length;
      while (index3--) {
        if (
          // The token starts before the line ending…
          childFlow.events[index3][1].start.offset < lineStartOffset && // …and either is not ended yet…
          (!childFlow.events[index3][1].end || // …or ends after it.
          childFlow.events[index3][1].end.offset > lineStartOffset)
        ) {
          return;
        }
      }
      const indexBeforeExits = self2.events.length;
      let indexBeforeFlow = indexBeforeExits;
      let seen;
      let point3;
      while (indexBeforeFlow--) {
        if (self2.events[indexBeforeFlow][0] === "exit" && self2.events[indexBeforeFlow][1].type === types.chunkFlow) {
          if (seen) {
            point3 = self2.events[indexBeforeFlow][1].end;
            break;
          }
          seen = true;
        }
      }
      ok(point3, "could not find previous flow chunk");
      exitContainers(continued);
      index3 = indexBeforeExits;
      while (index3 < self2.events.length) {
        self2.events[index3][1].end = { ...point3 };
        index3++;
      }
      splice(
        self2.events,
        indexBeforeFlow + 1,
        0,
        self2.events.slice(indexBeforeExits)
      );
      self2.events.length = index3;
    }
  }
  function exitContainers(size4) {
    let index3 = stack.length;
    while (index3-- > size4) {
      const entry = stack[index3];
      self2.containerState = entry[1];
      ok(
        entry[0].exit,
        "expected `exit` to be defined on container construct"
      );
      entry[0].exit.call(self2, effects);
    }
    stack.length = size4;
  }
  function closeFlow() {
    ok(
      self2.containerState,
      "expected `containerState` to be defined when closing flow"
    );
    ok(childFlow, "expected `childFlow` to be defined when closing it");
    childFlow.write([codes.eof]);
    childToken = void 0;
    childFlow = void 0;
    self2.containerState._closeFlow = void 0;
  }
}
function tokenizeContainer(effects, ok3, nok) {
  ok(
    this.parser.constructs.disable.null,
    "expected `disable.null` to be populated"
  );
  return factorySpace(
    effects,
    effects.attempt(this.parser.constructs.document, ok3, nok),
    types.linePrefix,
    this.parser.constructs.disable.null.includes("codeIndented") ? void 0 : constants.tabSize
  );
}

// node_modules/micromark-core-commonmark/dev/lib/attention.js
var attention = {
  name: "attention",
  resolveAll: resolveAllAttention,
  tokenize: tokenizeAttention
};
function resolveAllAttention(events, context) {
  let index3 = -1;
  let open;
  let group;
  let text4;
  let openingSequence;
  let closingSequence;
  let use;
  let nextEvents;
  let offset5;
  while (++index3 < events.length) {
    if (events[index3][0] === "enter" && events[index3][1].type === "attentionSequence" && events[index3][1]._close) {
      open = index3;
      while (open--) {
        if (events[open][0] === "exit" && events[open][1].type === "attentionSequence" && events[open][1]._open && // If the markers are the same:
        context.sliceSerialize(events[open][1]).charCodeAt(0) === context.sliceSerialize(events[index3][1]).charCodeAt(0)) {
          if ((events[open][1]._close || events[index3][1]._open) && (events[index3][1].end.offset - events[index3][1].start.offset) % 3 && !((events[open][1].end.offset - events[open][1].start.offset + events[index3][1].end.offset - events[index3][1].start.offset) % 3)) {
            continue;
          }
          use = events[open][1].end.offset - events[open][1].start.offset > 1 && events[index3][1].end.offset - events[index3][1].start.offset > 1 ? 2 : 1;
          const start2 = { ...events[open][1].end };
          const end = { ...events[index3][1].start };
          movePoint(start2, -use);
          movePoint(end, use);
          openingSequence = {
            type: use > 1 ? types.strongSequence : types.emphasisSequence,
            start: start2,
            end: { ...events[open][1].end }
          };
          closingSequence = {
            type: use > 1 ? types.strongSequence : types.emphasisSequence,
            start: { ...events[index3][1].start },
            end
          };
          text4 = {
            type: use > 1 ? types.strongText : types.emphasisText,
            start: { ...events[open][1].end },
            end: { ...events[index3][1].start }
          };
          group = {
            type: use > 1 ? types.strong : types.emphasis,
            start: { ...openingSequence.start },
            end: { ...closingSequence.end }
          };
          events[open][1].end = { ...openingSequence.start };
          events[index3][1].start = { ...closingSequence.end };
          nextEvents = [];
          if (events[open][1].end.offset - events[open][1].start.offset) {
            nextEvents = push(nextEvents, [
              ["enter", events[open][1], context],
              ["exit", events[open][1], context]
            ]);
          }
          nextEvents = push(nextEvents, [
            ["enter", group, context],
            ["enter", openingSequence, context],
            ["exit", openingSequence, context],
            ["enter", text4, context]
          ]);
          ok(
            context.parser.constructs.insideSpan.null,
            "expected `insideSpan` to be populated"
          );
          nextEvents = push(
            nextEvents,
            resolveAll(
              context.parser.constructs.insideSpan.null,
              events.slice(open + 1, index3),
              context
            )
          );
          nextEvents = push(nextEvents, [
            ["exit", text4, context],
            ["enter", closingSequence, context],
            ["exit", closingSequence, context],
            ["exit", group, context]
          ]);
          if (events[index3][1].end.offset - events[index3][1].start.offset) {
            offset5 = 2;
            nextEvents = push(nextEvents, [
              ["enter", events[index3][1], context],
              ["exit", events[index3][1], context]
            ]);
          } else {
            offset5 = 0;
          }
          splice(events, open - 1, index3 - open + 3, nextEvents);
          index3 = open + nextEvents.length - offset5 - 2;
          break;
        }
      }
    }
  }
  index3 = -1;
  while (++index3 < events.length) {
    if (events[index3][1].type === "attentionSequence") {
      events[index3][1].type = "data";
    }
  }
  return events;
}
function tokenizeAttention(effects, ok3) {
  const attentionMarkers2 = this.parser.constructs.attentionMarkers.null;
  const previous3 = this.previous;
  const before = classifyCharacter(previous3);
  let marker;
  return start2;
  function start2(code3) {
    ok(
      code3 === codes.asterisk || code3 === codes.underscore,
      "expected asterisk or underscore"
    );
    marker = code3;
    effects.enter("attentionSequence");
    return inside(code3);
  }
  function inside(code3) {
    if (code3 === marker) {
      effects.consume(code3);
      return inside;
    }
    const token = effects.exit("attentionSequence");
    const after = classifyCharacter(code3);
    ok(attentionMarkers2, "expected `attentionMarkers` to be populated");
    const open = !after || after === constants.characterGroupPunctuation && before || attentionMarkers2.includes(code3);
    const close2 = !before || before === constants.characterGroupPunctuation && after || attentionMarkers2.includes(previous3);
    token._open = Boolean(
      marker === codes.asterisk ? open : open && (before || !close2)
    );
    token._close = Boolean(
      marker === codes.asterisk ? close2 : close2 && (after || !open)
    );
    return ok3(code3);
  }
}
function movePoint(point3, offset5) {
  point3.column += offset5;
  point3.offset += offset5;
  point3._bufferIndex += offset5;
}

// node_modules/micromark-core-commonmark/dev/lib/autolink.js
var autolink = { name: "autolink", tokenize: tokenizeAutolink };
function tokenizeAutolink(effects, ok3, nok) {
  let size4 = 0;
  return start2;
  function start2(code3) {
    ok(code3 === codes.lessThan, "expected `<`");
    effects.enter(types.autolink);
    effects.enter(types.autolinkMarker);
    effects.consume(code3);
    effects.exit(types.autolinkMarker);
    effects.enter(types.autolinkProtocol);
    return open;
  }
  function open(code3) {
    if (asciiAlpha(code3)) {
      effects.consume(code3);
      return schemeOrEmailAtext;
    }
    if (code3 === codes.atSign) {
      return nok(code3);
    }
    return emailAtext(code3);
  }
  function schemeOrEmailAtext(code3) {
    if (code3 === codes.plusSign || code3 === codes.dash || code3 === codes.dot || asciiAlphanumeric(code3)) {
      size4 = 1;
      return schemeInsideOrEmailAtext(code3);
    }
    return emailAtext(code3);
  }
  function schemeInsideOrEmailAtext(code3) {
    if (code3 === codes.colon) {
      effects.consume(code3);
      size4 = 0;
      return urlInside;
    }
    if ((code3 === codes.plusSign || code3 === codes.dash || code3 === codes.dot || asciiAlphanumeric(code3)) && size4++ < constants.autolinkSchemeSizeMax) {
      effects.consume(code3);
      return schemeInsideOrEmailAtext;
    }
    size4 = 0;
    return emailAtext(code3);
  }
  function urlInside(code3) {
    if (code3 === codes.greaterThan) {
      effects.exit(types.autolinkProtocol);
      effects.enter(types.autolinkMarker);
      effects.consume(code3);
      effects.exit(types.autolinkMarker);
      effects.exit(types.autolink);
      return ok3;
    }
    if (code3 === codes.eof || code3 === codes.space || code3 === codes.lessThan || asciiControl(code3)) {
      return nok(code3);
    }
    effects.consume(code3);
    return urlInside;
  }
  function emailAtext(code3) {
    if (code3 === codes.atSign) {
      effects.consume(code3);
      return emailAtSignOrDot;
    }
    if (asciiAtext(code3)) {
      effects.consume(code3);
      return emailAtext;
    }
    return nok(code3);
  }
  function emailAtSignOrDot(code3) {
    return asciiAlphanumeric(code3) ? emailLabel(code3) : nok(code3);
  }
  function emailLabel(code3) {
    if (code3 === codes.dot) {
      effects.consume(code3);
      size4 = 0;
      return emailAtSignOrDot;
    }
    if (code3 === codes.greaterThan) {
      effects.exit(types.autolinkProtocol).type = types.autolinkEmail;
      effects.enter(types.autolinkMarker);
      effects.consume(code3);
      effects.exit(types.autolinkMarker);
      effects.exit(types.autolink);
      return ok3;
    }
    return emailValue(code3);
  }
  function emailValue(code3) {
    if ((code3 === codes.dash || asciiAlphanumeric(code3)) && size4++ < constants.autolinkDomainSizeMax) {
      const next = code3 === codes.dash ? emailValue : emailLabel;
      effects.consume(code3);
      return next;
    }
    return nok(code3);
  }
}

// node_modules/micromark-core-commonmark/dev/lib/blank-line.js
var blankLine = { partial: true, tokenize: tokenizeBlankLine };
function tokenizeBlankLine(effects, ok3, nok) {
  return start2;
  function start2(code3) {
    return markdownSpace(code3) ? factorySpace(effects, after, types.linePrefix)(code3) : after(code3);
  }
  function after(code3) {
    return code3 === codes.eof || markdownLineEnding(code3) ? ok3(code3) : nok(code3);
  }
}

// node_modules/micromark-core-commonmark/dev/lib/block-quote.js
var blockQuote = {
  continuation: { tokenize: tokenizeBlockQuoteContinuation },
  exit,
  name: "blockQuote",
  tokenize: tokenizeBlockQuoteStart
};
function tokenizeBlockQuoteStart(effects, ok3, nok) {
  const self2 = this;
  return start2;
  function start2(code3) {
    if (code3 === codes.greaterThan) {
      const state = self2.containerState;
      ok(state, "expected `containerState` to be defined in container");
      if (!state.open) {
        effects.enter(types.blockQuote, { _container: true });
        state.open = true;
      }
      effects.enter(types.blockQuotePrefix);
      effects.enter(types.blockQuoteMarker);
      effects.consume(code3);
      effects.exit(types.blockQuoteMarker);
      return after;
    }
    return nok(code3);
  }
  function after(code3) {
    if (markdownSpace(code3)) {
      effects.enter(types.blockQuotePrefixWhitespace);
      effects.consume(code3);
      effects.exit(types.blockQuotePrefixWhitespace);
      effects.exit(types.blockQuotePrefix);
      return ok3;
    }
    effects.exit(types.blockQuotePrefix);
    return ok3(code3);
  }
}
function tokenizeBlockQuoteContinuation(effects, ok3, nok) {
  const self2 = this;
  return contStart;
  function contStart(code3) {
    if (markdownSpace(code3)) {
      ok(
        self2.parser.constructs.disable.null,
        "expected `disable.null` to be populated"
      );
      return factorySpace(
        effects,
        contBefore,
        types.linePrefix,
        self2.parser.constructs.disable.null.includes("codeIndented") ? void 0 : constants.tabSize
      )(code3);
    }
    return contBefore(code3);
  }
  function contBefore(code3) {
    return effects.attempt(blockQuote, ok3, nok)(code3);
  }
}
function exit(effects) {
  effects.exit(types.blockQuote);
}

// node_modules/micromark-core-commonmark/dev/lib/character-escape.js
var characterEscape = {
  name: "characterEscape",
  tokenize: tokenizeCharacterEscape
};
function tokenizeCharacterEscape(effects, ok3, nok) {
  return start2;
  function start2(code3) {
    ok(code3 === codes.backslash, "expected `\\`");
    effects.enter(types.characterEscape);
    effects.enter(types.escapeMarker);
    effects.consume(code3);
    effects.exit(types.escapeMarker);
    return inside;
  }
  function inside(code3) {
    if (asciiPunctuation(code3)) {
      effects.enter(types.characterEscapeValue);
      effects.consume(code3);
      effects.exit(types.characterEscapeValue);
      effects.exit(types.characterEscape);
      return ok3;
    }
    return nok(code3);
  }
}

// node_modules/micromark-core-commonmark/dev/lib/character-reference.js
var characterReference = {
  name: "characterReference",
  tokenize: tokenizeCharacterReference
};
function tokenizeCharacterReference(effects, ok3, nok) {
  const self2 = this;
  let size4 = 0;
  let max2;
  let test;
  return start2;
  function start2(code3) {
    ok(code3 === codes.ampersand, "expected `&`");
    effects.enter(types.characterReference);
    effects.enter(types.characterReferenceMarker);
    effects.consume(code3);
    effects.exit(types.characterReferenceMarker);
    return open;
  }
  function open(code3) {
    if (code3 === codes.numberSign) {
      effects.enter(types.characterReferenceMarkerNumeric);
      effects.consume(code3);
      effects.exit(types.characterReferenceMarkerNumeric);
      return numeric;
    }
    effects.enter(types.characterReferenceValue);
    max2 = constants.characterReferenceNamedSizeMax;
    test = asciiAlphanumeric;
    return value2(code3);
  }
  function numeric(code3) {
    if (code3 === codes.uppercaseX || code3 === codes.lowercaseX) {
      effects.enter(types.characterReferenceMarkerHexadecimal);
      effects.consume(code3);
      effects.exit(types.characterReferenceMarkerHexadecimal);
      effects.enter(types.characterReferenceValue);
      max2 = constants.characterReferenceHexadecimalSizeMax;
      test = asciiHexDigit;
      return value2;
    }
    effects.enter(types.characterReferenceValue);
    max2 = constants.characterReferenceDecimalSizeMax;
    test = asciiDigit;
    return value2(code3);
  }
  function value2(code3) {
    if (code3 === codes.semicolon && size4) {
      const token = effects.exit(types.characterReferenceValue);
      if (test === asciiAlphanumeric && !decodeNamedCharacterReference(self2.sliceSerialize(token))) {
        return nok(code3);
      }
      effects.enter(types.characterReferenceMarker);
      effects.consume(code3);
      effects.exit(types.characterReferenceMarker);
      effects.exit(types.characterReference);
      return ok3;
    }
    if (test(code3) && size4++ < max2) {
      effects.consume(code3);
      return value2;
    }
    return nok(code3);
  }
}

// node_modules/micromark-core-commonmark/dev/lib/code-fenced.js
var nonLazyContinuation = {
  partial: true,
  tokenize: tokenizeNonLazyContinuation
};
var codeFenced = {
  concrete: true,
  name: "codeFenced",
  tokenize: tokenizeCodeFenced
};
function tokenizeCodeFenced(effects, ok3, nok) {
  const self2 = this;
  const closeStart = { partial: true, tokenize: tokenizeCloseStart };
  let initialPrefix = 0;
  let sizeOpen = 0;
  let marker;
  return start2;
  function start2(code3) {
    return beforeSequenceOpen(code3);
  }
  function beforeSequenceOpen(code3) {
    ok(
      code3 === codes.graveAccent || code3 === codes.tilde,
      "expected `` ` `` or `~`"
    );
    const tail = self2.events[self2.events.length - 1];
    initialPrefix = tail && tail[1].type === types.linePrefix ? tail[2].sliceSerialize(tail[1], true).length : 0;
    marker = code3;
    effects.enter(types.codeFenced);
    effects.enter(types.codeFencedFence);
    effects.enter(types.codeFencedFenceSequence);
    return sequenceOpen(code3);
  }
  function sequenceOpen(code3) {
    if (code3 === marker) {
      sizeOpen++;
      effects.consume(code3);
      return sequenceOpen;
    }
    if (sizeOpen < constants.codeFencedSequenceSizeMin) {
      return nok(code3);
    }
    effects.exit(types.codeFencedFenceSequence);
    return markdownSpace(code3) ? factorySpace(effects, infoBefore, types.whitespace)(code3) : infoBefore(code3);
  }
  function infoBefore(code3) {
    if (code3 === codes.eof || markdownLineEnding(code3)) {
      effects.exit(types.codeFencedFence);
      return self2.interrupt ? ok3(code3) : effects.check(nonLazyContinuation, atNonLazyBreak, after)(code3);
    }
    effects.enter(types.codeFencedFenceInfo);
    effects.enter(types.chunkString, { contentType: constants.contentTypeString });
    return info(code3);
  }
  function info(code3) {
    if (code3 === codes.eof || markdownLineEnding(code3)) {
      effects.exit(types.chunkString);
      effects.exit(types.codeFencedFenceInfo);
      return infoBefore(code3);
    }
    if (markdownSpace(code3)) {
      effects.exit(types.chunkString);
      effects.exit(types.codeFencedFenceInfo);
      return factorySpace(effects, metaBefore, types.whitespace)(code3);
    }
    if (code3 === codes.graveAccent && code3 === marker) {
      return nok(code3);
    }
    effects.consume(code3);
    return info;
  }
  function metaBefore(code3) {
    if (code3 === codes.eof || markdownLineEnding(code3)) {
      return infoBefore(code3);
    }
    effects.enter(types.codeFencedFenceMeta);
    effects.enter(types.chunkString, { contentType: constants.contentTypeString });
    return meta(code3);
  }
  function meta(code3) {
    if (code3 === codes.eof || markdownLineEnding(code3)) {
      effects.exit(types.chunkString);
      effects.exit(types.codeFencedFenceMeta);
      return infoBefore(code3);
    }
    if (code3 === codes.graveAccent && code3 === marker) {
      return nok(code3);
    }
    effects.consume(code3);
    return meta;
  }
  function atNonLazyBreak(code3) {
    ok(markdownLineEnding(code3), "expected eol");
    return effects.attempt(closeStart, after, contentBefore)(code3);
  }
  function contentBefore(code3) {
    ok(markdownLineEnding(code3), "expected eol");
    effects.enter(types.lineEnding);
    effects.consume(code3);
    effects.exit(types.lineEnding);
    return contentStart;
  }
  function contentStart(code3) {
    return initialPrefix > 0 && markdownSpace(code3) ? factorySpace(
      effects,
      beforeContentChunk,
      types.linePrefix,
      initialPrefix + 1
    )(code3) : beforeContentChunk(code3);
  }
  function beforeContentChunk(code3) {
    if (code3 === codes.eof || markdownLineEnding(code3)) {
      return effects.check(nonLazyContinuation, atNonLazyBreak, after)(code3);
    }
    effects.enter(types.codeFlowValue);
    return contentChunk(code3);
  }
  function contentChunk(code3) {
    if (code3 === codes.eof || markdownLineEnding(code3)) {
      effects.exit(types.codeFlowValue);
      return beforeContentChunk(code3);
    }
    effects.consume(code3);
    return contentChunk;
  }
  function after(code3) {
    effects.exit(types.codeFenced);
    return ok3(code3);
  }
  function tokenizeCloseStart(effects2, ok4, nok2) {
    let size4 = 0;
    return startBefore;
    function startBefore(code3) {
      ok(markdownLineEnding(code3), "expected eol");
      effects2.enter(types.lineEnding);
      effects2.consume(code3);
      effects2.exit(types.lineEnding);
      return start3;
    }
    function start3(code3) {
      ok(
        self2.parser.constructs.disable.null,
        "expected `disable.null` to be populated"
      );
      effects2.enter(types.codeFencedFence);
      return markdownSpace(code3) ? factorySpace(
        effects2,
        beforeSequenceClose,
        types.linePrefix,
        self2.parser.constructs.disable.null.includes("codeIndented") ? void 0 : constants.tabSize
      )(code3) : beforeSequenceClose(code3);
    }
    function beforeSequenceClose(code3) {
      if (code3 === marker) {
        effects2.enter(types.codeFencedFenceSequence);
        return sequenceClose(code3);
      }
      return nok2(code3);
    }
    function sequenceClose(code3) {
      if (code3 === marker) {
        size4++;
        effects2.consume(code3);
        return sequenceClose;
      }
      if (size4 >= sizeOpen) {
        effects2.exit(types.codeFencedFenceSequence);
        return markdownSpace(code3) ? factorySpace(effects2, sequenceCloseAfter, types.whitespace)(code3) : sequenceCloseAfter(code3);
      }
      return nok2(code3);
    }
    function sequenceCloseAfter(code3) {
      if (code3 === codes.eof || markdownLineEnding(code3)) {
        effects2.exit(types.codeFencedFence);
        return ok4(code3);
      }
      return nok2(code3);
    }
  }
}
function tokenizeNonLazyContinuation(effects, ok3, nok) {
  const self2 = this;
  return start2;
  function start2(code3) {
    if (code3 === codes.eof) {
      return nok(code3);
    }
    ok(markdownLineEnding(code3), "expected eol");
    effects.enter(types.lineEnding);
    effects.consume(code3);
    effects.exit(types.lineEnding);
    return lineStart;
  }
  function lineStart(code3) {
    return self2.parser.lazy[self2.now().line] ? nok(code3) : ok3(code3);
  }
}

// node_modules/micromark-core-commonmark/dev/lib/code-indented.js
var codeIndented = {
  name: "codeIndented",
  tokenize: tokenizeCodeIndented
};
var furtherStart = { partial: true, tokenize: tokenizeFurtherStart };
function tokenizeCodeIndented(effects, ok3, nok) {
  const self2 = this;
  return start2;
  function start2(code3) {
    ok(markdownSpace(code3));
    effects.enter(types.codeIndented);
    return factorySpace(
      effects,
      afterPrefix,
      types.linePrefix,
      constants.tabSize + 1
    )(code3);
  }
  function afterPrefix(code3) {
    const tail = self2.events[self2.events.length - 1];
    return tail && tail[1].type === types.linePrefix && tail[2].sliceSerialize(tail[1], true).length >= constants.tabSize ? atBreak(code3) : nok(code3);
  }
  function atBreak(code3) {
    if (code3 === codes.eof) {
      return after(code3);
    }
    if (markdownLineEnding(code3)) {
      return effects.attempt(furtherStart, atBreak, after)(code3);
    }
    effects.enter(types.codeFlowValue);
    return inside(code3);
  }
  function inside(code3) {
    if (code3 === codes.eof || markdownLineEnding(code3)) {
      effects.exit(types.codeFlowValue);
      return atBreak(code3);
    }
    effects.consume(code3);
    return inside;
  }
  function after(code3) {
    effects.exit(types.codeIndented);
    return ok3(code3);
  }
}
function tokenizeFurtherStart(effects, ok3, nok) {
  const self2 = this;
  return furtherStart2;
  function furtherStart2(code3) {
    if (self2.parser.lazy[self2.now().line]) {
      return nok(code3);
    }
    if (markdownLineEnding(code3)) {
      effects.enter(types.lineEnding);
      effects.consume(code3);
      effects.exit(types.lineEnding);
      return furtherStart2;
    }
    return factorySpace(
      effects,
      afterPrefix,
      types.linePrefix,
      constants.tabSize + 1
    )(code3);
  }
  function afterPrefix(code3) {
    const tail = self2.events[self2.events.length - 1];
    return tail && tail[1].type === types.linePrefix && tail[2].sliceSerialize(tail[1], true).length >= constants.tabSize ? ok3(code3) : markdownLineEnding(code3) ? furtherStart2(code3) : nok(code3);
  }
}

// node_modules/micromark-core-commonmark/dev/lib/code-text.js
var codeText = {
  name: "codeText",
  previous,
  resolve: resolveCodeText,
  tokenize: tokenizeCodeText
};
function resolveCodeText(events) {
  let tailExitIndex = events.length - 4;
  let headEnterIndex = 3;
  let index3;
  let enter2;
  if ((events[headEnterIndex][1].type === types.lineEnding || events[headEnterIndex][1].type === "space") && (events[tailExitIndex][1].type === types.lineEnding || events[tailExitIndex][1].type === "space")) {
    index3 = headEnterIndex;
    while (++index3 < tailExitIndex) {
      if (events[index3][1].type === types.codeTextData) {
        events[headEnterIndex][1].type = types.codeTextPadding;
        events[tailExitIndex][1].type = types.codeTextPadding;
        headEnterIndex += 2;
        tailExitIndex -= 2;
        break;
      }
    }
  }
  index3 = headEnterIndex - 1;
  tailExitIndex++;
  while (++index3 <= tailExitIndex) {
    if (enter2 === void 0) {
      if (index3 !== tailExitIndex && events[index3][1].type !== types.lineEnding) {
        enter2 = index3;
      }
    } else if (index3 === tailExitIndex || events[index3][1].type === types.lineEnding) {
      events[enter2][1].type = types.codeTextData;
      if (index3 !== enter2 + 2) {
        events[enter2][1].end = events[index3 - 1][1].end;
        events.splice(enter2 + 2, index3 - enter2 - 2);
        tailExitIndex -= index3 - enter2 - 2;
        index3 = enter2 + 2;
      }
      enter2 = void 0;
    }
  }
  return events;
}
function previous(code3) {
  return code3 !== codes.graveAccent || this.events[this.events.length - 1][1].type === types.characterEscape;
}
function tokenizeCodeText(effects, ok3, nok) {
  const self2 = this;
  let sizeOpen = 0;
  let size4;
  let token;
  return start2;
  function start2(code3) {
    ok(code3 === codes.graveAccent, "expected `` ` ``");
    ok(previous.call(self2, self2.previous), "expected correct previous");
    effects.enter(types.codeText);
    effects.enter(types.codeTextSequence);
    return sequenceOpen(code3);
  }
  function sequenceOpen(code3) {
    if (code3 === codes.graveAccent) {
      effects.consume(code3);
      sizeOpen++;
      return sequenceOpen;
    }
    effects.exit(types.codeTextSequence);
    return between2(code3);
  }
  function between2(code3) {
    if (code3 === codes.eof) {
      return nok(code3);
    }
    if (code3 === codes.space) {
      effects.enter("space");
      effects.consume(code3);
      effects.exit("space");
      return between2;
    }
    if (code3 === codes.graveAccent) {
      token = effects.enter(types.codeTextSequence);
      size4 = 0;
      return sequenceClose(code3);
    }
    if (markdownLineEnding(code3)) {
      effects.enter(types.lineEnding);
      effects.consume(code3);
      effects.exit(types.lineEnding);
      return between2;
    }
    effects.enter(types.codeTextData);
    return data2(code3);
  }
  function data2(code3) {
    if (code3 === codes.eof || code3 === codes.space || code3 === codes.graveAccent || markdownLineEnding(code3)) {
      effects.exit(types.codeTextData);
      return between2(code3);
    }
    effects.consume(code3);
    return data2;
  }
  function sequenceClose(code3) {
    if (code3 === codes.graveAccent) {
      effects.consume(code3);
      size4++;
      return sequenceClose;
    }
    if (size4 === sizeOpen) {
      effects.exit(types.codeTextSequence);
      effects.exit(types.codeText);
      return ok3(code3);
    }
    token.type = types.codeTextData;
    return data2(code3);
  }
}

// node_modules/micromark-util-subtokenize/dev/lib/splice-buffer.js
var SpliceBuffer = class {
  /**
   * @param {ReadonlyArray<T> | null | undefined} [initial]
   *   Initial items (optional).
   * @returns
   *   Splice buffer.
   */
  constructor(initial) {
    this.left = initial ? [...initial] : [];
    this.right = [];
  }
  /**
   * Array access;
   * does not move the cursor.
   *
   * @param {number} index
   *   Index.
   * @return {T}
   *   Item.
   */
  get(index3) {
    if (index3 < 0 || index3 >= this.left.length + this.right.length) {
      throw new RangeError(
        "Cannot access index `" + index3 + "` in a splice buffer of size `" + (this.left.length + this.right.length) + "`"
      );
    }
    if (index3 < this.left.length) return this.left[index3];
    return this.right[this.right.length - index3 + this.left.length - 1];
  }
  /**
   * The length of the splice buffer, one greater than the largest index in the
   * array.
   */
  get length() {
    return this.left.length + this.right.length;
  }
  /**
   * Remove and return `list[0]`;
   * moves the cursor to `0`.
   *
   * @returns {T | undefined}
   *   Item, optional.
   */
  shift() {
    this.setCursor(0);
    return this.right.pop();
  }
  /**
   * Slice the buffer to get an array;
   * does not move the cursor.
   *
   * @param {number} start
   *   Start.
   * @param {number | null | undefined} [end]
   *   End (optional).
   * @returns {Array<T>}
   *   Array of items.
   */
  slice(start2, end) {
    const stop = end === null || end === void 0 ? Number.POSITIVE_INFINITY : end;
    if (stop < this.left.length) {
      return this.left.slice(start2, stop);
    }
    if (start2 > this.left.length) {
      return this.right.slice(
        this.right.length - stop + this.left.length,
        this.right.length - start2 + this.left.length
      ).reverse();
    }
    return this.left.slice(start2).concat(
      this.right.slice(this.right.length - stop + this.left.length).reverse()
    );
  }
  /**
   * Mimics the behavior of Array.prototype.splice() except for the change of
   * interface necessary to avoid segfaults when patching in very large arrays.
   *
   * This operation moves cursor is moved to `start` and results in the cursor
   * placed after any inserted items.
   *
   * @param {number} start
   *   Start;
   *   zero-based index at which to start changing the array;
   *   negative numbers count backwards from the end of the array and values
   *   that are out-of bounds are clamped to the appropriate end of the array.
   * @param {number | null | undefined} [deleteCount=0]
   *   Delete count (default: `0`);
   *   maximum number of elements to delete, starting from start.
   * @param {Array<T> | null | undefined} [items=[]]
   *   Items to include in place of the deleted items (default: `[]`).
   * @return {Array<T>}
   *   Any removed items.
   */
  splice(start2, deleteCount, items) {
    const count3 = deleteCount || 0;
    this.setCursor(Math.trunc(start2));
    const removed = this.right.splice(
      this.right.length - count3,
      Number.POSITIVE_INFINITY
    );
    if (items) chunkedPush(this.left, items);
    return removed.reverse();
  }
  /**
   * Remove and return the highest-numbered item in the array, so
   * `list[list.length - 1]`;
   * Moves the cursor to `length`.
   *
   * @returns {T | undefined}
   *   Item, optional.
   */
  pop() {
    this.setCursor(Number.POSITIVE_INFINITY);
    return this.left.pop();
  }
  /**
   * Inserts a single item to the high-numbered side of the array;
   * moves the cursor to `length`.
   *
   * @param {T} item
   *   Item.
   * @returns {undefined}
   *   Nothing.
   */
  push(item) {
    this.setCursor(Number.POSITIVE_INFINITY);
    this.left.push(item);
  }
  /**
   * Inserts many items to the high-numbered side of the array.
   * Moves the cursor to `length`.
   *
   * @param {Array<T>} items
   *   Items.
   * @returns {undefined}
   *   Nothing.
   */
  pushMany(items) {
    this.setCursor(Number.POSITIVE_INFINITY);
    chunkedPush(this.left, items);
  }
  /**
   * Inserts a single item to the low-numbered side of the array;
   * Moves the cursor to `0`.
   *
   * @param {T} item
   *   Item.
   * @returns {undefined}
   *   Nothing.
   */
  unshift(item) {
    this.setCursor(0);
    this.right.push(item);
  }
  /**
   * Inserts many items to the low-numbered side of the array;
   * moves the cursor to `0`.
   *
   * @param {Array<T>} items
   *   Items.
   * @returns {undefined}
   *   Nothing.
   */
  unshiftMany(items) {
    this.setCursor(0);
    chunkedPush(this.right, items.reverse());
  }
  /**
   * Move the cursor to a specific position in the array. Requires
   * time proportional to the distance moved.
   *
   * If `n < 0`, the cursor will end up at the beginning.
   * If `n > length`, the cursor will end up at the end.
   *
   * @param {number} n
   *   Position.
   * @return {undefined}
   *   Nothing.
   */
  setCursor(n3) {
    if (n3 === this.left.length || n3 > this.left.length && this.right.length === 0 || n3 < 0 && this.left.length === 0)
      return;
    if (n3 < this.left.length) {
      const removed = this.left.splice(n3, Number.POSITIVE_INFINITY);
      chunkedPush(this.right, removed.reverse());
    } else {
      const removed = this.right.splice(
        this.left.length + this.right.length - n3,
        Number.POSITIVE_INFINITY
      );
      chunkedPush(this.left, removed.reverse());
    }
  }
};
function chunkedPush(list4, right) {
  let chunkStart = 0;
  if (right.length < constants.v8MaxSafeChunkSize) {
    list4.push(...right);
  } else {
    while (chunkStart < right.length) {
      list4.push(
        ...right.slice(chunkStart, chunkStart + constants.v8MaxSafeChunkSize)
      );
      chunkStart += constants.v8MaxSafeChunkSize;
    }
  }
}

// node_modules/micromark-util-subtokenize/dev/index.js
function subtokenize(eventsArray) {
  const jumps = {};
  let index3 = -1;
  let event;
  let lineIndex;
  let otherIndex;
  let otherEvent;
  let parameters;
  let subevents;
  let more;
  const events = new SpliceBuffer(eventsArray);
  while (++index3 < events.length) {
    while (index3 in jumps) {
      index3 = jumps[index3];
    }
    event = events.get(index3);
    if (index3 && event[1].type === types.chunkFlow && events.get(index3 - 1)[1].type === types.listItemPrefix) {
      ok(event[1]._tokenizer, "expected `_tokenizer` on subtokens");
      subevents = event[1]._tokenizer.events;
      otherIndex = 0;
      if (otherIndex < subevents.length && subevents[otherIndex][1].type === types.lineEndingBlank) {
        otherIndex += 2;
      }
      if (otherIndex < subevents.length && subevents[otherIndex][1].type === types.content) {
        while (++otherIndex < subevents.length) {
          if (subevents[otherIndex][1].type === types.content) {
            break;
          }
          if (subevents[otherIndex][1].type === types.chunkText) {
            subevents[otherIndex][1]._isInFirstContentOfListItem = true;
            otherIndex++;
          }
        }
      }
    }
    if (event[0] === "enter") {
      if (event[1].contentType) {
        Object.assign(jumps, subcontent(events, index3));
        index3 = jumps[index3];
        more = true;
      }
    } else if (event[1]._container) {
      otherIndex = index3;
      lineIndex = void 0;
      while (otherIndex--) {
        otherEvent = events.get(otherIndex);
        if (otherEvent[1].type === types.lineEnding || otherEvent[1].type === types.lineEndingBlank) {
          if (otherEvent[0] === "enter") {
            if (lineIndex) {
              events.get(lineIndex)[1].type = types.lineEndingBlank;
            }
            otherEvent[1].type = types.lineEnding;
            lineIndex = otherIndex;
          }
        } else if (otherEvent[1].type === types.linePrefix) {
        } else {
          break;
        }
      }
      if (lineIndex) {
        event[1].end = { ...events.get(lineIndex)[1].start };
        parameters = events.slice(lineIndex, index3);
        parameters.unshift(event);
        events.splice(lineIndex, index3 - lineIndex + 1, parameters);
      }
    }
  }
  splice(eventsArray, 0, Number.POSITIVE_INFINITY, events.slice(0));
  return !more;
}
function subcontent(events, eventIndex) {
  const token = events.get(eventIndex)[1];
  const context = events.get(eventIndex)[2];
  let startPosition = eventIndex - 1;
  const startPositions = [];
  ok(token.contentType, "expected `contentType` on subtokens");
  const tokenizer2 = token._tokenizer || context.parser[token.contentType](token.start);
  const childEvents = tokenizer2.events;
  const jumps = [];
  const gaps = {};
  let stream;
  let previous3;
  let index3 = -1;
  let current2 = token;
  let adjust = 0;
  let start2 = 0;
  const breaks = [start2];
  while (current2) {
    while (events.get(++startPosition)[1] !== current2) {
    }
    ok(
      !previous3 || current2.previous === previous3,
      "expected previous to match"
    );
    ok(!previous3 || previous3.next === current2, "expected next to match");
    startPositions.push(startPosition);
    if (!current2._tokenizer) {
      stream = context.sliceStream(current2);
      if (!current2.next) {
        stream.push(codes.eof);
      }
      if (previous3) {
        tokenizer2.defineSkip(current2.start);
      }
      if (current2._isInFirstContentOfListItem) {
        tokenizer2._gfmTasklistFirstContentOfListItem = true;
      }
      tokenizer2.write(stream);
      if (current2._isInFirstContentOfListItem) {
        tokenizer2._gfmTasklistFirstContentOfListItem = void 0;
      }
    }
    previous3 = current2;
    current2 = current2.next;
  }
  current2 = token;
  while (++index3 < childEvents.length) {
    if (
      // Find a void token that includes a break.
      childEvents[index3][0] === "exit" && childEvents[index3 - 1][0] === "enter" && childEvents[index3][1].type === childEvents[index3 - 1][1].type && childEvents[index3][1].start.line !== childEvents[index3][1].end.line
    ) {
      ok(current2, "expected a current token");
      start2 = index3 + 1;
      breaks.push(start2);
      current2._tokenizer = void 0;
      current2.previous = void 0;
      current2 = current2.next;
    }
  }
  tokenizer2.events = [];
  if (current2) {
    current2._tokenizer = void 0;
    current2.previous = void 0;
    ok(!current2.next, "expected no next token");
  } else {
    breaks.pop();
  }
  index3 = breaks.length;
  while (index3--) {
    const slice = childEvents.slice(breaks[index3], breaks[index3 + 1]);
    const start3 = startPositions.pop();
    ok(start3 !== void 0, "expected a start position when splicing");
    jumps.push([start3, start3 + slice.length - 1]);
    events.splice(start3, 2, slice);
  }
  jumps.reverse();
  index3 = -1;
  while (++index3 < jumps.length) {
    gaps[adjust + jumps[index3][0]] = adjust + jumps[index3][1];
    adjust += jumps[index3][1] - jumps[index3][0] - 1;
  }
  return gaps;
}

// node_modules/micromark-core-commonmark/dev/lib/content.js
var content2 = { resolve: resolveContent, tokenize: tokenizeContent };
var continuationConstruct = { partial: true, tokenize: tokenizeContinuation };
function resolveContent(events) {
  subtokenize(events);
  return events;
}
function tokenizeContent(effects, ok3) {
  let previous3;
  return chunkStart;
  function chunkStart(code3) {
    ok(
      code3 !== codes.eof && !markdownLineEnding(code3),
      "expected no eof or eol"
    );
    effects.enter(types.content);
    previous3 = effects.enter(types.chunkContent, {
      contentType: constants.contentTypeContent
    });
    return chunkInside(code3);
  }
  function chunkInside(code3) {
    if (code3 === codes.eof) {
      return contentEnd(code3);
    }
    if (markdownLineEnding(code3)) {
      return effects.check(
        continuationConstruct,
        contentContinue,
        contentEnd
      )(code3);
    }
    effects.consume(code3);
    return chunkInside;
  }
  function contentEnd(code3) {
    effects.exit(types.chunkContent);
    effects.exit(types.content);
    return ok3(code3);
  }
  function contentContinue(code3) {
    ok(markdownLineEnding(code3), "expected eol");
    effects.consume(code3);
    effects.exit(types.chunkContent);
    ok(previous3, "expected previous token");
    previous3.next = effects.enter(types.chunkContent, {
      contentType: constants.contentTypeContent,
      previous: previous3
    });
    previous3 = previous3.next;
    return chunkInside;
  }
}
function tokenizeContinuation(effects, ok3, nok) {
  const self2 = this;
  return startLookahead;
  function startLookahead(code3) {
    ok(markdownLineEnding(code3), "expected a line ending");
    effects.exit(types.chunkContent);
    effects.enter(types.lineEnding);
    effects.consume(code3);
    effects.exit(types.lineEnding);
    return factorySpace(effects, prefixed, types.linePrefix);
  }
  function prefixed(code3) {
    if (code3 === codes.eof || markdownLineEnding(code3)) {
      return nok(code3);
    }
    ok(
      self2.parser.constructs.disable.null,
      "expected `disable.null` to be populated"
    );
    const tail = self2.events[self2.events.length - 1];
    if (!self2.parser.constructs.disable.null.includes("codeIndented") && tail && tail[1].type === types.linePrefix && tail[2].sliceSerialize(tail[1], true).length >= constants.tabSize) {
      return ok3(code3);
    }
    return effects.interrupt(self2.parser.constructs.flow, nok, ok3)(code3);
  }
}

// node_modules/micromark-factory-destination/dev/index.js
function factoryDestination(effects, ok3, nok, type2, literalType, literalMarkerType, rawType, stringType, max2) {
  const limit = max2 || Number.POSITIVE_INFINITY;
  let balance = 0;
  return start2;
  function start2(code3) {
    if (code3 === codes.lessThan) {
      effects.enter(type2);
      effects.enter(literalType);
      effects.enter(literalMarkerType);
      effects.consume(code3);
      effects.exit(literalMarkerType);
      return enclosedBefore;
    }
    if (code3 === codes.eof || code3 === codes.space || code3 === codes.rightParenthesis || asciiControl(code3)) {
      return nok(code3);
    }
    effects.enter(type2);
    effects.enter(rawType);
    effects.enter(stringType);
    effects.enter(types.chunkString, { contentType: constants.contentTypeString });
    return raw(code3);
  }
  function enclosedBefore(code3) {
    if (code3 === codes.greaterThan) {
      effects.enter(literalMarkerType);
      effects.consume(code3);
      effects.exit(literalMarkerType);
      effects.exit(literalType);
      effects.exit(type2);
      return ok3;
    }
    effects.enter(stringType);
    effects.enter(types.chunkString, { contentType: constants.contentTypeString });
    return enclosed(code3);
  }
  function enclosed(code3) {
    if (code3 === codes.greaterThan) {
      effects.exit(types.chunkString);
      effects.exit(stringType);
      return enclosedBefore(code3);
    }
    if (code3 === codes.eof || code3 === codes.lessThan || markdownLineEnding(code3)) {
      return nok(code3);
    }
    effects.consume(code3);
    return code3 === codes.backslash ? enclosedEscape : enclosed;
  }
  function enclosedEscape(code3) {
    if (code3 === codes.lessThan || code3 === codes.greaterThan || code3 === codes.backslash) {
      effects.consume(code3);
      return enclosed;
    }
    return enclosed(code3);
  }
  function raw(code3) {
    if (!balance && (code3 === codes.eof || code3 === codes.rightParenthesis || markdownLineEndingOrSpace(code3))) {
      effects.exit(types.chunkString);
      effects.exit(stringType);
      effects.exit(rawType);
      effects.exit(type2);
      return ok3(code3);
    }
    if (balance < limit && code3 === codes.leftParenthesis) {
      effects.consume(code3);
      balance++;
      return raw;
    }
    if (code3 === codes.rightParenthesis) {
      effects.consume(code3);
      balance--;
      return raw;
    }
    if (code3 === codes.eof || code3 === codes.space || code3 === codes.leftParenthesis || asciiControl(code3)) {
      return nok(code3);
    }
    effects.consume(code3);
    return code3 === codes.backslash ? rawEscape : raw;
  }
  function rawEscape(code3) {
    if (code3 === codes.leftParenthesis || code3 === codes.rightParenthesis || code3 === codes.backslash) {
      effects.consume(code3);
      return raw;
    }
    return raw(code3);
  }
}

// node_modules/micromark-factory-label/dev/index.js
function factoryLabel(effects, ok3, nok, type2, markerType, stringType) {
  const self2 = this;
  let size4 = 0;
  let seen;
  return start2;
  function start2(code3) {
    ok(code3 === codes.leftSquareBracket, "expected `[`");
    effects.enter(type2);
    effects.enter(markerType);
    effects.consume(code3);
    effects.exit(markerType);
    effects.enter(stringType);
    return atBreak;
  }
  function atBreak(code3) {
    if (size4 > constants.linkReferenceSizeMax || code3 === codes.eof || code3 === codes.leftSquareBracket || code3 === codes.rightSquareBracket && !seen || // To do: remove in the future once we’ve switched from
    // `micromark-extension-footnote` to `micromark-extension-gfm-footnote`,
    // which doesn’t need this.
    // Hidden footnotes hook.
    /* c8 ignore next 3 */
    code3 === codes.caret && !size4 && "_hiddenFootnoteSupport" in self2.parser.constructs) {
      return nok(code3);
    }
    if (code3 === codes.rightSquareBracket) {
      effects.exit(stringType);
      effects.enter(markerType);
      effects.consume(code3);
      effects.exit(markerType);
      effects.exit(type2);
      return ok3;
    }
    if (markdownLineEnding(code3)) {
      effects.enter(types.lineEnding);
      effects.consume(code3);
      effects.exit(types.lineEnding);
      return atBreak;
    }
    effects.enter(types.chunkString, { contentType: constants.contentTypeString });
    return labelInside(code3);
  }
  function labelInside(code3) {
    if (code3 === codes.eof || code3 === codes.leftSquareBracket || code3 === codes.rightSquareBracket || markdownLineEnding(code3) || size4++ > constants.linkReferenceSizeMax) {
      effects.exit(types.chunkString);
      return atBreak(code3);
    }
    effects.consume(code3);
    if (!seen) seen = !markdownSpace(code3);
    return code3 === codes.backslash ? labelEscape : labelInside;
  }
  function labelEscape(code3) {
    if (code3 === codes.leftSquareBracket || code3 === codes.backslash || code3 === codes.rightSquareBracket) {
      effects.consume(code3);
      size4++;
      return labelInside;
    }
    return labelInside(code3);
  }
}

// node_modules/micromark-factory-title/dev/index.js
function factoryTitle(effects, ok3, nok, type2, markerType, stringType) {
  let marker;
  return start2;
  function start2(code3) {
    if (code3 === codes.quotationMark || code3 === codes.apostrophe || code3 === codes.leftParenthesis) {
      effects.enter(type2);
      effects.enter(markerType);
      effects.consume(code3);
      effects.exit(markerType);
      marker = code3 === codes.leftParenthesis ? codes.rightParenthesis : code3;
      return begin;
    }
    return nok(code3);
  }
  function begin(code3) {
    if (code3 === marker) {
      effects.enter(markerType);
      effects.consume(code3);
      effects.exit(markerType);
      effects.exit(type2);
      return ok3;
    }
    effects.enter(stringType);
    return atBreak(code3);
  }
  function atBreak(code3) {
    if (code3 === marker) {
      effects.exit(stringType);
      return begin(marker);
    }
    if (code3 === codes.eof) {
      return nok(code3);
    }
    if (markdownLineEnding(code3)) {
      effects.enter(types.lineEnding);
      effects.consume(code3);
      effects.exit(types.lineEnding);
      return factorySpace(effects, atBreak, types.linePrefix);
    }
    effects.enter(types.chunkString, { contentType: constants.contentTypeString });
    return inside(code3);
  }
  function inside(code3) {
    if (code3 === marker || code3 === codes.eof || markdownLineEnding(code3)) {
      effects.exit(types.chunkString);
      return atBreak(code3);
    }
    effects.consume(code3);
    return code3 === codes.backslash ? escape : inside;
  }
  function escape(code3) {
    if (code3 === marker || code3 === codes.backslash) {
      effects.consume(code3);
      return inside;
    }
    return inside(code3);
  }
}

// node_modules/micromark-factory-whitespace/dev/index.js
function factoryWhitespace(effects, ok3) {
  let seen;
  return start2;
  function start2(code3) {
    if (markdownLineEnding(code3)) {
      effects.enter(types.lineEnding);
      effects.consume(code3);
      effects.exit(types.lineEnding);
      seen = true;
      return start2;
    }
    if (markdownSpace(code3)) {
      return factorySpace(
        effects,
        start2,
        seen ? types.linePrefix : types.lineSuffix
      )(code3);
    }
    return ok3(code3);
  }
}

// node_modules/micromark-core-commonmark/dev/lib/definition.js
var definition2 = { name: "definition", tokenize: tokenizeDefinition };
var titleBefore = { partial: true, tokenize: tokenizeTitleBefore };
function tokenizeDefinition(effects, ok3, nok) {
  const self2 = this;
  let identifier;
  return start2;
  function start2(code3) {
    effects.enter(types.definition);
    return before(code3);
  }
  function before(code3) {
    ok(code3 === codes.leftSquareBracket, "expected `[`");
    return factoryLabel.call(
      self2,
      effects,
      labelAfter,
      // Note: we don’t need to reset the way `markdown-rs` does.
      nok,
      types.definitionLabel,
      types.definitionLabelMarker,
      types.definitionLabelString
    )(code3);
  }
  function labelAfter(code3) {
    identifier = normalizeIdentifier(
      self2.sliceSerialize(self2.events[self2.events.length - 1][1]).slice(1, -1)
    );
    if (code3 === codes.colon) {
      effects.enter(types.definitionMarker);
      effects.consume(code3);
      effects.exit(types.definitionMarker);
      return markerAfter;
    }
    return nok(code3);
  }
  function markerAfter(code3) {
    return markdownLineEndingOrSpace(code3) ? factoryWhitespace(effects, destinationBefore)(code3) : destinationBefore(code3);
  }
  function destinationBefore(code3) {
    return factoryDestination(
      effects,
      destinationAfter,
      // Note: we don’t need to reset the way `markdown-rs` does.
      nok,
      types.definitionDestination,
      types.definitionDestinationLiteral,
      types.definitionDestinationLiteralMarker,
      types.definitionDestinationRaw,
      types.definitionDestinationString
    )(code3);
  }
  function destinationAfter(code3) {
    return effects.attempt(titleBefore, after, after)(code3);
  }
  function after(code3) {
    return markdownSpace(code3) ? factorySpace(effects, afterWhitespace, types.whitespace)(code3) : afterWhitespace(code3);
  }
  function afterWhitespace(code3) {
    if (code3 === codes.eof || markdownLineEnding(code3)) {
      effects.exit(types.definition);
      self2.parser.defined.push(identifier);
      return ok3(code3);
    }
    return nok(code3);
  }
}
function tokenizeTitleBefore(effects, ok3, nok) {
  return titleBefore2;
  function titleBefore2(code3) {
    return markdownLineEndingOrSpace(code3) ? factoryWhitespace(effects, beforeMarker)(code3) : nok(code3);
  }
  function beforeMarker(code3) {
    return factoryTitle(
      effects,
      titleAfter,
      nok,
      types.definitionTitle,
      types.definitionTitleMarker,
      types.definitionTitleString
    )(code3);
  }
  function titleAfter(code3) {
    return markdownSpace(code3) ? factorySpace(
      effects,
      titleAfterOptionalWhitespace,
      types.whitespace
    )(code3) : titleAfterOptionalWhitespace(code3);
  }
  function titleAfterOptionalWhitespace(code3) {
    return code3 === codes.eof || markdownLineEnding(code3) ? ok3(code3) : nok(code3);
  }
}

// node_modules/micromark-core-commonmark/dev/lib/hard-break-escape.js
var hardBreakEscape = {
  name: "hardBreakEscape",
  tokenize: tokenizeHardBreakEscape
};
function tokenizeHardBreakEscape(effects, ok3, nok) {
  return start2;
  function start2(code3) {
    ok(code3 === codes.backslash, "expected `\\`");
    effects.enter(types.hardBreakEscape);
    effects.consume(code3);
    return after;
  }
  function after(code3) {
    if (markdownLineEnding(code3)) {
      effects.exit(types.hardBreakEscape);
      return ok3(code3);
    }
    return nok(code3);
  }
}

// node_modules/micromark-core-commonmark/dev/lib/heading-atx.js
var headingAtx = {
  name: "headingAtx",
  resolve: resolveHeadingAtx,
  tokenize: tokenizeHeadingAtx
};
function resolveHeadingAtx(events, context) {
  let contentEnd = events.length - 2;
  let contentStart = 3;
  let content3;
  let text4;
  if (events[contentStart][1].type === types.whitespace) {
    contentStart += 2;
  }
  if (contentEnd - 2 > contentStart && events[contentEnd][1].type === types.whitespace) {
    contentEnd -= 2;
  }
  if (events[contentEnd][1].type === types.atxHeadingSequence && (contentStart === contentEnd - 1 || contentEnd - 4 > contentStart && events[contentEnd - 2][1].type === types.whitespace)) {
    contentEnd -= contentStart + 1 === contentEnd ? 2 : 4;
  }
  if (contentEnd > contentStart) {
    content3 = {
      type: types.atxHeadingText,
      start: events[contentStart][1].start,
      end: events[contentEnd][1].end
    };
    text4 = {
      type: types.chunkText,
      start: events[contentStart][1].start,
      end: events[contentEnd][1].end,
      contentType: constants.contentTypeText
    };
    splice(events, contentStart, contentEnd - contentStart + 1, [
      ["enter", content3, context],
      ["enter", text4, context],
      ["exit", text4, context],
      ["exit", content3, context]
    ]);
  }
  return events;
}
function tokenizeHeadingAtx(effects, ok3, nok) {
  let size4 = 0;
  return start2;
  function start2(code3) {
    effects.enter(types.atxHeading);
    return before(code3);
  }
  function before(code3) {
    ok(code3 === codes.numberSign, "expected `#`");
    effects.enter(types.atxHeadingSequence);
    return sequenceOpen(code3);
  }
  function sequenceOpen(code3) {
    if (code3 === codes.numberSign && size4++ < constants.atxHeadingOpeningFenceSizeMax) {
      effects.consume(code3);
      return sequenceOpen;
    }
    if (code3 === codes.eof || markdownLineEndingOrSpace(code3)) {
      effects.exit(types.atxHeadingSequence);
      return atBreak(code3);
    }
    return nok(code3);
  }
  function atBreak(code3) {
    if (code3 === codes.numberSign) {
      effects.enter(types.atxHeadingSequence);
      return sequenceFurther(code3);
    }
    if (code3 === codes.eof || markdownLineEnding(code3)) {
      effects.exit(types.atxHeading);
      return ok3(code3);
    }
    if (markdownSpace(code3)) {
      return factorySpace(effects, atBreak, types.whitespace)(code3);
    }
    effects.enter(types.atxHeadingText);
    return data2(code3);
  }
  function sequenceFurther(code3) {
    if (code3 === codes.numberSign) {
      effects.consume(code3);
      return sequenceFurther;
    }
    effects.exit(types.atxHeadingSequence);
    return atBreak(code3);
  }
  function data2(code3) {
    if (code3 === codes.eof || code3 === codes.numberSign || markdownLineEndingOrSpace(code3)) {
      effects.exit(types.atxHeadingText);
      return atBreak(code3);
    }
    effects.consume(code3);
    return data2;
  }
}

// node_modules/micromark-util-html-tag-name/index.js
var htmlBlockNames = [
  "address",
  "article",
  "aside",
  "base",
  "basefont",
  "blockquote",
  "body",
  "caption",
  "center",
  "col",
  "colgroup",
  "dd",
  "details",
  "dialog",
  "dir",
  "div",
  "dl",
  "dt",
  "fieldset",
  "figcaption",
  "figure",
  "footer",
  "form",
  "frame",
  "frameset",
  "h1",
  "h2",
  "h3",
  "h4",
  "h5",
  "h6",
  "head",
  "header",
  "hr",
  "html",
  "iframe",
  "legend",
  "li",
  "link",
  "main",
  "menu",
  "menuitem",
  "nav",
  "noframes",
  "ol",
  "optgroup",
  "option",
  "p",
  "param",
  "search",
  "section",
  "summary",
  "table",
  "tbody",
  "td",
  "tfoot",
  "th",
  "thead",
  "title",
  "tr",
  "track",
  "ul"
];
var htmlRawNames = ["pre", "script", "style", "textarea"];

// node_modules/micromark-core-commonmark/dev/lib/html-flow.js
var htmlFlow = {
  concrete: true,
  name: "htmlFlow",
  resolveTo: resolveToHtmlFlow,
  tokenize: tokenizeHtmlFlow
};
var blankLineBefore = { partial: true, tokenize: tokenizeBlankLineBefore };
var nonLazyContinuationStart = {
  partial: true,
  tokenize: tokenizeNonLazyContinuationStart
};
function resolveToHtmlFlow(events) {
  let index3 = events.length;
  while (index3--) {
    if (events[index3][0] === "enter" && events[index3][1].type === types.htmlFlow) {
      break;
    }
  }
  if (index3 > 1 && events[index3 - 2][1].type === types.linePrefix) {
    events[index3][1].start = events[index3 - 2][1].start;
    events[index3 + 1][1].start = events[index3 - 2][1].start;
    events.splice(index3 - 2, 2);
  }
  return events;
}
function tokenizeHtmlFlow(effects, ok3, nok) {
  const self2 = this;
  let marker;
  let closingTag;
  let buffer;
  let index3;
  let markerB;
  return start2;
  function start2(code3) {
    return before(code3);
  }
  function before(code3) {
    ok(code3 === codes.lessThan, "expected `<`");
    effects.enter(types.htmlFlow);
    effects.enter(types.htmlFlowData);
    effects.consume(code3);
    return open;
  }
  function open(code3) {
    if (code3 === codes.exclamationMark) {
      effects.consume(code3);
      return declarationOpen;
    }
    if (code3 === codes.slash) {
      effects.consume(code3);
      closingTag = true;
      return tagCloseStart;
    }
    if (code3 === codes.questionMark) {
      effects.consume(code3);
      marker = constants.htmlInstruction;
      return self2.interrupt ? ok3 : continuationDeclarationInside;
    }
    if (asciiAlpha(code3)) {
      ok(code3 !== null);
      effects.consume(code3);
      buffer = String.fromCharCode(code3);
      return tagName;
    }
    return nok(code3);
  }
  function declarationOpen(code3) {
    if (code3 === codes.dash) {
      effects.consume(code3);
      marker = constants.htmlComment;
      return commentOpenInside;
    }
    if (code3 === codes.leftSquareBracket) {
      effects.consume(code3);
      marker = constants.htmlCdata;
      index3 = 0;
      return cdataOpenInside;
    }
    if (asciiAlpha(code3)) {
      effects.consume(code3);
      marker = constants.htmlDeclaration;
      return self2.interrupt ? ok3 : continuationDeclarationInside;
    }
    return nok(code3);
  }
  function commentOpenInside(code3) {
    if (code3 === codes.dash) {
      effects.consume(code3);
      return self2.interrupt ? ok3 : continuationDeclarationInside;
    }
    return nok(code3);
  }
  function cdataOpenInside(code3) {
    const value2 = constants.cdataOpeningString;
    if (code3 === value2.charCodeAt(index3++)) {
      effects.consume(code3);
      if (index3 === value2.length) {
        return self2.interrupt ? ok3 : continuation;
      }
      return cdataOpenInside;
    }
    return nok(code3);
  }
  function tagCloseStart(code3) {
    if (asciiAlpha(code3)) {
      ok(code3 !== null);
      effects.consume(code3);
      buffer = String.fromCharCode(code3);
      return tagName;
    }
    return nok(code3);
  }
  function tagName(code3) {
    if (code3 === codes.eof || code3 === codes.slash || code3 === codes.greaterThan || markdownLineEndingOrSpace(code3)) {
      const slash = code3 === codes.slash;
      const name2 = buffer.toLowerCase();
      if (!slash && !closingTag && htmlRawNames.includes(name2)) {
        marker = constants.htmlRaw;
        return self2.interrupt ? ok3(code3) : continuation(code3);
      }
      if (htmlBlockNames.includes(buffer.toLowerCase())) {
        marker = constants.htmlBasic;
        if (slash) {
          effects.consume(code3);
          return basicSelfClosing;
        }
        return self2.interrupt ? ok3(code3) : continuation(code3);
      }
      marker = constants.htmlComplete;
      return self2.interrupt && !self2.parser.lazy[self2.now().line] ? nok(code3) : closingTag ? completeClosingTagAfter(code3) : completeAttributeNameBefore(code3);
    }
    if (code3 === codes.dash || asciiAlphanumeric(code3)) {
      effects.consume(code3);
      buffer += String.fromCharCode(code3);
      return tagName;
    }
    return nok(code3);
  }
  function basicSelfClosing(code3) {
    if (code3 === codes.greaterThan) {
      effects.consume(code3);
      return self2.interrupt ? ok3 : continuation;
    }
    return nok(code3);
  }
  function completeClosingTagAfter(code3) {
    if (markdownSpace(code3)) {
      effects.consume(code3);
      return completeClosingTagAfter;
    }
    return completeEnd(code3);
  }
  function completeAttributeNameBefore(code3) {
    if (code3 === codes.slash) {
      effects.consume(code3);
      return completeEnd;
    }
    if (code3 === codes.colon || code3 === codes.underscore || asciiAlpha(code3)) {
      effects.consume(code3);
      return completeAttributeName;
    }
    if (markdownSpace(code3)) {
      effects.consume(code3);
      return completeAttributeNameBefore;
    }
    return completeEnd(code3);
  }
  function completeAttributeName(code3) {
    if (code3 === codes.dash || code3 === codes.dot || code3 === codes.colon || code3 === codes.underscore || asciiAlphanumeric(code3)) {
      effects.consume(code3);
      return completeAttributeName;
    }
    return completeAttributeNameAfter(code3);
  }
  function completeAttributeNameAfter(code3) {
    if (code3 === codes.equalsTo) {
      effects.consume(code3);
      return completeAttributeValueBefore;
    }
    if (markdownSpace(code3)) {
      effects.consume(code3);
      return completeAttributeNameAfter;
    }
    return completeAttributeNameBefore(code3);
  }
  function completeAttributeValueBefore(code3) {
    if (code3 === codes.eof || code3 === codes.lessThan || code3 === codes.equalsTo || code3 === codes.greaterThan || code3 === codes.graveAccent) {
      return nok(code3);
    }
    if (code3 === codes.quotationMark || code3 === codes.apostrophe) {
      effects.consume(code3);
      markerB = code3;
      return completeAttributeValueQuoted;
    }
    if (markdownSpace(code3)) {
      effects.consume(code3);
      return completeAttributeValueBefore;
    }
    return completeAttributeValueUnquoted(code3);
  }
  function completeAttributeValueQuoted(code3) {
    if (code3 === markerB) {
      effects.consume(code3);
      markerB = null;
      return completeAttributeValueQuotedAfter;
    }
    if (code3 === codes.eof || markdownLineEnding(code3)) {
      return nok(code3);
    }
    effects.consume(code3);
    return completeAttributeValueQuoted;
  }
  function completeAttributeValueUnquoted(code3) {
    if (code3 === codes.eof || code3 === codes.quotationMark || code3 === codes.apostrophe || code3 === codes.slash || code3 === codes.lessThan || code3 === codes.equalsTo || code3 === codes.greaterThan || code3 === codes.graveAccent || markdownLineEndingOrSpace(code3)) {
      return completeAttributeNameAfter(code3);
    }
    effects.consume(code3);
    return completeAttributeValueUnquoted;
  }
  function completeAttributeValueQuotedAfter(code3) {
    if (code3 === codes.slash || code3 === codes.greaterThan || markdownSpace(code3)) {
      return completeAttributeNameBefore(code3);
    }
    return nok(code3);
  }
  function completeEnd(code3) {
    if (code3 === codes.greaterThan) {
      effects.consume(code3);
      return completeAfter;
    }
    return nok(code3);
  }
  function completeAfter(code3) {
    if (code3 === codes.eof || markdownLineEnding(code3)) {
      return continuation(code3);
    }
    if (markdownSpace(code3)) {
      effects.consume(code3);
      return completeAfter;
    }
    return nok(code3);
  }
  function continuation(code3) {
    if (code3 === codes.dash && marker === constants.htmlComment) {
      effects.consume(code3);
      return continuationCommentInside;
    }
    if (code3 === codes.lessThan && marker === constants.htmlRaw) {
      effects.consume(code3);
      return continuationRawTagOpen;
    }
    if (code3 === codes.greaterThan && marker === constants.htmlDeclaration) {
      effects.consume(code3);
      return continuationClose;
    }
    if (code3 === codes.questionMark && marker === constants.htmlInstruction) {
      effects.consume(code3);
      return continuationDeclarationInside;
    }
    if (code3 === codes.rightSquareBracket && marker === constants.htmlCdata) {
      effects.consume(code3);
      return continuationCdataInside;
    }
    if (markdownLineEnding(code3) && (marker === constants.htmlBasic || marker === constants.htmlComplete)) {
      effects.exit(types.htmlFlowData);
      return effects.check(
        blankLineBefore,
        continuationAfter,
        continuationStart
      )(code3);
    }
    if (code3 === codes.eof || markdownLineEnding(code3)) {
      effects.exit(types.htmlFlowData);
      return continuationStart(code3);
    }
    effects.consume(code3);
    return continuation;
  }
  function continuationStart(code3) {
    return effects.check(
      nonLazyContinuationStart,
      continuationStartNonLazy,
      continuationAfter
    )(code3);
  }
  function continuationStartNonLazy(code3) {
    ok(markdownLineEnding(code3));
    effects.enter(types.lineEnding);
    effects.consume(code3);
    effects.exit(types.lineEnding);
    return continuationBefore;
  }
  function continuationBefore(code3) {
    if (code3 === codes.eof || markdownLineEnding(code3)) {
      return continuationStart(code3);
    }
    effects.enter(types.htmlFlowData);
    return continuation(code3);
  }
  function continuationCommentInside(code3) {
    if (code3 === codes.dash) {
      effects.consume(code3);
      return continuationDeclarationInside;
    }
    return continuation(code3);
  }
  function continuationRawTagOpen(code3) {
    if (code3 === codes.slash) {
      effects.consume(code3);
      buffer = "";
      return continuationRawEndTag;
    }
    return continuation(code3);
  }
  function continuationRawEndTag(code3) {
    if (code3 === codes.greaterThan) {
      const name2 = buffer.toLowerCase();
      if (htmlRawNames.includes(name2)) {
        effects.consume(code3);
        return continuationClose;
      }
      return continuation(code3);
    }
    if (asciiAlpha(code3) && buffer.length < constants.htmlRawSizeMax) {
      ok(code3 !== null);
      effects.consume(code3);
      buffer += String.fromCharCode(code3);
      return continuationRawEndTag;
    }
    return continuation(code3);
  }
  function continuationCdataInside(code3) {
    if (code3 === codes.rightSquareBracket) {
      effects.consume(code3);
      return continuationDeclarationInside;
    }
    return continuation(code3);
  }
  function continuationDeclarationInside(code3) {
    if (code3 === codes.greaterThan) {
      effects.consume(code3);
      return continuationClose;
    }
    if (code3 === codes.dash && marker === constants.htmlComment) {
      effects.consume(code3);
      return continuationDeclarationInside;
    }
    return continuation(code3);
  }
  function continuationClose(code3) {
    if (code3 === codes.eof || markdownLineEnding(code3)) {
      effects.exit(types.htmlFlowData);
      return continuationAfter(code3);
    }
    effects.consume(code3);
    return continuationClose;
  }
  function continuationAfter(code3) {
    effects.exit(types.htmlFlow);
    return ok3(code3);
  }
}
function tokenizeNonLazyContinuationStart(effects, ok3, nok) {
  const self2 = this;
  return start2;
  function start2(code3) {
    if (markdownLineEnding(code3)) {
      effects.enter(types.lineEnding);
      effects.consume(code3);
      effects.exit(types.lineEnding);
      return after;
    }
    return nok(code3);
  }
  function after(code3) {
    return self2.parser.lazy[self2.now().line] ? nok(code3) : ok3(code3);
  }
}
function tokenizeBlankLineBefore(effects, ok3, nok) {
  return start2;
  function start2(code3) {
    ok(markdownLineEnding(code3), "expected a line ending");
    effects.enter(types.lineEnding);
    effects.consume(code3);
    effects.exit(types.lineEnding);
    return effects.attempt(blankLine, ok3, nok);
  }
}

// node_modules/micromark-core-commonmark/dev/lib/html-text.js
var htmlText = { name: "htmlText", tokenize: tokenizeHtmlText };
function tokenizeHtmlText(effects, ok3, nok) {
  const self2 = this;
  let marker;
  let index3;
  let returnState;
  return start2;
  function start2(code3) {
    ok(code3 === codes.lessThan, "expected `<`");
    effects.enter(types.htmlText);
    effects.enter(types.htmlTextData);
    effects.consume(code3);
    return open;
  }
  function open(code3) {
    if (code3 === codes.exclamationMark) {
      effects.consume(code3);
      return declarationOpen;
    }
    if (code3 === codes.slash) {
      effects.consume(code3);
      return tagCloseStart;
    }
    if (code3 === codes.questionMark) {
      effects.consume(code3);
      return instruction;
    }
    if (asciiAlpha(code3)) {
      effects.consume(code3);
      return tagOpen;
    }
    return nok(code3);
  }
  function declarationOpen(code3) {
    if (code3 === codes.dash) {
      effects.consume(code3);
      return commentOpenInside;
    }
    if (code3 === codes.leftSquareBracket) {
      effects.consume(code3);
      index3 = 0;
      return cdataOpenInside;
    }
    if (asciiAlpha(code3)) {
      effects.consume(code3);
      return declaration;
    }
    return nok(code3);
  }
  function commentOpenInside(code3) {
    if (code3 === codes.dash) {
      effects.consume(code3);
      return commentEnd;
    }
    return nok(code3);
  }
  function comment2(code3) {
    if (code3 === codes.eof) {
      return nok(code3);
    }
    if (code3 === codes.dash) {
      effects.consume(code3);
      return commentClose;
    }
    if (markdownLineEnding(code3)) {
      returnState = comment2;
      return lineEndingBefore(code3);
    }
    effects.consume(code3);
    return comment2;
  }
  function commentClose(code3) {
    if (code3 === codes.dash) {
      effects.consume(code3);
      return commentEnd;
    }
    return comment2(code3);
  }
  function commentEnd(code3) {
    return code3 === codes.greaterThan ? end(code3) : code3 === codes.dash ? commentClose(code3) : comment2(code3);
  }
  function cdataOpenInside(code3) {
    const value2 = constants.cdataOpeningString;
    if (code3 === value2.charCodeAt(index3++)) {
      effects.consume(code3);
      return index3 === value2.length ? cdata : cdataOpenInside;
    }
    return nok(code3);
  }
  function cdata(code3) {
    if (code3 === codes.eof) {
      return nok(code3);
    }
    if (code3 === codes.rightSquareBracket) {
      effects.consume(code3);
      return cdataClose;
    }
    if (markdownLineEnding(code3)) {
      returnState = cdata;
      return lineEndingBefore(code3);
    }
    effects.consume(code3);
    return cdata;
  }
  function cdataClose(code3) {
    if (code3 === codes.rightSquareBracket) {
      effects.consume(code3);
      return cdataEnd;
    }
    return cdata(code3);
  }
  function cdataEnd(code3) {
    if (code3 === codes.greaterThan) {
      return end(code3);
    }
    if (code3 === codes.rightSquareBracket) {
      effects.consume(code3);
      return cdataEnd;
    }
    return cdata(code3);
  }
  function declaration(code3) {
    if (code3 === codes.eof || code3 === codes.greaterThan) {
      return end(code3);
    }
    if (markdownLineEnding(code3)) {
      returnState = declaration;
      return lineEndingBefore(code3);
    }
    effects.consume(code3);
    return declaration;
  }
  function instruction(code3) {
    if (code3 === codes.eof) {
      return nok(code3);
    }
    if (code3 === codes.questionMark) {
      effects.consume(code3);
      return instructionClose;
    }
    if (markdownLineEnding(code3)) {
      returnState = instruction;
      return lineEndingBefore(code3);
    }
    effects.consume(code3);
    return instruction;
  }
  function instructionClose(code3) {
    return code3 === codes.greaterThan ? end(code3) : instruction(code3);
  }
  function tagCloseStart(code3) {
    if (asciiAlpha(code3)) {
      effects.consume(code3);
      return tagClose;
    }
    return nok(code3);
  }
  function tagClose(code3) {
    if (code3 === codes.dash || asciiAlphanumeric(code3)) {
      effects.consume(code3);
      return tagClose;
    }
    return tagCloseBetween(code3);
  }
  function tagCloseBetween(code3) {
    if (markdownLineEnding(code3)) {
      returnState = tagCloseBetween;
      return lineEndingBefore(code3);
    }
    if (markdownSpace(code3)) {
      effects.consume(code3);
      return tagCloseBetween;
    }
    return end(code3);
  }
  function tagOpen(code3) {
    if (code3 === codes.dash || asciiAlphanumeric(code3)) {
      effects.consume(code3);
      return tagOpen;
    }
    if (code3 === codes.slash || code3 === codes.greaterThan || markdownLineEndingOrSpace(code3)) {
      return tagOpenBetween(code3);
    }
    return nok(code3);
  }
  function tagOpenBetween(code3) {
    if (code3 === codes.slash) {
      effects.consume(code3);
      return end;
    }
    if (code3 === codes.colon || code3 === codes.underscore || asciiAlpha(code3)) {
      effects.consume(code3);
      return tagOpenAttributeName;
    }
    if (markdownLineEnding(code3)) {
      returnState = tagOpenBetween;
      return lineEndingBefore(code3);
    }
    if (markdownSpace(code3)) {
      effects.consume(code3);
      return tagOpenBetween;
    }
    return end(code3);
  }
  function tagOpenAttributeName(code3) {
    if (code3 === codes.dash || code3 === codes.dot || code3 === codes.colon || code3 === codes.underscore || asciiAlphanumeric(code3)) {
      effects.consume(code3);
      return tagOpenAttributeName;
    }
    return tagOpenAttributeNameAfter(code3);
  }
  function tagOpenAttributeNameAfter(code3) {
    if (code3 === codes.equalsTo) {
      effects.consume(code3);
      return tagOpenAttributeValueBefore;
    }
    if (markdownLineEnding(code3)) {
      returnState = tagOpenAttributeNameAfter;
      return lineEndingBefore(code3);
    }
    if (markdownSpace(code3)) {
      effects.consume(code3);
      return tagOpenAttributeNameAfter;
    }
    return tagOpenBetween(code3);
  }
  function tagOpenAttributeValueBefore(code3) {
    if (code3 === codes.eof || code3 === codes.lessThan || code3 === codes.equalsTo || code3 === codes.greaterThan || code3 === codes.graveAccent) {
      return nok(code3);
    }
    if (code3 === codes.quotationMark || code3 === codes.apostrophe) {
      effects.consume(code3);
      marker = code3;
      return tagOpenAttributeValueQuoted;
    }
    if (markdownLineEnding(code3)) {
      returnState = tagOpenAttributeValueBefore;
      return lineEndingBefore(code3);
    }
    if (markdownSpace(code3)) {
      effects.consume(code3);
      return tagOpenAttributeValueBefore;
    }
    effects.consume(code3);
    return tagOpenAttributeValueUnquoted;
  }
  function tagOpenAttributeValueQuoted(code3) {
    if (code3 === marker) {
      effects.consume(code3);
      marker = void 0;
      return tagOpenAttributeValueQuotedAfter;
    }
    if (code3 === codes.eof) {
      return nok(code3);
    }
    if (markdownLineEnding(code3)) {
      returnState = tagOpenAttributeValueQuoted;
      return lineEndingBefore(code3);
    }
    effects.consume(code3);
    return tagOpenAttributeValueQuoted;
  }
  function tagOpenAttributeValueUnquoted(code3) {
    if (code3 === codes.eof || code3 === codes.quotationMark || code3 === codes.apostrophe || code3 === codes.lessThan || code3 === codes.equalsTo || code3 === codes.graveAccent) {
      return nok(code3);
    }
    if (code3 === codes.slash || code3 === codes.greaterThan || markdownLineEndingOrSpace(code3)) {
      return tagOpenBetween(code3);
    }
    effects.consume(code3);
    return tagOpenAttributeValueUnquoted;
  }
  function tagOpenAttributeValueQuotedAfter(code3) {
    if (code3 === codes.slash || code3 === codes.greaterThan || markdownLineEndingOrSpace(code3)) {
      return tagOpenBetween(code3);
    }
    return nok(code3);
  }
  function end(code3) {
    if (code3 === codes.greaterThan) {
      effects.consume(code3);
      effects.exit(types.htmlTextData);
      effects.exit(types.htmlText);
      return ok3;
    }
    return nok(code3);
  }
  function lineEndingBefore(code3) {
    ok(returnState, "expected return state");
    ok(markdownLineEnding(code3), "expected eol");
    effects.exit(types.htmlTextData);
    effects.enter(types.lineEnding);
    effects.consume(code3);
    effects.exit(types.lineEnding);
    return lineEndingAfter;
  }
  function lineEndingAfter(code3) {
    ok(
      self2.parser.constructs.disable.null,
      "expected `disable.null` to be populated"
    );
    return markdownSpace(code3) ? factorySpace(
      effects,
      lineEndingAfterPrefix,
      types.linePrefix,
      self2.parser.constructs.disable.null.includes("codeIndented") ? void 0 : constants.tabSize
    )(code3) : lineEndingAfterPrefix(code3);
  }
  function lineEndingAfterPrefix(code3) {
    effects.enter(types.htmlTextData);
    return returnState(code3);
  }
}

// node_modules/micromark-core-commonmark/dev/lib/label-end.js
var labelEnd = {
  name: "labelEnd",
  resolveAll: resolveAllLabelEnd,
  resolveTo: resolveToLabelEnd,
  tokenize: tokenizeLabelEnd
};
var resourceConstruct = { tokenize: tokenizeResource };
var referenceFullConstruct = { tokenize: tokenizeReferenceFull };
var referenceCollapsedConstruct = { tokenize: tokenizeReferenceCollapsed };
function resolveAllLabelEnd(events) {
  let index3 = -1;
  const newEvents = [];
  while (++index3 < events.length) {
    const token = events[index3][1];
    newEvents.push(events[index3]);
    if (token.type === types.labelImage || token.type === types.labelLink || token.type === types.labelEnd) {
      const offset5 = token.type === types.labelImage ? 4 : 2;
      token.type = types.data;
      index3 += offset5;
    }
  }
  if (events.length !== newEvents.length) {
    splice(events, 0, events.length, newEvents);
  }
  return events;
}
function resolveToLabelEnd(events, context) {
  let index3 = events.length;
  let offset5 = 0;
  let token;
  let open;
  let close2;
  let media;
  while (index3--) {
    token = events[index3][1];
    if (open) {
      if (token.type === types.link || token.type === types.labelLink && token._inactive) {
        break;
      }
      if (events[index3][0] === "enter" && token.type === types.labelLink) {
        token._inactive = true;
      }
    } else if (close2) {
      if (events[index3][0] === "enter" && (token.type === types.labelImage || token.type === types.labelLink) && !token._balanced) {
        open = index3;
        if (token.type !== types.labelLink) {
          offset5 = 2;
          break;
        }
      }
    } else if (token.type === types.labelEnd) {
      close2 = index3;
    }
  }
  ok(open !== void 0, "`open` is supposed to be found");
  ok(close2 !== void 0, "`close` is supposed to be found");
  const group = {
    type: events[open][1].type === types.labelLink ? types.link : types.image,
    start: { ...events[open][1].start },
    end: { ...events[events.length - 1][1].end }
  };
  const label4 = {
    type: types.label,
    start: { ...events[open][1].start },
    end: { ...events[close2][1].end }
  };
  const text4 = {
    type: types.labelText,
    start: { ...events[open + offset5 + 2][1].end },
    end: { ...events[close2 - 2][1].start }
  };
  media = [
    ["enter", group, context],
    ["enter", label4, context]
  ];
  media = push(media, events.slice(open + 1, open + offset5 + 3));
  media = push(media, [["enter", text4, context]]);
  ok(
    context.parser.constructs.insideSpan.null,
    "expected `insideSpan.null` to be populated"
  );
  media = push(
    media,
    resolveAll(
      context.parser.constructs.insideSpan.null,
      events.slice(open + offset5 + 4, close2 - 3),
      context
    )
  );
  media = push(media, [
    ["exit", text4, context],
    events[close2 - 2],
    events[close2 - 1],
    ["exit", label4, context]
  ]);
  media = push(media, events.slice(close2 + 1));
  media = push(media, [["exit", group, context]]);
  splice(events, open, events.length, media);
  return events;
}
function tokenizeLabelEnd(effects, ok3, nok) {
  const self2 = this;
  let index3 = self2.events.length;
  let labelStart;
  let defined;
  while (index3--) {
    if ((self2.events[index3][1].type === types.labelImage || self2.events[index3][1].type === types.labelLink) && !self2.events[index3][1]._balanced) {
      labelStart = self2.events[index3][1];
      break;
    }
  }
  return start2;
  function start2(code3) {
    ok(code3 === codes.rightSquareBracket, "expected `]`");
    if (!labelStart) {
      return nok(code3);
    }
    if (labelStart._inactive) {
      return labelEndNok(code3);
    }
    defined = self2.parser.defined.includes(
      normalizeIdentifier(
        self2.sliceSerialize({ start: labelStart.end, end: self2.now() })
      )
    );
    effects.enter(types.labelEnd);
    effects.enter(types.labelMarker);
    effects.consume(code3);
    effects.exit(types.labelMarker);
    effects.exit(types.labelEnd);
    return after;
  }
  function after(code3) {
    if (code3 === codes.leftParenthesis) {
      return effects.attempt(
        resourceConstruct,
        labelEndOk,
        defined ? labelEndOk : labelEndNok
      )(code3);
    }
    if (code3 === codes.leftSquareBracket) {
      return effects.attempt(
        referenceFullConstruct,
        labelEndOk,
        defined ? referenceNotFull : labelEndNok
      )(code3);
    }
    return defined ? labelEndOk(code3) : labelEndNok(code3);
  }
  function referenceNotFull(code3) {
    return effects.attempt(
      referenceCollapsedConstruct,
      labelEndOk,
      labelEndNok
    )(code3);
  }
  function labelEndOk(code3) {
    return ok3(code3);
  }
  function labelEndNok(code3) {
    labelStart._balanced = true;
    return nok(code3);
  }
}
function tokenizeResource(effects, ok3, nok) {
  return resourceStart;
  function resourceStart(code3) {
    ok(code3 === codes.leftParenthesis, "expected left paren");
    effects.enter(types.resource);
    effects.enter(types.resourceMarker);
    effects.consume(code3);
    effects.exit(types.resourceMarker);
    return resourceBefore;
  }
  function resourceBefore(code3) {
    return markdownLineEndingOrSpace(code3) ? factoryWhitespace(effects, resourceOpen)(code3) : resourceOpen(code3);
  }
  function resourceOpen(code3) {
    if (code3 === codes.rightParenthesis) {
      return resourceEnd(code3);
    }
    return factoryDestination(
      effects,
      resourceDestinationAfter,
      resourceDestinationMissing,
      types.resourceDestination,
      types.resourceDestinationLiteral,
      types.resourceDestinationLiteralMarker,
      types.resourceDestinationRaw,
      types.resourceDestinationString,
      constants.linkResourceDestinationBalanceMax
    )(code3);
  }
  function resourceDestinationAfter(code3) {
    return markdownLineEndingOrSpace(code3) ? factoryWhitespace(effects, resourceBetween)(code3) : resourceEnd(code3);
  }
  function resourceDestinationMissing(code3) {
    return nok(code3);
  }
  function resourceBetween(code3) {
    if (code3 === codes.quotationMark || code3 === codes.apostrophe || code3 === codes.leftParenthesis) {
      return factoryTitle(
        effects,
        resourceTitleAfter,
        nok,
        types.resourceTitle,
        types.resourceTitleMarker,
        types.resourceTitleString
      )(code3);
    }
    return resourceEnd(code3);
  }
  function resourceTitleAfter(code3) {
    return markdownLineEndingOrSpace(code3) ? factoryWhitespace(effects, resourceEnd)(code3) : resourceEnd(code3);
  }
  function resourceEnd(code3) {
    if (code3 === codes.rightParenthesis) {
      effects.enter(types.resourceMarker);
      effects.consume(code3);
      effects.exit(types.resourceMarker);
      effects.exit(types.resource);
      return ok3;
    }
    return nok(code3);
  }
}
function tokenizeReferenceFull(effects, ok3, nok) {
  const self2 = this;
  return referenceFull;
  function referenceFull(code3) {
    ok(code3 === codes.leftSquareBracket, "expected left bracket");
    return factoryLabel.call(
      self2,
      effects,
      referenceFullAfter,
      referenceFullMissing,
      types.reference,
      types.referenceMarker,
      types.referenceString
    )(code3);
  }
  function referenceFullAfter(code3) {
    return self2.parser.defined.includes(
      normalizeIdentifier(
        self2.sliceSerialize(self2.events[self2.events.length - 1][1]).slice(1, -1)
      )
    ) ? ok3(code3) : nok(code3);
  }
  function referenceFullMissing(code3) {
    return nok(code3);
  }
}
function tokenizeReferenceCollapsed(effects, ok3, nok) {
  return referenceCollapsedStart;
  function referenceCollapsedStart(code3) {
    ok(code3 === codes.leftSquareBracket, "expected left bracket");
    effects.enter(types.reference);
    effects.enter(types.referenceMarker);
    effects.consume(code3);
    effects.exit(types.referenceMarker);
    return referenceCollapsedOpen;
  }
  function referenceCollapsedOpen(code3) {
    if (code3 === codes.rightSquareBracket) {
      effects.enter(types.referenceMarker);
      effects.consume(code3);
      effects.exit(types.referenceMarker);
      effects.exit(types.reference);
      return ok3;
    }
    return nok(code3);
  }
}

// node_modules/micromark-core-commonmark/dev/lib/label-start-image.js
var labelStartImage = {
  name: "labelStartImage",
  resolveAll: labelEnd.resolveAll,
  tokenize: tokenizeLabelStartImage
};
function tokenizeLabelStartImage(effects, ok3, nok) {
  const self2 = this;
  return start2;
  function start2(code3) {
    ok(code3 === codes.exclamationMark, "expected `!`");
    effects.enter(types.labelImage);
    effects.enter(types.labelImageMarker);
    effects.consume(code3);
    effects.exit(types.labelImageMarker);
    return open;
  }
  function open(code3) {
    if (code3 === codes.leftSquareBracket) {
      effects.enter(types.labelMarker);
      effects.consume(code3);
      effects.exit(types.labelMarker);
      effects.exit(types.labelImage);
      return after;
    }
    return nok(code3);
  }
  function after(code3) {
    return code3 === codes.caret && "_hiddenFootnoteSupport" in self2.parser.constructs ? nok(code3) : ok3(code3);
  }
}

// node_modules/micromark-core-commonmark/dev/lib/label-start-link.js
var labelStartLink = {
  name: "labelStartLink",
  resolveAll: labelEnd.resolveAll,
  tokenize: tokenizeLabelStartLink
};
function tokenizeLabelStartLink(effects, ok3, nok) {
  const self2 = this;
  return start2;
  function start2(code3) {
    ok(code3 === codes.leftSquareBracket, "expected `[`");
    effects.enter(types.labelLink);
    effects.enter(types.labelMarker);
    effects.consume(code3);
    effects.exit(types.labelMarker);
    effects.exit(types.labelLink);
    return after;
  }
  function after(code3) {
    return code3 === codes.caret && "_hiddenFootnoteSupport" in self2.parser.constructs ? nok(code3) : ok3(code3);
  }
}

// node_modules/micromark-core-commonmark/dev/lib/line-ending.js
var lineEnding = { name: "lineEnding", tokenize: tokenizeLineEnding };
function tokenizeLineEnding(effects, ok3) {
  return start2;
  function start2(code3) {
    ok(markdownLineEnding(code3), "expected eol");
    effects.enter(types.lineEnding);
    effects.consume(code3);
    effects.exit(types.lineEnding);
    return factorySpace(effects, ok3, types.linePrefix);
  }
}

// node_modules/micromark-core-commonmark/dev/lib/thematic-break.js
var thematicBreak2 = {
  name: "thematicBreak",
  tokenize: tokenizeThematicBreak
};
function tokenizeThematicBreak(effects, ok3, nok) {
  let size4 = 0;
  let marker;
  return start2;
  function start2(code3) {
    effects.enter(types.thematicBreak);
    return before(code3);
  }
  function before(code3) {
    ok(
      code3 === codes.asterisk || code3 === codes.dash || code3 === codes.underscore,
      "expected `*`, `-`, or `_`"
    );
    marker = code3;
    return atBreak(code3);
  }
  function atBreak(code3) {
    if (code3 === marker) {
      effects.enter(types.thematicBreakSequence);
      return sequence(code3);
    }
    if (size4 >= constants.thematicBreakMarkerCountMin && (code3 === codes.eof || markdownLineEnding(code3))) {
      effects.exit(types.thematicBreak);
      return ok3(code3);
    }
    return nok(code3);
  }
  function sequence(code3) {
    if (code3 === marker) {
      effects.consume(code3);
      size4++;
      return sequence;
    }
    effects.exit(types.thematicBreakSequence);
    return markdownSpace(code3) ? factorySpace(effects, atBreak, types.whitespace)(code3) : atBreak(code3);
  }
}

// node_modules/micromark-core-commonmark/dev/lib/list.js
var list3 = {
  continuation: { tokenize: tokenizeListContinuation },
  exit: tokenizeListEnd,
  name: "list",
  tokenize: tokenizeListStart
};
var listItemPrefixWhitespaceConstruct = {
  partial: true,
  tokenize: tokenizeListItemPrefixWhitespace
};
var indentConstruct = { partial: true, tokenize: tokenizeIndent };
function tokenizeListStart(effects, ok3, nok) {
  const self2 = this;
  const tail = self2.events[self2.events.length - 1];
  let initialSize = tail && tail[1].type === types.linePrefix ? tail[2].sliceSerialize(tail[1], true).length : 0;
  let size4 = 0;
  return start2;
  function start2(code3) {
    ok(self2.containerState, "expected state");
    const kind = self2.containerState.type || (code3 === codes.asterisk || code3 === codes.plusSign || code3 === codes.dash ? types.listUnordered : types.listOrdered);
    if (kind === types.listUnordered ? !self2.containerState.marker || code3 === self2.containerState.marker : asciiDigit(code3)) {
      if (!self2.containerState.type) {
        self2.containerState.type = kind;
        effects.enter(kind, { _container: true });
      }
      if (kind === types.listUnordered) {
        effects.enter(types.listItemPrefix);
        return code3 === codes.asterisk || code3 === codes.dash ? effects.check(thematicBreak2, nok, atMarker)(code3) : atMarker(code3);
      }
      if (!self2.interrupt || code3 === codes.digit1) {
        effects.enter(types.listItemPrefix);
        effects.enter(types.listItemValue);
        return inside(code3);
      }
    }
    return nok(code3);
  }
  function inside(code3) {
    ok(self2.containerState, "expected state");
    if (asciiDigit(code3) && ++size4 < constants.listItemValueSizeMax) {
      effects.consume(code3);
      return inside;
    }
    if ((!self2.interrupt || size4 < 2) && (self2.containerState.marker ? code3 === self2.containerState.marker : code3 === codes.rightParenthesis || code3 === codes.dot)) {
      effects.exit(types.listItemValue);
      return atMarker(code3);
    }
    return nok(code3);
  }
  function atMarker(code3) {
    ok(self2.containerState, "expected state");
    ok(code3 !== codes.eof, "eof (`null`) is not a marker");
    effects.enter(types.listItemMarker);
    effects.consume(code3);
    effects.exit(types.listItemMarker);
    self2.containerState.marker = self2.containerState.marker || code3;
    return effects.check(
      blankLine,
      // Can’t be empty when interrupting.
      self2.interrupt ? nok : onBlank,
      effects.attempt(
        listItemPrefixWhitespaceConstruct,
        endOfPrefix,
        otherPrefix
      )
    );
  }
  function onBlank(code3) {
    ok(self2.containerState, "expected state");
    self2.containerState.initialBlankLine = true;
    initialSize++;
    return endOfPrefix(code3);
  }
  function otherPrefix(code3) {
    if (markdownSpace(code3)) {
      effects.enter(types.listItemPrefixWhitespace);
      effects.consume(code3);
      effects.exit(types.listItemPrefixWhitespace);
      return endOfPrefix;
    }
    return nok(code3);
  }
  function endOfPrefix(code3) {
    ok(self2.containerState, "expected state");
    self2.containerState.size = initialSize + self2.sliceSerialize(effects.exit(types.listItemPrefix), true).length;
    return ok3(code3);
  }
}
function tokenizeListContinuation(effects, ok3, nok) {
  const self2 = this;
  ok(self2.containerState, "expected state");
  self2.containerState._closeFlow = void 0;
  return effects.check(blankLine, onBlank, notBlank);
  function onBlank(code3) {
    ok(self2.containerState, "expected state");
    ok(typeof self2.containerState.size === "number", "expected size");
    self2.containerState.furtherBlankLines = self2.containerState.furtherBlankLines || self2.containerState.initialBlankLine;
    return factorySpace(
      effects,
      ok3,
      types.listItemIndent,
      self2.containerState.size + 1
    )(code3);
  }
  function notBlank(code3) {
    ok(self2.containerState, "expected state");
    if (self2.containerState.furtherBlankLines || !markdownSpace(code3)) {
      self2.containerState.furtherBlankLines = void 0;
      self2.containerState.initialBlankLine = void 0;
      return notInCurrentItem(code3);
    }
    self2.containerState.furtherBlankLines = void 0;
    self2.containerState.initialBlankLine = void 0;
    return effects.attempt(indentConstruct, ok3, notInCurrentItem)(code3);
  }
  function notInCurrentItem(code3) {
    ok(self2.containerState, "expected state");
    self2.containerState._closeFlow = true;
    self2.interrupt = void 0;
    ok(
      self2.parser.constructs.disable.null,
      "expected `disable.null` to be populated"
    );
    return factorySpace(
      effects,
      effects.attempt(list3, ok3, nok),
      types.linePrefix,
      self2.parser.constructs.disable.null.includes("codeIndented") ? void 0 : constants.tabSize
    )(code3);
  }
}
function tokenizeIndent(effects, ok3, nok) {
  const self2 = this;
  ok(self2.containerState, "expected state");
  ok(typeof self2.containerState.size === "number", "expected size");
  return factorySpace(
    effects,
    afterPrefix,
    types.listItemIndent,
    self2.containerState.size + 1
  );
  function afterPrefix(code3) {
    ok(self2.containerState, "expected state");
    const tail = self2.events[self2.events.length - 1];
    return tail && tail[1].type === types.listItemIndent && tail[2].sliceSerialize(tail[1], true).length === self2.containerState.size ? ok3(code3) : nok(code3);
  }
}
function tokenizeListEnd(effects) {
  ok(this.containerState, "expected state");
  ok(typeof this.containerState.type === "string", "expected type");
  effects.exit(this.containerState.type);
}
function tokenizeListItemPrefixWhitespace(effects, ok3, nok) {
  const self2 = this;
  ok(
    self2.parser.constructs.disable.null,
    "expected `disable.null` to be populated"
  );
  return factorySpace(
    effects,
    afterPrefix,
    types.listItemPrefixWhitespace,
    self2.parser.constructs.disable.null.includes("codeIndented") ? void 0 : constants.tabSize + 1
  );
  function afterPrefix(code3) {
    const tail = self2.events[self2.events.length - 1];
    return !markdownSpace(code3) && tail && tail[1].type === types.listItemPrefixWhitespace ? ok3(code3) : nok(code3);
  }
}

// node_modules/micromark-core-commonmark/dev/lib/setext-underline.js
var setextUnderline = {
  name: "setextUnderline",
  resolveTo: resolveToSetextUnderline,
  tokenize: tokenizeSetextUnderline
};
function resolveToSetextUnderline(events, context) {
  let index3 = events.length;
  let content3;
  let text4;
  let definition3;
  while (index3--) {
    if (events[index3][0] === "enter") {
      if (events[index3][1].type === types.content) {
        content3 = index3;
        break;
      }
      if (events[index3][1].type === types.paragraph) {
        text4 = index3;
      }
    } else {
      if (events[index3][1].type === types.content) {
        events.splice(index3, 1);
      }
      if (!definition3 && events[index3][1].type === types.definition) {
        definition3 = index3;
      }
    }
  }
  ok(text4 !== void 0, "expected a `text` index to be found");
  ok(content3 !== void 0, "expected a `text` index to be found");
  const heading2 = {
    type: types.setextHeading,
    start: { ...events[text4][1].start },
    end: { ...events[events.length - 1][1].end }
  };
  events[text4][1].type = types.setextHeadingText;
  if (definition3) {
    events.splice(text4, 0, ["enter", heading2, context]);
    events.splice(definition3 + 1, 0, ["exit", events[content3][1], context]);
    events[content3][1].end = { ...events[definition3][1].end };
  } else {
    events[content3][1] = heading2;
  }
  events.push(["exit", heading2, context]);
  return events;
}
function tokenizeSetextUnderline(effects, ok3, nok) {
  const self2 = this;
  let marker;
  return start2;
  function start2(code3) {
    let index3 = self2.events.length;
    let paragraph2;
    ok(
      code3 === codes.dash || code3 === codes.equalsTo,
      "expected `=` or `-`"
    );
    while (index3--) {
      if (self2.events[index3][1].type !== types.lineEnding && self2.events[index3][1].type !== types.linePrefix && self2.events[index3][1].type !== types.content) {
        paragraph2 = self2.events[index3][1].type === types.paragraph;
        break;
      }
    }
    if (!self2.parser.lazy[self2.now().line] && (self2.interrupt || paragraph2)) {
      effects.enter(types.setextHeadingLine);
      marker = code3;
      return before(code3);
    }
    return nok(code3);
  }
  function before(code3) {
    effects.enter(types.setextHeadingLineSequence);
    return inside(code3);
  }
  function inside(code3) {
    if (code3 === marker) {
      effects.consume(code3);
      return inside;
    }
    effects.exit(types.setextHeadingLineSequence);
    return markdownSpace(code3) ? factorySpace(effects, after, types.lineSuffix)(code3) : after(code3);
  }
  function after(code3) {
    if (code3 === codes.eof || markdownLineEnding(code3)) {
      effects.exit(types.setextHeadingLine);
      return ok3(code3);
    }
    return nok(code3);
  }
}

// node_modules/micromark/dev/lib/initialize/flow.js
var flow = { tokenize: initializeFlow };
function initializeFlow(effects) {
  const self2 = this;
  const initial = effects.attempt(
    // Try to parse a blank line.
    blankLine,
    atBlankEnding,
    // Try to parse initial flow (essentially, only code).
    effects.attempt(
      this.parser.constructs.flowInitial,
      afterConstruct,
      factorySpace(
        effects,
        effects.attempt(
          this.parser.constructs.flow,
          afterConstruct,
          effects.attempt(content2, afterConstruct)
        ),
        types.linePrefix
      )
    )
  );
  return initial;
  function atBlankEnding(code3) {
    ok(
      code3 === codes.eof || markdownLineEnding(code3),
      "expected eol or eof"
    );
    if (code3 === codes.eof) {
      effects.consume(code3);
      return;
    }
    effects.enter(types.lineEndingBlank);
    effects.consume(code3);
    effects.exit(types.lineEndingBlank);
    self2.currentConstruct = void 0;
    return initial;
  }
  function afterConstruct(code3) {
    ok(
      code3 === codes.eof || markdownLineEnding(code3),
      "expected eol or eof"
    );
    if (code3 === codes.eof) {
      effects.consume(code3);
      return;
    }
    effects.enter(types.lineEnding);
    effects.consume(code3);
    effects.exit(types.lineEnding);
    self2.currentConstruct = void 0;
    return initial;
  }
}

// node_modules/micromark/dev/lib/initialize/text.js
var resolver = { resolveAll: createResolver() };
var string = initializeFactory("string");
var text2 = initializeFactory("text");
function initializeFactory(field) {
  return {
    resolveAll: createResolver(
      field === "text" ? resolveAllLineSuffixes : void 0
    ),
    tokenize: initializeText
  };
  function initializeText(effects) {
    const self2 = this;
    const constructs2 = this.parser.constructs[field];
    const text4 = effects.attempt(constructs2, start2, notText);
    return start2;
    function start2(code3) {
      return atBreak(code3) ? text4(code3) : notText(code3);
    }
    function notText(code3) {
      if (code3 === codes.eof) {
        effects.consume(code3);
        return;
      }
      effects.enter(types.data);
      effects.consume(code3);
      return data2;
    }
    function data2(code3) {
      if (atBreak(code3)) {
        effects.exit(types.data);
        return text4(code3);
      }
      effects.consume(code3);
      return data2;
    }
    function atBreak(code3) {
      if (code3 === codes.eof) {
        return true;
      }
      const list4 = constructs2[code3];
      let index3 = -1;
      if (list4) {
        ok(Array.isArray(list4), "expected `disable.null` to be populated");
        while (++index3 < list4.length) {
          const item = list4[index3];
          if (!item.previous || item.previous.call(self2, self2.previous)) {
            return true;
          }
        }
      }
      return false;
    }
  }
}
function createResolver(extraResolver) {
  return resolveAllText;
  function resolveAllText(events, context) {
    let index3 = -1;
    let enter2;
    while (++index3 <= events.length) {
      if (enter2 === void 0) {
        if (events[index3] && events[index3][1].type === types.data) {
          enter2 = index3;
          index3++;
        }
      } else if (!events[index3] || events[index3][1].type !== types.data) {
        if (index3 !== enter2 + 2) {
          events[enter2][1].end = events[index3 - 1][1].end;
          events.splice(enter2 + 2, index3 - enter2 - 2);
          index3 = enter2 + 2;
        }
        enter2 = void 0;
      }
    }
    return extraResolver ? extraResolver(events, context) : events;
  }
}
function resolveAllLineSuffixes(events, context) {
  let eventIndex = 0;
  while (++eventIndex <= events.length) {
    if ((eventIndex === events.length || events[eventIndex][1].type === types.lineEnding) && events[eventIndex - 1][1].type === types.data) {
      const data2 = events[eventIndex - 1][1];
      const chunks = context.sliceStream(data2);
      let index3 = chunks.length;
      let bufferIndex = -1;
      let size4 = 0;
      let tabs;
      while (index3--) {
        const chunk = chunks[index3];
        if (typeof chunk === "string") {
          bufferIndex = chunk.length;
          while (chunk.charCodeAt(bufferIndex - 1) === codes.space) {
            size4++;
            bufferIndex--;
          }
          if (bufferIndex) break;
          bufferIndex = -1;
        } else if (chunk === codes.horizontalTab) {
          tabs = true;
          size4++;
        } else if (chunk === codes.virtualSpace) {
        } else {
          index3++;
          break;
        }
      }
      if (size4) {
        const token = {
          type: eventIndex === events.length || tabs || size4 < constants.hardBreakPrefixSizeMin ? types.lineSuffix : types.hardBreakTrailing,
          start: {
            _bufferIndex: index3 ? bufferIndex : data2.start._bufferIndex + bufferIndex,
            _index: data2.start._index + index3,
            line: data2.end.line,
            column: data2.end.column - size4,
            offset: data2.end.offset - size4
          },
          end: { ...data2.end }
        };
        data2.end = { ...token.start };
        if (data2.start.offset === data2.end.offset) {
          Object.assign(data2, token);
        } else {
          events.splice(
            eventIndex,
            0,
            ["enter", token, context],
            ["exit", token, context]
          );
          eventIndex += 2;
        }
      }
      eventIndex++;
    }
  }
  return events;
}

// node_modules/micromark/dev/lib/constructs.js
var constructs_exports = {};
__export(constructs_exports, {
  attentionMarkers: () => attentionMarkers,
  contentInitial: () => contentInitial,
  disable: () => disable,
  document: () => document3,
  flow: () => flow2,
  flowInitial: () => flowInitial,
  insideSpan: () => insideSpan,
  string: () => string2,
  text: () => text3
});
var document3 = {
  [codes.asterisk]: list3,
  [codes.plusSign]: list3,
  [codes.dash]: list3,
  [codes.digit0]: list3,
  [codes.digit1]: list3,
  [codes.digit2]: list3,
  [codes.digit3]: list3,
  [codes.digit4]: list3,
  [codes.digit5]: list3,
  [codes.digit6]: list3,
  [codes.digit7]: list3,
  [codes.digit8]: list3,
  [codes.digit9]: list3,
  [codes.greaterThan]: blockQuote
};
var contentInitial = {
  [codes.leftSquareBracket]: definition2
};
var flowInitial = {
  [codes.horizontalTab]: codeIndented,
  [codes.virtualSpace]: codeIndented,
  [codes.space]: codeIndented
};
var flow2 = {
  [codes.numberSign]: headingAtx,
  [codes.asterisk]: thematicBreak2,
  [codes.dash]: [setextUnderline, thematicBreak2],
  [codes.lessThan]: htmlFlow,
  [codes.equalsTo]: setextUnderline,
  [codes.underscore]: thematicBreak2,
  [codes.graveAccent]: codeFenced,
  [codes.tilde]: codeFenced
};
var string2 = {
  [codes.ampersand]: characterReference,
  [codes.backslash]: characterEscape
};
var text3 = {
  [codes.carriageReturn]: lineEnding,
  [codes.lineFeed]: lineEnding,
  [codes.carriageReturnLineFeed]: lineEnding,
  [codes.exclamationMark]: labelStartImage,
  [codes.ampersand]: characterReference,
  [codes.asterisk]: attention,
  [codes.lessThan]: [autolink, htmlText],
  [codes.leftSquareBracket]: labelStartLink,
  [codes.backslash]: [hardBreakEscape, characterEscape],
  [codes.rightSquareBracket]: labelEnd,
  [codes.underscore]: attention,
  [codes.graveAccent]: codeText
};
var insideSpan = { null: [attention, resolver] };
var attentionMarkers = { null: [codes.asterisk, codes.underscore] };
var disable = { null: [] };

// node_modules/micromark/dev/lib/create-tokenizer.js
var import_debug = __toESM(require_browser(), 1);
var debug = (0, import_debug.default)("micromark");
function createTokenizer(parser, initialize, from) {
  let point3 = {
    _bufferIndex: -1,
    _index: 0,
    line: from && from.line || 1,
    column: from && from.column || 1,
    offset: from && from.offset || 0
  };
  const columnStart = {};
  const resolveAllConstructs = [];
  let chunks = [];
  let stack = [];
  let consumed = true;
  const effects = {
    attempt: constructFactory(onsuccessfulconstruct),
    check: constructFactory(onsuccessfulcheck),
    consume,
    enter: enter2,
    exit: exit4,
    interrupt: constructFactory(onsuccessfulcheck, { interrupt: true })
  };
  const context = {
    code: codes.eof,
    containerState: {},
    defineSkip,
    events: [],
    now,
    parser,
    previous: codes.eof,
    sliceSerialize,
    sliceStream,
    write
  };
  let state = initialize.tokenize.call(context, effects);
  let expectedCode;
  if (initialize.resolveAll) {
    resolveAllConstructs.push(initialize);
  }
  return context;
  function write(slice) {
    chunks = push(chunks, slice);
    main();
    if (chunks[chunks.length - 1] !== codes.eof) {
      return [];
    }
    addResult(initialize, 0);
    context.events = resolveAll(resolveAllConstructs, context.events, context);
    return context.events;
  }
  function sliceSerialize(token, expandTabs) {
    return serializeChunks2(sliceStream(token), expandTabs);
  }
  function sliceStream(token) {
    return sliceChunks(chunks, token);
  }
  function now() {
    const { _bufferIndex, _index, line, column, offset: offset5 } = point3;
    return { _bufferIndex, _index, line, column, offset: offset5 };
  }
  function defineSkip(value2) {
    columnStart[value2.line] = value2.column;
    accountForPotentialSkip();
    debug("position: define skip: `%j`", point3);
  }
  function main() {
    let chunkIndex;
    while (point3._index < chunks.length) {
      const chunk = chunks[point3._index];
      if (typeof chunk === "string") {
        chunkIndex = point3._index;
        if (point3._bufferIndex < 0) {
          point3._bufferIndex = 0;
        }
        while (point3._index === chunkIndex && point3._bufferIndex < chunk.length) {
          go(chunk.charCodeAt(point3._bufferIndex));
        }
      } else {
        go(chunk);
      }
    }
  }
  function go(code3) {
    ok(consumed === true, "expected character to be consumed");
    consumed = void 0;
    debug("main: passing `%s` to %s", code3, state && state.name);
    expectedCode = code3;
    ok(typeof state === "function", "expected state");
    state = state(code3);
  }
  function consume(code3) {
    ok(code3 === expectedCode, "expected given code to equal expected code");
    debug("consume: `%s`", code3);
    ok(
      consumed === void 0,
      "expected code to not have been consumed: this might be because `return x(code)` instead of `return x` was used"
    );
    ok(
      code3 === null ? context.events.length === 0 || context.events[context.events.length - 1][0] === "exit" : context.events[context.events.length - 1][0] === "enter",
      "expected last token to be open"
    );
    if (markdownLineEnding(code3)) {
      point3.line++;
      point3.column = 1;
      point3.offset += code3 === codes.carriageReturnLineFeed ? 2 : 1;
      accountForPotentialSkip();
      debug("position: after eol: `%j`", point3);
    } else if (code3 !== codes.virtualSpace) {
      point3.column++;
      point3.offset++;
    }
    if (point3._bufferIndex < 0) {
      point3._index++;
    } else {
      point3._bufferIndex++;
      if (point3._bufferIndex === // Points w/ non-negative `_bufferIndex` reference
      // strings.
      /** @type {string} */
      chunks[point3._index].length) {
        point3._bufferIndex = -1;
        point3._index++;
      }
    }
    context.previous = code3;
    consumed = true;
  }
  function enter2(type2, fields) {
    const token = fields || {};
    token.type = type2;
    token.start = now();
    ok(typeof type2 === "string", "expected string type");
    ok(type2.length > 0, "expected non-empty string");
    debug("enter: `%s`", type2);
    context.events.push(["enter", token, context]);
    stack.push(token);
    return token;
  }
  function exit4(type2) {
    ok(typeof type2 === "string", "expected string type");
    ok(type2.length > 0, "expected non-empty string");
    const token = stack.pop();
    ok(token, "cannot close w/o open tokens");
    token.end = now();
    ok(type2 === token.type, "expected exit token to match current token");
    ok(
      !(token.start._index === token.end._index && token.start._bufferIndex === token.end._bufferIndex),
      "expected non-empty token (`" + type2 + "`)"
    );
    debug("exit: `%s`", token.type);
    context.events.push(["exit", token, context]);
    return token;
  }
  function onsuccessfulconstruct(construct, info) {
    addResult(construct, info.from);
  }
  function onsuccessfulcheck(_2, info) {
    info.restore();
  }
  function constructFactory(onreturn, fields) {
    return hook;
    function hook(constructs2, returnState, bogusState) {
      let listOfConstructs;
      let constructIndex;
      let currentConstruct;
      let info;
      return Array.isArray(constructs2) ? (
        /* c8 ignore next 1 */
        handleListOfConstructs(constructs2)
      ) : "tokenize" in constructs2 ? (
        // Looks like a construct.
        handleListOfConstructs([
          /** @type {Construct} */
          constructs2
        ])
      ) : handleMapOfConstructs(constructs2);
      function handleMapOfConstructs(map5) {
        return start2;
        function start2(code3) {
          const left = code3 !== null && map5[code3];
          const all2 = code3 !== null && map5.null;
          const list4 = [
            // To do: add more extension tests.
            /* c8 ignore next 2 */
            ...Array.isArray(left) ? left : left ? [left] : [],
            ...Array.isArray(all2) ? all2 : all2 ? [all2] : []
          ];
          return handleListOfConstructs(list4)(code3);
        }
      }
      function handleListOfConstructs(list4) {
        listOfConstructs = list4;
        constructIndex = 0;
        if (list4.length === 0) {
          ok(bogusState, "expected `bogusState` to be given");
          return bogusState;
        }
        return handleConstruct(list4[constructIndex]);
      }
      function handleConstruct(construct) {
        return start2;
        function start2(code3) {
          info = store();
          currentConstruct = construct;
          if (!construct.partial) {
            context.currentConstruct = construct;
          }
          ok(
            context.parser.constructs.disable.null,
            "expected `disable.null` to be populated"
          );
          if (construct.name && context.parser.constructs.disable.null.includes(construct.name)) {
            return nok(code3);
          }
          return construct.tokenize.call(
            // If we do have fields, create an object w/ `context` as its
            // prototype.
            // This allows a “live binding”, which is needed for `interrupt`.
            fields ? Object.assign(Object.create(context), fields) : context,
            effects,
            ok3,
            nok
          )(code3);
        }
      }
      function ok3(code3) {
        ok(code3 === expectedCode, "expected code");
        consumed = true;
        onreturn(currentConstruct, info);
        return returnState;
      }
      function nok(code3) {
        ok(code3 === expectedCode, "expected code");
        consumed = true;
        info.restore();
        if (++constructIndex < listOfConstructs.length) {
          return handleConstruct(listOfConstructs[constructIndex]);
        }
        return bogusState;
      }
    }
  }
  function addResult(construct, from2) {
    if (construct.resolveAll && !resolveAllConstructs.includes(construct)) {
      resolveAllConstructs.push(construct);
    }
    if (construct.resolve) {
      splice(
        context.events,
        from2,
        context.events.length - from2,
        construct.resolve(context.events.slice(from2), context)
      );
    }
    if (construct.resolveTo) {
      context.events = construct.resolveTo(context.events, context);
    }
    ok(
      construct.partial || context.events.length === 0 || context.events[context.events.length - 1][0] === "exit",
      "expected last token to end"
    );
  }
  function store() {
    const startPoint = now();
    const startPrevious = context.previous;
    const startCurrentConstruct = context.currentConstruct;
    const startEventsIndex = context.events.length;
    const startStack = Array.from(stack);
    return { from: startEventsIndex, restore };
    function restore() {
      point3 = startPoint;
      context.previous = startPrevious;
      context.currentConstruct = startCurrentConstruct;
      context.events.length = startEventsIndex;
      stack = startStack;
      accountForPotentialSkip();
      debug("position: restore: `%j`", point3);
    }
  }
  function accountForPotentialSkip() {
    if (point3.line in columnStart && point3.column < 2) {
      point3.column = columnStart[point3.line];
      point3.offset += columnStart[point3.line] - 1;
    }
  }
}
function sliceChunks(chunks, token) {
  const startIndex = token.start._index;
  const startBufferIndex = token.start._bufferIndex;
  const endIndex = token.end._index;
  const endBufferIndex = token.end._bufferIndex;
  let view;
  if (startIndex === endIndex) {
    ok(endBufferIndex > -1, "expected non-negative end buffer index");
    ok(startBufferIndex > -1, "expected non-negative start buffer index");
    view = [chunks[startIndex].slice(startBufferIndex, endBufferIndex)];
  } else {
    view = chunks.slice(startIndex, endIndex);
    if (startBufferIndex > -1) {
      const head = view[0];
      if (typeof head === "string") {
        view[0] = head.slice(startBufferIndex);
      } else {
        ok(startBufferIndex === 0, "expected `startBufferIndex` to be `0`");
        view.shift();
      }
    }
    if (endBufferIndex > 0) {
      view.push(chunks[endIndex].slice(0, endBufferIndex));
    }
  }
  return view;
}
function serializeChunks2(chunks, expandTabs) {
  let index3 = -1;
  const result = [];
  let atTab;
  while (++index3 < chunks.length) {
    const chunk = chunks[index3];
    let value2;
    if (typeof chunk === "string") {
      value2 = chunk;
    } else
      switch (chunk) {
        case codes.carriageReturn: {
          value2 = values.cr;
          break;
        }
        case codes.lineFeed: {
          value2 = values.lf;
          break;
        }
        case codes.carriageReturnLineFeed: {
          value2 = values.cr + values.lf;
          break;
        }
        case codes.horizontalTab: {
          value2 = expandTabs ? values.space : values.ht;
          break;
        }
        case codes.virtualSpace: {
          if (!expandTabs && atTab) continue;
          value2 = values.space;
          break;
        }
        default: {
          ok(typeof chunk === "number", "expected number");
          value2 = String.fromCharCode(chunk);
        }
      }
    atTab = chunk === codes.horizontalTab;
    result.push(value2);
  }
  return result.join("");
}

// node_modules/micromark/dev/lib/parse.js
function parse(options) {
  const settings = options || {};
  const constructs2 = (
    /** @type {FullNormalizedExtension} */
    combineExtensions([constructs_exports, ...settings.extensions || []])
  );
  const parser = {
    constructs: constructs2,
    content: create2(content),
    defined: [],
    document: create2(document2),
    flow: create2(flow),
    lazy: {},
    string: create2(string),
    text: create2(text2)
  };
  return parser;
  function create2(initial) {
    return creator;
    function creator(from) {
      return createTokenizer(parser, initial, from);
    }
  }
}

// node_modules/micromark/dev/lib/postprocess.js
function postprocess(events) {
  while (!subtokenize(events)) {
  }
  return events;
}

// node_modules/micromark/dev/lib/preprocess.js
var search = /[\0\t\n\r]/g;
function preprocess() {
  let column = 1;
  let buffer = "";
  let start2 = true;
  let atCarriageReturn;
  return preprocessor;
  function preprocessor(value2, encoding, end) {
    const chunks = [];
    let match;
    let next;
    let startPosition;
    let endPosition;
    let code3;
    value2 = buffer + (typeof value2 === "string" ? value2.toString() : new TextDecoder(encoding || void 0).decode(value2));
    startPosition = 0;
    buffer = "";
    if (start2) {
      if (value2.charCodeAt(0) === codes.byteOrderMarker) {
        startPosition++;
      }
      start2 = void 0;
    }
    while (startPosition < value2.length) {
      search.lastIndex = startPosition;
      match = search.exec(value2);
      endPosition = match && match.index !== void 0 ? match.index : value2.length;
      code3 = value2.charCodeAt(endPosition);
      if (!match) {
        buffer = value2.slice(startPosition);
        break;
      }
      if (code3 === codes.lf && startPosition === endPosition && atCarriageReturn) {
        chunks.push(codes.carriageReturnLineFeed);
        atCarriageReturn = void 0;
      } else {
        if (atCarriageReturn) {
          chunks.push(codes.carriageReturn);
          atCarriageReturn = void 0;
        }
        if (startPosition < endPosition) {
          chunks.push(value2.slice(startPosition, endPosition));
          column += endPosition - startPosition;
        }
        switch (code3) {
          case codes.nul: {
            chunks.push(codes.replacementCharacter);
            column++;
            break;
          }
          case codes.ht: {
            next = Math.ceil(column / constants.tabSize) * constants.tabSize;
            chunks.push(codes.horizontalTab);
            while (column++ < next) chunks.push(codes.virtualSpace);
            break;
          }
          case codes.lf: {
            chunks.push(codes.lineFeed);
            column = 1;
            break;
          }
          default: {
            atCarriageReturn = true;
            column = 1;
          }
        }
      }
      startPosition = endPosition + 1;
    }
    if (end) {
      if (atCarriageReturn) chunks.push(codes.carriageReturn);
      if (buffer) chunks.push(buffer);
      chunks.push(codes.eof);
    }
    return chunks;
  }
}

// node_modules/mdast-util-from-markdown/dev/lib/index.js
var own5 = {}.hasOwnProperty;
function fromMarkdown(value2, encoding, options) {
  if (typeof encoding !== "string") {
    options = encoding;
    encoding = void 0;
  }
  return compiler(options)(
    postprocess(
      parse(options).document().write(preprocess()(value2, encoding, true))
    )
  );
}
function compiler(options) {
  const config = {
    transforms: [],
    canContainEols: ["emphasis", "fragment", "heading", "paragraph", "strong"],
    enter: {
      autolink: opener2(link2),
      autolinkProtocol: onenterdata,
      autolinkEmail: onenterdata,
      atxHeading: opener2(heading2),
      blockQuote: opener2(blockQuote2),
      characterEscape: onenterdata,
      characterReference: onenterdata,
      codeFenced: opener2(codeFlow),
      codeFencedFenceInfo: buffer,
      codeFencedFenceMeta: buffer,
      codeIndented: opener2(codeFlow, buffer),
      codeText: opener2(codeText2, buffer),
      codeTextData: onenterdata,
      data: onenterdata,
      codeFlowValue: onenterdata,
      definition: opener2(definition3),
      definitionDestinationString: buffer,
      definitionLabelString: buffer,
      definitionTitleString: buffer,
      emphasis: opener2(emphasis2),
      hardBreakEscape: opener2(hardBreak2),
      hardBreakTrailing: opener2(hardBreak2),
      htmlFlow: opener2(html3, buffer),
      htmlFlowData: onenterdata,
      htmlText: opener2(html3, buffer),
      htmlTextData: onenterdata,
      image: opener2(image2),
      label: buffer,
      link: opener2(link2),
      listItem: opener2(listItem2),
      listItemValue: onenterlistitemvalue,
      listOrdered: opener2(list4, onenterlistordered),
      listUnordered: opener2(list4),
      paragraph: opener2(paragraph2),
      reference: onenterreference,
      referenceString: buffer,
      resourceDestinationString: buffer,
      resourceTitleString: buffer,
      setextHeading: opener2(heading2),
      strong: opener2(strong2),
      thematicBreak: opener2(thematicBreak3)
    },
    exit: {
      atxHeading: closer(),
      atxHeadingSequence: onexitatxheadingsequence,
      autolink: closer(),
      autolinkEmail: onexitautolinkemail,
      autolinkProtocol: onexitautolinkprotocol,
      blockQuote: closer(),
      characterEscapeValue: onexitdata,
      characterReferenceMarkerHexadecimal: onexitcharacterreferencemarker,
      characterReferenceMarkerNumeric: onexitcharacterreferencemarker,
      characterReferenceValue: onexitcharacterreferencevalue,
      characterReference: onexitcharacterreference,
      codeFenced: closer(onexitcodefenced),
      codeFencedFence: onexitcodefencedfence,
      codeFencedFenceInfo: onexitcodefencedfenceinfo,
      codeFencedFenceMeta: onexitcodefencedfencemeta,
      codeFlowValue: onexitdata,
      codeIndented: closer(onexitcodeindented),
      codeText: closer(onexitcodetext),
      codeTextData: onexitdata,
      data: onexitdata,
      definition: closer(),
      definitionDestinationString: onexitdefinitiondestinationstring,
      definitionLabelString: onexitdefinitionlabelstring,
      definitionTitleString: onexitdefinitiontitlestring,
      emphasis: closer(),
      hardBreakEscape: closer(onexithardbreak),
      hardBreakTrailing: closer(onexithardbreak),
      htmlFlow: closer(onexithtmlflow),
      htmlFlowData: onexitdata,
      htmlText: closer(onexithtmltext),
      htmlTextData: onexitdata,
      image: closer(onexitimage),
      label: onexitlabel,
      labelText: onexitlabeltext,
      lineEnding: onexitlineending,
      link: closer(onexitlink),
      listItem: closer(),
      listOrdered: closer(),
      listUnordered: closer(),
      paragraph: closer(),
      referenceString: onexitreferencestring,
      resourceDestinationString: onexitresourcedestinationstring,
      resourceTitleString: onexitresourcetitlestring,
      resource: onexitresource,
      setextHeading: closer(onexitsetextheading),
      setextHeadingLineSequence: onexitsetextheadinglinesequence,
      setextHeadingText: onexitsetextheadingtext,
      strong: closer(),
      thematicBreak: closer()
    }
  };
  configure2(config, (options || {}).mdastExtensions || []);
  const data2 = {};
  return compile2;
  function compile2(events) {
    let tree = { type: "root", children: [] };
    const context = {
      stack: [tree],
      tokenStack: [],
      config,
      enter: enter2,
      exit: exit4,
      buffer,
      resume,
      data: data2
    };
    const listStack = [];
    let index3 = -1;
    while (++index3 < events.length) {
      if (events[index3][1].type === types.listOrdered || events[index3][1].type === types.listUnordered) {
        if (events[index3][0] === "enter") {
          listStack.push(index3);
        } else {
          const tail = listStack.pop();
          ok(typeof tail === "number", "expected list ot be open");
          index3 = prepareList(events, tail, index3);
        }
      }
    }
    index3 = -1;
    while (++index3 < events.length) {
      const handler2 = config[events[index3][0]];
      if (own5.call(handler2, events[index3][1].type)) {
        handler2[events[index3][1].type].call(
          Object.assign(
            { sliceSerialize: events[index3][2].sliceSerialize },
            context
          ),
          events[index3][1]
        );
      }
    }
    if (context.tokenStack.length > 0) {
      const tail = context.tokenStack[context.tokenStack.length - 1];
      const handler2 = tail[1] || defaultOnError;
      handler2.call(context, void 0, tail[0]);
    }
    tree.position = {
      start: point2(
        events.length > 0 ? events[0][1].start : { line: 1, column: 1, offset: 0 }
      ),
      end: point2(
        events.length > 0 ? events[events.length - 2][1].end : { line: 1, column: 1, offset: 0 }
      )
    };
    index3 = -1;
    while (++index3 < config.transforms.length) {
      tree = config.transforms[index3](tree) || tree;
    }
    return tree;
  }
  function prepareList(events, start2, length) {
    let index3 = start2 - 1;
    let containerBalance = -1;
    let listSpread = false;
    let listItem3;
    let lineIndex;
    let firstBlankLineIndex;
    let atMarker;
    while (++index3 <= length) {
      const event = events[index3];
      switch (event[1].type) {
        case types.listUnordered:
        case types.listOrdered:
        case types.blockQuote: {
          if (event[0] === "enter") {
            containerBalance++;
          } else {
            containerBalance--;
          }
          atMarker = void 0;
          break;
        }
        case types.lineEndingBlank: {
          if (event[0] === "enter") {
            if (listItem3 && !atMarker && !containerBalance && !firstBlankLineIndex) {
              firstBlankLineIndex = index3;
            }
            atMarker = void 0;
          }
          break;
        }
        case types.linePrefix:
        case types.listItemValue:
        case types.listItemMarker:
        case types.listItemPrefix:
        case types.listItemPrefixWhitespace: {
          break;
        }
        default: {
          atMarker = void 0;
        }
      }
      if (!containerBalance && event[0] === "enter" && event[1].type === types.listItemPrefix || containerBalance === -1 && event[0] === "exit" && (event[1].type === types.listUnordered || event[1].type === types.listOrdered)) {
        if (listItem3) {
          let tailIndex = index3;
          lineIndex = void 0;
          while (tailIndex--) {
            const tailEvent = events[tailIndex];
            if (tailEvent[1].type === types.lineEnding || tailEvent[1].type === types.lineEndingBlank) {
              if (tailEvent[0] === "exit") continue;
              if (lineIndex) {
                events[lineIndex][1].type = types.lineEndingBlank;
                listSpread = true;
              }
              tailEvent[1].type = types.lineEnding;
              lineIndex = tailIndex;
            } else if (tailEvent[1].type === types.linePrefix || tailEvent[1].type === types.blockQuotePrefix || tailEvent[1].type === types.blockQuotePrefixWhitespace || tailEvent[1].type === types.blockQuoteMarker || tailEvent[1].type === types.listItemIndent) {
            } else {
              break;
            }
          }
          if (firstBlankLineIndex && (!lineIndex || firstBlankLineIndex < lineIndex)) {
            listItem3._spread = true;
          }
          listItem3.end = Object.assign(
            {},
            lineIndex ? events[lineIndex][1].start : event[1].end
          );
          events.splice(lineIndex || index3, 0, ["exit", listItem3, event[2]]);
          index3++;
          length++;
        }
        if (event[1].type === types.listItemPrefix) {
          const item = {
            type: "listItem",
            _spread: false,
            start: Object.assign({}, event[1].start),
            // @ts-expect-error: we’ll add `end` in a second.
            end: void 0
          };
          listItem3 = item;
          events.splice(index3, 0, ["enter", item, event[2]]);
          index3++;
          length++;
          firstBlankLineIndex = void 0;
          atMarker = true;
        }
      }
    }
    events[start2][1]._spread = listSpread;
    return length;
  }
  function opener2(create2, and) {
    return open;
    function open(token) {
      enter2.call(this, create2(token), token);
      if (and) and.call(this, token);
    }
  }
  function buffer() {
    this.stack.push({ type: "fragment", children: [] });
  }
  function enter2(node2, token, errorHandler) {
    const parent = this.stack[this.stack.length - 1];
    ok(parent, "expected `parent`");
    ok("children" in parent, "expected `parent`");
    const siblings = parent.children;
    siblings.push(node2);
    this.stack.push(node2);
    this.tokenStack.push([token, errorHandler || void 0]);
    node2.position = {
      start: point2(token.start),
      // @ts-expect-error: `end` will be patched later.
      end: void 0
    };
  }
  function closer(and) {
    return close2;
    function close2(token) {
      if (and) and.call(this, token);
      exit4.call(this, token);
    }
  }
  function exit4(token, onExitError) {
    const node2 = this.stack.pop();
    ok(node2, "expected `node`");
    const open = this.tokenStack.pop();
    if (!open) {
      throw new Error(
        "Cannot close `" + token.type + "` (" + stringifyPosition({ start: token.start, end: token.end }) + "): it’s not open"
      );
    } else if (open[0].type !== token.type) {
      if (onExitError) {
        onExitError.call(this, token, open[0]);
      } else {
        const handler2 = open[1] || defaultOnError;
        handler2.call(this, token, open[0]);
      }
    }
    ok(node2.type !== "fragment", "unexpected fragment `exit`ed");
    ok(node2.position, "expected `position` to be defined");
    node2.position.end = point2(token.end);
  }
  function resume() {
    return toString(this.stack.pop());
  }
  function onenterlistordered() {
    this.data.expectingFirstListItemValue = true;
  }
  function onenterlistitemvalue(token) {
    if (this.data.expectingFirstListItemValue) {
      const ancestor = this.stack[this.stack.length - 2];
      ok(ancestor, "expected nodes on stack");
      ok(ancestor.type === "list", "expected list on stack");
      ancestor.start = Number.parseInt(
        this.sliceSerialize(token),
        constants.numericBaseDecimal
      );
      this.data.expectingFirstListItemValue = void 0;
    }
  }
  function onexitcodefencedfenceinfo() {
    const data3 = this.resume();
    const node2 = this.stack[this.stack.length - 1];
    ok(node2, "expected node on stack");
    ok(node2.type === "code", "expected code on stack");
    node2.lang = data3;
  }
  function onexitcodefencedfencemeta() {
    const data3 = this.resume();
    const node2 = this.stack[this.stack.length - 1];
    ok(node2, "expected node on stack");
    ok(node2.type === "code", "expected code on stack");
    node2.meta = data3;
  }
  function onexitcodefencedfence() {
    if (this.data.flowCodeInside) return;
    this.buffer();
    this.data.flowCodeInside = true;
  }
  function onexitcodefenced() {
    const data3 = this.resume();
    const node2 = this.stack[this.stack.length - 1];
    ok(node2, "expected node on stack");
    ok(node2.type === "code", "expected code on stack");
    node2.value = data3.replace(/^(\r?\n|\r)|(\r?\n|\r)$/g, "");
    this.data.flowCodeInside = void 0;
  }
  function onexitcodeindented() {
    const data3 = this.resume();
    const node2 = this.stack[this.stack.length - 1];
    ok(node2, "expected node on stack");
    ok(node2.type === "code", "expected code on stack");
    node2.value = data3.replace(/(\r?\n|\r)$/g, "");
  }
  function onexitdefinitionlabelstring(token) {
    const label4 = this.resume();
    const node2 = this.stack[this.stack.length - 1];
    ok(node2, "expected node on stack");
    ok(node2.type === "definition", "expected definition on stack");
    node2.label = label4;
    node2.identifier = normalizeIdentifier(
      this.sliceSerialize(token)
    ).toLowerCase();
  }
  function onexitdefinitiontitlestring() {
    const data3 = this.resume();
    const node2 = this.stack[this.stack.length - 1];
    ok(node2, "expected node on stack");
    ok(node2.type === "definition", "expected definition on stack");
    node2.title = data3;
  }
  function onexitdefinitiondestinationstring() {
    const data3 = this.resume();
    const node2 = this.stack[this.stack.length - 1];
    ok(node2, "expected node on stack");
    ok(node2.type === "definition", "expected definition on stack");
    node2.url = data3;
  }
  function onexitatxheadingsequence(token) {
    const node2 = this.stack[this.stack.length - 1];
    ok(node2, "expected node on stack");
    ok(node2.type === "heading", "expected heading on stack");
    if (!node2.depth) {
      const depth2 = this.sliceSerialize(token).length;
      ok(
        depth2 === 1 || depth2 === 2 || depth2 === 3 || depth2 === 4 || depth2 === 5 || depth2 === 6,
        "expected `depth` between `1` and `6`"
      );
      node2.depth = depth2;
    }
  }
  function onexitsetextheadingtext() {
    this.data.setextHeadingSlurpLineEnding = true;
  }
  function onexitsetextheadinglinesequence(token) {
    const node2 = this.stack[this.stack.length - 1];
    ok(node2, "expected node on stack");
    ok(node2.type === "heading", "expected heading on stack");
    node2.depth = this.sliceSerialize(token).codePointAt(0) === codes.equalsTo ? 1 : 2;
  }
  function onexitsetextheading() {
    this.data.setextHeadingSlurpLineEnding = void 0;
  }
  function onenterdata(token) {
    const node2 = this.stack[this.stack.length - 1];
    ok(node2, "expected node on stack");
    ok("children" in node2, "expected parent on stack");
    const siblings = node2.children;
    let tail = siblings[siblings.length - 1];
    if (!tail || tail.type !== "text") {
      tail = text4();
      tail.position = {
        start: point2(token.start),
        // @ts-expect-error: we’ll add `end` later.
        end: void 0
      };
      siblings.push(tail);
    }
    this.stack.push(tail);
  }
  function onexitdata(token) {
    const tail = this.stack.pop();
    ok(tail, "expected a `node` to be on the stack");
    ok("value" in tail, "expected a `literal` to be on the stack");
    ok(tail.position, "expected `node` to have an open position");
    tail.value += this.sliceSerialize(token);
    tail.position.end = point2(token.end);
  }
  function onexitlineending(token) {
    const context = this.stack[this.stack.length - 1];
    ok(context, "expected `node`");
    if (this.data.atHardBreak) {
      ok("children" in context, "expected `parent`");
      const tail = context.children[context.children.length - 1];
      ok(tail.position, "expected tail to have a starting position");
      tail.position.end = point2(token.end);
      this.data.atHardBreak = void 0;
      return;
    }
    if (!this.data.setextHeadingSlurpLineEnding && config.canContainEols.includes(context.type)) {
      onenterdata.call(this, token);
      onexitdata.call(this, token);
    }
  }
  function onexithardbreak() {
    this.data.atHardBreak = true;
  }
  function onexithtmlflow() {
    const data3 = this.resume();
    const node2 = this.stack[this.stack.length - 1];
    ok(node2, "expected node on stack");
    ok(node2.type === "html", "expected html on stack");
    node2.value = data3;
  }
  function onexithtmltext() {
    const data3 = this.resume();
    const node2 = this.stack[this.stack.length - 1];
    ok(node2, "expected node on stack");
    ok(node2.type === "html", "expected html on stack");
    node2.value = data3;
  }
  function onexitcodetext() {
    const data3 = this.resume();
    const node2 = this.stack[this.stack.length - 1];
    ok(node2, "expected node on stack");
    ok(node2.type === "inlineCode", "expected inline code on stack");
    node2.value = data3;
  }
  function onexitlink() {
    const node2 = this.stack[this.stack.length - 1];
    ok(node2, "expected node on stack");
    ok(node2.type === "link", "expected link on stack");
    if (this.data.inReference) {
      const referenceType = this.data.referenceType || "shortcut";
      node2.type += "Reference";
      node2.referenceType = referenceType;
      delete node2.url;
      delete node2.title;
    } else {
      delete node2.identifier;
      delete node2.label;
    }
    this.data.referenceType = void 0;
  }
  function onexitimage() {
    const node2 = this.stack[this.stack.length - 1];
    ok(node2, "expected node on stack");
    ok(node2.type === "image", "expected image on stack");
    if (this.data.inReference) {
      const referenceType = this.data.referenceType || "shortcut";
      node2.type += "Reference";
      node2.referenceType = referenceType;
      delete node2.url;
      delete node2.title;
    } else {
      delete node2.identifier;
      delete node2.label;
    }
    this.data.referenceType = void 0;
  }
  function onexitlabeltext(token) {
    const string3 = this.sliceSerialize(token);
    const ancestor = this.stack[this.stack.length - 2];
    ok(ancestor, "expected ancestor on stack");
    ok(
      ancestor.type === "image" || ancestor.type === "link",
      "expected image or link on stack"
    );
    ancestor.label = decodeString(string3);
    ancestor.identifier = normalizeIdentifier(string3).toLowerCase();
  }
  function onexitlabel() {
    const fragment = this.stack[this.stack.length - 1];
    ok(fragment, "expected node on stack");
    ok(fragment.type === "fragment", "expected fragment on stack");
    const value2 = this.resume();
    const node2 = this.stack[this.stack.length - 1];
    ok(node2, "expected node on stack");
    ok(
      node2.type === "image" || node2.type === "link",
      "expected image or link on stack"
    );
    this.data.inReference = true;
    if (node2.type === "link") {
      const children = fragment.children;
      node2.children = children;
    } else {
      node2.alt = value2;
    }
  }
  function onexitresourcedestinationstring() {
    const data3 = this.resume();
    const node2 = this.stack[this.stack.length - 1];
    ok(node2, "expected node on stack");
    ok(
      node2.type === "image" || node2.type === "link",
      "expected image or link on stack"
    );
    node2.url = data3;
  }
  function onexitresourcetitlestring() {
    const data3 = this.resume();
    const node2 = this.stack[this.stack.length - 1];
    ok(node2, "expected node on stack");
    ok(
      node2.type === "image" || node2.type === "link",
      "expected image or link on stack"
    );
    node2.title = data3;
  }
  function onexitresource() {
    this.data.inReference = void 0;
  }
  function onenterreference() {
    this.data.referenceType = "collapsed";
  }
  function onexitreferencestring(token) {
    const label4 = this.resume();
    const node2 = this.stack[this.stack.length - 1];
    ok(node2, "expected node on stack");
    ok(
      node2.type === "image" || node2.type === "link",
      "expected image reference or link reference on stack"
    );
    node2.label = label4;
    node2.identifier = normalizeIdentifier(
      this.sliceSerialize(token)
    ).toLowerCase();
    this.data.referenceType = "full";
  }
  function onexitcharacterreferencemarker(token) {
    ok(
      token.type === "characterReferenceMarkerNumeric" || token.type === "characterReferenceMarkerHexadecimal"
    );
    this.data.characterReferenceType = token.type;
  }
  function onexitcharacterreferencevalue(token) {
    const data3 = this.sliceSerialize(token);
    const type2 = this.data.characterReferenceType;
    let value2;
    if (type2) {
      value2 = decodeNumericCharacterReference(
        data3,
        type2 === types.characterReferenceMarkerNumeric ? constants.numericBaseDecimal : constants.numericBaseHexadecimal
      );
      this.data.characterReferenceType = void 0;
    } else {
      const result = decodeNamedCharacterReference(data3);
      ok(result !== false, "expected reference to decode");
      value2 = result;
    }
    const tail = this.stack[this.stack.length - 1];
    ok(tail, "expected `node`");
    ok("value" in tail, "expected `node.value`");
    tail.value += value2;
  }
  function onexitcharacterreference(token) {
    const tail = this.stack.pop();
    ok(tail, "expected `node`");
    ok(tail.position, "expected `node.position`");
    tail.position.end = point2(token.end);
  }
  function onexitautolinkprotocol(token) {
    onexitdata.call(this, token);
    const node2 = this.stack[this.stack.length - 1];
    ok(node2, "expected node on stack");
    ok(node2.type === "link", "expected link on stack");
    node2.url = this.sliceSerialize(token);
  }
  function onexitautolinkemail(token) {
    onexitdata.call(this, token);
    const node2 = this.stack[this.stack.length - 1];
    ok(node2, "expected node on stack");
    ok(node2.type === "link", "expected link on stack");
    node2.url = "mailto:" + this.sliceSerialize(token);
  }
  function blockQuote2() {
    return { type: "blockquote", children: [] };
  }
  function codeFlow() {
    return { type: "code", lang: null, meta: null, value: "" };
  }
  function codeText2() {
    return { type: "inlineCode", value: "" };
  }
  function definition3() {
    return {
      type: "definition",
      identifier: "",
      label: null,
      title: null,
      url: ""
    };
  }
  function emphasis2() {
    return { type: "emphasis", children: [] };
  }
  function heading2() {
    return {
      type: "heading",
      // @ts-expect-error `depth` will be set later.
      depth: 0,
      children: []
    };
  }
  function hardBreak2() {
    return { type: "break" };
  }
  function html3() {
    return { type: "html", value: "" };
  }
  function image2() {
    return { type: "image", title: null, url: "", alt: null };
  }
  function link2() {
    return { type: "link", title: null, url: "", children: [] };
  }
  function list4(token) {
    return {
      type: "list",
      ordered: token.type === "listOrdered",
      start: null,
      spread: token._spread,
      children: []
    };
  }
  function listItem2(token) {
    return {
      type: "listItem",
      spread: token._spread,
      checked: null,
      children: []
    };
  }
  function paragraph2() {
    return { type: "paragraph", children: [] };
  }
  function strong2() {
    return { type: "strong", children: [] };
  }
  function text4() {
    return { type: "text", value: "" };
  }
  function thematicBreak3() {
    return { type: "thematicBreak" };
  }
}
function point2(d3) {
  return { line: d3.line, column: d3.column, offset: d3.offset };
}
function configure2(combined, extensions) {
  let index3 = -1;
  while (++index3 < extensions.length) {
    const value2 = extensions[index3];
    if (Array.isArray(value2)) {
      configure2(combined, value2);
    } else {
      extension(combined, value2);
    }
  }
}
function extension(combined, extension2) {
  let key2;
  for (key2 in extension2) {
    if (own5.call(extension2, key2)) {
      switch (key2) {
        case "canContainEols": {
          const right = extension2[key2];
          if (right) {
            combined[key2].push(...right);
          }
          break;
        }
        case "transforms": {
          const right = extension2[key2];
          if (right) {
            combined[key2].push(...right);
          }
          break;
        }
        case "enter":
        case "exit": {
          const right = extension2[key2];
          if (right) {
            Object.assign(combined[key2], right);
          }
          break;
        }
      }
    }
  }
}
function defaultOnError(left, right) {
  if (left) {
    throw new Error(
      "Cannot close `" + left.type + "` (" + stringifyPosition({ start: left.start, end: left.end }) + "): a different token (`" + right.type + "`, " + stringifyPosition({ start: right.start, end: right.end }) + ") is open"
    );
  } else {
    throw new Error(
      "Cannot close document, a token (`" + right.type + "`, " + stringifyPosition({ start: right.start, end: right.end }) + ") is still open"
    );
  }
}

// node_modules/@mdxeditor/editor/dist/importMarkdownToLexical.js
function isParent2(node2) {
  return node2.children instanceof Array;
}
var MarkdownParseError = class extends Error {
  constructor(message, cause) {
    super(message);
    this.name = "MarkdownParseError";
    this.cause = cause;
  }
};
var UnrecognizedMarkdownConstructError = class extends Error {
  constructor(message) {
    super(message);
    this.name = "UnrecognizedMarkdownConstructError";
  }
};
function importMarkdownToLexical({
  root: root2,
  markdown: markdown2,
  visitors,
  syntaxExtensions,
  mdastExtensions,
  ...descriptors
}) {
  var _a2;
  let mdastRoot;
  try {
    mdastRoot = fromMarkdown(markdown2, {
      extensions: syntaxExtensions,
      mdastExtensions
    });
  } catch (e2) {
    if (e2 instanceof Error) {
      throw new MarkdownParseError(`Error parsing markdown: ${e2.message}`, e2);
    } else {
      throw new MarkdownParseError(`Error parsing markdown: ${e2}`, e2);
    }
  }
  if (mdastRoot.children.length === 0) {
    mdastRoot.children.push({ type: "paragraph", children: [] });
  }
  if (((_a2 = mdastRoot.children.at(-1)) == null ? void 0 : _a2.type) !== "paragraph") {
    mdastRoot.children.push({ type: "paragraph", children: [] });
  }
  importMdastTreeToLexical({ root: root2, mdastRoot, visitors, ...descriptors });
}
function importMdastTreeToLexical({ root: root2, mdastRoot, visitors, ...descriptors }) {
  const formattingMap = /* @__PURE__ */ new WeakMap();
  visitors = visitors.sort((a2, b3) => (b3.priority ?? 0) - (a2.priority ?? 0));
  function visitChildren(mdastNode, lexicalParent) {
    if (!isParent2(mdastNode)) {
      throw new Error("Attempting to visit children of a non-parent");
    }
    mdastNode.children.forEach((child) => {
      visit3(child, lexicalParent, mdastNode);
    });
  }
  function visit3(mdastNode, lexicalParent, mdastParent) {
    const visitor = visitors.find((visitor2) => {
      if (typeof visitor2.testNode === "string") {
        return visitor2.testNode === mdastNode.type;
      }
      return visitor2.testNode(mdastNode, descriptors);
    });
    if (!visitor) {
      try {
        throw new UnrecognizedMarkdownConstructError(`Unsupported markdown syntax: ${toMarkdown(mdastNode)}`);
      } catch (e2) {
        throw new UnrecognizedMarkdownConstructError(
          `Parsing of the following markdown structure failed: ${JSON.stringify({
            type: mdastNode.type,
            name: "name" in mdastNode ? mdastNode.name : "N/A"
          })}`
        );
      }
    }
    visitor.visitNode({
      //@ts-expect-error root type is glitching
      mdastNode,
      lexicalParent,
      mdastParent,
      descriptors,
      actions: {
        visitChildren,
        addAndStepInto(lexicalNode) {
          lexicalParent.append(lexicalNode);
          if (isParent2(mdastNode)) {
            visitChildren(mdastNode, lexicalNode);
          }
        },
        addFormatting(format, node2) {
          if (!node2) {
            if (isParent2(mdastNode)) {
              node2 = mdastNode;
            }
          }
          if (node2) {
            formattingMap.set(node2, format | (formattingMap.get(mdastParent) ?? 0));
          }
        },
        removeFormatting(format, node2) {
          if (!node2) {
            if (isParent2(mdastNode)) {
              node2 = mdastNode;
            }
          }
          if (node2) {
            formattingMap.set(node2, format ^ (formattingMap.get(mdastParent) ?? 0));
          }
        },
        getParentFormatting() {
          return formattingMap.get(mdastParent) ?? 0;
        }
      }
    });
  }
  visit3(mdastRoot, root2, null);
}

// node_modules/@mdxeditor/editor/dist/plugins/core/GenericHTMLNode.js
var __defProp = Object.defineProperty;
var __defNormalProp = (obj, key2, value2) => key2 in obj ? __defProp(obj, key2, { enumerable: true, configurable: true, writable: true, value: value2 }) : obj[key2] = value2;
var __publicField2 = (obj, key2, value2) => {
  __defNormalProp(obj, typeof key2 !== "symbol" ? key2 + "" : key2, value2);
  return value2;
};
var TYPE_NAME = "generic-html";
var GenericHTMLNode = class _GenericHTMLNode extends ElementNode {
  /**
   * Constructs a new {@link GenericHTMLNode} with the specified MDAST HTML node as the object to edit.
   */
  constructor(tag, type2, attributes4, key2) {
    super(key2);
    __publicField2(this, "__tag");
    __publicField2(this, "__nodeType");
    __publicField2(this, "__attributes");
    this.__tag = tag;
    this.__nodeType = type2;
    this.__attributes = attributes4;
  }
  /** @internal */
  static getType() {
    return TYPE_NAME;
  }
  /** @internal */
  static clone(node2) {
    return new _GenericHTMLNode(node2.__tag, node2.__nodeType, node2.__attributes, node2.__key);
  }
  getTag() {
    return this.__tag;
  }
  getNodeType() {
    return this.__nodeType;
  }
  getAttributes() {
    return this.__attributes;
  }
  updateAttributes(attributes4) {
    const self2 = this.getWritable();
    self2.__attributes = attributes4;
  }
  getStyle() {
    var _a2;
    return (_a2 = this.__attributes.find((attribute) => attribute.name === "style")) == null ? void 0 : _a2.value;
  }
  // View
  createDOM() {
    const tag = this.__tag;
    const element2 = document.createElement(tag);
    this.__attributes.forEach((attribute) => {
      element2.setAttribute(attribute.name, attribute.value);
    });
    return element2;
  }
  updateDOM() {
    return false;
  }
  static importDOM() {
    return {};
  }
  exportDOM(editor) {
    const { element: element2 } = super.exportDOM(editor);
    return {
      element: element2
    };
  }
  static importJSON(serializedNode) {
    const node2 = $createGenericHTMLNode(serializedNode.tag, serializedNode.mdxType, serializedNode.attributes);
    node2.setFormat(serializedNode.format);
    node2.setIndent(serializedNode.indent);
    node2.setDirection(serializedNode.direction);
    return node2;
  }
  exportJSON() {
    return {
      ...super.exportJSON(),
      tag: this.getTag(),
      attributes: this.__attributes,
      mdxType: this.__nodeType,
      type: TYPE_NAME,
      version: 1
    };
  }
  /*
    // Mutation
    insertNewAfter(selection?: RangeSelection, restoreSelection = true): ParagraphNode | GenericHTMLNode {
      const anchorOffet = selection ? selection.anchor.offset : 0
      const newElement =
        anchorOffet > 0 && anchorOffet < this.getTextContentSize() ? $createHeadingNode(this.getTag()) : $createParagraphNode()
      const direction = this.getDirection()
      newElement.setDirection(direction)
      this.insertAfter(newElement, restoreSelection)
      return newElement
    }
  
    collapseAtStart(): true {
      const newElement = !this.isEmpty() ? $createHeadingNode(this.getTag()) : $createParagraphNode()
      const children = this.getChildren()
      children.forEach((child) => newElement.append(child))
      this.replace(newElement)
      return true
    }*/
  extractWithChild() {
    return true;
  }
  isInline() {
    return this.__nodeType === "mdxJsxTextElement";
  }
};
function $createGenericHTMLNode(tag, type2, attributes4) {
  return $applyNodeReplacement(new GenericHTMLNode(tag, type2, attributes4));
}
function $isGenericHTMLNode(node2) {
  return node2 instanceof GenericHTMLNode;
}

// node_modules/@mdxeditor/editor/dist/plugins/core/LexicalGenericHTMLNodeVisitor.js
var LexicalGenericHTMLVisitor = {
  testLexicalNode: $isGenericHTMLNode,
  visitLexicalNode({ actions, lexicalNode }) {
    actions.addAndStepInto("mdxJsxTextElement", {
      name: lexicalNode.getTag(),
      type: lexicalNode.getNodeType(),
      attributes: lexicalNode.getAttributes()
    });
  },
  priority: -100
};

// node_modules/@mdxeditor/editor/dist/plugins/core/LexicalLinebreakVisitor.js
var LexicalLinebreakVisitor = {
  testLexicalNode: $isLineBreakNode,
  visitLexicalNode: ({ mdastParent, actions }) => {
    actions.appendToParent(mdastParent, { type: "text", value: "\n" });
  }
};

// node_modules/@mdxeditor/editor/dist/plugins/core/LexicalParagraphVisitor.js
var LexicalParagraphVisitor = {
  testLexicalNode: $isParagraphNode,
  visitLexicalNode: ({ actions }) => {
    actions.addAndStepInto("paragraph");
  }
};

// node_modules/@mdxeditor/editor/dist/plugins/core/LexicalRootVisitor.js
var LexicalRootVisitor = {
  testLexicalNode: $isRootNode,
  visitLexicalNode: ({ actions }) => {
    actions.addAndStepInto("root");
  }
};

// node_modules/@mdxeditor/editor/dist/FormatConstants.js
var DEFAULT_FORMAT = 0;
var IS_BOLD2 = 1;
var IS_ITALIC2 = 2;
var IS_STRIKETHROUGH2 = 4;
var IS_UNDERLINE2 = 8;
var IS_CODE2 = 16;
var IS_SUBSCRIPT2 = 32;
var IS_SUPERSCRIPT2 = 64;
var IS_HIGHLIGHT2 = 128;

// node_modules/@mdxeditor/editor/dist/plugins/core/LexicalTextVisitor.js
function isMdastText(mdastNode) {
  return mdastNode.type === "text";
}
var JOINABLE_TAGS = ["u", "span", "sub", "sup"];
var LexicalTextVisitor = {
  shouldJoin: (prevNode, currentNode) => {
    if (["text", "emphasis", "strong"].includes(prevNode.type)) {
      return prevNode.type === currentNode.type;
    }
    if (prevNode.type === "mdxJsxTextElement" && // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition
    currentNode.type === "mdxJsxTextElement" && JOINABLE_TAGS.includes(currentNode.name)) {
      const currentMdxNode = currentNode;
      return prevNode.name === currentMdxNode.name && JSON.stringify(prevNode.attributes) === JSON.stringify(currentMdxNode.attributes);
    }
    return false;
  },
  join(prevNode, currentNode) {
    if (isMdastText(prevNode) && isMdastText(currentNode)) {
      return {
        type: "text",
        value: prevNode.value + currentNode.value
      };
    } else {
      return {
        ...prevNode,
        children: [...prevNode.children, ...currentNode.children]
      };
    }
  },
  testLexicalNode: $isTextNode,
  visitLexicalNode: ({ lexicalNode, mdastParent, actions }) => {
    const previousSibling = lexicalNode.getPreviousSibling();
    const prevFormat = $isTextNode(previousSibling) ? previousSibling.getFormat() : 0;
    const textContent = lexicalNode.getTextContent();
    const format = lexicalNode.getFormat();
    const style = lexicalNode.getStyle();
    let localParentNode = mdastParent;
    if (style) {
      localParentNode = actions.appendToParent(localParentNode, {
        type: "mdxJsxTextElement",
        name: "span",
        children: [],
        attributes: [{ type: "mdxJsxAttribute", name: "style", value: style }]
      });
    }
    if (prevFormat & format & IS_ITALIC2) {
      localParentNode = actions.appendToParent(localParentNode, {
        type: "emphasis",
        children: []
      });
    }
    if (prevFormat & format & IS_BOLD2) {
      localParentNode = actions.appendToParent(localParentNode, {
        type: "strong",
        children: []
      });
    }
    if (prevFormat & format & IS_UNDERLINE2) {
      localParentNode = actions.appendToParent(localParentNode, {
        type: "mdxJsxTextElement",
        name: "u",
        children: [],
        attributes: []
      });
    }
    if (prevFormat & format & IS_STRIKETHROUGH2) {
      localParentNode = actions.appendToParent(localParentNode, {
        type: "delete",
        children: []
      });
    }
    if (prevFormat & format & IS_SUPERSCRIPT2) {
      localParentNode = actions.appendToParent(localParentNode, {
        type: "mdxJsxTextElement",
        name: "sup",
        children: [],
        attributes: []
      });
    }
    if (prevFormat & format & IS_SUBSCRIPT2) {
      localParentNode = actions.appendToParent(localParentNode, {
        type: "mdxJsxTextElement",
        name: "sub",
        children: [],
        attributes: []
      });
    }
    if (format & IS_ITALIC2 && !(prevFormat & IS_ITALIC2)) {
      localParentNode = actions.appendToParent(localParentNode, {
        type: "emphasis",
        children: []
      });
    }
    if (format & IS_BOLD2 && !(prevFormat & IS_BOLD2)) {
      localParentNode = actions.appendToParent(localParentNode, {
        type: "strong",
        children: []
      });
    }
    if (format & IS_UNDERLINE2 && !(prevFormat & IS_UNDERLINE2)) {
      localParentNode = actions.appendToParent(localParentNode, {
        type: "mdxJsxTextElement",
        name: "u",
        children: [],
        attributes: []
      });
    }
    if (format & IS_STRIKETHROUGH2 && !(prevFormat & IS_STRIKETHROUGH2)) {
      localParentNode = actions.appendToParent(localParentNode, {
        type: "delete",
        children: []
      });
    }
    if (format & IS_SUPERSCRIPT2 && !(prevFormat & IS_SUPERSCRIPT2)) {
      localParentNode = actions.appendToParent(localParentNode, {
        type: "mdxJsxTextElement",
        name: "sup",
        children: [],
        attributes: []
      });
    }
    if (format & IS_SUBSCRIPT2 && !(prevFormat & IS_SUBSCRIPT2)) {
      localParentNode = actions.appendToParent(localParentNode, {
        type: "mdxJsxTextElement",
        name: "sub",
        children: [],
        attributes: []
      });
    }
    if (format & IS_CODE2) {
      actions.appendToParent(localParentNode, {
        type: "inlineCode",
        value: textContent
      });
      return;
    }
    actions.appendToParent(localParentNode, {
      type: "text",
      value: textContent
    });
  }
};

// node_modules/@mdxeditor/editor/dist/plugins/core/MdastBreakVisitor.js
var MdastBreakVisitor = {
  testNode: "break",
  visitNode: function({ lexicalParent }) {
    lexicalParent.append($createLineBreakNode());
  }
};

// node_modules/@mdxeditor/editor/dist/plugins/core/MdastFormattingVisitor.js
function buildFormattingVisitors(tag, format) {
  return [
    {
      testNode: (node2) => node2.type === "mdxJsxTextElement" && node2.name === tag,
      visitNode({ actions, mdastNode, lexicalParent }) {
        actions.addFormatting(format);
        actions.visitChildren(mdastNode, lexicalParent);
      }
    },
    {
      testNode: (node2) => node2.type === "html" && node2.value === `<${tag}>`,
      visitNode({ actions, mdastParent }) {
        actions.addFormatting(format, mdastParent);
      }
    },
    {
      testNode: (node2) => node2.type === "html" && node2.value === `</${tag}>`,
      visitNode({ actions, mdastParent }) {
        actions.removeFormatting(format, mdastParent);
      }
    }
  ];
}
var StrikeThroughVisitor = {
  testNode: "delete",
  visitNode({ mdastNode, actions, lexicalParent }) {
    actions.addFormatting(IS_STRIKETHROUGH2);
    actions.visitChildren(mdastNode, lexicalParent);
  }
};
var MdCodeVisitor = {
  testNode: "inlineCode",
  visitNode({ mdastNode, actions }) {
    actions.addAndStepInto($createTextNode(mdastNode.value).setFormat(actions.getParentFormatting() | IS_CODE2));
  }
};
var MdEmphasisVisitor = {
  testNode: "emphasis",
  visitNode({ mdastNode, actions, lexicalParent }) {
    actions.addFormatting(IS_ITALIC2);
    actions.visitChildren(mdastNode, lexicalParent);
  }
};
var MdStrongVisitor = {
  testNode: "strong",
  visitNode({ mdastNode, actions, lexicalParent }) {
    actions.addFormatting(IS_BOLD2);
    actions.visitChildren(mdastNode, lexicalParent);
  }
};
var formattingVisitors = [
  // emphasis
  MdEmphasisVisitor,
  // strong
  MdStrongVisitor,
  // underline
  ...buildFormattingVisitors("u", IS_UNDERLINE2),
  // code
  ...buildFormattingVisitors("code", IS_CODE2),
  MdCodeVisitor,
  // strikethrough
  StrikeThroughVisitor,
  // superscript
  ...buildFormattingVisitors("sup", IS_SUPERSCRIPT2),
  // subscript
  ...buildFormattingVisitors("sub", IS_SUBSCRIPT2)
];

// node_modules/@mdxeditor/editor/dist/plugins/core/MdastHTMLVisitor.js
var MdastHTMLVisitor = {
  testNode: isMdastHTMLNode,
  visitNode: function({ mdastNode, actions }) {
    actions.addAndStepInto($createGenericHTMLNode(mdastNode.name, mdastNode.type, mdastNode.attributes));
  },
  priority: -100
};

// node_modules/@mdxeditor/editor/dist/plugins/core/MdastParagraphVisitor.js
var lexicalTypesThatShouldSkipParagraphs = ["listitem", "quote", "admonition"];
var MdastParagraphVisitor = {
  testNode: "paragraph",
  visitNode: function({ mdastNode, lexicalParent, actions }) {
    if (lexicalTypesThatShouldSkipParagraphs.includes(lexicalParent.getType())) {
      actions.visitChildren(mdastNode, lexicalParent);
    } else {
      actions.addAndStepInto($createParagraphNode());
    }
  }
};

// node_modules/@mdxeditor/editor/dist/plugins/core/MdastRootVisitor.js
var MdastRootVisitor = {
  testNode: "root",
  visitNode({ actions, mdastNode, lexicalParent }) {
    actions.visitChildren(mdastNode, lexicalParent);
  }
};

// node_modules/@mdxeditor/editor/dist/plugins/core/MdastTextVisitor.js
var MdastTextVisitor = {
  testNode: "text",
  visitNode({ mdastNode, actions }) {
    actions.addAndStepInto($createTextNode(mdastNode.value).setFormat(actions.getParentFormatting()));
  }
};

// node_modules/@mdxeditor/editor/dist/plugins/core/SharedHistoryPlugin.js
var import_react4 = __toESM(require_react(), 1);
var SharedHistoryPlugin = () => {
  return import_react4.default.createElement(HistoryPlugin, { externalHistoryState: E(historyState$) });
};

// node_modules/@mdxeditor/editor/dist/mdastUtilHtmlComment.js
function commentFromMarkdown(_options) {
  return {
    canContainEols: ["comment"],
    enter: {
      comment(_2) {
        this.buffer();
      }
    },
    exit: {
      comment(token) {
        const text4 = this.resume();
        if (_options.ast) {
          this.enter(
            {
              // @ts-expect-error: not typing this
              type: "comment",
              value: "",
              commentValue: text4.slice(0, -2)
            },
            token
          );
          this.exit(token);
        }
      }
    }
  };
}
var tokenize = (effects, ok3, nok) => {
  return start2;
  function start2(code3) {
    effects.enter("comment");
    effects.consume(code3);
    return open;
  }
  function open(code3) {
    if (code3 === codes.exclamationMark) {
      effects.consume(code3);
      return declarationOpen;
    }
    return nok(code3);
  }
  function declarationOpen(code3) {
    if (code3 === codes.dash) {
      effects.consume(code3);
      return commentOpen;
    }
    return nok(code3);
  }
  function commentOpen(code3) {
    if (code3 === codes.dash) {
      effects.consume(code3);
      return commentStart;
    }
    return nok(code3);
  }
  function commentStart(code3) {
    if (code3 === codes.greaterThan) {
      return nok(code3);
    }
    if (markdownLineEnding(code3)) {
      return atLineEnding(code3);
    }
    effects.enter(types.data);
    if (code3 === codes.dash) {
      effects.consume(code3);
      return commentStartDash;
    }
    return comment2(code3);
  }
  function commentStartDash(code3) {
    if (code3 === codes.greaterThan) {
      return nok(code3);
    }
    return comment2(code3);
  }
  function comment2(code3) {
    if (code3 === codes.eof) {
      return nok(code3);
    }
    if (code3 === codes.dash) {
      effects.consume(code3);
      return commentClose;
    }
    if (markdownLineEnding(code3)) {
      effects.exit(types.data);
      return atLineEnding(code3);
    }
    effects.consume(code3);
    return comment2;
  }
  function atLineEnding(code3) {
    effects.enter(types.lineEnding);
    effects.consume(code3);
    effects.exit(types.lineEnding);
    return factorySpace(effects, afterPrefix, types.linePrefix);
  }
  function afterPrefix(code3) {
    if (markdownLineEnding(code3)) {
      return atLineEnding(code3);
    }
    effects.enter(types.data);
    return comment2(code3);
  }
  function commentClose(code3) {
    if (code3 === codes.dash) {
      effects.consume(code3);
      return end;
    }
    return comment2(code3);
  }
  function end(code3) {
    if (code3 === codes.greaterThan) {
      effects.exit(types.data);
      effects.enter("commentEnd");
      effects.consume(code3);
      effects.exit("commentEnd");
      effects.exit("comment");
      return ok3(code3);
    }
    if (code3 === codes.dash) {
      effects.consume(code3);
      return end;
    }
    return comment2(code3);
  }
};
var comment = {
  flow: { [60]: { tokenize, concrete: true } },
  text: { [60]: { tokenize } }
};

// node_modules/@mdxeditor/editor/dist/styles/lexical-theme.module.css.js
var light = "_light_1tncs_1";
var lightTheme = "_light-theme_1tncs_1";
var dark = "_dark_1tncs_1";
var darkTheme = "_dark-theme_1tncs_1";
var bold = "_bold_1tncs_10";
var italic = "_italic_1tncs_14";
var underline = "_underline_1tncs_18";
var strikethrough = "_strikethrough_1tncs_34";
var underlineStrikethrough = "_underlineStrikethrough_1tncs_38";
var subscript = "_subscript_1tncs_42";
var superscript = "_superscript_1tncs_47";
var code2 = "_code_1tncs_52";
var nestedListItem = "_nestedListItem_1tncs_59";
var listitem = "_listitem_1tncs_69";
var listItemChecked = "_listItemChecked_1tncs_73";
var listItemUnchecked = "_listItemUnchecked_1tncs_74";
var admonitionDanger = "_admonitionDanger_1tncs_151";
var admonitionInfo = "_admonitionInfo_1tncs_152";
var admonitionNote = "_admonitionNote_1tncs_153";
var admonitionTip = "_admonitionTip_1tncs_154";
var admonitionCaution = "_admonitionCaution_1tncs_155";
var mdxExpression = "_mdxExpression_1tncs_188";
var lexicalThemeStyles = {
  light,
  lightTheme,
  dark,
  darkTheme,
  bold,
  italic,
  underline,
  strikethrough,
  underlineStrikethrough,
  subscript,
  superscript,
  code: code2,
  nestedListItem,
  listitem,
  listItemChecked,
  listItemUnchecked,
  admonitionDanger,
  admonitionInfo,
  admonitionNote,
  admonitionTip,
  admonitionCaution,
  mdxExpression
};

// node_modules/@mdxeditor/editor/dist/styles/lexicalTheme.js
var lexicalTheme = {
  text: {
    bold: lexicalThemeStyles.bold,
    italic: lexicalThemeStyles.italic,
    underline: lexicalThemeStyles.underline,
    code: lexicalThemeStyles.code,
    strikethrough: lexicalThemeStyles.strikethrough,
    subscript: lexicalThemeStyles.subscript,
    superscript: lexicalThemeStyles.superscript,
    underlineStrikethrough: lexicalThemeStyles.underlineStrikethrough
  },
  list: {
    listitem: lexicalThemeStyles.listitem,
    listitemChecked: lexicalThemeStyles.listItemChecked,
    listitemUnchecked: lexicalThemeStyles.listItemUnchecked,
    nested: {
      listitem: lexicalThemeStyles.nestedListItem
    }
  },
  admonition: {
    danger: lexicalThemeStyles.admonitionDanger,
    info: lexicalThemeStyles.admonitionInfo,
    note: lexicalThemeStyles.admonitionNote,
    tip: lexicalThemeStyles.admonitionTip,
    caution: lexicalThemeStyles.admonitionCaution
  }
};

// node_modules/@mdxeditor/editor/dist/plugins/core/index.js
var NESTED_EDITOR_UPDATED_COMMAND = createCommand("NESTED_EDITOR_UPDATED_COMMAND");
var rootEditor$ = $(null);
var activeEditor$ = $(null);
var contentEditableClassName$ = $("");
var spellCheck$ = $(true);
var readOnly$ = $(false, (r2) => {
  r2.sub(r2.pipe(readOnly$, tt(rootEditor$)), ([readOnly, rootEditor]) => {
    rootEditor == null ? void 0 : rootEditor.setEditable(!readOnly);
  });
});
var placeholder$ = $("");
var autoFocus$ = $(false);
var inFocus$ = $(false);
var currentFormat$ = $(0);
var markdownProcessingError$ = $(null);
var markdownErrorSignal$ = K((r2) => {
  r2.link(
    r2.pipe(
      markdownProcessingError$,
      nt((e2) => e2 !== null)
    ),
    markdownErrorSignal$
  );
});
var applyFormat$ = K((r2) => {
  r2.sub(r2.pipe(applyFormat$, tt(activeEditor$)), ([format, theEditor]) => {
    theEditor == null ? void 0 : theEditor.dispatchCommand(FORMAT_TEXT_COMMAND, format);
  });
});
var currentSelection$ = $(null, (r2) => {
  r2.sub(r2.pipe(currentSelection$, tt(activeEditor$)), ([selection2, theEditor]) => {
    if (!selection2 || !theEditor) {
      return;
    }
    const anchorNode = selection2.anchor.getNode();
    let element2 = anchorNode.getKey() === "root" ? anchorNode : $findMatchingParent(anchorNode, (e2) => {
      const parent = e2.getParent();
      return parent !== null && $isRootOrShadowRoot(parent);
    });
    if (element2 === null) {
      element2 = anchorNode.getTopLevelElementOrThrow();
    }
    const elementKey = element2.getKey();
    const elementDOM = theEditor.getElementByKey(elementKey);
    if (elementDOM !== null) {
      const blockType = $isHeadingNode(element2) ? element2.getTag() : element2.getType();
      r2.pub(currentBlockType$, blockType);
    }
  });
});
var initialMarkdown$ = $("");
var markdown$ = $("");
var markdownSignal$ = K((r2) => {
  r2.link(markdown$, markdownSignal$);
  r2.link(initialMarkdown$, markdown$);
});
var mutableMarkdownSignal$ = K((r2) => {
  r2.link(
    r2.pipe(
      markdownSignal$,
      tt(muteChange$),
      nt(([, muted]) => !muted),
      _(([value2]) => value2)
    ),
    mutableMarkdownSignal$
  );
});
var importVisitors$ = $([]);
var usedLexicalNodes$ = $([]);
var syntaxExtensions$ = $([]);
var mdastExtensions$ = $([]);
var exportVisitors$ = $([]);
var toMarkdownExtensions$ = $([]);
var toMarkdownOptions$ = $({});
var jsxIsAvailable$ = $(false);
var jsxComponentDescriptors$ = $([]);
var directiveDescriptors$ = $([]);
var codeBlockEditorDescriptors$ = $([]);
var editorRootElementRef$ = $(null);
var contentEditableRef$ = $(null);
var addLexicalNode$ = Appender(usedLexicalNodes$);
var addImportVisitor$ = Appender(importVisitors$);
var addSyntaxExtension$ = Appender(syntaxExtensions$);
var addMdastExtension$ = Appender(mdastExtensions$);
var addExportVisitor$ = Appender(exportVisitors$);
var addToMarkdownExtension$ = Appender(toMarkdownExtensions$);
var muteChange$ = $(false);
var setMarkdown$ = K((r2) => {
  r2.sub(
    r2.pipe(
      setMarkdown$,
      tt(markdown$, rootEditor$, inFocus$),
      nt(([newMarkdown, oldMarkdown]) => {
        return newMarkdown.trim() !== oldMarkdown.trim();
      })
    ),
    ([theNewMarkdownValue, , editor, inFocus]) => {
      r2.pub(muteChange$, true);
      editor == null ? void 0 : editor.update(
        () => {
          $getRoot().clear();
          tryImportingMarkdown(r2, $getRoot(), theNewMarkdownValue);
          if (!inFocus) {
            $setSelection(null);
          } else {
            editor.focus();
          }
        },
        {
          onUpdate: () => {
            r2.pub(muteChange$, false);
          }
        }
      );
    }
  );
});
var insertMarkdown$ = K((r2) => {
  r2.sub(r2.pipe(insertMarkdown$, tt(activeEditor$, inFocus$)), ([markdownToInsert, editor, inFocus]) => {
    editor == null ? void 0 : editor.update(() => {
      const selection2 = $getSelection();
      if (selection2 !== null) {
        const importPoint = {
          children: [],
          append(node2) {
            this.children.push(node2);
          },
          getType() {
            return selection2.getNodes()[0].getType();
          }
        };
        tryImportingMarkdown(r2, importPoint, markdownToInsert);
        $insertNodes(importPoint.children);
      }
      if (!inFocus) {
        $setSelection(null);
      } else {
        editor.focus();
      }
    });
  });
});
function rebind() {
  return it((teardowns, [subs, activeEditorValue]) => {
    teardowns.forEach((teardown) => {
      if (!teardown) {
        throw new Error("You have a subscription that does not return a teardown");
      }
      teardown();
    });
    return activeEditorValue ? subs.map((s2) => s2(activeEditorValue)) : [];
  }, []);
}
var activeEditorSubscriptions$ = $([], (r2) => {
  r2.pipe(r2.combine(activeEditorSubscriptions$, activeEditor$), rebind());
});
var rootEditorSubscriptions$ = $([], (r2) => {
  r2.pipe(r2.combine(rootEditorSubscriptions$, rootEditor$), rebind());
});
var editorInFocus$ = $(null);
var onBlur$ = K();
var iconComponentFor$ = $((name2) => {
  throw new Error(`No icon component for ${name2}`);
});
function Appender(cell$, init) {
  return K((r2, sig$) => {
    r2.changeWith(cell$, sig$, (values2, newValue) => {
      if (!Array.isArray(newValue)) {
        newValue = [newValue];
      }
      let result = values2;
      for (const v3 of newValue) {
        if (!values2.includes(v3)) {
          result = [...result, v3];
        }
      }
      return result;
    });
    init == null ? void 0 : init(r2, sig$);
  });
}
function handleSelectionChange(r2) {
  const selection2 = $getSelection();
  if ($isRangeSelection(selection2)) {
    r2.pubIn({
      [currentSelection$]: selection2,
      [currentFormat$]: selection2.format
    });
  }
}
var createRootEditorSubscription$ = Appender(rootEditorSubscriptions$, (r2, sig$) => {
  r2.pub(sig$, [
    (rootEditor) => {
      return rootEditor.registerCommand(
        SELECTION_CHANGE_COMMAND,
        (_2, theActiveEditor) => {
          r2.pubIn({
            [activeEditor$]: theActiveEditor,
            [inFocus$]: true
          });
          if (theActiveEditor._parentEditor === null) {
            theActiveEditor.getEditorState().read(() => {
              r2.pub(editorInFocus$, {
                rootNode: $getRoot(),
                editorType: "lexical"
              });
            });
          }
          handleSelectionChange(r2);
          return false;
        },
        COMMAND_PRIORITY_CRITICAL
      );
    },
    // Export handler
    (rootEditor) => {
      return rootEditor.registerUpdateListener(({ dirtyElements, dirtyLeaves, editorState }) => {
        const err = r2.getValue(markdownProcessingError$);
        if (err !== null) {
          return;
        }
        if (dirtyElements.size === 0 && dirtyLeaves.size === 0) {
          return;
        }
        let theNewMarkdownValue;
        editorState.read(() => {
          const lastChild = $getRoot().getLastChild();
          if (lastChild instanceof DecoratorNode) {
            rootEditor.update(
              () => {
                $getRoot().append($createParagraphNode());
              },
              { discrete: true }
            );
          }
          theNewMarkdownValue = exportMarkdownFromLexical({
            root: $getRoot(),
            visitors: r2.getValue(exportVisitors$),
            jsxComponentDescriptors: r2.getValue(jsxComponentDescriptors$),
            toMarkdownExtensions: r2.getValue(toMarkdownExtensions$),
            toMarkdownOptions: r2.getValue(toMarkdownOptions$),
            jsxIsAvailable: r2.getValue(jsxIsAvailable$)
          });
        });
        r2.pub(markdown$, theNewMarkdownValue.trim());
      });
    },
    (rootEditor) => {
      return rootEditor.registerCommand(
        FOCUS_COMMAND,
        () => {
          r2.pub(inFocus$, true);
          return false;
        },
        COMMAND_PRIORITY_CRITICAL
      );
    }
    /*
        // Fixes select all when frontmatter is present
        (rootEditor) => {
          return rootEditor.registerCommand<KeyboardEvent>(
            KEY_DOWN_COMMAND,
            (event) => {
              const { keyCode, ctrlKey, metaKey } = event
              if (keyCode === 65 && controlOrMeta(metaKey, ctrlKey)) {
                let shouldOverride = false
    
                rootEditor.getEditorState().read(() => {
                  shouldOverride = $isDecoratorNode($getRoot().getFirstChild()) || $isDecoratorNode($getRoot().getLastChild())
                })
    
                // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition
                if (shouldOverride) {
                  event.preventDefault()
                  event.stopImmediatePropagation()
                  rootEditor.update(() => {
                    const rootElement = rootEditor.getRootElement() as HTMLDivElement
                    window.getSelection()?.selectAllChildren(rootElement)
                    rootElement.focus({
                      preventScroll: true
                    })
                  })
                  return true
                }
              }
    
              return false
            },
            COMMAND_PRIORITY_CRITICAL
          )
        }*/
  ]);
});
var createActiveEditorSubscription$ = Appender(activeEditorSubscriptions$, (r2, sig$) => {
  r2.pub(sig$, [
    (editor) => {
      return editor.registerUpdateListener(({ editorState }) => {
        editorState.read(() => {
          handleSelectionChange(r2);
        });
      });
    },
    (editor) => {
      return editor.registerCommand(
        BLUR_COMMAND,
        (payload) => {
          var _a2;
          const theRootEditor = r2.getValue(rootEditor$);
          if (theRootEditor) {
            const movingOutside = !((_a2 = theRootEditor.getRootElement()) == null ? void 0 : _a2.contains(payload.relatedTarget));
            if (movingOutside) {
              r2.pubIn({
                [inFocus$]: false,
                [onBlur$]: payload
              });
            }
          }
          return false;
        },
        COMMAND_PRIORITY_CRITICAL
      );
    }
  ]);
});
function tryImportingMarkdown(r2, node2, markdownValue) {
  try {
    importMarkdownToLexical({
      root: node2,
      visitors: r2.getValue(importVisitors$),
      mdastExtensions: r2.getValue(mdastExtensions$),
      markdown: markdownValue,
      syntaxExtensions: r2.getValue(syntaxExtensions$),
      jsxComponentDescriptors: r2.getValue(jsxComponentDescriptors$),
      directiveDescriptors: r2.getValue(directiveDescriptors$),
      codeBlockEditorDescriptors: r2.getValue(codeBlockEditorDescriptors$)
    });
    r2.pub(markdownProcessingError$, null);
  } catch (e2) {
    if (e2 instanceof MarkdownParseError || e2 instanceof UnrecognizedMarkdownConstructError) {
      r2.pubIn({
        [markdown$]: markdownValue,
        [markdownProcessingError$]: {
          error: e2.message,
          source: markdownValue
        }
      });
    } else {
      throw e2;
    }
  }
}
var composerChildren$ = $([]);
var addComposerChild$ = Appender(composerChildren$);
var topAreaChildren$ = $([]);
var addTopAreaChild$ = Appender(topAreaChildren$);
var editorWrappers$ = $([]);
var addEditorWrapper$ = Appender(editorWrappers$);
var nestedEditorChildren$ = $([]);
var addNestedEditorChild$ = Appender(nestedEditorChildren$);
var historyState$ = $(createEmptyHistoryState());
var currentBlockType$ = $("");
var applyBlockType$ = K();
var convertSelectionToNode$ = K((r2) => {
  r2.sub(r2.pipe(convertSelectionToNode$, tt(activeEditor$)), ([factory, editor]) => {
    editor == null ? void 0 : editor.update(() => {
      const selection2 = $getSelection();
      if ($isRangeSelection(selection2)) {
        $setBlocksType(selection2, factory);
        setTimeout(() => {
          editor.focus();
        });
      }
    });
  });
});
var insertDecoratorNode$ = K((r2) => {
  r2.sub(r2.pipe(insertDecoratorNode$, tt(activeEditor$)), ([nodeFactory, theEditor]) => {
    theEditor == null ? void 0 : theEditor.focus(
      () => {
        theEditor.getEditorState().read(() => {
          const selection2 = $getSelection();
          if ($isRangeSelection(selection2)) {
            theEditor.update(() => {
              const node2 = nodeFactory();
              if (node2.isInline()) {
                $insertNodes([node2]);
                if ($isRootOrShadowRoot(node2.getParentOrThrow())) {
                  $wrapNodeInElement(node2, $createParagraphNode).selectEnd();
                }
              } else {
                $insertNodeToNearestRoot(node2);
              }
              setTimeout(() => {
                if ("select" in node2 && typeof node2.select === "function") {
                  node2.select();
                }
              });
            });
            setTimeout(() => {
              theEditor.dispatchCommand(NESTED_EDITOR_UPDATED_COMMAND, void 0);
            });
          }
        });
      },
      { defaultSelection: "rootEnd" }
    );
  });
});
var viewMode$ = $("rich-text", (r2) => {
  function currentNextViewMode() {
    return it(
      (prev, next) => {
        return {
          current: prev.next,
          next
        };
      },
      { current: "rich-text", next: "rich-text" }
    );
  }
  r2.sub(r2.pipe(viewMode$, currentNextViewMode(), tt(markdownSourceEditorValue$)), ([{ current: current2 }, markdownSourceFromEditor]) => {
    if (current2 === "source" || current2 === "diff") {
      r2.pub(setMarkdown$, markdownSourceFromEditor);
    }
  });
  r2.sub(
    r2.pipe(
      viewMode$,
      currentNextViewMode(),
      nt((mode) => mode.current === "rich-text"),
      tt(activeEditor$)
    ),
    ([, editor]) => {
      editor == null ? void 0 : editor.dispatchCommand(NESTED_EDITOR_UPDATED_COMMAND, void 0);
    }
  );
});
var markdownSourceEditorValue$ = $("", (r2) => {
  r2.link(markdown$, markdownSourceEditorValue$);
  r2.link(markdownSourceEditorValue$, markdownSignal$);
});
var activePlugins$ = $([]);
var addActivePlugin$ = Appender(activePlugins$);
var translation$ = $(() => {
  throw new Error("No translation function provided");
});
var lexicalTheme$ = $(lexicalTheme);
var corePlugin = realmPlugin({
  init(r2, params) {
    const initialMarkdown = (params == null ? void 0 : params.initialMarkdown) ?? "";
    r2.register(createRootEditorSubscription$);
    r2.register(createActiveEditorSubscription$);
    r2.register(markdownSignal$);
    r2.pubIn({
      [initialMarkdown$]: (params == null ? void 0 : params.trim) ? initialMarkdown.trim() : initialMarkdown,
      [iconComponentFor$]: params == null ? void 0 : params.iconComponentFor,
      [addImportVisitor$]: [MdastRootVisitor, MdastParagraphVisitor, MdastTextVisitor, MdastBreakVisitor, ...formattingVisitors],
      [addLexicalNode$]: [ParagraphNode, TextNode, GenericHTMLNode],
      [addExportVisitor$]: [
        LexicalRootVisitor,
        LexicalParagraphVisitor,
        LexicalTextVisitor,
        LexicalLinebreakVisitor,
        LexicalGenericHTMLVisitor
      ],
      [addComposerChild$]: SharedHistoryPlugin,
      [contentEditableClassName$]: params == null ? void 0 : params.contentEditableClassName,
      [spellCheck$]: params == null ? void 0 : params.spellCheck,
      [toMarkdownOptions$]: params == null ? void 0 : params.toMarkdownOptions,
      [autoFocus$]: params == null ? void 0 : params.autoFocus,
      [placeholder$]: params == null ? void 0 : params.placeholder,
      [readOnly$]: params == null ? void 0 : params.readOnly,
      [translation$]: params == null ? void 0 : params.translation,
      [addMdastExtension$]: gfmStrikethroughFromMarkdown(),
      [addSyntaxExtension$]: gfmStrikethrough(),
      [addToMarkdownExtension$]: [mdxJsxToMarkdown(), gfmStrikethroughToMarkdown()],
      [lexicalTheme$]: (params == null ? void 0 : params.lexicalTheme) ?? lexicalTheme
    });
    r2.singletonSub(markdownErrorSignal$, params == null ? void 0 : params.onError);
    r2.singletonSub(mutableMarkdownSignal$, params == null ? void 0 : params.onChange);
    r2.singletonSub(onBlur$, params == null ? void 0 : params.onBlur);
    if (!(params == null ? void 0 : params.suppressHtmlProcessing)) {
      r2.pubIn({
        [addMdastExtension$]: [mdxJsxFromMarkdown(), commentFromMarkdown({ ast: false })],
        [addSyntaxExtension$]: [mdxJsx(), mdxMd(), comment],
        [addImportVisitor$]: MdastHTMLVisitor
      });
    }
  },
  postInit(r2, params) {
    const newEditor = createEditor({
      editable: (params == null ? void 0 : params.readOnly) !== true,
      namespace: "MDXEditor",
      nodes: r2.getValue(usedLexicalNodes$),
      onError: (error) => {
        throw error;
      },
      theme: r2.getValue(lexicalTheme$)
    });
    newEditor.update(() => {
      const markdown2 = (params == null ? void 0 : params.initialMarkdown.trim()) ?? "";
      tryImportingMarkdown(r2, $getRoot(), markdown2);
      const autoFocusValue = params == null ? void 0 : params.autoFocus;
      if (autoFocusValue) {
        if (autoFocusValue === true) {
          setTimeout(() => {
            newEditor.focus(noop, { defaultSelection: "rootStart" });
          });
          return;
        }
        setTimeout(() => {
          newEditor.focus(noop, {
            defaultSelection: autoFocusValue.defaultSelection ?? "rootStart"
          });
        });
      }
    });
    r2.pub(rootEditor$, newEditor);
    r2.pub(activeEditor$, newEditor);
  },
  update(realm, params) {
    realm.pubIn({
      [contentEditableClassName$]: params == null ? void 0 : params.contentEditableClassName,
      [spellCheck$]: params == null ? void 0 : params.spellCheck,
      [toMarkdownOptions$]: params == null ? void 0 : params.toMarkdownOptions,
      [autoFocus$]: params == null ? void 0 : params.autoFocus,
      [placeholder$]: params == null ? void 0 : params.placeholder,
      [readOnly$]: params == null ? void 0 : params.readOnly
    });
    realm.singletonSub(mutableMarkdownSignal$, params == null ? void 0 : params.onChange);
    realm.singletonSub(onBlur$, params == null ? void 0 : params.onBlur);
    realm.singletonSub(markdownErrorSignal$, params == null ? void 0 : params.onError);
  }
});
function useTranslation() {
  return E(translation$);
}

// node_modules/@lexical/react/LexicalContentEditable.dev.mjs
var import_react5 = __toESM(require_react(), 1);
var import_jsx_runtime2 = __toESM(require_jsx_runtime(), 1);

// node_modules/@lexical/text/LexicalText.dev.mjs
function $rootTextContent() {
  const root2 = $getRoot();
  return root2.getTextContent();
}
function $isRootTextContentEmpty(isEditorComposing, trim = true) {
  if (isEditorComposing) {
    return false;
  }
  let text4 = $rootTextContent();
  if (trim) {
    text4 = text4.trim();
  }
  return text4 === "";
}
function $canShowPlaceholder(isComposing) {
  if (!$isRootTextContentEmpty(isComposing, false)) {
    return false;
  }
  const root2 = $getRoot();
  const children = root2.getChildren();
  const childrenLength = children.length;
  if (childrenLength > 1) {
    return false;
  }
  for (let i3 = 0; i3 < childrenLength; i3++) {
    const topBlock = children[i3];
    if ($isDecoratorNode(topBlock)) {
      return false;
    }
    if ($isElementNode(topBlock)) {
      if (!$isParagraphNode(topBlock)) {
        return false;
      }
      if (topBlock.__indent !== 0) {
        return false;
      }
      const topBlockChildren = topBlock.getChildren();
      const topBlockChildrenLength = topBlockChildren.length;
      for (let s2 = 0; s2 < topBlockChildrenLength; s2++) {
        const child = topBlockChildren[i3];
        if (!$isTextNode(child)) {
          return false;
        }
      }
    }
  }
  return true;
}
function $canShowPlaceholderCurry(isEditorComposing) {
  return () => $canShowPlaceholder(isEditorComposing);
}

// node_modules/@lexical/react/LexicalContentEditable.dev.mjs
var CAN_USE_DOM4 = typeof window !== "undefined" && typeof window.document !== "undefined" && typeof window.document.createElement !== "undefined";
var useLayoutEffectImpl = CAN_USE_DOM4 ? import_react5.useLayoutEffect : import_react5.useEffect;
function mergeRefs(...refs) {
  return (value2) => {
    refs.forEach((ref2) => {
      if (typeof ref2 === "function") {
        ref2(value2);
      } else if (ref2 != null) {
        ref2.current = value2;
      }
    });
  };
}
function ContentEditableElementImpl({
  editor,
  ariaActiveDescendant,
  ariaAutoComplete,
  ariaControls,
  ariaDescribedBy,
  ariaErrorMessage,
  ariaExpanded,
  ariaInvalid,
  ariaLabel,
  ariaLabelledBy,
  ariaMultiline,
  ariaOwns,
  ariaRequired,
  autoCapitalize,
  className,
  id,
  role = "textbox",
  spellCheck = true,
  style,
  tabIndex,
  "data-testid": testid,
  ...rest
}, ref2) {
  const [isEditable, setEditable] = (0, import_react5.useState)(editor.isEditable());
  const handleRef = (0, import_react5.useCallback)((rootElement) => {
    if (rootElement && rootElement.ownerDocument && rootElement.ownerDocument.defaultView) {
      editor.setRootElement(rootElement);
    } else {
      editor.setRootElement(null);
    }
  }, [editor]);
  const mergedRefs = (0, import_react5.useMemo)(() => mergeRefs(ref2, handleRef), [handleRef, ref2]);
  useLayoutEffectImpl(() => {
    setEditable(editor.isEditable());
    return editor.registerEditableListener((currentIsEditable) => {
      setEditable(currentIsEditable);
    });
  }, [editor]);
  return (0, import_jsx_runtime2.jsx)("div", {
    "aria-activedescendant": isEditable ? ariaActiveDescendant : void 0,
    "aria-autocomplete": isEditable ? ariaAutoComplete : "none",
    "aria-controls": isEditable ? ariaControls : void 0,
    "aria-describedby": ariaDescribedBy,
    ...ariaErrorMessage != null ? {
      "aria-errormessage": ariaErrorMessage
    } : {},
    "aria-expanded": isEditable && role === "combobox" ? !!ariaExpanded : void 0,
    ...ariaInvalid != null ? {
      "aria-invalid": ariaInvalid
    } : {},
    "aria-label": ariaLabel,
    "aria-labelledby": ariaLabelledBy,
    "aria-multiline": ariaMultiline,
    "aria-owns": isEditable ? ariaOwns : void 0,
    "aria-readonly": isEditable ? void 0 : true,
    "aria-required": ariaRequired,
    autoCapitalize,
    className,
    contentEditable: isEditable,
    "data-testid": testid,
    id,
    ref: mergedRefs,
    role: isEditable ? role : void 0,
    spellCheck,
    style,
    tabIndex,
    ...rest
  });
}
var ContentEditableElement = (0, import_react5.forwardRef)(ContentEditableElementImpl);
function canShowPlaceholderFromCurrentEditorState(editor) {
  const currentCanShowPlaceholder = editor.getEditorState().read($canShowPlaceholderCurry(editor.isComposing()));
  return currentCanShowPlaceholder;
}
function useCanShowPlaceholder(editor) {
  const [canShowPlaceholder, setCanShowPlaceholder] = (0, import_react5.useState)(() => canShowPlaceholderFromCurrentEditorState(editor));
  useLayoutEffectImpl(() => {
    function resetCanShowPlaceholder() {
      const currentCanShowPlaceholder = canShowPlaceholderFromCurrentEditorState(editor);
      setCanShowPlaceholder(currentCanShowPlaceholder);
    }
    resetCanShowPlaceholder();
    return mergeRegister(editor.registerUpdateListener(() => {
      resetCanShowPlaceholder();
    }), editor.registerEditableListener(() => {
      resetCanShowPlaceholder();
    }));
  }, [editor]);
  return canShowPlaceholder;
}
var ContentEditable = (0, import_react5.forwardRef)(ContentEditableImpl);
function ContentEditableImpl(props, ref2) {
  const {
    placeholder: placeholder2,
    ...rest
  } = props;
  const [editor] = useLexicalComposerContext();
  return (0, import_jsx_runtime2.jsxs)(import_jsx_runtime2.Fragment, {
    children: [(0, import_jsx_runtime2.jsx)(ContentEditableElement, {
      editor,
      ...rest,
      ref: ref2
    }), placeholder2 != null && (0, import_jsx_runtime2.jsx)(Placeholder, {
      editor,
      content: placeholder2
    })]
  });
}
function Placeholder({
  content: content3,
  editor
}) {
  const showPlaceholder = useCanShowPlaceholder(editor);
  const [isEditable, setEditable] = (0, import_react5.useState)(editor.isEditable());
  (0, import_react5.useLayoutEffect)(() => {
    setEditable(editor.isEditable());
    return editor.registerEditableListener((currentIsEditable) => {
      setEditable(currentIsEditable);
    });
  }, [editor]);
  if (!showPlaceholder) {
    return null;
  }
  let placeholder2 = null;
  if (typeof content3 === "function") {
    placeholder2 = content3(isEditable);
  } else if (content3 !== null) {
    placeholder2 = content3;
  }
  if (placeholder2 === null) {
    return null;
  }
  return (0, import_jsx_runtime2.jsx)("div", {
    "aria-hidden": true,
    children: placeholder2
  });
}

// node_modules/@lexical/react/LexicalErrorBoundary.dev.mjs
var React = __toESM(require_react(), 1);
var import_jsx_runtime3 = __toESM(require_jsx_runtime(), 1);
function _setPrototypeOf(o3, p2) {
  _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf3(o4, p3) {
    o4.__proto__ = p3;
    return o4;
  };
  return _setPrototypeOf(o3, p2);
}
function _inheritsLoose(subClass, superClass) {
  subClass.prototype = Object.create(superClass.prototype);
  subClass.prototype.constructor = subClass;
  _setPrototypeOf(subClass, superClass);
}
var changedArray = function changedArray2(a2, b3) {
  if (a2 === void 0) {
    a2 = [];
  }
  if (b3 === void 0) {
    b3 = [];
  }
  return a2.length !== b3.length || a2.some(function(item, index3) {
    return !Object.is(item, b3[index3]);
  });
};
var initialState = {
  error: null
};
var ErrorBoundary = function(_React$Component) {
  _inheritsLoose(ErrorBoundary2, _React$Component);
  function ErrorBoundary2() {
    var _this;
    for (var _len = arguments.length, _args = new Array(_len), _key = 0; _key < _len; _key++) {
      _args[_key] = arguments[_key];
    }
    _this = _React$Component.call.apply(_React$Component, [this].concat(_args)) || this;
    _this.state = initialState;
    _this.resetErrorBoundary = function() {
      var _this$props;
      for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
        args[_key2] = arguments[_key2];
      }
      _this.props.onReset == null ? void 0 : (_this$props = _this.props).onReset.apply(_this$props, args);
      _this.reset();
    };
    return _this;
  }
  ErrorBoundary2.getDerivedStateFromError = function getDerivedStateFromError(error) {
    return {
      error
    };
  };
  var _proto = ErrorBoundary2.prototype;
  _proto.reset = function reset2() {
    this.setState(initialState);
  };
  _proto.componentDidCatch = function componentDidCatch(error, info) {
    var _this$props$onError, _this$props2;
    (_this$props$onError = (_this$props2 = this.props).onError) == null ? void 0 : _this$props$onError.call(_this$props2, error, info);
  };
  _proto.componentDidUpdate = function componentDidUpdate(prevProps, prevState) {
    var error = this.state.error;
    var resetKeys = this.props.resetKeys;
    if (error !== null && prevState.error !== null && changedArray(prevProps.resetKeys, resetKeys)) {
      var _this$props$onResetKe, _this$props3;
      (_this$props$onResetKe = (_this$props3 = this.props).onResetKeysChange) == null ? void 0 : _this$props$onResetKe.call(_this$props3, prevProps.resetKeys, resetKeys);
      this.reset();
    }
  };
  _proto.render = function render() {
    var error = this.state.error;
    var _this$props4 = this.props, fallbackRender = _this$props4.fallbackRender, FallbackComponent = _this$props4.FallbackComponent, fallback = _this$props4.fallback;
    if (error !== null) {
      var _props = {
        error,
        resetErrorBoundary: this.resetErrorBoundary
      };
      if (React.isValidElement(fallback)) {
        return fallback;
      } else if (typeof fallbackRender === "function") {
        return fallbackRender(_props);
      } else if (FallbackComponent) {
        return React.createElement(FallbackComponent, _props);
      } else {
        throw new Error("react-error-boundary requires either a fallback, fallbackRender, or FallbackComponent prop");
      }
    }
    return this.props.children;
  };
  return ErrorBoundary2;
}(React.Component);
function LexicalErrorBoundary({
  children,
  onError
}) {
  return (0, import_jsx_runtime3.jsx)(ErrorBoundary, {
    fallback: (0, import_jsx_runtime3.jsx)("div", {
      style: {
        border: "1px solid #f00",
        color: "#f00",
        padding: "8px"
      },
      children: "An error was thrown."
    }),
    onError,
    children
  });
}

// node_modules/@lexical/react/useLexicalEditable.dev.mjs
var import_react6 = __toESM(require_react(), 1);
var CAN_USE_DOM5 = typeof window !== "undefined" && typeof window.document !== "undefined" && typeof window.document.createElement !== "undefined";
var useLayoutEffectImpl2 = CAN_USE_DOM5 ? import_react6.useLayoutEffect : import_react6.useEffect;
function useLexicalSubscription(subscription2) {
  const [editor] = useLexicalComposerContext();
  const initializedSubscription = (0, import_react6.useMemo)(() => subscription2(editor), [editor, subscription2]);
  const [value2, setValue] = (0, import_react6.useState)(() => initializedSubscription.initialValueFn());
  const valueRef = (0, import_react6.useRef)(value2);
  useLayoutEffectImpl2(() => {
    const {
      initialValueFn,
      subscribe
    } = initializedSubscription;
    const currentValue = initialValueFn();
    if (valueRef.current !== currentValue) {
      valueRef.current = currentValue;
      setValue(currentValue);
    }
    return subscribe((newValue) => {
      valueRef.current = newValue;
      setValue(newValue);
    });
  }, [initializedSubscription, subscription2]);
  return value2;
}
function subscription(editor) {
  return {
    initialValueFn: () => editor.isEditable(),
    subscribe: (callback) => {
      return editor.registerEditableListener(callback);
    }
  };
}
function useLexicalEditable() {
  return useLexicalSubscription(subscription);
}

// node_modules/@lexical/react/LexicalRichTextPlugin.dev.mjs
var import_react7 = __toESM(require_react(), 1);
var import_react_dom = __toESM(require_react_dom(), 1);
var import_jsx_runtime4 = __toESM(require_jsx_runtime(), 1);

// node_modules/@lexical/dragon/LexicalDragon.dev.mjs
function registerDragonSupport(editor) {
  const origin = window.location.origin;
  const handler2 = (event) => {
    if (event.origin !== origin) {
      return;
    }
    const rootElement = editor.getRootElement();
    if (document.activeElement !== rootElement) {
      return;
    }
    const data2 = event.data;
    if (typeof data2 === "string") {
      let parsedData;
      try {
        parsedData = JSON.parse(data2);
      } catch (e2) {
        return;
      }
      if (parsedData && parsedData.protocol === "nuanria_messaging" && parsedData.type === "request") {
        const payload = parsedData.payload;
        if (payload && payload.functionId === "makeChanges") {
          const args = payload.args;
          if (args) {
            const [elementStart, elementLength, text4, selStart, selLength, formatCommand] = args;
            editor.update(() => {
              const selection2 = $getSelection();
              if ($isRangeSelection(selection2)) {
                const anchor = selection2.anchor;
                let anchorNode = anchor.getNode();
                let setSelStart = 0;
                let setSelEnd = 0;
                if ($isTextNode(anchorNode)) {
                  if (elementStart >= 0 && elementLength >= 0) {
                    setSelStart = elementStart;
                    setSelEnd = elementStart + elementLength;
                    selection2.setTextNodeRange(anchorNode, setSelStart, anchorNode, setSelEnd);
                  }
                }
                if (setSelStart !== setSelEnd || text4 !== "") {
                  selection2.insertRawText(text4);
                  anchorNode = anchor.getNode();
                }
                if ($isTextNode(anchorNode)) {
                  setSelStart = selStart;
                  setSelEnd = selStart + selLength;
                  const anchorNodeTextLength = anchorNode.getTextContentSize();
                  setSelStart = setSelStart > anchorNodeTextLength ? anchorNodeTextLength : setSelStart;
                  setSelEnd = setSelEnd > anchorNodeTextLength ? anchorNodeTextLength : setSelEnd;
                  selection2.setTextNodeRange(anchorNode, setSelStart, anchorNode, setSelEnd);
                }
                event.stopImmediatePropagation();
              }
            });
          }
        }
      }
    }
  };
  window.addEventListener("message", handler2, true);
  return () => {
    window.removeEventListener("message", handler2, true);
  };
}

// node_modules/@lexical/react/LexicalRichTextPlugin.dev.mjs
var CAN_USE_DOM6 = typeof window !== "undefined" && typeof window.document !== "undefined" && typeof window.document.createElement !== "undefined";
var useLayoutEffectImpl3 = CAN_USE_DOM6 ? import_react7.useLayoutEffect : import_react7.useEffect;
function canShowPlaceholderFromCurrentEditorState2(editor) {
  const currentCanShowPlaceholder = editor.getEditorState().read($canShowPlaceholderCurry(editor.isComposing()));
  return currentCanShowPlaceholder;
}
function useCanShowPlaceholder2(editor) {
  const [canShowPlaceholder, setCanShowPlaceholder] = (0, import_react7.useState)(() => canShowPlaceholderFromCurrentEditorState2(editor));
  useLayoutEffectImpl3(() => {
    function resetCanShowPlaceholder() {
      const currentCanShowPlaceholder = canShowPlaceholderFromCurrentEditorState2(editor);
      setCanShowPlaceholder(currentCanShowPlaceholder);
    }
    resetCanShowPlaceholder();
    return mergeRegister(editor.registerUpdateListener(() => {
      resetCanShowPlaceholder();
    }), editor.registerEditableListener(() => {
      resetCanShowPlaceholder();
    }));
  }, [editor]);
  return canShowPlaceholder;
}
function useDecorators(editor, ErrorBoundary2) {
  const [decorators, setDecorators] = (0, import_react7.useState)(() => editor.getDecorators());
  useLayoutEffectImpl3(() => {
    return editor.registerDecoratorListener((nextDecorators) => {
      (0, import_react_dom.flushSync)(() => {
        setDecorators(nextDecorators);
      });
    });
  }, [editor]);
  (0, import_react7.useEffect)(() => {
    setDecorators(editor.getDecorators());
  }, [editor]);
  return (0, import_react7.useMemo)(() => {
    const decoratedPortals = [];
    const decoratorKeys = Object.keys(decorators);
    for (let i3 = 0; i3 < decoratorKeys.length; i3++) {
      const nodeKey = decoratorKeys[i3];
      const reactDecorator = (0, import_jsx_runtime4.jsx)(ErrorBoundary2, {
        onError: (e2) => editor._onError(e2),
        children: (0, import_jsx_runtime4.jsx)(import_react7.Suspense, {
          fallback: null,
          children: decorators[nodeKey]
        })
      });
      const element2 = editor.getElementByKey(nodeKey);
      if (element2 !== null) {
        decoratedPortals.push((0, import_react_dom.createPortal)(reactDecorator, element2, nodeKey));
      }
    }
    return decoratedPortals;
  }, [ErrorBoundary2, decorators, editor]);
}
function useRichTextSetup(editor) {
  useLayoutEffectImpl3(() => {
    return mergeRegister(registerRichText(editor), registerDragonSupport(editor));
  }, [editor]);
}
function RichTextPlugin({
  contentEditable: contentEditable2,
  // TODO Remove. This property is now part of ContentEditable
  placeholder: placeholder2 = null,
  ErrorBoundary: ErrorBoundary2
}) {
  const [editor] = useLexicalComposerContext();
  const decorators = useDecorators(editor, ErrorBoundary2);
  useRichTextSetup(editor);
  return (0, import_jsx_runtime4.jsxs)(import_jsx_runtime4.Fragment, {
    children: [contentEditable2, (0, import_jsx_runtime4.jsx)(Placeholder2, {
      content: placeholder2
    }), decorators]
  });
}
function Placeholder2({
  content: content3
}) {
  const [editor] = useLexicalComposerContext();
  const showPlaceholder = useCanShowPlaceholder2(editor);
  const editable = useLexicalEditable();
  if (!showPlaceholder) {
    return null;
  }
  if (typeof content3 === "function") {
    return content3(editable);
  } else {
    return content3;
  }
}

// node_modules/@mdxeditor/editor/dist/MDXEditor.js
var import_classnames = __toESM(require_classnames(), 1);

// node_modules/@mdxeditor/editor/dist/styles/ui.module.css.js
var editorRoot = "_editorRoot_uazmk_53";
var editorWrapper = "_editorWrapper_uazmk_154";
var nestedListItem2 = "_nestedListItem_uazmk_156";
var toolbarRoot = "_toolbarRoot_uazmk_160";
var readOnlyToolbarRoot = "_readOnlyToolbarRoot_uazmk_187";
var toolbarModeSwitch = "_toolbarModeSwitch_uazmk_196";
var toolbarToggleItem = "_toolbarToggleItem_uazmk_206";
var toolbarGroupOfGroups = "_toolbarGroupOfGroups_uazmk_217";
var toolbarToggleSingleGroup = "_toolbarToggleSingleGroup_uazmk_222";
var toolbarButton = "_toolbarButton_uazmk_237";
var activeToolbarButton = "_activeToolbarButton_uazmk_274";
var toolbarNodeKindSelectContainer = "_toolbarNodeKindSelectContainer_uazmk_284";
var toolbarButtonDropdownContainer = "_toolbarButtonDropdownContainer_uazmk_285";
var toolbarCodeBlockLanguageSelectContent = "_toolbarCodeBlockLanguageSelectContent_uazmk_286";
var selectContainer = "_selectContainer_uazmk_287";
var selectItem = "_selectItem_uazmk_300";
var toolbarNodeKindSelectTrigger = "_toolbarNodeKindSelectTrigger_uazmk_305";
var toolbarButtonSelectTrigger = "_toolbarButtonSelectTrigger_uazmk_306";
var selectTrigger = "_selectTrigger_uazmk_307";
var toolbarCodeBlockLanguageSelectTrigger = "_toolbarCodeBlockLanguageSelectTrigger_uazmk_342";
var toolbarNodeKindSelectItem = "_toolbarNodeKindSelectItem_uazmk_347";
var toolbarNodeKindSelectDropdownArrow = "_toolbarNodeKindSelectDropdownArrow_uazmk_372";
var selectDropdownArrow = "_selectDropdownArrow_uazmk_373";
var contentEditable = "_contentEditable_uazmk_379";
var codeMirrorWrapper = "_codeMirrorWrapper_uazmk_391";
var sandPackWrapper = "_sandPackWrapper_uazmk_400";
var codeMirrorToolbar = "_codeMirrorToolbar_uazmk_408";
var frontmatterWrapper = "_frontmatterWrapper_uazmk_412";
var frontmatterToggleButton = "_frontmatterToggleButton_uazmk_422";
var propertyPanelTitle = "_propertyPanelTitle_uazmk_430";
var propertyEditorTable = "_propertyEditorTable_uazmk_438";
var iconButton = "_iconButton_uazmk_456";
var readOnlyColumnCell = "_readOnlyColumnCell_uazmk_461";
var propertyEditorLabelCell = "_propertyEditorLabelCell_uazmk_466";
var buttonsFooter = "_buttonsFooter_uazmk_474";
var propertyEditorInput = "_propertyEditorInput_uazmk_480";
var primaryButton = "_primaryButton_uazmk_506";
var secondaryButton = "_secondaryButton_uazmk_507";
var smallButton = "_smallButton_uazmk_522";
var dialogForm = "_dialogForm_uazmk_534";
var linkDialogEditForm = "_linkDialogEditForm_uazmk_540";
var linkDialogInputContainer = "_linkDialogInputContainer_uazmk_548";
var linkDialogInputWrapper = "_linkDialogInputWrapper_uazmk_554";
var linkDialogInput = "_linkDialogInput_uazmk_548";
var dialogInput = "_dialogInput_uazmk_575";
var linkDialogAnchor = "_linkDialogAnchor_uazmk_586";
var linkDialogPopoverContent = "_linkDialogPopoverContent_uazmk_600";
var tableColumnEditorPopoverContent = "_tableColumnEditorPopoverContent_uazmk_601";
var dialogContent = "_dialogContent_uazmk_602";
var largeDialogContent = "_largeDialogContent_uazmk_614";
var dialogTitle = "_dialogTitle_uazmk_624";
var dialogCloseButton = "_dialogCloseButton_uazmk_630";
var popoverContent = "_popoverContent_uazmk_637";
var popoverArrow = "_popoverArrow_uazmk_649";
var linkDialogPreviewAnchor = "_linkDialogPreviewAnchor_uazmk_653";
var tooltipTrigger = "_tooltipTrigger_uazmk_676";
var tooltipContent = "_tooltipContent_uazmk_680";
var actionButton = "_actionButton_uazmk_694";
var primaryActionButton = "_primaryActionButton_uazmk_701";
var tableEditor = "_tableEditor_uazmk_713";
var toolCell = "_toolCell_uazmk_724";
var tableColumnEditorTrigger = "_tableColumnEditorTrigger_uazmk_743";
var tableRowEditorTrigger = "_tableRowEditorTrigger_uazmk_744";
var addRowButton = "_addRowButton_uazmk_745";
var addColumnButton = "_addColumnButton_uazmk_746";
var tableColumnEditorToolbar = "_tableColumnEditorToolbar_uazmk_789";
var toggleGroupRoot = "_toggleGroupRoot_uazmk_803";
var tableToolsColumn = "_tableToolsColumn_uazmk_821";
var leftAlignedCell = "_leftAlignedCell_uazmk_830";
var rightAlignedCell = "_rightAlignedCell_uazmk_834";
var centeredCell = "_centeredCell_uazmk_838";
var dialogOverlay = "_dialogOverlay_uazmk_871";
var overlayShow = "_overlayShow_uazmk_1";
var contentShow = "_contentShow_uazmk_1";
var focusedImage = "_focusedImage_uazmk_918";
var imageWrapper = "_imageWrapper_uazmk_922";
var editImageToolbar = "_editImageToolbar_uazmk_935";
var editImageButton = "_editImageButton_uazmk_939";
var inlineEditor = "_inlineEditor_uazmk_945";
var blockEditor = "_blockEditor_uazmk_954";
var nestedEditor = "_nestedEditor_uazmk_963";
var genericComponentName = "_genericComponentName_uazmk_982";
var diffSourceToggle = "_diffSourceToggle_uazmk_988";
var selectWithLabel = "_selectWithLabel_uazmk_1002";
var toolbarTitleMode = "_toolbarTitleMode_uazmk_1017";
var imageControlWrapperResizing = "_imageControlWrapperResizing_uazmk_1023";
var imageResizer = "_imageResizer_uazmk_1027";
var imageResizerN = "_imageResizerN_uazmk_1036";
var imageResizerNe = "_imageResizerNe_uazmk_1042";
var imageResizerE = "_imageResizerE_uazmk_1048";
var imageResizerSe = "_imageResizerSe_uazmk_1054";
var imageResizerS = "_imageResizerS_uazmk_1054";
var imageResizerSw = "_imageResizerSw_uazmk_1066";
var imageResizerW = "_imageResizerW_uazmk_1072";
var imageResizerNw = "_imageResizerNw_uazmk_1078";
var placeholder = "_placeholder_uazmk_1084";
var rootContentEditableWrapper = "_rootContentEditableWrapper_uazmk_1097";
var downshiftContainer = "_downshiftContainer_uazmk_1103";
var downshiftInputWrapper = "_downshiftInputWrapper_uazmk_1109";
var downshiftInput = "_downshiftInput_uazmk_1109";
var downshiftAutocompleteContainer = "_downshiftAutocompleteContainer_uazmk_1140";
var textInput = "_textInput_uazmk_1186";
var multiFieldForm = "_multiFieldForm_uazmk_1194";
var formField = "_formField_uazmk_1200";
var markdownParseError = "_markdownParseError_uazmk_1211";
var popupContainer = "_popupContainer_uazmk_1220";
var inputSizer = "_inputSizer_uazmk_1225";
var styles = {
  editorRoot,
  editorWrapper,
  nestedListItem: nestedListItem2,
  toolbarRoot,
  readOnlyToolbarRoot,
  toolbarModeSwitch,
  toolbarToggleItem,
  toolbarGroupOfGroups,
  toolbarToggleSingleGroup,
  toolbarButton,
  activeToolbarButton,
  toolbarNodeKindSelectContainer,
  toolbarButtonDropdownContainer,
  toolbarCodeBlockLanguageSelectContent,
  selectContainer,
  selectItem,
  toolbarNodeKindSelectTrigger,
  toolbarButtonSelectTrigger,
  selectTrigger,
  toolbarCodeBlockLanguageSelectTrigger,
  toolbarNodeKindSelectItem,
  toolbarNodeKindSelectDropdownArrow,
  selectDropdownArrow,
  contentEditable,
  codeMirrorWrapper,
  sandPackWrapper,
  codeMirrorToolbar,
  frontmatterWrapper,
  frontmatterToggleButton,
  propertyPanelTitle,
  propertyEditorTable,
  iconButton,
  readOnlyColumnCell,
  propertyEditorLabelCell,
  buttonsFooter,
  propertyEditorInput,
  primaryButton,
  secondaryButton,
  smallButton,
  dialogForm,
  linkDialogEditForm,
  linkDialogInputContainer,
  linkDialogInputWrapper,
  linkDialogInput,
  dialogInput,
  linkDialogAnchor,
  linkDialogPopoverContent,
  tableColumnEditorPopoverContent,
  dialogContent,
  largeDialogContent,
  dialogTitle,
  dialogCloseButton,
  popoverContent,
  popoverArrow,
  linkDialogPreviewAnchor,
  tooltipTrigger,
  tooltipContent,
  actionButton,
  primaryActionButton,
  tableEditor,
  toolCell,
  tableColumnEditorTrigger,
  tableRowEditorTrigger,
  addRowButton,
  addColumnButton,
  tableColumnEditorToolbar,
  toggleGroupRoot,
  tableToolsColumn,
  leftAlignedCell,
  rightAlignedCell,
  centeredCell,
  dialogOverlay,
  overlayShow,
  contentShow,
  focusedImage,
  imageWrapper,
  editImageToolbar,
  editImageButton,
  inlineEditor,
  blockEditor,
  nestedEditor,
  genericComponentName,
  diffSourceToggle,
  selectWithLabel,
  toolbarTitleMode,
  imageControlWrapperResizing,
  imageResizer,
  imageResizerN,
  imageResizerNe,
  imageResizerE,
  imageResizerSe,
  imageResizerS,
  imageResizerSw,
  imageResizerW,
  imageResizerNw,
  placeholder,
  rootContentEditableWrapper,
  downshiftContainer,
  downshiftInputWrapper,
  downshiftInput,
  downshiftAutocompleteContainer,
  textInput,
  multiFieldForm,
  formField,
  markdownParseError,
  popupContainer,
  inputSizer
};

// node_modules/@mdxeditor/editor/dist/defaultSvgIcons.js
var import_react8 = __toESM(require_react(), 1);
var defaultSvgIcons = {
  undo: import_react8.default.createElement("svg", { width: "24", height: "24", viewBox: "0 0 24 24", fill: "none", xmlns: "http://www.w3.org/2000/svg" }, import_react8.default.createElement(
    "path",
    {
      d: "M7.202 18.5V17H14.3788C15.4224 17 16.3205 16.6554 17.073 15.9663C17.8257 15.2773 18.202 14.4263 18.202 13.4135C18.202 12.4007 17.8257 11.5512 17.073 10.8652C16.3205 10.1794 15.4224 9.8365 14.3788 9.8365H7.35775L10.1402 12.6193L9.0865 13.673L4.5 9.0865L9.0865 4.5L10.1402 5.55375L7.35775 8.3365H14.3788C15.8416 8.3365 17.0945 8.82467 18.1375 9.801C19.1805 10.7773 19.702 11.9815 19.702 13.4135C19.702 14.8455 19.1805 16.0513 18.1375 17.0308C17.0945 18.0103 15.8416 18.5 14.3788 18.5H7.202Z",
      fill: "currentColor"
    }
  )),
  redo: import_react8.default.createElement("svg", { width: "24", height: "24", viewBox: "0 0 24 24", fill: "none", xmlns: "http://www.w3.org/2000/svg" }, import_react8.default.createElement(
    "path",
    {
      d: "M9.6211 18.5C8.15827 18.5 6.90535 18.0103 5.86235 17.0308C4.81935 16.0513 4.29785 14.8455 4.29785 13.4135C4.29785 11.9815 4.81935 10.7773 5.86235 9.801C6.90535 8.82467 8.15827 8.3365 9.6211 8.3365H16.6421L13.8596 5.55375L14.9134 4.5L19.4999 9.0865L14.9134 13.673L13.8596 12.6193L16.6421 9.8365H9.6211C8.57744 9.8365 7.67935 10.1794 6.92685 10.8652C6.17418 11.5512 5.79785 12.4007 5.79785 13.4135C5.79785 14.4263 6.17418 15.2773 6.92685 15.9663C7.67935 16.6554 8.57744 17 9.6211 17H16.7979V18.5H9.6211Z",
      fill: "currentColor"
    }
  )),
  format_bold: import_react8.default.createElement("svg", { width: "24", height: "24", viewBox: "0 0 24 24", fill: "none", xmlns: "http://www.w3.org/2000/svg" }, import_react8.default.createElement(
    "path",
    {
      d: "M7.33838 18.625V5.375H12.1999C13.219 5.375 14.1405 5.69233 14.9644 6.327C15.788 6.9615 16.1999 7.816 16.1999 8.8905C16.1999 9.63783 16.0194 10.2471 15.6584 10.7182C15.2975 11.1894 14.9088 11.5314 14.4921 11.7442C15.005 11.9211 15.4947 12.2708 15.9614 12.7933C16.428 13.3158 16.6614 14.0193 16.6614 14.9038C16.6614 16.1819 16.1902 17.1217 15.2479 17.723C14.3055 18.3243 13.3562 18.625 12.3999 18.625H7.33838ZM9.48838 16.6328H12.3191C13.1063 16.6328 13.6627 16.4142 13.9884 15.977C14.314 15.5398 14.4769 15.1206 14.4769 14.7192C14.4769 14.3179 14.314 13.8987 13.9884 13.4615C13.6627 13.0243 13.0909 12.8058 12.2729 12.8058H9.48838V16.6328ZM9.48838 10.875H12.0826C12.6903 10.875 13.172 10.7013 13.5279 10.3538C13.8835 10.0064 14.0614 9.59042 14.0614 9.10575C14.0614 8.59042 13.8733 8.16925 13.4971 7.84225C13.1208 7.51542 12.6595 7.352 12.1134 7.352H9.48838V10.875Z",
      fill: "currentColor"
    }
  )),
  format_italic: import_react8.default.createElement("svg", { width: "24", height: "24", viewBox: "0 0 24 24", fill: "none", xmlns: "http://www.w3.org/2000/svg" }, import_react8.default.createElement(
    "path",
    {
      d: "M5.39404 18.625V16.8173H9.21129L12.4518 7.18275H8.63454V5.375H17.7883V7.18275H14.2785L11.0383 16.8173H14.5478V18.625H5.39404Z",
      fill: "currentColor"
    }
  )),
  format_underlined: import_react8.default.createElement("svg", { width: "24", height: "24", viewBox: "0 0 24 24", fill: "none", xmlns: "http://www.w3.org/2000/svg" }, import_react8.default.createElement(
    "path",
    {
      d: "M5.34619 22.125V20.625H18.6537V22.125H5.34619ZM11.9999 18.5287C10.4448 18.5287 9.23102 18.0566 8.35869 17.1125C7.48619 16.1683 7.04994 14.9032 7.04994 13.3172V5.41345H8.90369V13.4095C8.90369 14.4198 9.17228 15.2295 9.70944 15.8385C10.2466 16.4475 11.0101 16.752 11.9999 16.752C12.9898 16.752 13.7533 16.4475 14.2904 15.8385C14.8276 15.2295 15.0962 14.4198 15.0962 13.4095V5.41345H16.9499V13.3172C16.9499 14.9032 16.5137 16.1683 15.6412 17.1125C14.7689 18.0566 13.5551 18.5287 11.9999 18.5287Z",
      fill: "currentColor"
    }
  )),
  code: import_react8.default.createElement("svg", { width: "24", height: "24", viewBox: "0 0 24 24", fill: "none", xmlns: "http://www.w3.org/2000/svg" }, import_react8.default.createElement(
    "path",
    {
      d: "M7.99994 17.6537L2.34619 11.9999L7.99994 6.34619L9.06919 7.41544L4.46919 12.0154L9.05369 16.5999L7.99994 17.6537ZM15.9999 17.6537L14.9307 16.5844L19.5307 11.9844L14.9462 7.39994L15.9999 6.34619L21.6537 11.9999L15.9999 17.6537Z",
      fill: "currentColor"
    }
  )),
  strikeThrough: import_react8.default.createElement("svg", { width: "24", height: "24", viewBox: "0 0 24 24", fill: "none", xmlns: "http://www.w3.org/2000/svg" }, import_react8.default.createElement(
    "path",
    {
      d: "M12.15 19.6923C10.9732 19.6923 9.9315 19.359 9.025 18.6923C8.11867 18.0256 7.45525 17.1128 7.03475 15.9538L8.6385 15.2635C8.91667 16.0444 9.3545 16.6867 9.952 17.1905C10.5493 17.6944 11.2923 17.9463 12.1808 17.9463C12.9578 17.9463 13.6744 17.7508 14.3307 17.3598C14.9872 16.9686 15.3155 16.3487 15.3155 15.5C15.3155 15.123 15.2555 14.7968 15.1355 14.5213C15.0157 14.2456 14.8462 13.9885 14.627 13.75H16.677C16.7987 13.9705 16.8932 14.2256 16.9605 14.5153C17.0278 14.8051 17.0615 15.1334 17.0615 15.5C17.0615 16.8372 16.5747 17.8702 15.601 18.599C14.6272 19.3279 13.4768 19.6923 12.15 19.6923ZM2.25 11.75V10.25H21.75V11.75H2.25ZM12.05 4.19629C13.0475 4.19629 13.9123 4.42704 14.6443 4.88854C15.3763 5.35004 15.9673 6.05896 16.4173 7.01529L14.823 7.73079C14.6218 7.26029 14.2978 6.84462 13.851 6.48379C13.4042 6.12279 12.8141 5.94229 12.0808 5.94229C11.2244 5.94229 10.5392 6.16221 10.025 6.60204C9.51083 7.04171 9.264 7.59104 9.2845 8.25004H7.5385C7.50133 7.16421 7.89783 6.21712 8.728 5.40879C9.558 4.60046 10.6653 4.19629 12.05 4.19629Z",
      fill: "currentColor"
    }
  )),
  superscript: import_react8.default.createElement("svg", { width: "24", height: "24", viewBox: "0 0 24 24", fill: "none", xmlns: "http://www.w3.org/2000/svg" }, import_react8.default.createElement(
    "path",
    {
      d: "M16.6924 8V6.2115C16.6924 5.95383 16.7786 5.73875 16.9511 5.56625C17.1235 5.39392 17.3385 5.30775 17.5961 5.30775H19.5001V4.38475H16.6924V3.5H19.4809C19.7385 3.5 19.9536 3.58625 20.1261 3.75875C20.2985 3.93108 20.3846 4.14617 20.3846 4.404V5.2885C20.3846 5.54617 20.2985 5.76125 20.1261 5.93375C19.9536 6.10608 19.7385 6.19225 19.4809 6.19225H17.5771V7.1155H20.3846V8H16.6924ZM4.44238 18.5L8.84638 11.6287L4.77713 5.30775H6.74438L9.95963 10.404H10.0214L13.2501 5.30775H15.2329L11.1194 11.6287L15.5579 18.5H13.5751L10.0214 12.9308H9.95963L6.42513 18.5H4.44238Z",
      fill: "currentColor"
    }
  )),
  subscript: import_react8.default.createElement("svg", { width: "24", height: "24", viewBox: "0 0 24 24", fill: "none", xmlns: "http://www.w3.org/2000/svg" }, import_react8.default.createElement(
    "path",
    {
      d: "M16.6924 20.5V18.7115C16.6924 18.4538 16.7786 18.2387 16.9511 18.0662C17.1235 17.8939 17.3385 17.8077 17.5961 17.8077H19.5001V16.8845H16.6924V16H19.4809C19.7385 16 19.9536 16.0863 20.1261 16.2587C20.2985 16.4311 20.3846 16.6461 20.3846 16.9038V17.7885C20.3846 18.0462 20.2985 18.2612 20.1261 18.4337C19.9536 18.6061 19.7385 18.6923 19.4809 18.6923H17.5771V19.6152H20.3846V20.5H16.6924ZM4.44238 18.6923L8.84638 11.8212L4.77713 5.5H6.74438L9.95963 10.5962H10.0214L13.2501 5.5H15.2329L11.1194 11.8212L15.5579 18.6923H13.5751L10.0214 13.123H9.95963L6.42513 18.6923H4.44238Z",
      fill: "currentColor"
    }
  )),
  format_list_bulleted: import_react8.default.createElement("svg", { width: "24", height: "24", viewBox: "0 0 24 24", fill: "none", xmlns: "http://www.w3.org/2000/svg" }, import_react8.default.createElement(
    "path",
    {
      d: "M9.30775 18.75V17.25H20.5V18.75H9.30775ZM9.30775 12.75V11.25H20.5V12.75H9.30775ZM9.30775 6.75005V5.25005H20.5V6.75005H9.30775ZM5.1635 19.6635C4.706 19.6635 4.31442 19.5006 3.98875 19.1748C3.66292 18.8491 3.5 18.4575 3.5 18C3.5 17.5425 3.66292 17.151 3.98875 16.8253C4.31442 16.4995 4.706 16.3365 5.1635 16.3365C5.621 16.3365 6.01258 16.4995 6.33825 16.8253C6.66408 17.151 6.827 17.5425 6.827 18C6.827 18.4575 6.66408 18.8491 6.33825 19.1748C6.01258 19.5006 5.621 19.6635 5.1635 19.6635ZM5.1635 13.6635C4.706 13.6635 4.31442 13.5006 3.98875 13.1748C3.66292 12.8491 3.5 12.4575 3.5 12C3.5 11.5425 3.66292 11.151 3.98875 10.8253C4.31442 10.4995 4.706 10.3365 5.1635 10.3365C5.621 10.3365 6.01258 10.4995 6.33825 10.8253C6.66408 11.151 6.827 11.5425 6.827 12C6.827 12.4575 6.66408 12.8491 6.33825 13.1748C6.01258 13.5006 5.621 13.6635 5.1635 13.6635ZM5.1635 7.66355C4.706 7.66355 4.31442 7.50063 3.98875 7.1748C3.66292 6.84913 3.5 6.45755 3.5 6.00005C3.5 5.54255 3.66292 5.15096 3.98875 4.8253C4.31442 4.49946 4.706 4.33655 5.1635 4.33655C5.621 4.33655 6.01258 4.49946 6.33825 4.8253C6.66408 5.15096 6.827 5.54255 6.827 6.00005C6.827 6.45755 6.66408 6.84913 6.33825 7.1748C6.01258 7.50063 5.621 7.66355 5.1635 7.66355Z",
      fill: "currentColor"
    }
  )),
  format_list_numbered: import_react8.default.createElement("svg", { width: "24", height: "24", viewBox: "0 0 24 24", fill: "none", xmlns: "http://www.w3.org/2000/svg" }, import_react8.default.createElement(
    "path",
    {
      d: "M3.5 21.5V20.3078H6V19.25H4.5V18.0577H6V17H3.5V15.8077H6.34625C6.58592 15.8077 6.78683 15.8888 6.949 16.051C7.11117 16.2132 7.19225 16.4141 7.19225 16.6538V17.8462C7.19225 18.0859 7.11117 18.2868 6.949 18.449C6.78683 18.6112 6.58592 18.6923 6.34625 18.6923C6.58592 18.6923 6.78683 18.7733 6.949 18.9355C7.11117 19.0977 7.19225 19.2987 7.19225 19.5385V20.6538C7.19225 20.8936 7.11117 21.0946 6.949 21.2568C6.78683 21.4189 6.58592 21.5 6.34625 21.5H3.5ZM3.5 14.8463V12.25C3.5 12.0103 3.58108 11.8093 3.74325 11.647C3.90542 11.4848 4.10642 11.4038 4.34625 11.4038H6V10.3462H3.5V9.15375H6.34625C6.58592 9.15375 6.78683 9.23483 6.949 9.397C7.11117 9.55933 7.19225 9.76033 7.19225 10V11.75C7.19225 11.9897 7.11117 12.1907 6.949 12.353C6.78683 12.5152 6.58592 12.5963 6.34625 12.5963H4.69225V13.6538H7.19225V14.8463H3.5ZM5 8.19225V3.69225H3.5V2.5H6.19225V8.19225H5ZM9.30775 18.75V17.25H20.5V18.75H9.30775ZM9.30775 12.75V11.25H20.5V12.75H9.30775ZM9.30775 6.75V5.25H20.5V6.75H9.30775Z",
      fill: "currentColor"
    }
  )),
  format_list_checked: import_react8.default.createElement("svg", { width: "24", height: "24", viewBox: "0 0 24 24", fill: "none", xmlns: "http://www.w3.org/2000/svg" }, import_react8.default.createElement(
    "path",
    {
      d: "M5.69425 18.452L2.5 15.2578L3.54425 14.2135L5.66925 16.3385L9.91925 12.0885L10.9635 13.1578L5.69425 18.452ZM5.69425 10.8365L2.5 7.64227L3.54425 6.59802L5.66925 8.72302L9.91925 4.47302L10.9635 5.54227L5.69425 10.8365ZM13.0095 16.5578V15.0578H21.5095V16.5578H13.0095ZM13.0095 8.94227V7.44227H21.5095V8.94227H13.0095Z",
      fill: "currentColor"
    }
  )),
  link: import_react8.default.createElement("svg", { width: "24", height: "24", viewBox: "0 0 24 24", fill: "none", xmlns: "http://www.w3.org/2000/svg" }, import_react8.default.createElement(
    "path",
    {
      d: "M10.8077 16.5385H7.0385C5.78283 16.5385 4.7125 16.096 3.8275 15.211C2.9425 14.3262 2.5 13.256 2.5 12.0005C2.5 10.745 2.9425 9.67471 3.8275 8.78955C4.7125 7.90421 5.78283 7.46155 7.0385 7.46155H10.8077V8.96155H7.0385C6.19867 8.96155 5.48233 9.25805 4.8895 9.85105C4.2965 10.444 4 11.1604 4 12C4 12.8397 4.2965 13.556 4.8895 14.149C5.48233 14.742 6.19867 15.0385 7.0385 15.0385H10.8077V16.5385ZM8.25 12.75V11.25H15.75V12.75H8.25ZM13.1923 16.5385V15.0385H16.9615C17.8013 15.0385 18.5177 14.742 19.1105 14.149C19.7035 13.556 20 12.8397 20 12C20 11.1604 19.7035 10.444 19.1105 9.85105C18.5177 9.25805 17.8013 8.96155 16.9615 8.96155H13.1923V7.46155H16.9615C18.2172 7.46155 19.2875 7.90405 20.1725 8.78905C21.0575 9.67388 21.5 10.744 21.5 11.9995C21.5 13.255 21.0575 14.3254 20.1725 15.2105C19.2875 16.0959 18.2172 16.5385 16.9615 16.5385H13.1923Z",
      fill: "currentColor"
    }
  )),
  add_photo: import_react8.default.createElement("svg", { width: "24", height: "24", viewBox: "0 0 24 24", fill: "none", xmlns: "http://www.w3.org/2000/svg" }, import_react8.default.createElement(
    "path",
    {
      d: "M5.11537 20.5C4.6182 20.5 4.19262 20.323 3.83862 19.969C3.48462 19.615 3.30762 19.1894 3.30762 18.6922V5.30773C3.30762 4.81056 3.48462 4.38498 3.83862 4.03098C4.19262 3.67698 4.6182 3.49998 5.11537 3.49998H13.8076V4.99998H5.11537C5.02553 4.99998 4.95178 5.02881 4.89412 5.08648C4.83645 5.14415 4.80762 5.2179 4.80762 5.30773V18.6922C4.80762 18.7821 4.83645 18.8558 4.89412 18.9135C4.95178 18.9711 5.02553 19 5.11537 19H18.4999C18.5895 19 18.6633 18.9711 18.7211 18.9135C18.7788 18.8558 18.8076 18.7821 18.8076 18.6922V9.99998H20.3076V18.6922C20.3076 19.1894 20.1306 19.615 19.7766 19.969C19.4226 20.323 18.997 20.5 18.4999 20.5H5.11537ZM17.1921 8.61523V6.61523H15.1921V5.11548H17.1921V3.11548H18.6921V5.11548H20.6921V6.61523H18.6921V8.61523H17.1921ZM6.55762 16.75H17.1344L13.8459 12.3655L11.0384 16.0192L9.03837 13.4615L6.55762 16.75Z",
      fill: "currentColor"
    }
  )),
  table: import_react8.default.createElement("svg", { width: "24", height: "24", viewBox: "0 0 24 24", fill: "none", xmlns: "http://www.w3.org/2000/svg" }, import_react8.default.createElement(
    "path",
    {
      d: "M3.5 18.6923V5.30775C3.5 4.81058 3.677 4.385 4.031 4.031C4.385 3.677 4.81058 3.5 5.30775 3.5H18.6923C19.1894 3.5 19.615 3.677 19.969 4.031C20.323 4.385 20.5 4.81058 20.5 5.30775V18.6923C20.5 19.1894 20.323 19.615 19.969 19.969C19.615 20.323 19.1894 20.5 18.6923 20.5H5.30775C4.81058 20.5 4.385 20.323 4.031 19.969C3.677 19.615 3.5 19.1894 3.5 18.6923ZM5 9.077H19V5.30775C19 5.21792 18.9712 5.14417 18.9135 5.0865C18.8558 5.02883 18.7821 5 18.6923 5H5.30775C5.21792 5 5.14417 5.02883 5.0865 5.0865C5.02883 5.14417 5 5.21792 5 5.30775V9.077ZM10.1615 14.0385H13.8385V10.577H10.1615V14.0385ZM10.1615 19H13.8385V15.5385H10.1615V19ZM5 14.0385H8.6615V10.577H5V14.0385ZM15.3385 14.0385H19V10.577H15.3385V14.0385ZM5.30775 19H8.6615V15.5385H5V18.6923C5 18.7821 5.02883 18.8558 5.0865 18.9135C5.14417 18.9712 5.21792 19 5.30775 19ZM15.3385 19H18.6923C18.7821 19 18.8558 18.9712 18.9135 18.9135C18.9712 18.8558 19 18.7821 19 18.6923V15.5385H15.3385V19Z",
      fill: "currentColor"
    }
  )),
  horizontal_rule: import_react8.default.createElement("svg", { width: "24", height: "24", viewBox: "0 0 24 24", fill: "none", xmlns: "http://www.w3.org/2000/svg" }, import_react8.default.createElement("path", { d: "M4.5 12.75V11.25H19.5V12.75H4.5Z", fill: "currentColor" })),
  frontmatter: import_react8.default.createElement("svg", { width: "24", height: "24", viewBox: "0 0 24 24", fill: "none", xmlns: "http://www.w3.org/2000/svg" }, import_react8.default.createElement("path", { d: "M4.5 8.75V7.25H8.5V8.75H4.5Z", fill: "currentColor" }), import_react8.default.createElement("path", { d: "M4.5 14.75V13.25H8.5V14.75H4.5Z", fill: "currentColor" }), import_react8.default.createElement("path", { d: "M9.5 8.75V7.25H13.5V8.75H9.5Z", fill: "currentColor" }), import_react8.default.createElement("path", { d: "M9.5 14.75V13.25H13.5V14.75H9.5Z", fill: "currentColor" }), import_react8.default.createElement("path", { d: "M14.5 8.75V7.25H18.5V8.75H14.5Z", fill: "currentColor" }), import_react8.default.createElement("path", { d: "M14.5 14.75V13.25H18.5V14.75H14.5Z", fill: "currentColor" })),
  frame_source: import_react8.default.createElement("svg", { width: "24", height: "24", viewBox: "0 0 24 24", fill: "none", xmlns: "http://www.w3.org/2000/svg" }, import_react8.default.createElement(
    "path",
    {
      d: "M8.6 15.2443L5.35575 12L8.6 8.75575L9.64425 9.825L7.46925 12L9.64425 14.175L8.6 15.2443ZM15.4 15.2443L14.3558 14.175L16.5307 12L14.3558 9.825L15.4 8.75575L18.6443 12L15.4 15.2443ZM5.30775 20.5C4.80258 20.5 4.375 20.325 4.025 19.975C3.675 19.625 3.5 19.1974 3.5 18.6923V15H5V18.6923C5 18.7692 5.03208 18.8398 5.09625 18.9038C5.16025 18.9679 5.23075 19 5.30775 19H9V20.5H5.30775ZM15 20.5V19H18.6923C18.7692 19 18.8398 18.9679 18.9038 18.9038C18.9679 18.8398 19 18.7692 19 18.6923V15H20.5V18.6923C20.5 19.1974 20.325 19.625 19.975 19.975C19.625 20.325 19.1974 20.5 18.6923 20.5H15ZM3.5 9V5.30775C3.5 4.80258 3.675 4.375 4.025 4.025C4.375 3.675 4.80258 3.5 5.30775 3.5H9V5H5.30775C5.23075 5 5.16025 5.03208 5.09625 5.09625C5.03208 5.16025 5 5.23075 5 5.30775V9H3.5ZM19 9V5.30775C19 5.23075 18.9679 5.16025 18.9038 5.09625C18.8398 5.03208 18.7692 5 18.6923 5H15V3.5H18.6923C19.1974 3.5 19.625 3.675 19.975 4.025C20.325 4.375 20.5 4.80258 20.5 5.30775V9H19Z",
      fill: "currentColor"
    }
  )),
  arrow_drop_down: import_react8.default.createElement("svg", { width: "24", height: "24", viewBox: "0 0 24 24", fill: "none", xmlns: "http://www.w3.org/2000/svg" }, import_react8.default.createElement("path", { d: "M11.9999 14.6537L7.59619 10.25H16.4037L11.9999 14.6537Z", fill: "currentColor" })),
  admonition: import_react8.default.createElement("svg", { width: "24", height: "24", viewBox: "0 0 24 24", fill: "none", xmlns: "http://www.w3.org/2000/svg" }, import_react8.default.createElement(
    "path",
    {
      d: "M12.0001 21.4C11.7654 21.4 11.5385 21.3548 11.3193 21.2645C11.1002 21.174 10.9002 21.0435 10.7193 20.873L3.1271 13.2807C2.9566 13.0999 2.8261 12.8999 2.7356 12.6807C2.64526 12.4616 2.6001 12.2346 2.6001 12C2.6001 11.7653 2.64526 11.5358 2.7356 11.3115C2.8261 11.0871 2.9566 10.8897 3.1271 10.7192L10.7193 3.12698C10.9002 2.94614 11.1002 2.81314 11.3193 2.72798C11.5385 2.64264 11.7654 2.59998 12.0001 2.59998C12.2348 2.59998 12.4643 2.64264 12.6886 2.72798C12.9129 2.81314 13.1103 2.94614 13.2808 3.12698L20.8731 10.7192C21.0539 10.8897 21.1869 11.0871 21.2721 11.3115C21.3574 11.5358 21.4001 11.7653 21.4001 12C21.4001 12.2346 21.3574 12.4616 21.2721 12.6807C21.1869 12.8999 21.0539 13.0999 20.8731 13.2807L13.2808 20.873C13.1103 21.0435 12.9129 21.174 12.6886 21.2645C12.4643 21.3548 12.2348 21.4 12.0001 21.4ZM12.2213 19.8037L19.8039 12.2212C19.8552 12.1699 19.8808 12.0961 19.8808 12C19.8808 11.9038 19.8552 11.8301 19.8039 11.7787L12.2213 4.19623C12.17 4.14489 12.0963 4.11923 12.0001 4.11923C11.9039 4.11923 11.8302 4.14489 11.7788 4.19623L4.19635 11.7787C4.14501 11.8301 4.11935 11.9038 4.11935 12C4.11935 12.0961 4.14501 12.1699 4.19635 12.2212L11.7788 19.8037C11.8302 19.8551 11.9039 19.8807 12.0001 19.8807C12.0963 19.8807 12.17 19.8551 12.2213 19.8037ZM11.2501 13.0865H12.7501V7.47123H11.2501V13.0865ZM12.0001 15.702C12.2258 15.702 12.4168 15.6237 12.5731 15.4672C12.7296 15.3109 12.8078 15.1199 12.8078 14.8942C12.8078 14.6686 12.7296 14.4776 12.5731 14.3212C12.4168 14.1647 12.2258 14.0865 12.0001 14.0865C11.7744 14.0865 11.5834 14.1647 11.4271 14.3212C11.2706 14.4776 11.1923 14.6686 11.1923 14.8942C11.1923 15.1199 11.2706 15.3109 11.4271 15.4672C11.5834 15.6237 11.7744 15.702 12.0001 15.702Z",
      fill: "currentColor"
    }
  )),
  sandpack: import_react8.default.createElement("svg", { width: "24", height: "24", viewBox: "0 0 24 24", fill: "none", xmlns: "http://www.w3.org/2000/svg" }, import_react8.default.createElement(
    "path",
    {
      d: "M12.9999 22.5C12.4947 22.5 12.0671 22.325 11.7171 21.975C11.3671 21.625 11.1921 21.1974 11.1921 20.6922V7.30775C11.1921 6.80258 11.3671 6.375 11.7171 6.025C12.0671 5.675 12.4947 5.5 12.9999 5.5H16.3844C16.8895 5.5 17.3171 5.675 17.6671 6.025C18.0171 6.375 18.1921 6.80258 18.1921 7.30775V20.6922C18.1921 21.1974 18.0171 21.625 17.6671 21.975C17.3171 22.325 16.8895 22.5 16.3844 22.5H12.9999ZM12.6921 7.30775V20.6922C12.6921 20.7692 12.7242 20.8398 12.7884 20.9038C12.8524 20.9679 12.9229 21 12.9999 21H16.3844C16.4614 21 16.5319 20.9679 16.5959 20.9038C16.66 20.8398 16.6921 20.7692 16.6921 20.6922V7.30775C16.6921 7.23075 16.66 7.16025 16.5959 7.09625C16.5319 7.03208 16.4614 7 16.3844 7H12.9999C12.9229 7 12.8524 7.03208 12.7884 7.09625C12.7242 7.16025 12.6921 7.23075 12.6921 7.30775ZM6.61537 18.5C6.1102 18.5 5.68262 18.325 5.33262 17.975C4.98262 17.625 4.80762 17.1974 4.80762 16.6923V3.30775C4.80762 2.80258 4.98262 2.375 5.33262 2.025C5.68262 1.675 6.1102 1.5 6.61537 1.5H9.99987C10.505 1.5 10.9326 1.675 11.2826 2.025C11.6326 2.375 11.8076 2.80258 11.8076 3.30775V16.6923C11.8076 17.1974 11.6326 17.625 11.2826 17.975C10.9326 18.325 10.505 18.5 9.99987 18.5H6.61537ZM6.30762 3.30775V16.6923C6.30762 16.7692 6.3397 16.8398 6.40387 16.9038C6.46787 16.9679 6.53837 17 6.61537 17H9.99987C10.0769 17 10.1474 16.9679 10.2114 16.9038C10.2755 16.8398 10.3076 16.7692 10.3076 16.6923V3.30775C10.3076 3.23075 10.2755 3.16025 10.2114 3.09625C10.1474 3.03208 10.0769 3 9.99987 3H6.61537C6.53837 3 6.46787 3.03208 6.40387 3.09625C6.3397 3.16025 6.30762 3.23075 6.30762 3.30775Z",
      fill: "currentColor"
    }
  )),
  rich_text: import_react8.default.createElement("svg", { width: "24", height: "24", viewBox: "0 0 24 24", fill: "none", xmlns: "http://www.w3.org/2000/svg" }, import_react8.default.createElement(
    "path",
    {
      d: "M5.30775 20.5C4.80258 20.5 4.375 20.325 4.025 19.975C3.675 19.625 3.5 19.1974 3.5 18.6923V5.30775C3.5 4.80258 3.675 4.375 4.025 4.025C4.375 3.675 4.80258 3.5 5.30775 3.5H18.6923C19.1974 3.5 19.625 3.675 19.975 4.025C20.325 4.375 20.5 4.80258 20.5 5.30775V18.6923C20.5 19.1974 20.325 19.625 19.975 19.975C19.625 20.325 19.1974 20.5 18.6923 20.5H5.30775ZM5.30775 19H18.6923C18.7692 19 18.8398 18.9679 18.9038 18.9038C18.9679 18.8398 19 18.7692 19 18.6923V5.30775C19 5.23075 18.9679 5.16025 18.9038 5.09625C18.8398 5.03208 18.7692 5 18.6923 5H5.30775C5.23075 5 5.16025 5.03208 5.09625 5.09625C5.03208 5.16025 5 5.23075 5 5.30775V18.6923C5 18.7692 5.03208 18.8398 5.09625 18.9038C5.16025 18.9679 5.23075 19 5.30775 19ZM6.75 17H17.3268L14 12.3655L11.2308 16.0192L9 13.4615L6.75 17Z",
      fill: "currentColor"
    }
  ), import_react8.default.createElement(
    "path",
    {
      fillRule: "evenodd",
      clipRule: "evenodd",
      d: "M6 12V6.5H9.1925C9.5925 6.5 9.9425 6.65 10.2425 6.95C10.5425 7.25 10.6925 7.6 10.6925 8V8.6925C10.6925 9.03733 10.605 9.32675 10.43 9.56075C10.255 9.79458 10.0168 9.97817 9.7155 10.1115L10.6155 12H9.404L8.504 10.1925H7.1925V12H6ZM9.1925 9H7.1925V7.6925H9.1925C9.26933 7.6925 9.33983 7.7245 9.404 7.7885C9.468 7.85267 9.5 7.92317 9.5 8V8.6925C9.5 8.76933 9.468 8.83983 9.404 8.904C9.33983 8.968 9.26933 9 9.1925 9Z",
      fill: "currentColor"
    }
  ), import_react8.default.createElement("path", { d: "M12.5 7H17.5V8.25H12.5V7Z", fill: "currentColor" }), import_react8.default.createElement("path", { d: "M12.5 9.25H17.5V10.5H12.5V9.25Z", fill: "currentColor" })),
  difference: import_react8.default.createElement("svg", { width: "24", height: "24", viewBox: "0 0 24 24", fill: "none", xmlns: "http://www.w3.org/2000/svg" }, import_react8.default.createElement(
    "path",
    {
      fillRule: "evenodd",
      clipRule: "evenodd",
      d: "M5.30775 20.5C4.80258 20.5 4.375 20.325 4.025 19.975C3.675 19.625 3.5 19.1974 3.5 18.6923V5.30775C3.5 4.80258 3.675 4.375 4.025 4.025C4.375 3.675 4.80258 3.5 5.30775 3.5H18.6923C19.1974 3.5 19.625 3.675 19.975 4.025C20.325 4.375 20.5 4.80258 20.5 5.30775V18.6923C20.5 19.1974 20.325 19.625 19.975 19.975C19.625 20.325 19.1974 20.5 18.6923 20.5H5.30775ZM18.6923 19H5.30775C5.23075 19 5.16025 18.9679 5.09625 18.9038C5.03208 18.8398 5 18.7692 5 18.6923V5.30775C5 5.23075 5.03208 5.16025 5.09625 5.09625C5.16025 5.03208 5.23075 5 5.30775 5H18.6923C18.7692 5 18.8398 5.03208 18.9038 5.09625C18.9679 5.16025 19 5.23075 19 5.30775V18.6923C19 18.7692 18.9679 18.8398 18.9038 18.9038C18.8398 18.9679 18.7692 19 18.6923 19Z",
      fill: "currentColor"
    }
  ), import_react8.default.createElement("rect", { x: "9", y: "10", width: "5.5", height: "1.5", fill: "currentColor" }), import_react8.default.createElement("rect", { x: "9", y: "15", width: "5.5", height: "1.5", fill: "currentColor" }), import_react8.default.createElement("rect", { x: "11", y: "8", width: "1.5", height: "5.5", fill: "currentColor" })),
  markdown: import_react8.default.createElement("svg", { width: "24", height: "24", viewBox: "0 0 24 24", fill: "none", xmlns: "http://www.w3.org/2000/svg" }, import_react8.default.createElement(
    "path",
    {
      fillRule: "evenodd",
      clipRule: "evenodd",
      d: "M5.30775 20.5C4.80258 20.5 4.375 20.325 4.025 19.975C3.675 19.625 3.5 19.1974 3.5 18.6923V5.30775C3.5 4.80258 3.675 4.375 4.025 4.025C4.375 3.675 4.80258 3.5 5.30775 3.5H18.6923C19.1974 3.5 19.625 3.675 19.975 4.025C20.325 4.375 20.5 4.80258 20.5 5.30775V18.6923C20.5 19.1974 20.325 19.625 19.975 19.975C19.625 20.325 19.1974 20.5 18.6923 20.5H5.30775ZM18.6923 19H5.30775C5.23075 19 5.16025 18.9679 5.09625 18.9038C5.03208 18.8398 5 18.7692 5 18.6923V5.30775C5 5.23075 5.03208 5.16025 5.09625 5.09625C5.16025 5.03208 5.23075 5 5.30775 5H18.6923C18.7692 5 18.8398 5.03208 18.9038 5.09625C18.9679 5.16025 19 5.23075 19 5.30775V18.6923C19 18.7692 18.9679 18.8398 18.9038 18.9038C18.8398 18.9679 18.7692 19 18.6923 19Z",
      fill: "currentColor"
    }
  ), import_react8.default.createElement("path", { d: "M13 15H11.5V11L9.5 14L7.5 11V15H6V8H7.5L9.5 11L11.5 8H13V15Z", fill: "currentColor" }), import_react8.default.createElement(
    "path",
    {
      d: "M15.9921 15.5833L13.2886 12.8797L14.0546 12.1137L15.4504 13.5016V7.99597L16.5336 7.99993V13.5016L17.9296 12.1137L18.6954 12.8797L15.9921 15.5833Z",
      fill: "currentColor"
    }
  )),
  open_in_new: import_react8.default.createElement("svg", { width: "24", height: "24", viewBox: "0 0 24 24", fill: "none", xmlns: "http://www.w3.org/2000/svg" }, import_react8.default.createElement(
    "path",
    {
      d: "M5.30775 20.5C4.80258 20.5 4.375 20.325 4.025 19.975C3.675 19.625 3.5 19.1974 3.5 18.6923V5.30775C3.5 4.80258 3.675 4.375 4.025 4.025C4.375 3.675 4.80258 3.5 5.30775 3.5H11.6152V5H5.30775C5.23075 5 5.16025 5.03208 5.09625 5.09625C5.03208 5.16025 5 5.23075 5 5.30775V18.6923C5 18.7692 5.03208 18.8398 5.09625 18.9038C5.16025 18.9679 5.23075 19 5.30775 19H18.6923C18.7692 19 18.8398 18.9679 18.9038 18.9038C18.9679 18.8398 19 18.7692 19 18.6923V12.3848H20.5V18.6923C20.5 19.1974 20.325 19.625 19.975 19.975C19.625 20.325 19.1974 20.5 18.6923 20.5H5.30775ZM9.71925 15.3345L8.6655 14.2808L17.9462 5H14V3.5H20.5V10H19V6.05375L9.71925 15.3345Z",
      fill: "currentColor"
    }
  )),
  link_off: import_react8.default.createElement("svg", { width: "24", height: "24", viewBox: "0 0 24 24", fill: "none", xmlns: "http://www.w3.org/2000/svg" }, import_react8.default.createElement(
    "path",
    {
      d: "M18.8843 16.1038L17.7498 14.9385C18.4228 14.7552 18.9661 14.3946 19.3796 13.8568C19.7931 13.319 19.9998 12.7 19.9998 12C19.9998 11.1604 19.705 10.444 19.1153 9.85105C18.5255 9.25805 17.8139 8.96155 16.9806 8.96155H13.1728V7.46155H16.9806C18.2293 7.46155 19.2947 7.90422 20.1768 8.78955C21.0588 9.67472 21.4998 10.7449 21.4998 12C21.4998 12.8859 21.262 13.6951 20.7863 14.4278C20.3107 15.1606 19.6767 15.7193 18.8843 16.1038ZM15.5806 12.75L14.0806 11.25H15.7306V12.75H15.5806ZM20.1461 22.2538L1.74609 3.8538L2.79984 2.80005L21.1998 21.2L20.1461 22.2538ZM10.8268 16.5386H7.03834C5.78318 16.5386 4.71301 16.0959 3.82784 15.2105C2.94251 14.3254 2.49984 13.2552 2.49984 12C2.49984 10.8885 2.85784 9.91322 3.57384 9.07405C4.28984 8.23505 5.18826 7.72838 6.26909 7.55405H6.49984L7.90759 8.96155H7.03834C6.19851 8.96155 5.48218 9.25805 4.88934 9.85105C4.29634 10.444 3.99984 11.1604 3.99984 12C3.99984 12.8397 4.29634 13.556 4.88934 14.149C5.48218 14.742 6.19851 15.0385 7.03834 15.0385H10.8268V16.5386ZM8.26909 12.75V11.25H10.2113L11.6863 12.75H8.26909Z",
      fill: "currentColor"
    }
  )),
  edit: import_react8.default.createElement("svg", { width: "24", height: "24", viewBox: "0 0 24 24", fill: "none", xmlns: "http://www.w3.org/2000/svg" }, import_react8.default.createElement(
    "path",
    {
      d: "M5 19H6.2615L16.498 8.7635L15.2365 7.502L5 17.7385V19ZM3.5 20.5V17.1155L16.6905 3.93075C16.8417 3.79342 17.0086 3.68733 17.1913 3.6125C17.3741 3.5375 17.5658 3.5 17.7663 3.5C17.9668 3.5 18.1609 3.53558 18.3488 3.60675C18.5367 3.67792 18.7032 3.79108 18.848 3.94625L20.0693 5.18275C20.2244 5.32758 20.335 5.49425 20.401 5.68275C20.467 5.87125 20.5 6.05975 20.5 6.24825C20.5 6.44942 20.4657 6.64133 20.397 6.824C20.3283 7.00683 20.2191 7.17383 20.0693 7.325L6.8845 20.5H3.5ZM15.8562 8.14375L15.2365 7.502L16.498 8.7635L15.8562 8.14375Z",
      fill: "currentColor"
    }
  )),
  content_copy: import_react8.default.createElement("svg", { width: "24", height: "24", viewBox: "0 0 24 24", fill: "none", xmlns: "http://www.w3.org/2000/svg" }, import_react8.default.createElement(
    "path",
    {
      d: "M9.05775 17.5C8.55258 17.5 8.125 17.325 7.775 16.975C7.425 16.625 7.25 16.1974 7.25 15.6923V4.30775C7.25 3.80258 7.425 3.375 7.775 3.025C8.125 2.675 8.55258 2.5 9.05775 2.5H17.4423C17.9474 2.5 18.375 2.675 18.725 3.025C19.075 3.375 19.25 3.80258 19.25 4.30775V15.6923C19.25 16.1974 19.075 16.625 18.725 16.975C18.375 17.325 17.9474 17.5 17.4423 17.5H9.05775ZM9.05775 16H17.4423C17.5192 16 17.5898 15.9679 17.6538 15.9038C17.7179 15.8398 17.75 15.7692 17.75 15.6923V4.30775C17.75 4.23075 17.7179 4.16025 17.6538 4.09625C17.5898 4.03208 17.5192 4 17.4423 4H9.05775C8.98075 4 8.91025 4.03208 8.84625 4.09625C8.78208 4.16025 8.75 4.23075 8.75 4.30775V15.6923C8.75 15.7692 8.78208 15.8398 8.84625 15.9038C8.91025 15.9679 8.98075 16 9.05775 16ZM5.55775 21C5.05258 21 4.625 20.825 4.275 20.475C3.925 20.125 3.75 19.6974 3.75 19.1923V6.30775H5.25V19.1923C5.25 19.2693 5.28208 19.3398 5.34625 19.4038C5.41025 19.4679 5.48075 19.5 5.55775 19.5H15.4423V21H5.55775Z",
      fill: "currentColor"
    }
  )),
  more_horiz: import_react8.default.createElement("svg", { width: "24", height: "24", viewBox: "0 0 24 24", fill: "none", xmlns: "http://www.w3.org/2000/svg" }, import_react8.default.createElement(
    "path",
    {
      d: "M6.23096 13.5C5.81846 13.5 5.46537 13.3531 5.17171 13.0592C4.87787 12.7656 4.73096 12.4125 4.73096 12C4.73096 11.5875 4.87787 11.2344 5.17171 10.9408C5.46537 10.6469 5.81846 10.5 6.23096 10.5C6.64346 10.5 6.99662 10.6469 7.29046 10.9408C7.58412 11.2344 7.73096 11.5875 7.73096 12C7.73096 12.4125 7.58412 12.7656 7.29046 13.0592C6.99662 13.3531 6.64346 13.5 6.23096 13.5ZM12.0002 13.5C11.5877 13.5 11.2346 13.3531 10.941 13.0592C10.6471 12.7656 10.5002 12.4125 10.5002 12C10.5002 11.5875 10.6471 11.2344 10.941 10.9408C11.2346 10.6469 11.5877 10.5 12.0002 10.5C12.4127 10.5 12.7658 10.6469 13.0595 10.9408C13.3533 11.2344 13.5002 11.5875 13.5002 12C13.5002 12.4125 13.3533 12.7656 13.0595 13.0592C12.7658 13.3531 12.4127 13.5 12.0002 13.5ZM17.7695 13.5C17.357 13.5 17.0038 13.3531 16.71 13.0592C16.4163 12.7656 16.2695 12.4125 16.2695 12C16.2695 11.5875 16.4163 11.2344 16.71 10.9408C17.0038 10.6469 17.357 10.5 17.7695 10.5C18.182 10.5 18.535 10.6469 18.8287 10.9408C19.1225 11.2344 19.2695 11.5875 19.2695 12C19.2695 12.4125 19.1225 12.7656 18.8287 13.0592C18.535 13.3531 18.182 13.5 17.7695 13.5Z",
      fill: "currentColor"
    }
  )),
  more_vert: import_react8.default.createElement("svg", { width: "24", height: "24", viewBox: "0 0 24 24", fill: "none", xmlns: "http://www.w3.org/2000/svg" }, import_react8.default.createElement(
    "path",
    {
      d: "M12 19.2692C11.5875 19.2692 11.2344 19.1223 10.9408 18.8285C10.6469 18.5348 10.5 18.1817 10.5 17.7692C10.5 17.3567 10.6469 17.0035 10.9408 16.7097C11.2344 16.416 11.5875 16.2692 12 16.2692C12.4125 16.2692 12.7656 16.416 13.0592 16.7097C13.3531 17.0035 13.5 17.3567 13.5 17.7692C13.5 18.1817 13.3531 18.5348 13.0592 18.8285C12.7656 19.1223 12.4125 19.2692 12 19.2692ZM12 13.5C11.5875 13.5 11.2344 13.353 10.9408 13.0592C10.6469 12.7655 10.5 12.4125 10.5 12C10.5 11.5875 10.6469 11.2344 10.9408 10.9407C11.2344 10.6469 11.5875 10.5 12 10.5C12.4125 10.5 12.7656 10.6469 13.0592 10.9407C13.3531 11.2344 13.5 11.5875 13.5 12C13.5 12.4125 13.3531 12.7655 13.0592 13.0592C12.7656 13.353 12.4125 13.5 12 13.5ZM12 7.73071C11.5875 7.73071 11.2344 7.58388 10.9408 7.29021C10.6469 6.99638 10.5 6.64321 10.5 6.23071C10.5 5.81821 10.6469 5.46513 10.9408 5.17146C11.2344 4.87763 11.5875 4.73071 12 4.73071C12.4125 4.73071 12.7656 4.87763 13.0592 5.17146C13.3531 5.46513 13.5 5.81821 13.5 6.23071C13.5 6.64321 13.3531 6.99638 13.0592 7.29021C12.7656 7.58388 12.4125 7.73071 12 7.73071Z",
      fill: "currentColor"
    }
  )),
  close: import_react8.default.createElement("svg", { width: "24", height: "24", viewBox: "0 0 24 24", fill: "none", xmlns: "http://www.w3.org/2000/svg" }, import_react8.default.createElement(
    "path",
    {
      d: "M6.39994 18.6538L5.34619 17.6L10.9462 12L5.34619 6.4L6.39994 5.34625L11.9999 10.9463L17.5999 5.34625L18.6537 6.4L13.0537 12L18.6537 17.6L17.5999 18.6538L11.9999 13.0538L6.39994 18.6538Z",
      fill: "currentColor"
    }
  )),
  settings: import_react8.default.createElement("svg", { width: "24", height: "24", viewBox: "0 0 24 24", fill: "none", xmlns: "http://www.w3.org/2000/svg" }, import_react8.default.createElement(
    "path",
    {
      d: "M9.69225 21.5L9.3115 18.4538C9.04367 18.3641 8.769 18.2385 8.4875 18.077C8.20617 17.9153 7.95459 17.7422 7.73275 17.5577L4.9115 18.75L2.604 14.75L5.04425 12.9058C5.02125 12.7571 5.00492 12.6077 4.99525 12.4578C4.98559 12.3078 4.98075 12.1583 4.98075 12.0095C4.98075 11.8673 4.98559 11.7228 4.99525 11.576C5.00492 11.4292 5.02125 11.2686 5.04425 11.0943L2.604 9.25L4.9115 5.26925L7.723 6.452C7.96417 6.261 8.22159 6.08633 8.49525 5.928C8.76892 5.76967 9.03784 5.64242 9.302 5.54625L9.69225 2.5H14.3078L14.6885 5.55575C14.9885 5.66475 15.2599 5.792 15.5028 5.9375C15.7458 6.083 15.991 6.2545 16.2385 6.452L19.0885 5.26925L21.396 9.25L18.9173 11.123C18.9531 11.2845 18.9727 11.4355 18.976 11.576C18.9792 11.7163 18.9808 11.8577 18.9808 12C18.9808 12.1358 18.9775 12.274 18.971 12.4145C18.9647 12.5548 18.9417 12.7154 18.902 12.8963L21.3615 14.75L19.0538 18.75L16.2385 17.548C15.991 17.7455 15.7384 17.9202 15.4808 18.072C15.2231 18.224 14.959 18.3481 14.6885 18.4443L14.3078 21.5H9.69225ZM11 20H12.9655L13.325 17.3212C13.8353 17.1879 14.3017 16.9985 14.724 16.753C15.1465 16.5073 15.5539 16.1916 15.9463 15.8057L18.4308 16.85L19.4155 15.15L17.2463 13.5155C17.3296 13.2565 17.3863 13.0026 17.4163 12.7537C17.4464 12.5051 17.4615 12.2538 17.4615 12C17.4615 11.7397 17.4464 11.4884 17.4163 11.2463C17.3863 11.0039 17.3296 10.7564 17.2463 10.5038L19.4345 8.85L18.45 7.15L15.9365 8.2095C15.6018 7.85183 15.2009 7.53583 14.7338 7.2615C14.2664 6.98717 13.7937 6.79292 13.3155 6.67875L13 4H11.0155L10.6845 6.66925C10.1743 6.78975 9.70325 6.97433 9.27125 7.223C8.83909 7.47183 8.42684 7.79233 8.0345 8.1845L5.55 7.15L4.5655 8.85L6.725 10.4595C6.64167 10.6968 6.58334 10.9437 6.55 11.2C6.51667 11.4563 6.5 11.7262 6.5 12.0095C6.5 12.2698 6.51667 12.525 6.55 12.775C6.58334 13.025 6.6385 13.2718 6.7155 13.5155L4.5655 15.15L5.55 16.85L8.025 15.8C8.4045 16.1897 8.81025 16.5089 9.24225 16.7578C9.67442 17.0064 10.152 17.1974 10.675 17.3307L11 20ZM12.0115 15C12.8435 15 13.5515 14.708 14.1355 14.124C14.7195 13.54 15.0115 12.832 15.0115 12C15.0115 11.168 14.7195 10.46 14.1355 9.876C13.5515 9.292 12.8435 9 12.0115 9C11.1692 9 10.4586 9.292 9.87975 9.876C9.30092 10.46 9.0115 11.168 9.0115 12C9.0115 12.832 9.30092 13.54 9.87975 14.124C10.4586 14.708 11.1692 15 12.0115 15Z",
      fill: "currentColor"
    }
  )),
  delete_big: import_react8.default.createElement("svg", { width: "24", height: "24", viewBox: "0 0 24 24", fill: "none", xmlns: "http://www.w3.org/2000/svg" }, import_react8.default.createElement(
    "path",
    {
      d: "M7.30775 20.5C6.80908 20.5 6.38308 20.3234 6.02975 19.9702C5.67658 19.6169 5.5 19.1909 5.5 18.6922V5.99998H4.5V4.49998H9V3.61548H15V4.49998H19.5V5.99998H18.5V18.6922C18.5 19.1974 18.325 19.625 17.975 19.975C17.625 20.325 17.1974 20.5 16.6923 20.5H7.30775ZM17 5.99998H7V18.6922C7 18.7821 7.02883 18.8558 7.0865 18.9135C7.14417 18.9711 7.21792 19 7.30775 19H16.6923C16.7692 19 16.8398 18.9679 16.9038 18.9037C16.9679 18.8397 17 18.7692 17 18.6922V5.99998ZM9.404 17H10.9037V7.99998H9.404V17ZM13.0962 17H14.596V7.99998H13.0962V17Z",
      fill: "currentColor"
    }
  )),
  delete_small: import_react8.default.createElement("svg", { width: "24", height: "24", viewBox: "0 0 24 24", fill: "none", xmlns: "http://www.w3.org/2000/svg" }, import_react8.default.createElement(
    "path",
    {
      d: "M7.30775 20.5C6.80908 20.5 6.38308 20.3234 6.02975 19.9702C5.67658 19.6169 5.5 19.1909 5.5 18.6922V5.99998H4.5V4.49998H9V3.61548H15V4.49998H19.5V5.99998H18.5V18.6922C18.5 19.1974 18.325 19.625 17.975 19.975C17.625 20.325 17.1974 20.5 16.6923 20.5H7.30775ZM17 5.99998H7V18.6922C7 18.7821 7.02883 18.8558 7.0865 18.9135C7.14417 18.9711 7.21792 19 7.30775 19H16.6923C16.7692 19 16.8398 18.9679 16.9038 18.9037C16.9679 18.8397 17 18.7692 17 18.6922V5.99998ZM9.404 17H10.9037V7.99998H9.404V17ZM13.0962 17H14.596V7.99998H13.0962V17Z",
      fill: "currentColor"
    }
  )),
  format_align_center: import_react8.default.createElement("svg", { width: "24", height: "24", viewBox: "0 0 24 24", fill: "none", xmlns: "http://www.w3.org/2000/svg" }, import_react8.default.createElement(
    "path",
    {
      d: "M3.5 20.5V19H20.5V20.5H3.5ZM7.5 16.625V15.125H16.5V16.625H7.5ZM3.5 12.75V11.25H20.5V12.75H3.5ZM7.5 8.875V7.375H16.5V8.875H7.5ZM3.5 5V3.5H20.5V5H3.5Z",
      fill: "currentColor"
    }
  )),
  format_align_left: import_react8.default.createElement("svg", { width: "24", height: "24", viewBox: "0 0 24 24", fill: "none", xmlns: "http://www.w3.org/2000/svg" }, import_react8.default.createElement(
    "path",
    {
      d: "M3.5 20.5V19H20.5V20.5H3.5ZM3.5 16.625V15.125H14.5V16.625H3.5ZM3.5 12.75V11.25H20.5V12.75H3.5ZM3.5 8.875V7.375H14.5V8.875H3.5ZM3.5 5V3.5H20.5V5H3.5Z",
      fill: "currentColor"
    }
  )),
  format_align_right: import_react8.default.createElement("svg", { width: "24", height: "24", viewBox: "0 0 24 24", fill: "none", xmlns: "http://www.w3.org/2000/svg" }, import_react8.default.createElement(
    "path",
    {
      d: "M3.5 5V3.5H20.5V5H3.5ZM9.5 8.875V7.375H20.5V8.875H9.5ZM3.5 12.75V11.25H20.5V12.75H3.5ZM9.5 16.625V15.125H20.5V16.625H9.5ZM3.5 20.5V19H20.5V20.5H3.5Z",
      fill: "currentColor"
    }
  )),
  add_row: import_react8.default.createElement("svg", { width: "24", height: "24", viewBox: "0 0 24 24", fill: "none", xmlns: "http://www.w3.org/2000/svg" }, import_react8.default.createElement(
    "path",
    {
      fillRule: "evenodd",
      clipRule: "evenodd",
      d: "M4.025 10.2077C4.375 9.85775 4.80258 9.68275 5.30775 9.68275H6.5V11.1827H5.30775C5.21792 11.1827 5.14417 11.2116 5.0865 11.2693C5.02883 11.3269 5 11.4007 5 11.4905V16.1923C5 16.2821 5.02883 16.3558 5.0865 16.4135C5.14417 16.4712 5.21792 16.5 5.30775 16.5H18.6923C18.7821 16.5 18.8558 16.4712 18.9135 16.4135C18.9712 16.3558 19 16.2821 19 16.1923V11.4905C19 11.4007 18.9712 11.3269 18.9135 11.2693C18.8558 11.2116 18.7821 11.1827 18.6923 11.1827H17.6923V9.68275H18.6923C19.1974 9.68275 19.625 9.85775 19.975 10.2077C20.325 10.5577 20.5 10.9853 20.5 11.4905V16.1923C20.5 16.6974 20.325 17.125 19.975 17.475C19.625 17.825 19.1974 18 18.6923 18H5.30775C4.80258 18 4.375 17.825 4.025 17.475C3.675 17.125 3.5 16.6974 3.5 16.1923V11.4905C3.5 10.9853 3.675 10.5577 4.025 10.2077Z",
      fill: "currentColor"
    }
  ), import_react8.default.createElement(
    "path",
    {
      d: "M11.3848 9.68275V7.5H12.8848V9.68275H15V11.1827H12.8848V13.2307H11.3848V11.1827H9.26925V9.68275H11.3848Z",
      fill: "currentColor"
    }
  )),
  add_column: import_react8.default.createElement("svg", { width: "24", height: "24", viewBox: "0 0 24 24", fill: "none", xmlns: "http://www.w3.org/2000/svg" }, import_react8.default.createElement(
    "path",
    {
      fillRule: "evenodd",
      clipRule: "evenodd",
      d: "M9.70775 4.025C9.35775 4.375 9.18275 4.80258 9.18275 5.30775V6.5H10.6827V5.30775C10.6827 5.21792 10.7116 5.14417 10.7693 5.0865C10.8269 5.02883 10.9007 5 10.9905 5H15.6923C15.7821 5 15.8558 5.02883 15.9135 5.0865C15.9712 5.14417 16 5.21792 16 5.30775V18.6923C16 18.7821 15.9712 18.8558 15.9135 18.9135C15.8558 18.9712 15.7821 19 15.6923 19H10.9905C10.9007 19 10.8269 18.9712 10.7693 18.9135C10.7116 18.8558 10.6827 18.7821 10.6827 18.6923V17.6923H9.18275V18.6923C9.18275 19.1974 9.35775 19.625 9.70775 19.975C10.0577 20.325 10.4853 20.5 10.9905 20.5H15.6923C16.1974 20.5 16.625 20.325 16.975 19.975C17.325 19.625 17.5 19.1974 17.5 18.6923V5.30775C17.5 4.80258 17.325 4.375 16.975 4.025C16.625 3.675 16.1974 3.5 15.6923 3.5H10.9905C10.4853 3.5 10.0577 3.675 9.70775 4.025Z",
      fill: "currentColor"
    }
  ), import_react8.default.createElement(
    "path",
    {
      d: "M9.18275 11.3848H7V12.8848H9.18275V15H10.6827V12.8848H12.7307V11.3848H10.6827V9.26925H9.18275V11.3848Z",
      fill: "currentColor"
    }
  )),
  insert_col_left: import_react8.default.createElement("svg", { width: "24", height: "24", viewBox: "0 0 24 24", fill: "none", xmlns: "http://www.w3.org/2000/svg" }, import_react8.default.createElement(
    "path",
    {
      d: "M13.0001 20.1152H8.67713H8.75388H8.69238H13.0001ZM7.19238 19.8075C7.19238 20.3127 7.36738 20.7402 7.71738 21.0902C8.06738 21.4402 8.49497 21.6152 9.00013 21.6152H12.6924C13.1975 21.6152 13.6251 21.4402 13.9751 21.0902C14.3251 20.7402 14.5001 20.3127 14.5001 19.8075V10.423H13.0001V19.8075C13.0001 19.8973 12.9713 19.9711 12.9136 20.0287C12.856 20.0864 12.7822 20.1152 12.6924 20.1152H9.00013C8.9103 20.1152 8.83655 20.0864 8.77888 20.0287C8.72122 19.9711 8.69238 19.8973 8.69238 19.8075V4.69223C8.26422 4.74357 7.90722 4.93299 7.62138 5.26048C7.33538 5.58798 7.19238 5.97548 7.19238 6.42298V19.8075ZM13.0001 2.49998V4.61523H10.8846V6.11523H13.0001V8.23073H14.5001V6.11523H16.6154V4.61523H14.5001V2.49998H13.0001Z",
      fill: "currentColor"
    }
  )),
  insert_row_above: import_react8.default.createElement("svg", { width: "24", height: "24", viewBox: "0 0 24 24", fill: "none", xmlns: "http://www.w3.org/2000/svg" }, import_react8.default.createElement(
    "path",
    {
      d: "M20.1152 9.99987V14.3229V14.2461V14.3076V9.99987ZM19.8075 15.8076C20.3127 15.8076 20.7402 15.6326 21.0902 15.2826C21.4402 14.9326 21.6152 14.505 21.6152 13.9999V10.3076C21.6152 9.80245 21.4402 9.37487 21.0902 9.02487C20.7402 8.67487 20.3127 8.49987 19.8075 8.49987H10.423V9.99987H19.8075C19.8973 9.99987 19.9711 10.0287 20.0287 10.0864C20.0864 10.144 20.1152 10.2178 20.1152 10.3076V13.9999C20.1152 14.0897 20.0864 14.1635 20.0287 14.2211C19.9711 14.2788 19.8973 14.3076 19.8075 14.3076H4.69223C4.74357 14.7358 4.93299 15.0928 5.26048 15.3786C5.58798 15.6646 5.97548 15.8076 6.42298 15.8076H19.8075ZM2.49998 9.99987H4.61523V12.1154H6.11523V9.99987H8.23073V8.49987H6.11523V6.38462H4.61523V8.49987H2.49998V9.99987Z",
      fill: "currentColor"
    }
  )),
  insert_row_below: import_react8.default.createElement("svg", { width: "24", height: "24", viewBox: "0 0 24 24", fill: "none", xmlns: "http://www.w3.org/2000/svg" }, import_react8.default.createElement(
    "path",
    {
      d: "M20.1152 14.1924V9.86939V9.94614V9.88464V14.1924ZM19.8075 8.38464C20.3127 8.38464 20.7402 8.55964 21.0902 8.90964C21.4402 9.25964 21.6152 9.68723 21.6152 10.1924V13.8846C21.6152 14.3898 21.4402 14.8174 21.0902 15.1674C20.7402 15.5174 20.3127 15.6924 19.8075 15.6924H10.423V14.1924H19.8075C19.8973 14.1924 19.9711 14.1636 20.0287 14.1059C20.0864 14.0482 20.1152 13.9745 20.1152 13.8846V10.1924C20.1152 10.1026 20.0864 10.0288 20.0287 9.97114C19.9711 9.91348 19.8973 9.88464 19.8075 9.88464H4.69223C4.74357 9.45648 4.93299 9.09948 5.26048 8.81364C5.58798 8.52764 5.97548 8.38464 6.42298 8.38464H19.8075ZM2.49998 14.1924H4.61523V12.0769H6.11523V14.1924H8.23073V15.6924H6.11523V17.8076H4.61523V15.6924H2.49998V14.1924Z",
      fill: "currentColor"
    }
  )),
  insert_col_right: import_react8.default.createElement("svg", { width: "24", height: "24", viewBox: "0 0 24 24", fill: "none", xmlns: "http://www.w3.org/2000/svg" }, import_react8.default.createElement(
    "path",
    {
      d: "M10.8075 20.1152H15.1305H15.0537H15.1152H10.8075ZM16.6152 19.8075C16.6152 20.3127 16.4402 20.7402 16.0902 21.0902C15.7402 21.4402 15.3127 21.6152 14.8075 21.6152H11.1152C10.6101 21.6152 10.1825 21.4402 9.83248 21.0902C9.48248 20.7402 9.30748 20.3127 9.30748 19.8075V10.423H10.8075V19.8075C10.8075 19.8973 10.8363 19.9711 10.894 20.0287C10.9517 20.0864 11.0254 20.1152 11.1152 20.1152H14.8075C14.8973 20.1152 14.9711 20.0864 15.0287 20.0287C15.0864 19.9711 15.1152 19.8973 15.1152 19.8075V4.69223C15.5434 4.74357 15.9004 4.93299 16.1862 5.26048C16.4722 5.58798 16.6152 5.97548 16.6152 6.42298V19.8075ZM10.8075 2.49998V4.61523H12.923V6.11523H10.8075V8.23073H9.30748V6.11523H7.19223V4.61523H9.30748V2.49998H10.8075Z",
      fill: "currentColor"
    }
  )),
  check: import_react8.default.createElement("svg", { width: "24", height: "24", viewBox: "0 0 24 24", fill: "none", xmlns: "http://www.w3.org/2000/svg" }, import_react8.default.createElement(
    "path",
    {
      d: "M9.54983 17.6537L4.21533 12.3192L5.28433 11.25L9.54983 15.5155L18.7153 6.34998L19.7843 7.41923L9.54983 17.6537Z",
      fill: "currentColor"
    }
  ))
};

// node_modules/@mdxeditor/editor/dist/MDXEditor.js
var LexicalProvider = ({ children }) => {
  const rootEditor = E(rootEditor$);
  const composerContextValue = import_react9.default.useMemo(() => {
    return [rootEditor, createLexicalComposerContext(null, lexicalTheme)];
  }, [rootEditor]);
  return import_react9.default.createElement(LexicalComposerContext.Provider, { value: composerContextValue }, children);
};
var RichTextEditor = () => {
  const t3 = useTranslation();
  const setContentEditableRef = A(contentEditableRef$);
  const onRef = (_contentEditableRef) => {
    setContentEditableRef({ current: _contentEditableRef });
  };
  const [contentEditableClassName, spellCheck, composerChildren, topAreaChildren, editorWrappers, placeholder2] = X(
    contentEditableClassName$,
    spellCheck$,
    composerChildren$,
    topAreaChildren$,
    editorWrappers$,
    placeholder$
  );
  return import_react9.default.createElement(import_react9.default.Fragment, null, topAreaChildren.map((Child, index3) => import_react9.default.createElement(Child, { key: index3 })), import_react9.default.createElement(RenderRecursiveWrappers, { wrappers: editorWrappers }, import_react9.default.createElement("div", { className: (0, import_classnames.default)(styles.rootContentEditableWrapper, "mdxeditor-root-contenteditable") }, import_react9.default.createElement(
    RichTextPlugin,
    {
      contentEditable: import_react9.default.createElement("div", { ref: onRef }, import_react9.default.createElement(
        ContentEditable,
        {
          className: (0, import_classnames.default)(styles.contentEditable, contentEditableClassName),
          ariaLabel: t3("contentArea.editableMarkdown", "editable markdown"),
          spellCheck
        }
      )),
      placeholder: import_react9.default.createElement("div", { className: (0, import_classnames.default)(styles.contentEditable, styles.placeholder, contentEditableClassName) }, import_react9.default.createElement("p", null, placeholder2)),
      ErrorBoundary: LexicalErrorBoundary
    }
  ))), composerChildren.map((Child, index3) => import_react9.default.createElement(Child, { key: index3 })));
};
var DEFAULT_MARKDOWN_OPTIONS = {
  listItemIndent: "one"
};
var defaultIconComponentFor = (name2) => {
  return defaultSvgIcons[name2];
};
function defaultTranslation(key2, defaultValue, interpolations = {}) {
  let value2 = defaultValue;
  for (const [k3, v3] of Object.entries(interpolations)) {
    value2 = value2.replaceAll(`{{${k3}}}`, String(v3));
  }
  return value2;
}
var RenderRecursiveWrappers = ({ wrappers, children }) => {
  if (wrappers.length === 0) {
    return import_react9.default.createElement(import_react9.default.Fragment, null, children);
  }
  const Wrapper = wrappers[0];
  return import_react9.default.createElement(Wrapper, null, import_react9.default.createElement(RenderRecursiveWrappers, { wrappers: wrappers.slice(1) }, children));
};
var EditorRootElement = ({ children, className }) => {
  const editorRootElementRef = import_react9.default.useRef(null);
  const setEditorRootElementRef = A(editorRootElementRef$);
  import_react9.default.useEffect(() => {
    const popupContainer2 = document.createElement("div");
    popupContainer2.classList.add(
      "mdxeditor-popup-container",
      styles.editorRoot,
      styles.popupContainer,
      ...(className ?? "").trim().split(" ").filter(Boolean)
    );
    document.body.appendChild(popupContainer2);
    editorRootElementRef.current = popupContainer2;
    setEditorRootElementRef(editorRootElementRef);
    return () => {
      popupContainer2.remove();
    };
  }, [className, editorRootElementRef, setEditorRootElementRef]);
  return import_react9.default.createElement("div", { className: (0, import_classnames.default)("mdxeditor", styles.editorRoot, styles.editorWrapper, className) }, children);
};
var Methods = ({ mdxRef }) => {
  const realm = R();
  import_react9.default.useImperativeHandle(
    mdxRef,
    () => {
      return {
        getMarkdown: () => {
          if (realm.getValue(viewMode$) === "source") {
            return realm.getValue(markdownSourceEditorValue$);
          }
          return realm.getValue(markdown$);
        },
        setMarkdown: (markdown2) => {
          realm.pub(setMarkdown$, markdown2);
        },
        insertMarkdown: (markdown2) => {
          realm.pub(insertMarkdown$, markdown2);
        },
        focus: (callbackFn, opts) => {
          var _a2;
          (_a2 = realm.getValue(rootEditor$)) == null ? void 0 : _a2.focus(callbackFn, opts);
        }
      };
    },
    [realm]
  );
  return null;
};
var MDXEditor = import_react9.default.forwardRef((props, ref2) => {
  return import_react9.default.createElement(
    RealmWithPlugins,
    {
      plugins: [
        corePlugin({
          contentEditableClassName: props.contentEditableClassName ?? "",
          spellCheck: props.spellCheck ?? true,
          initialMarkdown: props.markdown,
          onChange: props.onChange ?? noop,
          onBlur: props.onBlur ?? noop,
          toMarkdownOptions: props.toMarkdownOptions ?? DEFAULT_MARKDOWN_OPTIONS,
          autoFocus: props.autoFocus ?? false,
          placeholder: props.placeholder ?? "",
          readOnly: Boolean(props.readOnly),
          iconComponentFor: props.iconComponentFor ?? defaultIconComponentFor,
          suppressHtmlProcessing: props.suppressHtmlProcessing ?? false,
          onError: props.onError ?? noop,
          translation: props.translation ?? defaultTranslation,
          trim: props.trim ?? true,
          lexicalTheme: props.lexicalTheme
        }),
        ...props.plugins ?? []
      ]
    },
    import_react9.default.createElement(EditorRootElement, { className: props.className }, import_react9.default.createElement(LexicalProvider, null, import_react9.default.createElement(RichTextEditor, null))),
    import_react9.default.createElement(Methods, { mdxRef: ref2 })
  );
});

// node_modules/@mdxeditor/editor/dist/utils/detectMac.js
var CAN_USE_DOM7 = typeof window !== "undefined" && typeof window.document.createElement !== "undefined";
var IS_APPLE2 = CAN_USE_DOM7 && /Mac|iPod|iPhone|iPad/.test(navigator.platform);
function controlOrMeta2(metaKey, ctrlKey) {
  if (IS_APPLE2) {
    return metaKey;
  }
  return ctrlKey;
}

// node_modules/@mdxeditor/editor/dist/plugins/headings/LexicalHeadingVisitor.js
var LexicalHeadingVisitor = {
  testLexicalNode: $isHeadingNode,
  visitLexicalNode: ({ lexicalNode, actions }) => {
    const depth2 = parseInt(lexicalNode.getTag()[1], 10);
    actions.addAndStepInto("heading", { depth: depth2 });
  }
};

// node_modules/@mdxeditor/editor/dist/plugins/headings/MdastHeadingVisitor.js
var MdastHeadingVisitor = {
  testNode: "heading",
  visitNode: function({ mdastNode, actions }) {
    actions.addAndStepInto($createHeadingNode(`h${mdastNode.depth}`));
  }
};

// node_modules/@mdxeditor/editor/dist/plugins/headings/index.js
var FORMATTING_KEYS = [48, 49, 50, 51, 52, 53, 54];
var ALL_HEADING_LEVELS = [1, 2, 3, 4, 5, 6];
var CODE_TO_HEADING_LEVEL_MAP = {
  49: 1,
  50: 2,
  51: 3,
  52: 4,
  53: 5,
  54: 6
};
var allowedHeadingLevels$ = $(ALL_HEADING_LEVELS, (r2) => {
  r2.pub(createRootEditorSubscription$, (theRootEditor) => {
    return theRootEditor.registerCommand(
      KEY_DOWN_COMMAND,
      (event) => {
        const { keyCode, ctrlKey, metaKey, altKey } = event;
        if (FORMATTING_KEYS.includes(keyCode) && controlOrMeta2(metaKey, ctrlKey) && altKey) {
          event.preventDefault();
          theRootEditor.update(() => {
            if (keyCode === 48) {
              r2.pub(convertSelectionToNode$, () => $createParagraphNode());
            } else {
              const allowedHeadingLevels = r2.getValue(allowedHeadingLevels$);
              const requestedHeadingLevel = CODE_TO_HEADING_LEVEL_MAP[keyCode];
              if (!allowedHeadingLevels.includes(requestedHeadingLevel)) {
                r2.pub(convertSelectionToNode$, () => $createHeadingNode(`h${requestedHeadingLevel}`));
              }
            }
          });
          return true;
        }
        return false;
      },
      COMMAND_PRIORITY_LOW
    );
  });
});
var headingsPlugin = realmPlugin({
  init(realm) {
    realm.pubIn({
      [addActivePlugin$]: "headings",
      [addImportVisitor$]: MdastHeadingVisitor,
      [addLexicalNode$]: HeadingNode,
      [addExportVisitor$]: LexicalHeadingVisitor
    });
  },
  update(realm, params) {
    realm.pub(allowedHeadingLevels$, (params == null ? void 0 : params.allowedHeadingLevels) ?? ALL_HEADING_LEVELS);
  }
});

// node_modules/@lexical/react/useLexicalNodeSelection.dev.mjs
var import_react10 = __toESM(require_react(), 1);
function isNodeSelected(editor, key2) {
  return editor.getEditorState().read(() => {
    const node2 = $getNodeByKey(key2);
    if (node2 === null) {
      return false;
    }
    return node2.isSelected();
  });
}
function useLexicalNodeSelection(key2) {
  const [editor] = useLexicalComposerContext();
  const [isSelected, setIsSelected] = (0, import_react10.useState)(() => isNodeSelected(editor, key2));
  (0, import_react10.useEffect)(() => {
    let isMounted = true;
    const unregister = editor.registerUpdateListener(() => {
      if (isMounted) {
        setIsSelected(isNodeSelected(editor, key2));
      }
    });
    return () => {
      isMounted = false;
      unregister();
    };
  }, [editor, key2]);
  const setSelected = (0, import_react10.useCallback)((selected) => {
    editor.update(() => {
      let selection2 = $getSelection();
      if (!$isNodeSelection(selection2)) {
        selection2 = $createNodeSelection();
        $setSelection(selection2);
      }
      if ($isNodeSelection(selection2)) {
        if (selected) {
          selection2.add(key2);
        } else {
          selection2.delete(key2);
        }
      }
    });
  }, [editor, key2]);
  const clearSelected = (0, import_react10.useCallback)(() => {
    editor.update(() => {
      const selection2 = $getSelection();
      if ($isNodeSelection(selection2)) {
        selection2.clear();
      }
    });
  }, [editor]);
  return [isSelected, setSelected, clearSelected];
}

// node_modules/@lexical/react/LexicalHorizontalRuleNode.dev.mjs
var import_react11 = __toESM(require_react(), 1);
var import_jsx_runtime5 = __toESM(require_jsx_runtime(), 1);
var INSERT_HORIZONTAL_RULE_COMMAND = createCommand("INSERT_HORIZONTAL_RULE_COMMAND");
function HorizontalRuleComponent({
  nodeKey
}) {
  const [editor] = useLexicalComposerContext();
  const [isSelected, setSelected, clearSelection] = useLexicalNodeSelection(nodeKey);
  const $onDelete = (0, import_react11.useCallback)((event) => {
    const deleteSelection = $getSelection();
    if (isSelected && $isNodeSelection(deleteSelection)) {
      event.preventDefault();
      editor.update(() => {
        deleteSelection.getNodes().forEach((node2) => {
          if ($isHorizontalRuleNode(node2)) {
            node2.remove();
          }
        });
      });
    }
    return false;
  }, [editor, isSelected]);
  (0, import_react11.useEffect)(() => {
    return mergeRegister(editor.registerCommand(CLICK_COMMAND, (event) => {
      const hrElem = editor.getElementByKey(nodeKey);
      if (event.target === hrElem) {
        if (!event.shiftKey) {
          clearSelection();
        }
        setSelected(!isSelected);
        return true;
      }
      return false;
    }, COMMAND_PRIORITY_LOW), editor.registerCommand(KEY_DELETE_COMMAND, $onDelete, COMMAND_PRIORITY_LOW), editor.registerCommand(KEY_BACKSPACE_COMMAND, $onDelete, COMMAND_PRIORITY_LOW));
  }, [clearSelection, editor, isSelected, nodeKey, $onDelete, setSelected]);
  (0, import_react11.useEffect)(() => {
    const hrElem = editor.getElementByKey(nodeKey);
    const isSelectedClassName = "selected";
    if (hrElem !== null) {
      if (isSelected) {
        addClassNamesToElement(hrElem, isSelectedClassName);
      } else {
        removeClassNamesFromElement(hrElem, isSelectedClassName);
      }
    }
  }, [editor, isSelected, nodeKey]);
  return null;
}
var HorizontalRuleNode = class _HorizontalRuleNode extends DecoratorNode {
  static getType() {
    return "horizontalrule";
  }
  static clone(node2) {
    return new _HorizontalRuleNode(node2.__key);
  }
  static importJSON(serializedNode) {
    return $createHorizontalRuleNode().updateFromJSON(serializedNode);
  }
  static importDOM() {
    return {
      hr: () => ({
        conversion: $convertHorizontalRuleElement,
        priority: 0
      })
    };
  }
  exportDOM() {
    return {
      element: document.createElement("hr")
    };
  }
  createDOM(config) {
    const element2 = document.createElement("hr");
    addClassNamesToElement(element2, config.theme.hr);
    return element2;
  }
  getTextContent() {
    return "\n";
  }
  isInline() {
    return false;
  }
  updateDOM() {
    return false;
  }
  decorate() {
    return (0, import_jsx_runtime5.jsx)(HorizontalRuleComponent, {
      nodeKey: this.__key
    });
  }
};
function $convertHorizontalRuleElement() {
  return {
    node: $createHorizontalRuleNode()
  };
}
function $createHorizontalRuleNode() {
  return $applyNodeReplacement(new HorizontalRuleNode());
}
function $isHorizontalRuleNode(node2) {
  return node2 instanceof HorizontalRuleNode;
}

// node_modules/@lexical/react/LexicalHorizontalRulePlugin.dev.mjs
var import_react12 = __toESM(require_react(), 1);
function HorizontalRulePlugin() {
  const [editor] = useLexicalComposerContext();
  (0, import_react12.useEffect)(() => {
    return editor.registerCommand(INSERT_HORIZONTAL_RULE_COMMAND, (type2) => {
      const selection2 = $getSelection();
      if (!$isRangeSelection(selection2)) {
        return false;
      }
      const focusNode = selection2.focus.getNode();
      if (focusNode !== null) {
        const horizontalRuleNode = $createHorizontalRuleNode();
        $insertNodeToNearestRoot(horizontalRuleNode);
      }
      return true;
    }, COMMAND_PRIORITY_EDITOR);
  }, [editor]);
  return null;
}

// node_modules/@mdxeditor/editor/dist/plugins/thematic-break/LexicalThematicBreakVisitor.js
var LexicalThematicBreakVisitor = {
  testLexicalNode: $isHorizontalRuleNode,
  visitLexicalNode({ actions }) {
    actions.addAndStepInto("thematicBreak");
  }
};

// node_modules/@mdxeditor/editor/dist/plugins/thematic-break/MdastThematicBreakVisitor.js
var MdastThematicBreakVisitor = {
  testNode: "thematicBreak",
  visitNode({ actions }) {
    actions.addAndStepInto($createHorizontalRuleNode());
  }
};

// node_modules/@mdxeditor/editor/dist/plugins/thematic-break/index.js
var insertThematicBreak$ = q((r2) => {
  r2.sub(r2.pipe(insertThematicBreak$, tt(activeEditor$)), ([, theEditor]) => {
    theEditor == null ? void 0 : theEditor.dispatchCommand(INSERT_HORIZONTAL_RULE_COMMAND, void 0);
  });
});
var thematicBreakPlugin = realmPlugin({
  init(realm) {
    realm.pubIn({
      [addImportVisitor$]: MdastThematicBreakVisitor,
      [addLexicalNode$]: HorizontalRuleNode,
      [addExportVisitor$]: LexicalThematicBreakVisitor,
      [addComposerChild$]: HorizontalRulePlugin
    });
  }
});

// node_modules/@lexical/list/LexicalList.dev.mjs
function $getListDepth(listNode) {
  let depth2 = 1;
  let parent = listNode.getParent();
  while (parent != null) {
    if ($isListItemNode(parent)) {
      const parentList = parent.getParent();
      if ($isListNode(parentList)) {
        depth2++;
        parent = parentList.getParent();
        continue;
      }
      {
        throw Error(`A ListItemNode must have a ListNode for a parent.`);
      }
    }
    return depth2;
  }
  return depth2;
}
function $getTopListNode(listItem2) {
  let list4 = listItem2.getParent();
  if (!$isListNode(list4)) {
    {
      throw Error(`A ListItemNode must have a ListNode for a parent.`);
    }
  }
  let parent = list4;
  while (parent !== null) {
    parent = parent.getParent();
    if ($isListNode(parent)) {
      list4 = parent;
    }
  }
  return list4;
}
function $getAllListItems(node2) {
  let listItemNodes = [];
  const listChildren = node2.getChildren().filter($isListItemNode);
  for (let i3 = 0; i3 < listChildren.length; i3++) {
    const listItemNode = listChildren[i3];
    const firstChild = listItemNode.getFirstChild();
    if ($isListNode(firstChild)) {
      listItemNodes = listItemNodes.concat($getAllListItems(firstChild));
    } else {
      listItemNodes.push(listItemNode);
    }
  }
  return listItemNodes;
}
function isNestedListNode(node2) {
  return $isListItemNode(node2) && $isListNode(node2.getFirstChild());
}
function $removeHighestEmptyListParent(sublist) {
  let emptyListPtr = sublist;
  while (emptyListPtr.getNextSibling() == null && emptyListPtr.getPreviousSibling() == null) {
    const parent = emptyListPtr.getParent();
    if (parent == null || !($isListItemNode(emptyListPtr) || $isListNode(emptyListPtr))) {
      break;
    }
    emptyListPtr = parent;
  }
  emptyListPtr.remove();
}
function $wrapInListItem(node2) {
  const listItemWrapper = $createListItemNode();
  return listItemWrapper.append(node2);
}
function $isSelectingEmptyListItem(anchorNode, nodes) {
  return $isListItemNode(anchorNode) && (nodes.length === 0 || nodes.length === 1 && anchorNode.is(nodes[0]) && anchorNode.getChildrenSize() === 0);
}
function insertList(editor, listType) {
  editor.update(() => {
    const selection2 = $getSelection();
    if (selection2 !== null) {
      const nodes = selection2.getNodes();
      if ($isRangeSelection(selection2)) {
        const anchorAndFocus = selection2.getStartEndPoints();
        if (!(anchorAndFocus !== null)) {
          throw Error(`insertList: anchor should be defined`);
        }
        const [anchor] = anchorAndFocus;
        const anchorNode = anchor.getNode();
        const anchorNodeParent = anchorNode.getParent();
        if ($isSelectingEmptyListItem(anchorNode, nodes)) {
          const list4 = $createListNode(listType);
          if ($isRootOrShadowRoot(anchorNodeParent)) {
            anchorNode.replace(list4);
            const listItem2 = $createListItemNode();
            if ($isElementNode(anchorNode)) {
              listItem2.setFormat(anchorNode.getFormatType());
              listItem2.setIndent(anchorNode.getIndent());
            }
            list4.append(listItem2);
          } else if ($isListItemNode(anchorNode)) {
            const parent = anchorNode.getParentOrThrow();
            append(list4, parent.getChildren());
            parent.replace(list4);
          }
          return;
        }
      }
      const handled = /* @__PURE__ */ new Set();
      for (let i3 = 0; i3 < nodes.length; i3++) {
        const node2 = nodes[i3];
        if ($isElementNode(node2) && node2.isEmpty() && !$isListItemNode(node2) && !handled.has(node2.getKey())) {
          $createListOrMerge(node2, listType);
          continue;
        }
        if ($isLeafNode(node2)) {
          let parent = node2.getParent();
          while (parent != null) {
            const parentKey = parent.getKey();
            if ($isListNode(parent)) {
              if (!handled.has(parentKey)) {
                const newListNode = $createListNode(listType);
                append(newListNode, parent.getChildren());
                parent.replace(newListNode);
                handled.add(parentKey);
              }
              break;
            } else {
              const nextParent = parent.getParent();
              if ($isRootOrShadowRoot(nextParent) && !handled.has(parentKey)) {
                handled.add(parentKey);
                $createListOrMerge(parent, listType);
                break;
              }
              parent = nextParent;
            }
          }
        }
      }
    }
  });
}
function append(node2, nodesToAppend) {
  node2.splice(node2.getChildrenSize(), 0, nodesToAppend);
}
function $createListOrMerge(node2, listType) {
  if ($isListNode(node2)) {
    return node2;
  }
  const previousSibling = node2.getPreviousSibling();
  const nextSibling = node2.getNextSibling();
  const listItem2 = $createListItemNode();
  append(listItem2, node2.getChildren());
  let targetList;
  if ($isListNode(previousSibling) && listType === previousSibling.getListType()) {
    previousSibling.append(listItem2);
    if ($isListNode(nextSibling) && listType === nextSibling.getListType()) {
      append(previousSibling, nextSibling.getChildren());
      nextSibling.remove();
    }
    targetList = previousSibling;
  } else if ($isListNode(nextSibling) && listType === nextSibling.getListType()) {
    nextSibling.getFirstChildOrThrow().insertBefore(listItem2);
    targetList = nextSibling;
  } else {
    const list4 = $createListNode(listType);
    list4.append(listItem2);
    node2.replace(list4);
    targetList = list4;
  }
  listItem2.setFormat(node2.getFormatType());
  listItem2.setIndent(node2.getIndent());
  node2.remove();
  return targetList;
}
function mergeLists(list1, list22) {
  const listItem1 = list1.getLastChild();
  const listItem2 = list22.getFirstChild();
  if (listItem1 && listItem2 && isNestedListNode(listItem1) && isNestedListNode(listItem2)) {
    mergeLists(listItem1.getFirstChild(), listItem2.getFirstChild());
    listItem2.remove();
  }
  const toMerge = list22.getChildren();
  if (toMerge.length > 0) {
    list1.append(...toMerge);
  }
  list22.remove();
}
function removeList(editor) {
  editor.update(() => {
    const selection2 = $getSelection();
    if ($isRangeSelection(selection2)) {
      const listNodes = /* @__PURE__ */ new Set();
      const nodes = selection2.getNodes();
      const anchorNode = selection2.anchor.getNode();
      if ($isSelectingEmptyListItem(anchorNode, nodes)) {
        listNodes.add($getTopListNode(anchorNode));
      } else {
        for (let i3 = 0; i3 < nodes.length; i3++) {
          const node2 = nodes[i3];
          if ($isLeafNode(node2)) {
            const listItemNode = $getNearestNodeOfType(node2, ListItemNode);
            if (listItemNode != null) {
              listNodes.add($getTopListNode(listItemNode));
            }
          }
        }
      }
      for (const listNode of listNodes) {
        let insertionPoint = listNode;
        const listItems = $getAllListItems(listNode);
        for (const listItemNode of listItems) {
          const paragraph2 = $createParagraphNode();
          append(paragraph2, listItemNode.getChildren());
          insertionPoint.insertAfter(paragraph2);
          insertionPoint = paragraph2;
          if (listItemNode.__key === selection2.anchor.key) {
            selection2.anchor.set(paragraph2.getKey(), 0, "element");
          }
          if (listItemNode.__key === selection2.focus.key) {
            selection2.focus.set(paragraph2.getKey(), 0, "element");
          }
          listItemNode.remove();
        }
        listNode.remove();
      }
    }
  });
}
function updateChildrenListItemValue(list4) {
  const isNotChecklist = list4.getListType() !== "check";
  let value2 = list4.getStart();
  for (const child of list4.getChildren()) {
    if ($isListItemNode(child)) {
      if (child.getValue() !== value2) {
        child.setValue(value2);
      }
      if (isNotChecklist && child.getLatest().__checked != null) {
        child.setChecked(void 0);
      }
      if (!$isListNode(child.getFirstChild())) {
        value2++;
      }
    }
  }
}
function mergeNextSiblingListIfSameType(list4) {
  const nextSibling = list4.getNextSibling();
  if ($isListNode(nextSibling) && list4.getListType() === nextSibling.getListType()) {
    mergeLists(list4, nextSibling);
  }
}
function $handleIndent(listItemNode) {
  const removed = /* @__PURE__ */ new Set();
  if (isNestedListNode(listItemNode) || removed.has(listItemNode.getKey())) {
    return;
  }
  const parent = listItemNode.getParent();
  const nextSibling = listItemNode.getNextSibling();
  const previousSibling = listItemNode.getPreviousSibling();
  if (isNestedListNode(nextSibling) && isNestedListNode(previousSibling)) {
    const innerList = previousSibling.getFirstChild();
    if ($isListNode(innerList)) {
      innerList.append(listItemNode);
      const nextInnerList = nextSibling.getFirstChild();
      if ($isListNode(nextInnerList)) {
        const children = nextInnerList.getChildren();
        append(innerList, children);
        nextSibling.remove();
        removed.add(nextSibling.getKey());
      }
    }
  } else if (isNestedListNode(nextSibling)) {
    const innerList = nextSibling.getFirstChild();
    if ($isListNode(innerList)) {
      const firstChild = innerList.getFirstChild();
      if (firstChild !== null) {
        firstChild.insertBefore(listItemNode);
      }
    }
  } else if (isNestedListNode(previousSibling)) {
    const innerList = previousSibling.getFirstChild();
    if ($isListNode(innerList)) {
      innerList.append(listItemNode);
    }
  } else {
    if ($isListNode(parent)) {
      const newListItem = $createListItemNode();
      const newList = $createListNode(parent.getListType());
      newListItem.append(newList);
      newList.append(listItemNode);
      if (previousSibling) {
        previousSibling.insertAfter(newListItem);
      } else if (nextSibling) {
        nextSibling.insertBefore(newListItem);
      } else {
        parent.append(newListItem);
      }
    }
  }
}
function $handleOutdent(listItemNode) {
  if (isNestedListNode(listItemNode)) {
    return;
  }
  const parentList = listItemNode.getParent();
  const grandparentListItem = parentList ? parentList.getParent() : void 0;
  const greatGrandparentList = grandparentListItem ? grandparentListItem.getParent() : void 0;
  if ($isListNode(greatGrandparentList) && $isListItemNode(grandparentListItem) && $isListNode(parentList)) {
    const firstChild = parentList ? parentList.getFirstChild() : void 0;
    const lastChild = parentList ? parentList.getLastChild() : void 0;
    if (listItemNode.is(firstChild)) {
      grandparentListItem.insertBefore(listItemNode);
      if (parentList.isEmpty()) {
        grandparentListItem.remove();
      }
    } else if (listItemNode.is(lastChild)) {
      grandparentListItem.insertAfter(listItemNode);
      if (parentList.isEmpty()) {
        grandparentListItem.remove();
      }
    } else {
      const listType = parentList.getListType();
      const previousSiblingsListItem = $createListItemNode();
      const previousSiblingsList = $createListNode(listType);
      previousSiblingsListItem.append(previousSiblingsList);
      listItemNode.getPreviousSiblings().forEach((sibling2) => previousSiblingsList.append(sibling2));
      const nextSiblingsListItem = $createListItemNode();
      const nextSiblingsList = $createListNode(listType);
      nextSiblingsListItem.append(nextSiblingsList);
      append(nextSiblingsList, listItemNode.getNextSiblings());
      grandparentListItem.insertBefore(previousSiblingsListItem);
      grandparentListItem.insertAfter(nextSiblingsListItem);
      grandparentListItem.replace(listItemNode);
    }
  }
}
function $handleListInsertParagraph() {
  const selection2 = $getSelection();
  if (!$isRangeSelection(selection2) || !selection2.isCollapsed()) {
    return false;
  }
  const anchor = selection2.anchor.getNode();
  if (!$isListItemNode(anchor) || anchor.getChildrenSize() !== 0) {
    return false;
  }
  const topListNode = $getTopListNode(anchor);
  const parent = anchor.getParent();
  if (!$isListNode(parent)) {
    throw Error(`A ListItemNode must have a ListNode for a parent.`);
  }
  const grandparent = parent.getParent();
  let replacementNode;
  if ($isRootOrShadowRoot(grandparent)) {
    replacementNode = $createParagraphNode();
    replacementNode.setTextStyle(selection2.style);
    replacementNode.setTextFormat(selection2.format);
    topListNode.insertAfter(replacementNode);
  } else if ($isListItemNode(grandparent)) {
    replacementNode = $createListItemNode();
    grandparent.insertAfter(replacementNode);
  } else {
    return false;
  }
  replacementNode.select();
  const nextSiblings = anchor.getNextSiblings();
  if (nextSiblings.length > 0) {
    const newList = $createListNode(parent.getListType());
    if ($isListItemNode(replacementNode)) {
      const newListItem = $createListItemNode();
      newListItem.append(newList);
      replacementNode.insertAfter(newListItem);
    } else {
      replacementNode.insertAfter(newList);
    }
    newList.append(...nextSiblings);
  }
  $removeHighestEmptyListParent(anchor);
  return true;
}
function normalizeClassNames3(...classNames14) {
  const rval = [];
  for (const className of classNames14) {
    if (className && typeof className === "string") {
      for (const [s2] of className.matchAll(/\S+/g)) {
        rval.push(s2);
      }
    }
  }
  return rval;
}
var ListItemNode = class _ListItemNode extends ElementNode {
  /** @internal */
  /** @internal */
  static getType() {
    return "listitem";
  }
  static clone(node2) {
    return new _ListItemNode(node2.__value, node2.__checked, node2.__key);
  }
  constructor(value2, checked, key2) {
    super(key2);
    this.__value = value2 === void 0 ? 1 : value2;
    this.__checked = checked;
  }
  createDOM(config) {
    const element2 = document.createElement("li");
    const parent = this.getParent();
    if ($isListNode(parent) && parent.getListType() === "check") {
      updateListItemChecked(element2, this, null);
    }
    element2.value = this.__value;
    $setListItemThemeClassNames(element2, config.theme, this);
    return element2;
  }
  updateDOM(prevNode, dom, config) {
    const parent = this.getParent();
    if ($isListNode(parent) && parent.getListType() === "check") {
      updateListItemChecked(dom, this, prevNode);
    }
    dom.value = this.__value;
    $setListItemThemeClassNames(dom, config.theme, this);
    return false;
  }
  static transform() {
    return (node2) => {
      if (!$isListItemNode(node2)) {
        throw Error(`node is not a ListItemNode`);
      }
      if (node2.__checked == null) {
        return;
      }
      const parent = node2.getParent();
      if ($isListNode(parent)) {
        if (parent.getListType() !== "check" && node2.getChecked() != null) {
          node2.setChecked(void 0);
        }
      }
    };
  }
  static importDOM() {
    return {
      li: () => ({
        conversion: $convertListItemElement,
        priority: 0
      })
    };
  }
  static importJSON(serializedNode) {
    return $createListItemNode().updateFromJSON(serializedNode);
  }
  updateFromJSON(serializedNode) {
    return super.updateFromJSON(serializedNode).setValue(serializedNode.value).setChecked(serializedNode.checked);
  }
  exportDOM(editor) {
    const element2 = this.createDOM(editor._config);
    element2.style.textAlign = this.getFormatType();
    return {
      element: element2
    };
  }
  exportJSON() {
    return {
      ...super.exportJSON(),
      checked: this.getChecked(),
      value: this.getValue()
    };
  }
  append(...nodes) {
    for (let i3 = 0; i3 < nodes.length; i3++) {
      const node2 = nodes[i3];
      if ($isElementNode(node2) && this.canMergeWith(node2)) {
        const children = node2.getChildren();
        this.append(...children);
        node2.remove();
      } else {
        super.append(node2);
      }
    }
    return this;
  }
  replace(replaceWithNode, includeChildren) {
    if ($isListItemNode(replaceWithNode)) {
      return super.replace(replaceWithNode);
    }
    this.setIndent(0);
    const list4 = this.getParentOrThrow();
    if (!$isListNode(list4)) {
      return replaceWithNode;
    }
    if (list4.__first === this.getKey()) {
      list4.insertBefore(replaceWithNode);
    } else if (list4.__last === this.getKey()) {
      list4.insertAfter(replaceWithNode);
    } else {
      const newList = $createListNode(list4.getListType());
      let nextSibling = this.getNextSibling();
      while (nextSibling) {
        const nodeToAppend = nextSibling;
        nextSibling = nextSibling.getNextSibling();
        newList.append(nodeToAppend);
      }
      list4.insertAfter(replaceWithNode);
      replaceWithNode.insertAfter(newList);
    }
    if (includeChildren) {
      if (!$isElementNode(replaceWithNode)) {
        throw Error(`includeChildren should only be true for ElementNodes`);
      }
      this.getChildren().forEach((child) => {
        replaceWithNode.append(child);
      });
    }
    this.remove();
    if (list4.getChildrenSize() === 0) {
      list4.remove();
    }
    return replaceWithNode;
  }
  insertAfter(node2, restoreSelection = true) {
    const listNode = this.getParentOrThrow();
    if (!$isListNode(listNode)) {
      {
        throw Error(`insertAfter: list node is not parent of list item node`);
      }
    }
    if ($isListItemNode(node2)) {
      return super.insertAfter(node2, restoreSelection);
    }
    const siblings = this.getNextSiblings();
    listNode.insertAfter(node2, restoreSelection);
    if (siblings.length !== 0) {
      const newListNode = $createListNode(listNode.getListType());
      siblings.forEach((sibling2) => newListNode.append(sibling2));
      node2.insertAfter(newListNode, restoreSelection);
    }
    return node2;
  }
  remove(preserveEmptyParent) {
    const prevSibling = this.getPreviousSibling();
    const nextSibling = this.getNextSibling();
    super.remove(preserveEmptyParent);
    if (prevSibling && nextSibling && isNestedListNode(prevSibling) && isNestedListNode(nextSibling)) {
      mergeLists(prevSibling.getFirstChild(), nextSibling.getFirstChild());
      nextSibling.remove();
    }
  }
  insertNewAfter(_2, restoreSelection = true) {
    const newElement = $createListItemNode().updateFromJSON(this.exportJSON()).setChecked(this.getChecked() ? false : void 0);
    this.insertAfter(newElement, restoreSelection);
    return newElement;
  }
  collapseAtStart(selection2) {
    const paragraph2 = $createParagraphNode();
    const children = this.getChildren();
    children.forEach((child) => paragraph2.append(child));
    const listNode = this.getParentOrThrow();
    const listNodeParent = listNode.getParentOrThrow();
    const isIndented = $isListItemNode(listNodeParent);
    if (listNode.getChildrenSize() === 1) {
      if (isIndented) {
        listNode.remove();
        listNodeParent.select();
      } else {
        listNode.insertBefore(paragraph2);
        listNode.remove();
        const anchor = selection2.anchor;
        const focus2 = selection2.focus;
        const key2 = paragraph2.getKey();
        if (anchor.type === "element" && anchor.getNode().is(this)) {
          anchor.set(key2, anchor.offset, "element");
        }
        if (focus2.type === "element" && focus2.getNode().is(this)) {
          focus2.set(key2, focus2.offset, "element");
        }
      }
    } else {
      listNode.insertBefore(paragraph2);
      this.remove();
    }
    return true;
  }
  getValue() {
    const self2 = this.getLatest();
    return self2.__value;
  }
  setValue(value2) {
    const self2 = this.getWritable();
    self2.__value = value2;
    return self2;
  }
  getChecked() {
    const self2 = this.getLatest();
    let listType;
    const parent = this.getParent();
    if ($isListNode(parent)) {
      listType = parent.getListType();
    }
    return listType === "check" ? Boolean(self2.__checked) : void 0;
  }
  setChecked(checked) {
    const self2 = this.getWritable();
    self2.__checked = checked;
    return self2;
  }
  toggleChecked() {
    const self2 = this.getWritable();
    return self2.setChecked(!self2.__checked);
  }
  getIndent() {
    const parent = this.getParent();
    if (parent === null) {
      return this.getLatest().__indent;
    }
    let listNodeParent = parent.getParentOrThrow();
    let indentLevel = 0;
    while ($isListItemNode(listNodeParent)) {
      listNodeParent = listNodeParent.getParentOrThrow().getParentOrThrow();
      indentLevel++;
    }
    return indentLevel;
  }
  setIndent(indent2) {
    if (!(typeof indent2 === "number")) {
      throw Error(`Invalid indent value.`);
    }
    indent2 = Math.floor(indent2);
    if (!(indent2 >= 0)) {
      throw Error(`Indent value must be non-negative.`);
    }
    let currentIndent = this.getIndent();
    while (currentIndent !== indent2) {
      if (currentIndent < indent2) {
        $handleIndent(this);
        currentIndent++;
      } else {
        $handleOutdent(this);
        currentIndent--;
      }
    }
    return this;
  }
  /** @deprecated @internal */
  canInsertAfter(node2) {
    return $isListItemNode(node2);
  }
  /** @deprecated @internal */
  canReplaceWith(replacement) {
    return $isListItemNode(replacement);
  }
  canMergeWith(node2) {
    return $isListItemNode(node2) || $isParagraphNode(node2);
  }
  extractWithChild(child, selection2) {
    if (!$isRangeSelection(selection2)) {
      return false;
    }
    const anchorNode = selection2.anchor.getNode();
    const focusNode = selection2.focus.getNode();
    return this.isParentOf(anchorNode) && this.isParentOf(focusNode) && this.getTextContent().length === selection2.getTextContent().length;
  }
  isParentRequired() {
    return true;
  }
  createParentElementNode() {
    return $createListNode("bullet");
  }
  canMergeWhenEmpty() {
    return true;
  }
};
function $setListItemThemeClassNames(dom, editorThemeClasses, node2) {
  const classesToAdd = [];
  const classesToRemove = [];
  const listTheme = editorThemeClasses.list;
  const listItemClassName = listTheme ? listTheme.listitem : void 0;
  let nestedListItemClassName;
  if (listTheme && listTheme.nested) {
    nestedListItemClassName = listTheme.nested.listitem;
  }
  if (listItemClassName !== void 0) {
    classesToAdd.push(...normalizeClassNames3(listItemClassName));
  }
  if (listTheme) {
    const parentNode = node2.getParent();
    const isCheckList = $isListNode(parentNode) && parentNode.getListType() === "check";
    const checked = node2.getChecked();
    if (!isCheckList || checked) {
      classesToRemove.push(listTheme.listitemUnchecked);
    }
    if (!isCheckList || !checked) {
      classesToRemove.push(listTheme.listitemChecked);
    }
    if (isCheckList) {
      classesToAdd.push(checked ? listTheme.listitemChecked : listTheme.listitemUnchecked);
    }
  }
  if (nestedListItemClassName !== void 0) {
    const nestedListItemClasses = normalizeClassNames3(nestedListItemClassName);
    if (node2.getChildren().some((child) => $isListNode(child))) {
      classesToAdd.push(...nestedListItemClasses);
    } else {
      classesToRemove.push(...nestedListItemClasses);
    }
  }
  if (classesToRemove.length > 0) {
    removeClassNamesFromElement(dom, ...classesToRemove);
  }
  if (classesToAdd.length > 0) {
    addClassNamesToElement(dom, ...classesToAdd);
  }
}
function updateListItemChecked(dom, listItemNode, prevListItemNode, listNode) {
  if ($isListNode(listItemNode.getFirstChild())) {
    dom.removeAttribute("role");
    dom.removeAttribute("tabIndex");
    dom.removeAttribute("aria-checked");
  } else {
    dom.setAttribute("role", "checkbox");
    dom.setAttribute("tabIndex", "-1");
    if (!prevListItemNode || listItemNode.__checked !== prevListItemNode.__checked) {
      dom.setAttribute("aria-checked", listItemNode.getChecked() ? "true" : "false");
    }
  }
}
function $convertListItemElement(domNode) {
  const isGitHubCheckList = domNode.classList.contains("task-list-item");
  if (isGitHubCheckList) {
    for (const child of domNode.children) {
      if (child.tagName === "INPUT") {
        return $convertCheckboxInput(child);
      }
    }
  }
  const ariaCheckedAttr = domNode.getAttribute("aria-checked");
  const checked = ariaCheckedAttr === "true" ? true : ariaCheckedAttr === "false" ? false : void 0;
  return {
    node: $createListItemNode(checked)
  };
}
function $convertCheckboxInput(domNode) {
  const isCheckboxInput = domNode.getAttribute("type") === "checkbox";
  if (!isCheckboxInput) {
    return {
      node: null
    };
  }
  const checked = domNode.hasAttribute("checked");
  return {
    node: $createListItemNode(checked)
  };
}
function $createListItemNode(checked) {
  return $applyNodeReplacement(new ListItemNode(void 0, checked));
}
function $isListItemNode(node2) {
  return node2 instanceof ListItemNode;
}
var ListNode = class _ListNode extends ElementNode {
  /** @internal */
  /** @internal */
  /** @internal */
  static getType() {
    return "list";
  }
  static clone(node2) {
    const listType = node2.__listType || TAG_TO_LIST_TYPE[node2.__tag];
    return new _ListNode(listType, node2.__start, node2.__key);
  }
  constructor(listType = "number", start2 = 1, key2) {
    super(key2);
    const _listType = TAG_TO_LIST_TYPE[listType] || listType;
    this.__listType = _listType;
    this.__tag = _listType === "number" ? "ol" : "ul";
    this.__start = start2;
  }
  getTag() {
    return this.__tag;
  }
  setListType(type2) {
    const writable = this.getWritable();
    writable.__listType = type2;
    writable.__tag = type2 === "number" ? "ol" : "ul";
    return writable;
  }
  getListType() {
    return this.__listType;
  }
  getStart() {
    return this.__start;
  }
  setStart(start2) {
    const self2 = this.getWritable();
    self2.__start = start2;
    return self2;
  }
  // View
  createDOM(config, _editor) {
    const tag = this.__tag;
    const dom = document.createElement(tag);
    if (this.__start !== 1) {
      dom.setAttribute("start", String(this.__start));
    }
    dom.__lexicalListType = this.__listType;
    $setListThemeClassNames(dom, config.theme, this);
    return dom;
  }
  updateDOM(prevNode, dom, config) {
    if (prevNode.__tag !== this.__tag) {
      return true;
    }
    $setListThemeClassNames(dom, config.theme, this);
    return false;
  }
  static transform() {
    return (node2) => {
      if (!$isListNode(node2)) {
        throw Error(`node is not a ListNode`);
      }
      mergeNextSiblingListIfSameType(node2);
      updateChildrenListItemValue(node2);
    };
  }
  static importDOM() {
    return {
      ol: () => ({
        conversion: $convertListNode,
        priority: 0
      }),
      ul: () => ({
        conversion: $convertListNode,
        priority: 0
      })
    };
  }
  static importJSON(serializedNode) {
    return $createListNode().updateFromJSON(serializedNode);
  }
  updateFromJSON(serializedNode) {
    return super.updateFromJSON(serializedNode).setListType(serializedNode.listType).setStart(serializedNode.start);
  }
  exportDOM(editor) {
    const element2 = this.createDOM(editor._config, editor);
    if (isHTMLElement(element2)) {
      if (this.__start !== 1) {
        element2.setAttribute("start", String(this.__start));
      }
      if (this.__listType === "check") {
        element2.setAttribute("__lexicalListType", "check");
      }
    }
    return {
      element: element2
    };
  }
  exportJSON() {
    return {
      ...super.exportJSON(),
      listType: this.getListType(),
      start: this.getStart(),
      tag: this.getTag()
    };
  }
  canBeEmpty() {
    return false;
  }
  canIndent() {
    return false;
  }
  append(...nodesToAppend) {
    for (let i3 = 0; i3 < nodesToAppend.length; i3++) {
      const currentNode = nodesToAppend[i3];
      if ($isListItemNode(currentNode)) {
        super.append(currentNode);
      } else {
        const listItemNode = $createListItemNode();
        if ($isListNode(currentNode)) {
          listItemNode.append(currentNode);
        } else if ($isElementNode(currentNode)) {
          if (currentNode.isInline()) {
            listItemNode.append(currentNode);
          } else {
            const textNode = $createTextNode(currentNode.getTextContent());
            listItemNode.append(textNode);
          }
        } else {
          listItemNode.append(currentNode);
        }
        super.append(listItemNode);
      }
    }
    return this;
  }
  extractWithChild(child) {
    return $isListItemNode(child);
  }
};
function $setListThemeClassNames(dom, editorThemeClasses, node2) {
  const classesToAdd = [];
  const classesToRemove = [];
  const listTheme = editorThemeClasses.list;
  if (listTheme !== void 0) {
    const listLevelsClassNames = listTheme[`${node2.__tag}Depth`] || [];
    const listDepth = $getListDepth(node2) - 1;
    const normalizedListDepth = listDepth % listLevelsClassNames.length;
    const listLevelClassName = listLevelsClassNames[normalizedListDepth];
    const listClassName = listTheme[node2.__tag];
    let nestedListClassName;
    const nestedListTheme = listTheme.nested;
    const checklistClassName = listTheme.checklist;
    if (nestedListTheme !== void 0 && nestedListTheme.list) {
      nestedListClassName = nestedListTheme.list;
    }
    if (listClassName !== void 0) {
      classesToAdd.push(listClassName);
    }
    if (checklistClassName !== void 0 && node2.__listType === "check") {
      classesToAdd.push(checklistClassName);
    }
    if (listLevelClassName !== void 0) {
      classesToAdd.push(...normalizeClassNames3(listLevelClassName));
      for (let i3 = 0; i3 < listLevelsClassNames.length; i3++) {
        if (i3 !== normalizedListDepth) {
          classesToRemove.push(node2.__tag + i3);
        }
      }
    }
    if (nestedListClassName !== void 0) {
      const nestedListItemClasses = normalizeClassNames3(nestedListClassName);
      if (listDepth > 1) {
        classesToAdd.push(...nestedListItemClasses);
      } else {
        classesToRemove.push(...nestedListItemClasses);
      }
    }
  }
  if (classesToRemove.length > 0) {
    removeClassNamesFromElement(dom, ...classesToRemove);
  }
  if (classesToAdd.length > 0) {
    addClassNamesToElement(dom, ...classesToAdd);
  }
}
function $normalizeChildren(nodes) {
  const normalizedListItems = [];
  for (let i3 = 0; i3 < nodes.length; i3++) {
    const node2 = nodes[i3];
    if ($isListItemNode(node2)) {
      normalizedListItems.push(node2);
      const children = node2.getChildren();
      if (children.length > 1) {
        children.forEach((child) => {
          if ($isListNode(child)) {
            normalizedListItems.push($wrapInListItem(child));
          }
        });
      }
    } else {
      normalizedListItems.push($wrapInListItem(node2));
    }
  }
  return normalizedListItems;
}
function isDomChecklist(domNode) {
  if (domNode.getAttribute("__lexicallisttype") === "check" || // is github checklist
  domNode.classList.contains("contains-task-list")) {
    return true;
  }
  for (const child of domNode.childNodes) {
    if (isHTMLElement(child) && child.hasAttribute("aria-checked")) {
      return true;
    }
  }
  return false;
}
function $convertListNode(domNode) {
  const nodeName = domNode.nodeName.toLowerCase();
  let node2 = null;
  if (nodeName === "ol") {
    const start2 = domNode.start;
    node2 = $createListNode("number", start2);
  } else if (nodeName === "ul") {
    if (isDomChecklist(domNode)) {
      node2 = $createListNode("check");
    } else {
      node2 = $createListNode("bullet");
    }
  }
  return {
    after: $normalizeChildren,
    node: node2
  };
}
var TAG_TO_LIST_TYPE = {
  ol: "number",
  ul: "bullet"
};
function $createListNode(listType = "number", start2 = 1) {
  return $applyNodeReplacement(new ListNode(listType, start2));
}
function $isListNode(node2) {
  return node2 instanceof ListNode;
}
var INSERT_UNORDERED_LIST_COMMAND = createCommand("INSERT_UNORDERED_LIST_COMMAND");
var INSERT_ORDERED_LIST_COMMAND = createCommand("INSERT_ORDERED_LIST_COMMAND");
var INSERT_CHECK_LIST_COMMAND = createCommand("INSERT_CHECK_LIST_COMMAND");
var REMOVE_LIST_COMMAND = createCommand("REMOVE_LIST_COMMAND");
function registerList(editor) {
  const removeListener = mergeRegister(editor.registerCommand(INSERT_ORDERED_LIST_COMMAND, () => {
    insertList(editor, "number");
    return true;
  }, COMMAND_PRIORITY_LOW), editor.registerCommand(INSERT_UNORDERED_LIST_COMMAND, () => {
    insertList(editor, "bullet");
    return true;
  }, COMMAND_PRIORITY_LOW), editor.registerCommand(REMOVE_LIST_COMMAND, () => {
    removeList(editor);
    return true;
  }, COMMAND_PRIORITY_LOW), editor.registerCommand(INSERT_PARAGRAPH_COMMAND, () => {
    const hasHandledInsertParagraph = $handleListInsertParagraph();
    if (hasHandledInsertParagraph) {
      return true;
    }
    return false;
  }, COMMAND_PRIORITY_LOW));
  return removeListener;
}

// node_modules/@mdxeditor/editor/dist/plugins/lists/MdastListVisitor.js
var MdastListVisitor = {
  testNode: "list",
  visitNode: function({ mdastNode, lexicalParent, actions }) {
    const listType = mdastNode.children.some((e2) => typeof e2.checked === "boolean") ? "check" : mdastNode.ordered ? "number" : "bullet";
    const lexicalNode = $createListNode(listType);
    if ($isListItemNode(lexicalParent)) {
      const dedicatedParent = $createListItemNode();
      dedicatedParent.append(lexicalNode);
      lexicalParent.insertAfter(dedicatedParent);
    } else {
      lexicalParent.append(lexicalNode);
    }
    actions.visitChildren(mdastNode, lexicalNode);
  }
};

// node_modules/@mdxeditor/editor/dist/plugins/lists/MdastListItemVisitor.js
var MdastListItemVisitor = {
  testNode: "listItem",
  visitNode({ mdastNode, actions, lexicalParent }) {
    const isChecked = lexicalParent.getListType() === "check" ? mdastNode.checked ?? false : void 0;
    actions.addAndStepInto($createListItemNode(isChecked));
  }
};

// node_modules/@mdxeditor/editor/dist/plugins/lists/LexicalListVisitor.js
var LexicalListVisitor = {
  testLexicalNode: $isListNode,
  visitLexicalNode: ({ lexicalNode, actions }) => {
    actions.addAndStepInto("list", {
      ordered: lexicalNode.getListType() === "number",
      spread: false
    });
  }
};

// node_modules/@mdxeditor/editor/dist/plugins/lists/LexicalListItemVisitor.js
var LexicalListItemVisitor = {
  testLexicalNode: $isListItemNode,
  visitLexicalNode: ({ lexicalNode, mdastParent, actions }) => {
    const children = lexicalNode.getChildren();
    const firstChild = children[0];
    if (children.length === 1 && $isListNode(firstChild)) {
      const prevListItemNode = mdastParent.children.at(-1);
      if (!prevListItemNode) {
        actions.visitChildren(firstChild, mdastParent);
      } else {
        actions.visitChildren(lexicalNode, prevListItemNode);
      }
    } else {
      const parentList = lexicalNode.getParent();
      const listItem2 = actions.appendToParent(mdastParent, {
        type: "listItem",
        checked: parentList.getListType() === "check" ? Boolean(lexicalNode.getChecked()) : void 0,
        spread: false,
        children: []
      });
      let surroundingParagraph = null;
      for (const child of lexicalNode.getChildren()) {
        if ($isTextNode(child)) {
          if (!surroundingParagraph) {
            surroundingParagraph = actions.appendToParent(listItem2, {
              type: "paragraph",
              children: []
            });
          }
          actions.visit(child, surroundingParagraph);
        } else {
          surroundingParagraph = null;
          actions.visit(child, listItem2);
        }
      }
    }
  }
};

// node_modules/@lexical/react/LexicalTabIndentationPlugin.dev.mjs
var import_react13 = __toESM(require_react(), 1);
function $indentOverTab(selection2) {
  const nodes = selection2.getNodes();
  const canIndentBlockNodes = $filter(nodes, (node2) => {
    if ($isBlockElementNode(node2) && node2.canIndent()) {
      return node2;
    }
    return null;
  });
  if (canIndentBlockNodes.length > 0) {
    return true;
  }
  const anchor = selection2.anchor;
  const focus2 = selection2.focus;
  const first = focus2.isBefore(anchor) ? focus2 : anchor;
  const firstNode = first.getNode();
  const firstBlock = $getNearestBlockElementAncestorOrThrow(firstNode);
  if (firstBlock.canIndent()) {
    const firstBlockKey = firstBlock.getKey();
    let selectionAtStart = $createRangeSelection();
    selectionAtStart.anchor.set(firstBlockKey, 0, "element");
    selectionAtStart.focus.set(firstBlockKey, 0, "element");
    selectionAtStart = $normalizeSelection(selectionAtStart);
    if (selectionAtStart.anchor.is(first)) {
      return true;
    }
  }
  return false;
}
function registerTabIndentation(editor, maxIndent) {
  return mergeRegister(editor.registerCommand(KEY_TAB_COMMAND, (event) => {
    const selection2 = $getSelection();
    if (!$isRangeSelection(selection2)) {
      return false;
    }
    event.preventDefault();
    const command2 = $indentOverTab(selection2) ? event.shiftKey ? OUTDENT_CONTENT_COMMAND : INDENT_CONTENT_COMMAND : INSERT_TAB_COMMAND;
    return editor.dispatchCommand(command2, void 0);
  }, COMMAND_PRIORITY_EDITOR), editor.registerCommand(INDENT_CONTENT_COMMAND, () => {
    if (maxIndent == null) {
      return false;
    }
    const selection2 = $getSelection();
    if (!$isRangeSelection(selection2)) {
      return false;
    }
    const indents = selection2.getNodes().map((node2) => $getNearestBlockElementAncestorOrThrow(node2).getIndent());
    return Math.max(...indents) + 1 >= maxIndent;
  }, COMMAND_PRIORITY_CRITICAL));
}
function TabIndentationPlugin({
  maxIndent
}) {
  const [editor] = useLexicalComposerContext();
  (0, import_react13.useEffect)(() => {
    return registerTabIndentation(editor, maxIndent);
  }, [editor, maxIndent]);
  return null;
}

// node_modules/@lexical/react/LexicalCheckListPlugin.dev.mjs
var import_react14 = __toESM(require_react(), 1);
function CheckListPlugin() {
  const [editor] = useLexicalComposerContext();
  (0, import_react14.useEffect)(() => {
    return mergeRegister(editor.registerCommand(INSERT_CHECK_LIST_COMMAND, () => {
      insertList(editor, "check");
      return true;
    }, COMMAND_PRIORITY_LOW), editor.registerCommand(KEY_ARROW_DOWN_COMMAND, (event) => {
      return handleArrownUpOrDown(event, editor, false);
    }, COMMAND_PRIORITY_LOW), editor.registerCommand(KEY_ARROW_UP_COMMAND, (event) => {
      return handleArrownUpOrDown(event, editor, true);
    }, COMMAND_PRIORITY_LOW), editor.registerCommand(KEY_ESCAPE_COMMAND, (event) => {
      const activeItem = getActiveCheckListItem();
      if (activeItem != null) {
        const rootElement = editor.getRootElement();
        if (rootElement != null) {
          rootElement.focus();
        }
        return true;
      }
      return false;
    }, COMMAND_PRIORITY_LOW), editor.registerCommand(KEY_SPACE_COMMAND, (event) => {
      const activeItem = getActiveCheckListItem();
      if (activeItem != null && editor.isEditable()) {
        editor.update(() => {
          const listItemNode = $getNearestNodeFromDOMNode(activeItem);
          if ($isListItemNode(listItemNode)) {
            event.preventDefault();
            listItemNode.toggleChecked();
          }
        });
        return true;
      }
      return false;
    }, COMMAND_PRIORITY_LOW), editor.registerCommand(KEY_ARROW_LEFT_COMMAND, (event) => {
      return editor.getEditorState().read(() => {
        const selection2 = $getSelection();
        if ($isRangeSelection(selection2) && selection2.isCollapsed()) {
          const {
            anchor
          } = selection2;
          const isElement2 = anchor.type === "element";
          if (isElement2 || anchor.offset === 0) {
            const anchorNode = anchor.getNode();
            const elementNode = $findMatchingParent(anchorNode, (node2) => $isElementNode(node2) && !node2.isInline());
            if ($isListItemNode(elementNode)) {
              const parent = elementNode.getParent();
              if ($isListNode(parent) && parent.getListType() === "check" && (isElement2 || elementNode.getFirstDescendant() === anchorNode)) {
                const domNode = editor.getElementByKey(elementNode.__key);
                if (domNode != null && document.activeElement !== domNode) {
                  domNode.focus();
                  event.preventDefault();
                  return true;
                }
              }
            }
          }
        }
        return false;
      });
    }, COMMAND_PRIORITY_LOW), editor.registerRootListener((rootElement, prevElement) => {
      if (rootElement !== null) {
        rootElement.addEventListener("click", handleClick);
        rootElement.addEventListener("pointerdown", handlePointerDown);
      }
      if (prevElement !== null) {
        prevElement.removeEventListener("click", handleClick);
        prevElement.removeEventListener("pointerdown", handlePointerDown);
      }
    }));
  });
  return null;
}
function handleCheckItemEvent(event, callback) {
  const target = event.target;
  if (!isHTMLElement(target)) {
    return;
  }
  const firstChild = target.firstChild;
  if (isHTMLElement(firstChild) && (firstChild.tagName === "UL" || firstChild.tagName === "OL")) {
    return;
  }
  const parentNode = target.parentNode;
  if (!parentNode || parentNode.__lexicalListType !== "check") {
    return;
  }
  const rect = target.getBoundingClientRect();
  const pageX = event.pageX / calculateZoomLevel(target);
  if (target.dir === "rtl" ? pageX < rect.right && pageX > rect.right - 20 : pageX > rect.left && pageX < rect.left + 20) {
    callback();
  }
}
function handleClick(event) {
  handleCheckItemEvent(event, () => {
    if (isHTMLElement(event.target)) {
      const domNode = event.target;
      const editor = getNearestEditorFromDOMNode(domNode);
      if (editor != null && editor.isEditable()) {
        editor.update(() => {
          const node2 = $getNearestNodeFromDOMNode(domNode);
          if ($isListItemNode(node2)) {
            domNode.focus();
            node2.toggleChecked();
          }
        });
      }
    }
  });
}
function handlePointerDown(event) {
  handleCheckItemEvent(event, () => {
    event.preventDefault();
  });
}
function getActiveCheckListItem() {
  const activeElement = document.activeElement;
  return isHTMLElement(activeElement) && activeElement.tagName === "LI" && activeElement.parentNode != null && // @ts-ignore internal field
  activeElement.parentNode.__lexicalListType === "check" ? activeElement : null;
}
function findCheckListItemSibling(node2, backward) {
  let sibling2 = backward ? node2.getPreviousSibling() : node2.getNextSibling();
  let parent = node2;
  while (sibling2 == null && $isListItemNode(parent)) {
    parent = parent.getParentOrThrow().getParent();
    if (parent != null) {
      sibling2 = backward ? parent.getPreviousSibling() : parent.getNextSibling();
    }
  }
  while ($isListItemNode(sibling2)) {
    const firstChild = backward ? sibling2.getLastChild() : sibling2.getFirstChild();
    if (!$isListNode(firstChild)) {
      return sibling2;
    }
    sibling2 = backward ? firstChild.getLastChild() : firstChild.getFirstChild();
  }
  return null;
}
function handleArrownUpOrDown(event, editor, backward) {
  const activeItem = getActiveCheckListItem();
  if (activeItem != null) {
    editor.update(() => {
      const listItem2 = $getNearestNodeFromDOMNode(activeItem);
      if (!$isListItemNode(listItem2)) {
        return;
      }
      const nextListItem = findCheckListItemSibling(listItem2, backward);
      if (nextListItem != null) {
        nextListItem.selectStart();
        const dom = editor.getElementByKey(nextListItem.__key);
        if (dom != null) {
          event.preventDefault();
          setTimeout(() => {
            dom.focus();
          }, 0);
        }
      }
    });
  }
  return false;
}

// node_modules/@lexical/react/LexicalListPlugin.dev.mjs
var import_react15 = __toESM(require_react(), 1);
function useList(editor) {
  (0, import_react15.useEffect)(() => {
    return registerList(editor);
  }, [editor]);
}
function ListPlugin() {
  const [editor] = useLexicalComposerContext();
  (0, import_react15.useEffect)(() => {
    if (!editor.hasNodes([ListNode, ListItemNode])) {
      throw new Error("ListPlugin: ListNode and/or ListItemNode not registered on editor");
    }
  }, [editor]);
  useList(editor);
  return null;
}

// node_modules/micromark-extension-gfm-task-list-item/dev/lib/syntax.js
var tasklistCheck = { name: "tasklistCheck", tokenize: tokenizeTasklistCheck };
function gfmTaskListItem() {
  return {
    text: { [codes.leftSquareBracket]: tasklistCheck }
  };
}
function tokenizeTasklistCheck(effects, ok3, nok) {
  const self2 = this;
  return open;
  function open(code3) {
    ok(code3 === codes.leftSquareBracket, "expected `[`");
    if (
      // Exit if there’s stuff before.
      self2.previous !== codes.eof || // Exit if not in the first content that is the first child of a list
      // item.
      !self2._gfmTasklistFirstContentOfListItem
    ) {
      return nok(code3);
    }
    effects.enter("taskListCheck");
    effects.enter("taskListCheckMarker");
    effects.consume(code3);
    effects.exit("taskListCheckMarker");
    return inside;
  }
  function inside(code3) {
    if (markdownLineEndingOrSpace(code3)) {
      effects.enter("taskListCheckValueUnchecked");
      effects.consume(code3);
      effects.exit("taskListCheckValueUnchecked");
      return close2;
    }
    if (code3 === codes.uppercaseX || code3 === codes.lowercaseX) {
      effects.enter("taskListCheckValueChecked");
      effects.consume(code3);
      effects.exit("taskListCheckValueChecked");
      return close2;
    }
    return nok(code3);
  }
  function close2(code3) {
    if (code3 === codes.rightSquareBracket) {
      effects.enter("taskListCheckMarker");
      effects.consume(code3);
      effects.exit("taskListCheckMarker");
      effects.exit("taskListCheck");
      return after;
    }
    return nok(code3);
  }
  function after(code3) {
    if (markdownLineEnding(code3)) {
      return ok3(code3);
    }
    if (markdownSpace(code3)) {
      return effects.check({ tokenize: spaceThenNonSpace }, ok3, nok)(code3);
    }
    return nok(code3);
  }
}
function spaceThenNonSpace(effects, ok3, nok) {
  return factorySpace(effects, after, types.whitespace);
  function after(code3) {
    return code3 === codes.eof ? nok(code3) : ok3(code3);
  }
}

// node_modules/mdast-util-gfm-task-list-item/lib/index.js
function gfmTaskListItemFromMarkdown() {
  return {
    exit: {
      taskListCheckValueChecked: exitCheck,
      taskListCheckValueUnchecked: exitCheck,
      paragraph: exitParagraphWithTaskListItem
    }
  };
}
function gfmTaskListItemToMarkdown() {
  return {
    unsafe: [{ atBreak: true, character: "-", after: "[:|-]" }],
    handlers: { listItem: listItemWithTaskListItem }
  };
}
function exitCheck(token) {
  const node2 = this.stack[this.stack.length - 2];
  ok(node2.type === "listItem");
  node2.checked = token.type === "taskListCheckValueChecked";
}
function exitParagraphWithTaskListItem(token) {
  const parent = this.stack[this.stack.length - 2];
  if (parent && parent.type === "listItem" && typeof parent.checked === "boolean") {
    const node2 = this.stack[this.stack.length - 1];
    ok(node2.type === "paragraph");
    const head = node2.children[0];
    if (head && head.type === "text") {
      const siblings = parent.children;
      let index3 = -1;
      let firstParaghraph;
      while (++index3 < siblings.length) {
        const sibling2 = siblings[index3];
        if (sibling2.type === "paragraph") {
          firstParaghraph = sibling2;
          break;
        }
      }
      if (firstParaghraph === node2) {
        head.value = head.value.slice(1);
        if (head.value.length === 0) {
          node2.children.shift();
        } else if (node2.position && head.position && typeof head.position.start.offset === "number") {
          head.position.start.column++;
          head.position.start.offset++;
          node2.position.start = Object.assign({}, head.position.start);
        }
      }
    }
  }
  this.exit(token);
}
function listItemWithTaskListItem(node2, parent, state, info) {
  const head = node2.children[0];
  const checkable = typeof node2.checked === "boolean" && head && head.type === "paragraph";
  const checkbox = "[" + (node2.checked ? "x" : " ") + "] ";
  const tracker = state.createTracker(info);
  if (checkable) {
    tracker.move(checkbox);
  }
  let value2 = handle.listItem(node2, parent, state, {
    ...info,
    ...tracker.current()
  });
  if (checkable) {
    value2 = value2.replace(/^(?:[*+-]|\d+\.)([\r\n]| {1,3})/, check);
  }
  return value2;
  function check($0) {
    return $0 + checkbox;
  }
}

// node_modules/@mdxeditor/editor/dist/plugins/lists/index.js
var ListTypeCommandMap = /* @__PURE__ */ new Map([
  ["number", INSERT_ORDERED_LIST_COMMAND],
  ["bullet", INSERT_UNORDERED_LIST_COMMAND],
  ["check", INSERT_CHECK_LIST_COMMAND],
  ["", REMOVE_LIST_COMMAND]
]);
var currentListType$ = $("", (r2) => {
  r2.sub(r2.pipe(currentSelection$, tt(activeEditor$)), ([selection2, theEditor]) => {
    if (!selection2 || !theEditor) {
      return;
    }
    const anchorNode = selection2.anchor.getNode();
    let element2 = anchorNode.getKey() === "root" ? anchorNode : $findMatchingParent(anchorNode, (e2) => {
      const parent = e2.getParent();
      return parent !== null && $isRootOrShadowRoot(parent);
    });
    if (element2 === null) {
      element2 = anchorNode.getTopLevelElementOrThrow();
    }
    const elementKey = element2.getKey();
    const elementDOM = theEditor.getElementByKey(elementKey);
    if (elementDOM !== null) {
      if ($isListNode(element2)) {
        const parentList = $getNearestNodeOfType(anchorNode, ListNode);
        const type2 = parentList ? parentList.getListType() : element2.getListType();
        r2.pub(currentListType$, type2);
      } else {
        r2.pub(currentListType$, "");
      }
    }
  });
});
var applyListType$ = K((r2) => {
  r2.sub(r2.pipe(applyListType$, tt(activeEditor$)), ([listType, theEditor]) => {
    theEditor == null ? void 0 : theEditor.dispatchCommand(ListTypeCommandMap.get(listType), void 0);
  });
});
var listsPlugin = realmPlugin({
  init(realm) {
    var _a2;
    (_a2 = realm.getValue(rootEditor$)) == null ? void 0 : _a2.registerCommand(INDENT_CONTENT_COMMAND, () => !isIndentPermitted(7), COMMAND_PRIORITY_CRITICAL);
    realm.pubIn({
      [addActivePlugin$]: "lists",
      [addMdastExtension$]: gfmTaskListItemFromMarkdown(),
      [addSyntaxExtension$]: gfmTaskListItem(),
      [addImportVisitor$]: [MdastListVisitor, MdastListItemVisitor],
      [addLexicalNode$]: [ListItemNode, ListNode],
      [addExportVisitor$]: [LexicalListVisitor, LexicalListItemVisitor],
      [addToMarkdownExtension$]: gfmTaskListItemToMarkdown(),
      [addComposerChild$]: [TabIndentationPlugin, ListPlugin, CheckListPlugin],
      [addNestedEditorChild$]: [TabIndentationPlugin, ListPlugin, CheckListPlugin]
    });
  }
});
function getElementNodesInSelection(selection2) {
  const nodesInSelection = selection2.getNodes();
  if (nodesInSelection.length === 0) {
    return /* @__PURE__ */ new Set([selection2.anchor.getNode().getParentOrThrow(), selection2.focus.getNode().getParentOrThrow()]);
  }
  return new Set(nodesInSelection.map((n3) => $isElementNode(n3) ? n3 : n3.getParentOrThrow()));
}
function isIndentPermitted(maxDepth) {
  const selection2 = $getSelection();
  if (!$isRangeSelection(selection2)) {
    return false;
  }
  const elementNodesInSelection = getElementNodesInSelection(selection2);
  let totalDepth = 0;
  for (const elementNode of elementNodesInSelection) {
    if ($isListNode(elementNode)) {
      totalDepth = Math.max($getListDepth(elementNode) + 1, totalDepth);
    } else if ($isListItemNode(elementNode)) {
      const parent = elementNode.getParent();
      if ((parent == null ? void 0 : parent.getChildren().length) === 1) {
        const grandParentListItem = parent.getParent();
        if ($isListItemNode(grandParentListItem) && grandParentListItem.getChildren().length === 1) {
          return false;
        }
      }
      if (!$isListNode(parent)) {
        throw new Error("ListMaxIndentLevelPlugin: A ListItemNode must have a ListNode for a parent.");
      }
      totalDepth = Math.max($getListDepth(parent) + 1, totalDepth);
    }
  }
  return totalDepth <= maxDepth;
}

// node_modules/markdown-table/index.js
function defaultStringLength(value2) {
  return value2.length;
}
function markdownTable(table, options) {
  const settings = options || {};
  const align = (settings.align || []).concat();
  const stringLength = settings.stringLength || defaultStringLength;
  const alignments2 = [];
  const cellMatrix = [];
  const sizeMatrix = [];
  const longestCellByColumn = [];
  let mostCellsPerRow = 0;
  let rowIndex = -1;
  while (++rowIndex < table.length) {
    const row2 = [];
    const sizes2 = [];
    let columnIndex2 = -1;
    if (table[rowIndex].length > mostCellsPerRow) {
      mostCellsPerRow = table[rowIndex].length;
    }
    while (++columnIndex2 < table[rowIndex].length) {
      const cell = serialize(table[rowIndex][columnIndex2]);
      if (settings.alignDelimiters !== false) {
        const size4 = stringLength(cell);
        sizes2[columnIndex2] = size4;
        if (longestCellByColumn[columnIndex2] === void 0 || size4 > longestCellByColumn[columnIndex2]) {
          longestCellByColumn[columnIndex2] = size4;
        }
      }
      row2.push(cell);
    }
    cellMatrix[rowIndex] = row2;
    sizeMatrix[rowIndex] = sizes2;
  }
  let columnIndex = -1;
  if (typeof align === "object" && "length" in align) {
    while (++columnIndex < mostCellsPerRow) {
      alignments2[columnIndex] = toAlignment(align[columnIndex]);
    }
  } else {
    const code3 = toAlignment(align);
    while (++columnIndex < mostCellsPerRow) {
      alignments2[columnIndex] = code3;
    }
  }
  columnIndex = -1;
  const row = [];
  const sizes = [];
  while (++columnIndex < mostCellsPerRow) {
    const code3 = alignments2[columnIndex];
    let before = "";
    let after = "";
    if (code3 === 99) {
      before = ":";
      after = ":";
    } else if (code3 === 108) {
      before = ":";
    } else if (code3 === 114) {
      after = ":";
    }
    let size4 = settings.alignDelimiters === false ? 1 : Math.max(
      1,
      longestCellByColumn[columnIndex] - before.length - after.length
    );
    const cell = before + "-".repeat(size4) + after;
    if (settings.alignDelimiters !== false) {
      size4 = before.length + size4 + after.length;
      if (size4 > longestCellByColumn[columnIndex]) {
        longestCellByColumn[columnIndex] = size4;
      }
      sizes[columnIndex] = size4;
    }
    row[columnIndex] = cell;
  }
  cellMatrix.splice(1, 0, row);
  sizeMatrix.splice(1, 0, sizes);
  rowIndex = -1;
  const lines = [];
  while (++rowIndex < cellMatrix.length) {
    const row2 = cellMatrix[rowIndex];
    const sizes2 = sizeMatrix[rowIndex];
    columnIndex = -1;
    const line = [];
    while (++columnIndex < mostCellsPerRow) {
      const cell = row2[columnIndex] || "";
      let before = "";
      let after = "";
      if (settings.alignDelimiters !== false) {
        const size4 = longestCellByColumn[columnIndex] - (sizes2[columnIndex] || 0);
        const code3 = alignments2[columnIndex];
        if (code3 === 114) {
          before = " ".repeat(size4);
        } else if (code3 === 99) {
          if (size4 % 2) {
            before = " ".repeat(size4 / 2 + 0.5);
            after = " ".repeat(size4 / 2 - 0.5);
          } else {
            before = " ".repeat(size4 / 2);
            after = before;
          }
        } else {
          after = " ".repeat(size4);
        }
      }
      if (settings.delimiterStart !== false && !columnIndex) {
        line.push("|");
      }
      if (settings.padding !== false && // Don’t add the opening space if we’re not aligning and the cell is
      // empty: there will be a closing space.
      !(settings.alignDelimiters === false && cell === "") && (settings.delimiterStart !== false || columnIndex)) {
        line.push(" ");
      }
      if (settings.alignDelimiters !== false) {
        line.push(before);
      }
      line.push(cell);
      if (settings.alignDelimiters !== false) {
        line.push(after);
      }
      if (settings.padding !== false) {
        line.push(" ");
      }
      if (settings.delimiterEnd !== false || columnIndex !== mostCellsPerRow - 1) {
        line.push("|");
      }
    }
    lines.push(
      settings.delimiterEnd === false ? line.join("").replace(/ +$/, "") : line.join("")
    );
  }
  return lines.join("\n");
}
function serialize(value2) {
  return value2 === null || value2 === void 0 ? "" : String(value2);
}
function toAlignment(value2) {
  const code3 = typeof value2 === "string" ? value2.codePointAt(0) : 0;
  return code3 === 67 || code3 === 99 ? 99 : code3 === 76 || code3 === 108 ? 108 : code3 === 82 || code3 === 114 ? 114 : 0;
}

// node_modules/mdast-util-gfm-table/lib/index.js
function gfmTableFromMarkdown() {
  return {
    enter: {
      table: enterTable,
      tableData: enterCell,
      tableHeader: enterCell,
      tableRow: enterRow
    },
    exit: {
      codeText: exitCodeText,
      table: exitTable,
      tableData: exit2,
      tableHeader: exit2,
      tableRow: exit2
    }
  };
}
function enterTable(token) {
  const align = token._align;
  ok(align, "expected `_align` on table");
  this.enter(
    {
      type: "table",
      align: align.map(function(d3) {
        return d3 === "none" ? null : d3;
      }),
      children: []
    },
    token
  );
  this.data.inTable = true;
}
function exitTable(token) {
  this.exit(token);
  this.data.inTable = void 0;
}
function enterRow(token) {
  this.enter({ type: "tableRow", children: [] }, token);
}
function exit2(token) {
  this.exit(token);
}
function enterCell(token) {
  this.enter({ type: "tableCell", children: [] }, token);
}
function exitCodeText(token) {
  let value2 = this.resume();
  if (this.data.inTable) {
    value2 = value2.replace(/\\([\\|])/g, replace);
  }
  const node2 = this.stack[this.stack.length - 1];
  ok(node2.type === "inlineCode");
  node2.value = value2;
  this.exit(token);
}
function replace($0, $1) {
  return $1 === "|" ? $1 : $0;
}
function gfmTableToMarkdown(options) {
  const settings = options || {};
  const padding = settings.tableCellPadding;
  const alignDelimiters = settings.tablePipeAlign;
  const stringLength = settings.stringLength;
  const around = padding ? " " : "|";
  return {
    unsafe: [
      { character: "\r", inConstruct: "tableCell" },
      { character: "\n", inConstruct: "tableCell" },
      // A pipe, when followed by a tab or space (padding), or a dash or colon
      // (unpadded delimiter row), could result in a table.
      { atBreak: true, character: "|", after: "[	 :-]" },
      // A pipe in a cell must be encoded.
      { character: "|", inConstruct: "tableCell" },
      // A colon must be followed by a dash, in which case it could start a
      // delimiter row.
      { atBreak: true, character: ":", after: "-" },
      // A delimiter row can also start with a dash, when followed by more
      // dashes, a colon, or a pipe.
      // This is a stricter version than the built in check for lists, thematic
      // breaks, and setex heading underlines though:
      // <https://github.com/syntax-tree/mdast-util-to-markdown/blob/51a2038/lib/unsafe.js#L57>
      { atBreak: true, character: "-", after: "[:|-]" }
    ],
    handlers: {
      inlineCode: inlineCodeWithTable,
      table: handleTable,
      tableCell: handleTableCell,
      tableRow: handleTableRow
    }
  };
  function handleTable(node2, _2, state, info) {
    return serializeData(handleTableAsData(node2, state, info), node2.align);
  }
  function handleTableRow(node2, _2, state, info) {
    const row = handleTableRowAsData(node2, state, info);
    const value2 = serializeData([row]);
    return value2.slice(0, value2.indexOf("\n"));
  }
  function handleTableCell(node2, _2, state, info) {
    const exit4 = state.enter("tableCell");
    const subexit = state.enter("phrasing");
    const value2 = state.containerPhrasing(node2, {
      ...info,
      before: around,
      after: around
    });
    subexit();
    exit4();
    return value2;
  }
  function serializeData(matrix, align) {
    return markdownTable(matrix, {
      align,
      // @ts-expect-error: `markdown-table` types should support `null`.
      alignDelimiters,
      // @ts-expect-error: `markdown-table` types should support `null`.
      padding,
      // @ts-expect-error: `markdown-table` types should support `null`.
      stringLength
    });
  }
  function handleTableAsData(node2, state, info) {
    const children = node2.children;
    let index3 = -1;
    const result = [];
    const subexit = state.enter("table");
    while (++index3 < children.length) {
      result[index3] = handleTableRowAsData(children[index3], state, info);
    }
    subexit();
    return result;
  }
  function handleTableRowAsData(node2, state, info) {
    const children = node2.children;
    let index3 = -1;
    const result = [];
    const subexit = state.enter("tableRow");
    while (++index3 < children.length) {
      result[index3] = handleTableCell(children[index3], node2, state, info);
    }
    subexit();
    return result;
  }
  function inlineCodeWithTable(node2, parent, state) {
    let value2 = handle.inlineCode(node2, parent, state);
    if (state.stack.includes("tableCell")) {
      value2 = value2.replace(/\|/g, "\\$&");
    }
    return value2;
  }
}

// node_modules/micromark-extension-gfm-table/dev/lib/edit-map.js
var EditMap = class {
  /**
   * Create a new edit map.
   */
  constructor() {
    this.map = [];
  }
  /**
   * Create an edit: a remove and/or add at a certain place.
   *
   * @param {number} index
   * @param {number} remove
   * @param {Array<Event>} add
   * @returns {undefined}
   */
  add(index3, remove, add2) {
    addImplementation(this, index3, remove, add2);
  }
  // To do: add this when moving to `micromark`.
  // /**
  //  * Create an edit: but insert `add` before existing additions.
  //  *
  //  * @param {number} index
  //  * @param {number} remove
  //  * @param {Array<Event>} add
  //  * @returns {undefined}
  //  */
  // addBefore(index, remove, add) {
  //   addImplementation(this, index, remove, add, true)
  // }
  /**
   * Done, change the events.
   *
   * @param {Array<Event>} events
   * @returns {undefined}
   */
  consume(events) {
    this.map.sort(function(a2, b3) {
      return a2[0] - b3[0];
    });
    if (this.map.length === 0) {
      return;
    }
    let index3 = this.map.length;
    const vecs = [];
    while (index3 > 0) {
      index3 -= 1;
      vecs.push(
        events.slice(this.map[index3][0] + this.map[index3][1]),
        this.map[index3][2]
      );
      events.length = this.map[index3][0];
    }
    vecs.push(events.slice());
    events.length = 0;
    let slice = vecs.pop();
    while (slice) {
      for (const element2 of slice) {
        events.push(element2);
      }
      slice = vecs.pop();
    }
    this.map.length = 0;
  }
};
function addImplementation(editMap, at3, remove, add2) {
  let index3 = 0;
  if (remove === 0 && add2.length === 0) {
    return;
  }
  while (index3 < editMap.map.length) {
    if (editMap.map[index3][0] === at3) {
      editMap.map[index3][1] += remove;
      editMap.map[index3][2].push(...add2);
      return;
    }
    index3 += 1;
  }
  editMap.map.push([at3, remove, add2]);
}

// node_modules/micromark-extension-gfm-table/dev/lib/infer.js
function gfmTableAlign(events, index3) {
  ok(events[index3][1].type === "table", "expected table");
  let inDelimiterRow = false;
  const align = [];
  while (index3 < events.length) {
    const event = events[index3];
    if (inDelimiterRow) {
      if (event[0] === "enter") {
        if (event[1].type === "tableContent") {
          align.push(
            events[index3 + 1][1].type === "tableDelimiterMarker" ? "left" : "none"
          );
        }
      } else if (event[1].type === "tableContent") {
        if (events[index3 - 1][1].type === "tableDelimiterMarker") {
          const alignIndex = align.length - 1;
          align[alignIndex] = align[alignIndex] === "left" ? "center" : "right";
        }
      } else if (event[1].type === "tableDelimiterRow") {
        break;
      }
    } else if (event[0] === "enter" && event[1].type === "tableDelimiterRow") {
      inDelimiterRow = true;
    }
    index3 += 1;
  }
  return align;
}

// node_modules/micromark-extension-gfm-table/dev/lib/syntax.js
function gfmTable() {
  return {
    flow: {
      null: { name: "table", tokenize: tokenizeTable, resolveAll: resolveTable }
    }
  };
}
function tokenizeTable(effects, ok3, nok) {
  const self2 = this;
  let size4 = 0;
  let sizeB = 0;
  let seen;
  return start2;
  function start2(code3) {
    let index3 = self2.events.length - 1;
    while (index3 > -1) {
      const type2 = self2.events[index3][1].type;
      if (type2 === types.lineEnding || // Note: markdown-rs uses `whitespace` instead of `linePrefix`
      type2 === types.linePrefix)
        index3--;
      else break;
    }
    const tail = index3 > -1 ? self2.events[index3][1].type : null;
    const next = tail === "tableHead" || tail === "tableRow" ? bodyRowStart : headRowBefore;
    if (next === bodyRowStart && self2.parser.lazy[self2.now().line]) {
      return nok(code3);
    }
    return next(code3);
  }
  function headRowBefore(code3) {
    effects.enter("tableHead");
    effects.enter("tableRow");
    return headRowStart(code3);
  }
  function headRowStart(code3) {
    if (code3 === codes.verticalBar) {
      return headRowBreak(code3);
    }
    seen = true;
    sizeB += 1;
    return headRowBreak(code3);
  }
  function headRowBreak(code3) {
    if (code3 === codes.eof) {
      return nok(code3);
    }
    if (markdownLineEnding(code3)) {
      if (sizeB > 1) {
        sizeB = 0;
        self2.interrupt = true;
        effects.exit("tableRow");
        effects.enter(types.lineEnding);
        effects.consume(code3);
        effects.exit(types.lineEnding);
        return headDelimiterStart;
      }
      return nok(code3);
    }
    if (markdownSpace(code3)) {
      return factorySpace(effects, headRowBreak, types.whitespace)(code3);
    }
    sizeB += 1;
    if (seen) {
      seen = false;
      size4 += 1;
    }
    if (code3 === codes.verticalBar) {
      effects.enter("tableCellDivider");
      effects.consume(code3);
      effects.exit("tableCellDivider");
      seen = true;
      return headRowBreak;
    }
    effects.enter(types.data);
    return headRowData(code3);
  }
  function headRowData(code3) {
    if (code3 === codes.eof || code3 === codes.verticalBar || markdownLineEndingOrSpace(code3)) {
      effects.exit(types.data);
      return headRowBreak(code3);
    }
    effects.consume(code3);
    return code3 === codes.backslash ? headRowEscape : headRowData;
  }
  function headRowEscape(code3) {
    if (code3 === codes.backslash || code3 === codes.verticalBar) {
      effects.consume(code3);
      return headRowData;
    }
    return headRowData(code3);
  }
  function headDelimiterStart(code3) {
    self2.interrupt = false;
    if (self2.parser.lazy[self2.now().line]) {
      return nok(code3);
    }
    effects.enter("tableDelimiterRow");
    seen = false;
    if (markdownSpace(code3)) {
      ok(self2.parser.constructs.disable.null, "expected `disabled.null`");
      return factorySpace(
        effects,
        headDelimiterBefore,
        types.linePrefix,
        self2.parser.constructs.disable.null.includes("codeIndented") ? void 0 : constants.tabSize
      )(code3);
    }
    return headDelimiterBefore(code3);
  }
  function headDelimiterBefore(code3) {
    if (code3 === codes.dash || code3 === codes.colon) {
      return headDelimiterValueBefore(code3);
    }
    if (code3 === codes.verticalBar) {
      seen = true;
      effects.enter("tableCellDivider");
      effects.consume(code3);
      effects.exit("tableCellDivider");
      return headDelimiterCellBefore;
    }
    return headDelimiterNok(code3);
  }
  function headDelimiterCellBefore(code3) {
    if (markdownSpace(code3)) {
      return factorySpace(
        effects,
        headDelimiterValueBefore,
        types.whitespace
      )(code3);
    }
    return headDelimiterValueBefore(code3);
  }
  function headDelimiterValueBefore(code3) {
    if (code3 === codes.colon) {
      sizeB += 1;
      seen = true;
      effects.enter("tableDelimiterMarker");
      effects.consume(code3);
      effects.exit("tableDelimiterMarker");
      return headDelimiterLeftAlignmentAfter;
    }
    if (code3 === codes.dash) {
      sizeB += 1;
      return headDelimiterLeftAlignmentAfter(code3);
    }
    if (code3 === codes.eof || markdownLineEnding(code3)) {
      return headDelimiterCellAfter(code3);
    }
    return headDelimiterNok(code3);
  }
  function headDelimiterLeftAlignmentAfter(code3) {
    if (code3 === codes.dash) {
      effects.enter("tableDelimiterFiller");
      return headDelimiterFiller(code3);
    }
    return headDelimiterNok(code3);
  }
  function headDelimiterFiller(code3) {
    if (code3 === codes.dash) {
      effects.consume(code3);
      return headDelimiterFiller;
    }
    if (code3 === codes.colon) {
      seen = true;
      effects.exit("tableDelimiterFiller");
      effects.enter("tableDelimiterMarker");
      effects.consume(code3);
      effects.exit("tableDelimiterMarker");
      return headDelimiterRightAlignmentAfter;
    }
    effects.exit("tableDelimiterFiller");
    return headDelimiterRightAlignmentAfter(code3);
  }
  function headDelimiterRightAlignmentAfter(code3) {
    if (markdownSpace(code3)) {
      return factorySpace(
        effects,
        headDelimiterCellAfter,
        types.whitespace
      )(code3);
    }
    return headDelimiterCellAfter(code3);
  }
  function headDelimiterCellAfter(code3) {
    if (code3 === codes.verticalBar) {
      return headDelimiterBefore(code3);
    }
    if (code3 === codes.eof || markdownLineEnding(code3)) {
      if (!seen || size4 !== sizeB) {
        return headDelimiterNok(code3);
      }
      effects.exit("tableDelimiterRow");
      effects.exit("tableHead");
      return ok3(code3);
    }
    return headDelimiterNok(code3);
  }
  function headDelimiterNok(code3) {
    return nok(code3);
  }
  function bodyRowStart(code3) {
    effects.enter("tableRow");
    return bodyRowBreak(code3);
  }
  function bodyRowBreak(code3) {
    if (code3 === codes.verticalBar) {
      effects.enter("tableCellDivider");
      effects.consume(code3);
      effects.exit("tableCellDivider");
      return bodyRowBreak;
    }
    if (code3 === codes.eof || markdownLineEnding(code3)) {
      effects.exit("tableRow");
      return ok3(code3);
    }
    if (markdownSpace(code3)) {
      return factorySpace(effects, bodyRowBreak, types.whitespace)(code3);
    }
    effects.enter(types.data);
    return bodyRowData(code3);
  }
  function bodyRowData(code3) {
    if (code3 === codes.eof || code3 === codes.verticalBar || markdownLineEndingOrSpace(code3)) {
      effects.exit(types.data);
      return bodyRowBreak(code3);
    }
    effects.consume(code3);
    return code3 === codes.backslash ? bodyRowEscape : bodyRowData;
  }
  function bodyRowEscape(code3) {
    if (code3 === codes.backslash || code3 === codes.verticalBar) {
      effects.consume(code3);
      return bodyRowData;
    }
    return bodyRowData(code3);
  }
}
function resolveTable(events, context) {
  let index3 = -1;
  let inFirstCellAwaitingPipe = true;
  let rowKind = 0;
  let lastCell = [0, 0, 0, 0];
  let cell = [0, 0, 0, 0];
  let afterHeadAwaitingFirstBodyRow = false;
  let lastTableEnd = 0;
  let currentTable;
  let currentBody;
  let currentCell;
  const map5 = new EditMap();
  while (++index3 < events.length) {
    const event = events[index3];
    const token = event[1];
    if (event[0] === "enter") {
      if (token.type === "tableHead") {
        afterHeadAwaitingFirstBodyRow = false;
        if (lastTableEnd !== 0) {
          ok(currentTable, "there should be a table opening");
          flushTableEnd(map5, context, lastTableEnd, currentTable, currentBody);
          currentBody = void 0;
          lastTableEnd = 0;
        }
        currentTable = {
          type: "table",
          start: Object.assign({}, token.start),
          // Note: correct end is set later.
          end: Object.assign({}, token.end)
        };
        map5.add(index3, 0, [["enter", currentTable, context]]);
      } else if (token.type === "tableRow" || token.type === "tableDelimiterRow") {
        inFirstCellAwaitingPipe = true;
        currentCell = void 0;
        lastCell = [0, 0, 0, 0];
        cell = [0, index3 + 1, 0, 0];
        if (afterHeadAwaitingFirstBodyRow) {
          afterHeadAwaitingFirstBodyRow = false;
          currentBody = {
            type: "tableBody",
            start: Object.assign({}, token.start),
            // Note: correct end is set later.
            end: Object.assign({}, token.end)
          };
          map5.add(index3, 0, [["enter", currentBody, context]]);
        }
        rowKind = token.type === "tableDelimiterRow" ? 2 : currentBody ? 3 : 1;
      } else if (rowKind && (token.type === types.data || token.type === "tableDelimiterMarker" || token.type === "tableDelimiterFiller")) {
        inFirstCellAwaitingPipe = false;
        if (cell[2] === 0) {
          if (lastCell[1] !== 0) {
            cell[0] = cell[1];
            currentCell = flushCell(
              map5,
              context,
              lastCell,
              rowKind,
              void 0,
              currentCell
            );
            lastCell = [0, 0, 0, 0];
          }
          cell[2] = index3;
        }
      } else if (token.type === "tableCellDivider") {
        if (inFirstCellAwaitingPipe) {
          inFirstCellAwaitingPipe = false;
        } else {
          if (lastCell[1] !== 0) {
            cell[0] = cell[1];
            currentCell = flushCell(
              map5,
              context,
              lastCell,
              rowKind,
              void 0,
              currentCell
            );
          }
          lastCell = cell;
          cell = [lastCell[1], index3, 0, 0];
        }
      }
    } else if (token.type === "tableHead") {
      afterHeadAwaitingFirstBodyRow = true;
      lastTableEnd = index3;
    } else if (token.type === "tableRow" || token.type === "tableDelimiterRow") {
      lastTableEnd = index3;
      if (lastCell[1] !== 0) {
        cell[0] = cell[1];
        currentCell = flushCell(
          map5,
          context,
          lastCell,
          rowKind,
          index3,
          currentCell
        );
      } else if (cell[1] !== 0) {
        currentCell = flushCell(map5, context, cell, rowKind, index3, currentCell);
      }
      rowKind = 0;
    } else if (rowKind && (token.type === types.data || token.type === "tableDelimiterMarker" || token.type === "tableDelimiterFiller")) {
      cell[3] = index3;
    }
  }
  if (lastTableEnd !== 0) {
    ok(currentTable, "expected table opening");
    flushTableEnd(map5, context, lastTableEnd, currentTable, currentBody);
  }
  map5.consume(context.events);
  index3 = -1;
  while (++index3 < context.events.length) {
    const event = context.events[index3];
    if (event[0] === "enter" && event[1].type === "table") {
      event[1]._align = gfmTableAlign(context.events, index3);
    }
  }
  return events;
}
function flushCell(map5, context, range, rowKind, rowEnd, previousCell) {
  const groupName = rowKind === 1 ? "tableHeader" : rowKind === 2 ? "tableDelimiter" : "tableData";
  const valueName = "tableContent";
  if (range[0] !== 0) {
    ok(previousCell, "expected previous cell enter");
    previousCell.end = Object.assign({}, getPoint(context.events, range[0]));
    map5.add(range[0], 0, [["exit", previousCell, context]]);
  }
  const now = getPoint(context.events, range[1]);
  previousCell = {
    type: groupName,
    start: Object.assign({}, now),
    // Note: correct end is set later.
    end: Object.assign({}, now)
  };
  map5.add(range[1], 0, [["enter", previousCell, context]]);
  if (range[2] !== 0) {
    const relatedStart = getPoint(context.events, range[2]);
    const relatedEnd = getPoint(context.events, range[3]);
    const valueToken = {
      type: valueName,
      start: Object.assign({}, relatedStart),
      end: Object.assign({}, relatedEnd)
    };
    map5.add(range[2], 0, [["enter", valueToken, context]]);
    ok(range[3] !== 0);
    if (rowKind !== 2) {
      const start2 = context.events[range[2]];
      const end = context.events[range[3]];
      start2[1].end = Object.assign({}, end[1].end);
      start2[1].type = types.chunkText;
      start2[1].contentType = constants.contentTypeText;
      if (range[3] > range[2] + 1) {
        const a2 = range[2] + 1;
        const b3 = range[3] - range[2] - 1;
        map5.add(a2, b3, []);
      }
    }
    map5.add(range[3] + 1, 0, [["exit", valueToken, context]]);
  }
  if (rowEnd !== void 0) {
    previousCell.end = Object.assign({}, getPoint(context.events, rowEnd));
    map5.add(rowEnd, 0, [["exit", previousCell, context]]);
    previousCell = void 0;
  }
  return previousCell;
}
function flushTableEnd(map5, context, index3, table, tableBody) {
  const exits = [];
  const related = getPoint(context.events, index3);
  if (tableBody) {
    tableBody.end = Object.assign({}, related);
    exits.push(["exit", tableBody, context]);
  }
  table.end = Object.assign({}, related);
  exits.push(["exit", table, context]);
  map5.add(index3 + 1, 0, exits);
}
function getPoint(events, index3) {
  const event = events[index3];
  const side = event[0] === "enter" ? "start" : "end";
  return event[1][side];
}

// node_modules/@mdxeditor/editor/dist/plugins/table/TableNode.js
var import_react25 = __toESM(require_react(), 1);

// node_modules/@lexical/react/LexicalCollaborationContext.dev.mjs
var import_react16 = __toESM(require_react(), 1);
var entries = [["Cat", "rgb(125, 50, 0)"], ["Dog", "rgb(100, 0, 0)"], ["Rabbit", "rgb(150, 0, 0)"], ["Frog", "rgb(200, 0, 0)"], ["Fox", "rgb(200, 75, 0)"], ["Hedgehog", "rgb(0, 75, 0)"], ["Pigeon", "rgb(0, 125, 0)"], ["Squirrel", "rgb(75, 100, 0)"], ["Bear", "rgb(125, 100, 0)"], ["Tiger", "rgb(0, 0, 150)"], ["Leopard", "rgb(0, 0, 200)"], ["Zebra", "rgb(0, 0, 250)"], ["Wolf", "rgb(0, 100, 150)"], ["Owl", "rgb(0, 100, 100)"], ["Gull", "rgb(100, 0, 100)"], ["Squid", "rgb(150, 0, 150)"]];
var randomEntry = entries[Math.floor(Math.random() * entries.length)];
var CollaborationContext = (0, import_react16.createContext)({
  clientID: 0,
  color: randomEntry[1],
  isCollabActive: false,
  name: randomEntry[0],
  yjsDocMap: /* @__PURE__ */ new Map()
});
function useCollaborationContext(username, color4) {
  const collabContext = (0, import_react16.useContext)(CollaborationContext);
  if (username != null) {
    collabContext.name = username;
  }
  if (color4 != null) {
    collabContext.color = color4;
  }
  return collabContext;
}

// node_modules/@lexical/react/LexicalNestedComposer.dev.mjs
var import_react17 = __toESM(require_react(), 1);
var import_jsx_runtime6 = __toESM(require_jsx_runtime(), 1);
function getTransformSetFromKlass(klass) {
  const transform = klass.transform();
  return transform !== null ? /* @__PURE__ */ new Set([transform]) : /* @__PURE__ */ new Set();
}
function LexicalNestedComposer({
  initialEditor,
  children,
  initialNodes,
  initialTheme,
  skipCollabChecks
}) {
  const wasCollabPreviouslyReadyRef = (0, import_react17.useRef)(false);
  const parentContext = (0, import_react17.useContext)(LexicalComposerContext);
  if (parentContext == null) {
    {
      throw Error(`Unexpected parent context null on a nested composer`);
    }
  }
  const [parentEditor, {
    getTheme: getParentTheme
  }] = parentContext;
  const composerContext = (0, import_react17.useMemo)(
    () => {
      const composerTheme = initialTheme || getParentTheme() || void 0;
      const context = createLexicalComposerContext(parentContext, composerTheme);
      if (composerTheme !== void 0) {
        initialEditor._config.theme = composerTheme;
      }
      initialEditor._parentEditor = parentEditor;
      if (!initialNodes) {
        const parentNodes = initialEditor._nodes = new Map(parentEditor._nodes);
        for (const [type2, entry] of parentNodes) {
          initialEditor._nodes.set(type2, {
            exportDOM: entry.exportDOM,
            klass: entry.klass,
            replace: entry.replace,
            replaceWithKlass: entry.replaceWithKlass,
            transforms: getTransformSetFromKlass(entry.klass)
          });
        }
      } else {
        for (let klass of initialNodes) {
          let replace2 = null;
          let replaceWithKlass = null;
          if (typeof klass !== "function") {
            const options = klass;
            klass = options.replace;
            replace2 = options.with;
            replaceWithKlass = options.withKlass || null;
          }
          const registeredKlass = initialEditor._nodes.get(klass.getType());
          initialEditor._nodes.set(klass.getType(), {
            exportDOM: registeredKlass ? registeredKlass.exportDOM : void 0,
            klass,
            replace: replace2,
            replaceWithKlass,
            transforms: getTransformSetFromKlass(klass)
          });
        }
      }
      initialEditor._config.namespace = parentEditor._config.namespace;
      initialEditor._editable = parentEditor._editable;
      return [initialEditor, context];
    },
    // We only do this for init
    // eslint-disable-next-line react-hooks/exhaustive-deps
    []
  );
  const {
    isCollabActive,
    yjsDocMap
  } = useCollaborationContext();
  const isCollabReady = skipCollabChecks || wasCollabPreviouslyReadyRef.current || yjsDocMap.has(initialEditor.getKey());
  (0, import_react17.useEffect)(() => {
    if (isCollabReady) {
      wasCollabPreviouslyReadyRef.current = true;
    }
  }, [isCollabReady]);
  (0, import_react17.useEffect)(() => {
    return parentEditor.registerEditableListener((editable) => {
      initialEditor.setEditable(editable);
    });
  }, [initialEditor, parentEditor]);
  return (0, import_jsx_runtime6.jsx)(LexicalComposerContext.Provider, {
    value: composerContext,
    children: !isCollabActive || isCollabReady ? children : null
  });
}

// node_modules/@radix-ui/react-popover/dist/index.mjs
var React30 = __toESM(require_react(), 1);

// node_modules/@radix-ui/primitive/dist/index.mjs
function composeEventHandlers(originalEventHandler, ourEventHandler, { checkForDefaultPrevented = true } = {}) {
  return function handleEvent(event) {
    originalEventHandler == null ? void 0 : originalEventHandler(event);
    if (checkForDefaultPrevented === false || !event.defaultPrevented) {
      return ourEventHandler == null ? void 0 : ourEventHandler(event);
    }
  };
}

// node_modules/@radix-ui/react-compose-refs/dist/index.mjs
var React2 = __toESM(require_react(), 1);
function setRef(ref2, value2) {
  if (typeof ref2 === "function") {
    return ref2(value2);
  } else if (ref2 !== null && ref2 !== void 0) {
    ref2.current = value2;
  }
}
function composeRefs(...refs) {
  return (node2) => {
    let hasCleanup = false;
    const cleanups = refs.map((ref2) => {
      const cleanup = setRef(ref2, node2);
      if (!hasCleanup && typeof cleanup == "function") {
        hasCleanup = true;
      }
      return cleanup;
    });
    if (hasCleanup) {
      return () => {
        for (let i3 = 0; i3 < cleanups.length; i3++) {
          const cleanup = cleanups[i3];
          if (typeof cleanup == "function") {
            cleanup();
          } else {
            setRef(refs[i3], null);
          }
        }
      };
    }
  };
}
function useComposedRefs(...refs) {
  return React2.useCallback(composeRefs(...refs), refs);
}

// node_modules/@radix-ui/react-context/dist/index.mjs
var React3 = __toESM(require_react(), 1);
var import_jsx_runtime7 = __toESM(require_jsx_runtime(), 1);
function createContext22(rootComponentName, defaultContext) {
  const Context = React3.createContext(defaultContext);
  const Provider2 = (props) => {
    const { children, ...context } = props;
    const value2 = React3.useMemo(() => context, Object.values(context));
    return (0, import_jsx_runtime7.jsx)(Context.Provider, { value: value2, children });
  };
  Provider2.displayName = rootComponentName + "Provider";
  function useContext22(consumerName) {
    const context = React3.useContext(Context);
    if (context) return context;
    if (defaultContext !== void 0) return defaultContext;
    throw new Error(`\`${consumerName}\` must be used within \`${rootComponentName}\``);
  }
  return [Provider2, useContext22];
}
function createContextScope(scopeName, createContextScopeDeps = []) {
  let defaultContexts = [];
  function createContext32(rootComponentName, defaultContext) {
    const BaseContext = React3.createContext(defaultContext);
    const index3 = defaultContexts.length;
    defaultContexts = [...defaultContexts, defaultContext];
    const Provider2 = (props) => {
      var _a2;
      const { scope, children, ...context } = props;
      const Context = ((_a2 = scope == null ? void 0 : scope[scopeName]) == null ? void 0 : _a2[index3]) || BaseContext;
      const value2 = React3.useMemo(() => context, Object.values(context));
      return (0, import_jsx_runtime7.jsx)(Context.Provider, { value: value2, children });
    };
    Provider2.displayName = rootComponentName + "Provider";
    function useContext22(consumerName, scope) {
      var _a2;
      const Context = ((_a2 = scope == null ? void 0 : scope[scopeName]) == null ? void 0 : _a2[index3]) || BaseContext;
      const context = React3.useContext(Context);
      if (context) return context;
      if (defaultContext !== void 0) return defaultContext;
      throw new Error(`\`${consumerName}\` must be used within \`${rootComponentName}\``);
    }
    return [Provider2, useContext22];
  }
  const createScope = () => {
    const scopeContexts = defaultContexts.map((defaultContext) => {
      return React3.createContext(defaultContext);
    });
    return function useScope(scope) {
      const contexts = (scope == null ? void 0 : scope[scopeName]) || scopeContexts;
      return React3.useMemo(
        () => ({ [`__scope${scopeName}`]: { ...scope, [scopeName]: contexts } }),
        [scope, contexts]
      );
    };
  };
  createScope.scopeName = scopeName;
  return [createContext32, composeContextScopes(createScope, ...createContextScopeDeps)];
}
function composeContextScopes(...scopes) {
  const baseScope = scopes[0];
  if (scopes.length === 1) return baseScope;
  const createScope = () => {
    const scopeHooks = scopes.map((createScope2) => ({
      useScope: createScope2(),
      scopeName: createScope2.scopeName
    }));
    return function useComposedScopes(overrideScopes) {
      const nextScopes = scopeHooks.reduce((nextScopes2, { useScope, scopeName }) => {
        const scopeProps = useScope(overrideScopes);
        const currentScope = scopeProps[`__scope${scopeName}`];
        return { ...nextScopes2, ...currentScope };
      }, {});
      return React3.useMemo(() => ({ [`__scope${baseScope.scopeName}`]: nextScopes }), [nextScopes]);
    };
  };
  createScope.scopeName = baseScope.scopeName;
  return createScope;
}

// node_modules/@radix-ui/react-dismissable-layer/dist/index.mjs
var React8 = __toESM(require_react(), 1);

// node_modules/@radix-ui/react-primitive/dist/index.mjs
var React5 = __toESM(require_react(), 1);
var ReactDOM = __toESM(require_react_dom(), 1);

// node_modules/@radix-ui/react-slot/dist/index.mjs
var React4 = __toESM(require_react(), 1);
var import_jsx_runtime8 = __toESM(require_jsx_runtime(), 1);
var Slot = React4.forwardRef((props, forwardedRef) => {
  const { children, ...slotProps } = props;
  const childrenArray = React4.Children.toArray(children);
  const slottable = childrenArray.find(isSlottable);
  if (slottable) {
    const newElement = slottable.props.children;
    const newChildren = childrenArray.map((child) => {
      if (child === slottable) {
        if (React4.Children.count(newElement) > 1) return React4.Children.only(null);
        return React4.isValidElement(newElement) ? newElement.props.children : null;
      } else {
        return child;
      }
    });
    return (0, import_jsx_runtime8.jsx)(SlotClone, { ...slotProps, ref: forwardedRef, children: React4.isValidElement(newElement) ? React4.cloneElement(newElement, void 0, newChildren) : null });
  }
  return (0, import_jsx_runtime8.jsx)(SlotClone, { ...slotProps, ref: forwardedRef, children });
});
Slot.displayName = "Slot";
var SlotClone = React4.forwardRef((props, forwardedRef) => {
  const { children, ...slotProps } = props;
  if (React4.isValidElement(children)) {
    const childrenRef = getElementRef(children);
    const props2 = mergeProps(slotProps, children.props);
    if (children.type !== React4.Fragment) {
      props2.ref = forwardedRef ? composeRefs(forwardedRef, childrenRef) : childrenRef;
    }
    return React4.cloneElement(children, props2);
  }
  return React4.Children.count(children) > 1 ? React4.Children.only(null) : null;
});
SlotClone.displayName = "SlotClone";
var Slottable = ({ children }) => {
  return (0, import_jsx_runtime8.jsx)(import_jsx_runtime8.Fragment, { children });
};
function isSlottable(child) {
  return React4.isValidElement(child) && child.type === Slottable;
}
function mergeProps(slotProps, childProps) {
  const overrideProps = { ...childProps };
  for (const propName in childProps) {
    const slotPropValue = slotProps[propName];
    const childPropValue = childProps[propName];
    const isHandler = /^on[A-Z]/.test(propName);
    if (isHandler) {
      if (slotPropValue && childPropValue) {
        overrideProps[propName] = (...args) => {
          childPropValue(...args);
          slotPropValue(...args);
        };
      } else if (slotPropValue) {
        overrideProps[propName] = slotPropValue;
      }
    } else if (propName === "style") {
      overrideProps[propName] = { ...slotPropValue, ...childPropValue };
    } else if (propName === "className") {
      overrideProps[propName] = [slotPropValue, childPropValue].filter(Boolean).join(" ");
    }
  }
  return { ...slotProps, ...overrideProps };
}
function getElementRef(element2) {
  var _a2, _b2;
  let getter = (_a2 = Object.getOwnPropertyDescriptor(element2.props, "ref")) == null ? void 0 : _a2.get;
  let mayWarn = getter && "isReactWarning" in getter && getter.isReactWarning;
  if (mayWarn) {
    return element2.ref;
  }
  getter = (_b2 = Object.getOwnPropertyDescriptor(element2, "ref")) == null ? void 0 : _b2.get;
  mayWarn = getter && "isReactWarning" in getter && getter.isReactWarning;
  if (mayWarn) {
    return element2.props.ref;
  }
  return element2.props.ref || element2.ref;
}

// node_modules/@radix-ui/react-primitive/dist/index.mjs
var import_jsx_runtime9 = __toESM(require_jsx_runtime(), 1);
var NODES = [
  "a",
  "button",
  "div",
  "form",
  "h2",
  "h3",
  "img",
  "input",
  "label",
  "li",
  "nav",
  "ol",
  "p",
  "span",
  "svg",
  "ul"
];
var Primitive = NODES.reduce((primitive, node2) => {
  const Node4 = React5.forwardRef((props, forwardedRef) => {
    const { asChild, ...primitiveProps } = props;
    const Comp = asChild ? Slot : node2;
    if (typeof window !== "undefined") {
      window[Symbol.for("radix-ui")] = true;
    }
    return (0, import_jsx_runtime9.jsx)(Comp, { ...primitiveProps, ref: forwardedRef });
  });
  Node4.displayName = `Primitive.${node2}`;
  return { ...primitive, [node2]: Node4 };
}, {});
function dispatchDiscreteCustomEvent(target, event) {
  if (target) ReactDOM.flushSync(() => target.dispatchEvent(event));
}

// node_modules/@radix-ui/react-use-callback-ref/dist/index.mjs
var React6 = __toESM(require_react(), 1);
function useCallbackRef(callback) {
  const callbackRef = React6.useRef(callback);
  React6.useEffect(() => {
    callbackRef.current = callback;
  });
  return React6.useMemo(() => (...args) => {
    var _a2;
    return (_a2 = callbackRef.current) == null ? void 0 : _a2.call(callbackRef, ...args);
  }, []);
}

// node_modules/@radix-ui/react-use-escape-keydown/dist/index.mjs
var React7 = __toESM(require_react(), 1);
function useEscapeKeydown(onEscapeKeyDownProp, ownerDocument = globalThis == null ? void 0 : globalThis.document) {
  const onEscapeKeyDown = useCallbackRef(onEscapeKeyDownProp);
  React7.useEffect(() => {
    const handleKeyDown = (event) => {
      if (event.key === "Escape") {
        onEscapeKeyDown(event);
      }
    };
    ownerDocument.addEventListener("keydown", handleKeyDown, { capture: true });
    return () => ownerDocument.removeEventListener("keydown", handleKeyDown, { capture: true });
  }, [onEscapeKeyDown, ownerDocument]);
}

// node_modules/@radix-ui/react-dismissable-layer/dist/index.mjs
var import_jsx_runtime10 = __toESM(require_jsx_runtime(), 1);
var DISMISSABLE_LAYER_NAME = "DismissableLayer";
var CONTEXT_UPDATE = "dismissableLayer.update";
var POINTER_DOWN_OUTSIDE = "dismissableLayer.pointerDownOutside";
var FOCUS_OUTSIDE = "dismissableLayer.focusOutside";
var originalBodyPointerEvents;
var DismissableLayerContext = React8.createContext({
  layers: /* @__PURE__ */ new Set(),
  layersWithOutsidePointerEventsDisabled: /* @__PURE__ */ new Set(),
  branches: /* @__PURE__ */ new Set()
});
var DismissableLayer = React8.forwardRef(
  (props, forwardedRef) => {
    const {
      disableOutsidePointerEvents = false,
      onEscapeKeyDown,
      onPointerDownOutside,
      onFocusOutside,
      onInteractOutside,
      onDismiss,
      ...layerProps
    } = props;
    const context = React8.useContext(DismissableLayerContext);
    const [node2, setNode] = React8.useState(null);
    const ownerDocument = (node2 == null ? void 0 : node2.ownerDocument) ?? (globalThis == null ? void 0 : globalThis.document);
    const [, force] = React8.useState({});
    const composedRefs = useComposedRefs(forwardedRef, (node22) => setNode(node22));
    const layers = Array.from(context.layers);
    const [highestLayerWithOutsidePointerEventsDisabled] = [...context.layersWithOutsidePointerEventsDisabled].slice(-1);
    const highestLayerWithOutsidePointerEventsDisabledIndex = layers.indexOf(highestLayerWithOutsidePointerEventsDisabled);
    const index3 = node2 ? layers.indexOf(node2) : -1;
    const isBodyPointerEventsDisabled = context.layersWithOutsidePointerEventsDisabled.size > 0;
    const isPointerEventsEnabled = index3 >= highestLayerWithOutsidePointerEventsDisabledIndex;
    const pointerDownOutside = usePointerDownOutside((event) => {
      const target = event.target;
      const isPointerDownOnBranch = [...context.branches].some((branch) => branch.contains(target));
      if (!isPointerEventsEnabled || isPointerDownOnBranch) return;
      onPointerDownOutside == null ? void 0 : onPointerDownOutside(event);
      onInteractOutside == null ? void 0 : onInteractOutside(event);
      if (!event.defaultPrevented) onDismiss == null ? void 0 : onDismiss();
    }, ownerDocument);
    const focusOutside = useFocusOutside((event) => {
      const target = event.target;
      const isFocusInBranch = [...context.branches].some((branch) => branch.contains(target));
      if (isFocusInBranch) return;
      onFocusOutside == null ? void 0 : onFocusOutside(event);
      onInteractOutside == null ? void 0 : onInteractOutside(event);
      if (!event.defaultPrevented) onDismiss == null ? void 0 : onDismiss();
    }, ownerDocument);
    useEscapeKeydown((event) => {
      const isHighestLayer = index3 === context.layers.size - 1;
      if (!isHighestLayer) return;
      onEscapeKeyDown == null ? void 0 : onEscapeKeyDown(event);
      if (!event.defaultPrevented && onDismiss) {
        event.preventDefault();
        onDismiss();
      }
    }, ownerDocument);
    React8.useEffect(() => {
      if (!node2) return;
      if (disableOutsidePointerEvents) {
        if (context.layersWithOutsidePointerEventsDisabled.size === 0) {
          originalBodyPointerEvents = ownerDocument.body.style.pointerEvents;
          ownerDocument.body.style.pointerEvents = "none";
        }
        context.layersWithOutsidePointerEventsDisabled.add(node2);
      }
      context.layers.add(node2);
      dispatchUpdate();
      return () => {
        if (disableOutsidePointerEvents && context.layersWithOutsidePointerEventsDisabled.size === 1) {
          ownerDocument.body.style.pointerEvents = originalBodyPointerEvents;
        }
      };
    }, [node2, ownerDocument, disableOutsidePointerEvents, context]);
    React8.useEffect(() => {
      return () => {
        if (!node2) return;
        context.layers.delete(node2);
        context.layersWithOutsidePointerEventsDisabled.delete(node2);
        dispatchUpdate();
      };
    }, [node2, context]);
    React8.useEffect(() => {
      const handleUpdate = () => force({});
      document.addEventListener(CONTEXT_UPDATE, handleUpdate);
      return () => document.removeEventListener(CONTEXT_UPDATE, handleUpdate);
    }, []);
    return (0, import_jsx_runtime10.jsx)(
      Primitive.div,
      {
        ...layerProps,
        ref: composedRefs,
        style: {
          pointerEvents: isBodyPointerEventsDisabled ? isPointerEventsEnabled ? "auto" : "none" : void 0,
          ...props.style
        },
        onFocusCapture: composeEventHandlers(props.onFocusCapture, focusOutside.onFocusCapture),
        onBlurCapture: composeEventHandlers(props.onBlurCapture, focusOutside.onBlurCapture),
        onPointerDownCapture: composeEventHandlers(
          props.onPointerDownCapture,
          pointerDownOutside.onPointerDownCapture
        )
      }
    );
  }
);
DismissableLayer.displayName = DISMISSABLE_LAYER_NAME;
var BRANCH_NAME = "DismissableLayerBranch";
var DismissableLayerBranch = React8.forwardRef((props, forwardedRef) => {
  const context = React8.useContext(DismissableLayerContext);
  const ref2 = React8.useRef(null);
  const composedRefs = useComposedRefs(forwardedRef, ref2);
  React8.useEffect(() => {
    const node2 = ref2.current;
    if (node2) {
      context.branches.add(node2);
      return () => {
        context.branches.delete(node2);
      };
    }
  }, [context.branches]);
  return (0, import_jsx_runtime10.jsx)(Primitive.div, { ...props, ref: composedRefs });
});
DismissableLayerBranch.displayName = BRANCH_NAME;
function usePointerDownOutside(onPointerDownOutside, ownerDocument = globalThis == null ? void 0 : globalThis.document) {
  const handlePointerDownOutside = useCallbackRef(onPointerDownOutside);
  const isPointerInsideReactTreeRef = React8.useRef(false);
  const handleClickRef = React8.useRef(() => {
  });
  React8.useEffect(() => {
    const handlePointerDown2 = (event) => {
      if (event.target && !isPointerInsideReactTreeRef.current) {
        let handleAndDispatchPointerDownOutsideEvent2 = function() {
          handleAndDispatchCustomEvent(
            POINTER_DOWN_OUTSIDE,
            handlePointerDownOutside,
            eventDetail,
            { discrete: true }
          );
        };
        var handleAndDispatchPointerDownOutsideEvent = handleAndDispatchPointerDownOutsideEvent2;
        const eventDetail = { originalEvent: event };
        if (event.pointerType === "touch") {
          ownerDocument.removeEventListener("click", handleClickRef.current);
          handleClickRef.current = handleAndDispatchPointerDownOutsideEvent2;
          ownerDocument.addEventListener("click", handleClickRef.current, { once: true });
        } else {
          handleAndDispatchPointerDownOutsideEvent2();
        }
      } else {
        ownerDocument.removeEventListener("click", handleClickRef.current);
      }
      isPointerInsideReactTreeRef.current = false;
    };
    const timerId = window.setTimeout(() => {
      ownerDocument.addEventListener("pointerdown", handlePointerDown2);
    }, 0);
    return () => {
      window.clearTimeout(timerId);
      ownerDocument.removeEventListener("pointerdown", handlePointerDown2);
      ownerDocument.removeEventListener("click", handleClickRef.current);
    };
  }, [ownerDocument, handlePointerDownOutside]);
  return {
    // ensures we check React component tree (not just DOM tree)
    onPointerDownCapture: () => isPointerInsideReactTreeRef.current = true
  };
}
function useFocusOutside(onFocusOutside, ownerDocument = globalThis == null ? void 0 : globalThis.document) {
  const handleFocusOutside = useCallbackRef(onFocusOutside);
  const isFocusInsideReactTreeRef = React8.useRef(false);
  React8.useEffect(() => {
    const handleFocus = (event) => {
      if (event.target && !isFocusInsideReactTreeRef.current) {
        const eventDetail = { originalEvent: event };
        handleAndDispatchCustomEvent(FOCUS_OUTSIDE, handleFocusOutside, eventDetail, {
          discrete: false
        });
      }
    };
    ownerDocument.addEventListener("focusin", handleFocus);
    return () => ownerDocument.removeEventListener("focusin", handleFocus);
  }, [ownerDocument, handleFocusOutside]);
  return {
    onFocusCapture: () => isFocusInsideReactTreeRef.current = true,
    onBlurCapture: () => isFocusInsideReactTreeRef.current = false
  };
}
function dispatchUpdate() {
  const event = new CustomEvent(CONTEXT_UPDATE);
  document.dispatchEvent(event);
}
function handleAndDispatchCustomEvent(name2, handler2, detail, { discrete }) {
  const target = detail.originalEvent.target;
  const event = new CustomEvent(name2, { bubbles: false, cancelable: true, detail });
  if (handler2) target.addEventListener(name2, handler2, { once: true });
  if (discrete) {
    dispatchDiscreteCustomEvent(target, event);
  } else {
    target.dispatchEvent(event);
  }
}

// node_modules/@radix-ui/react-focus-guards/dist/index.mjs
var React9 = __toESM(require_react(), 1);
var count = 0;
function useFocusGuards() {
  React9.useEffect(() => {
    const edgeGuards = document.querySelectorAll("[data-radix-focus-guard]");
    document.body.insertAdjacentElement("afterbegin", edgeGuards[0] ?? createFocusGuard());
    document.body.insertAdjacentElement("beforeend", edgeGuards[1] ?? createFocusGuard());
    count++;
    return () => {
      if (count === 1) {
        document.querySelectorAll("[data-radix-focus-guard]").forEach((node2) => node2.remove());
      }
      count--;
    };
  }, []);
}
function createFocusGuard() {
  const element2 = document.createElement("span");
  element2.setAttribute("data-radix-focus-guard", "");
  element2.tabIndex = 0;
  element2.style.outline = "none";
  element2.style.opacity = "0";
  element2.style.position = "fixed";
  element2.style.pointerEvents = "none";
  return element2;
}

// node_modules/@radix-ui/react-focus-scope/dist/index.mjs
var React10 = __toESM(require_react(), 1);
var import_jsx_runtime11 = __toESM(require_jsx_runtime(), 1);
var AUTOFOCUS_ON_MOUNT = "focusScope.autoFocusOnMount";
var AUTOFOCUS_ON_UNMOUNT = "focusScope.autoFocusOnUnmount";
var EVENT_OPTIONS = { bubbles: false, cancelable: true };
var FOCUS_SCOPE_NAME = "FocusScope";
var FocusScope = React10.forwardRef((props, forwardedRef) => {
  const {
    loop = false,
    trapped = false,
    onMountAutoFocus: onMountAutoFocusProp,
    onUnmountAutoFocus: onUnmountAutoFocusProp,
    ...scopeProps
  } = props;
  const [container, setContainer] = React10.useState(null);
  const onMountAutoFocus = useCallbackRef(onMountAutoFocusProp);
  const onUnmountAutoFocus = useCallbackRef(onUnmountAutoFocusProp);
  const lastFocusedElementRef = React10.useRef(null);
  const composedRefs = useComposedRefs(forwardedRef, (node2) => setContainer(node2));
  const focusScope = React10.useRef({
    paused: false,
    pause() {
      this.paused = true;
    },
    resume() {
      this.paused = false;
    }
  }).current;
  React10.useEffect(() => {
    if (trapped) {
      let handleFocusIn2 = function(event) {
        if (focusScope.paused || !container) return;
        const target = event.target;
        if (container.contains(target)) {
          lastFocusedElementRef.current = target;
        } else {
          focus(lastFocusedElementRef.current, { select: true });
        }
      }, handleFocusOut2 = function(event) {
        if (focusScope.paused || !container) return;
        const relatedTarget = event.relatedTarget;
        if (relatedTarget === null) return;
        if (!container.contains(relatedTarget)) {
          focus(lastFocusedElementRef.current, { select: true });
        }
      }, handleMutations2 = function(mutations) {
        const focusedElement = document.activeElement;
        if (focusedElement !== document.body) return;
        for (const mutation of mutations) {
          if (mutation.removedNodes.length > 0) focus(container);
        }
      };
      var handleFocusIn = handleFocusIn2, handleFocusOut = handleFocusOut2, handleMutations = handleMutations2;
      document.addEventListener("focusin", handleFocusIn2);
      document.addEventListener("focusout", handleFocusOut2);
      const mutationObserver = new MutationObserver(handleMutations2);
      if (container) mutationObserver.observe(container, { childList: true, subtree: true });
      return () => {
        document.removeEventListener("focusin", handleFocusIn2);
        document.removeEventListener("focusout", handleFocusOut2);
        mutationObserver.disconnect();
      };
    }
  }, [trapped, container, focusScope.paused]);
  React10.useEffect(() => {
    if (container) {
      focusScopesStack.add(focusScope);
      const previouslyFocusedElement = document.activeElement;
      const hasFocusedCandidate = container.contains(previouslyFocusedElement);
      if (!hasFocusedCandidate) {
        const mountEvent = new CustomEvent(AUTOFOCUS_ON_MOUNT, EVENT_OPTIONS);
        container.addEventListener(AUTOFOCUS_ON_MOUNT, onMountAutoFocus);
        container.dispatchEvent(mountEvent);
        if (!mountEvent.defaultPrevented) {
          focusFirst(removeLinks(getTabbableCandidates(container)), { select: true });
          if (document.activeElement === previouslyFocusedElement) {
            focus(container);
          }
        }
      }
      return () => {
        container.removeEventListener(AUTOFOCUS_ON_MOUNT, onMountAutoFocus);
        setTimeout(() => {
          const unmountEvent = new CustomEvent(AUTOFOCUS_ON_UNMOUNT, EVENT_OPTIONS);
          container.addEventListener(AUTOFOCUS_ON_UNMOUNT, onUnmountAutoFocus);
          container.dispatchEvent(unmountEvent);
          if (!unmountEvent.defaultPrevented) {
            focus(previouslyFocusedElement ?? document.body, { select: true });
          }
          container.removeEventListener(AUTOFOCUS_ON_UNMOUNT, onUnmountAutoFocus);
          focusScopesStack.remove(focusScope);
        }, 0);
      };
    }
  }, [container, onMountAutoFocus, onUnmountAutoFocus, focusScope]);
  const handleKeyDown = React10.useCallback(
    (event) => {
      if (!loop && !trapped) return;
      if (focusScope.paused) return;
      const isTabKey = event.key === "Tab" && !event.altKey && !event.ctrlKey && !event.metaKey;
      const focusedElement = document.activeElement;
      if (isTabKey && focusedElement) {
        const container2 = event.currentTarget;
        const [first, last] = getTabbableEdges(container2);
        const hasTabbableElementsInside = first && last;
        if (!hasTabbableElementsInside) {
          if (focusedElement === container2) event.preventDefault();
        } else {
          if (!event.shiftKey && focusedElement === last) {
            event.preventDefault();
            if (loop) focus(first, { select: true });
          } else if (event.shiftKey && focusedElement === first) {
            event.preventDefault();
            if (loop) focus(last, { select: true });
          }
        }
      }
    },
    [loop, trapped, focusScope.paused]
  );
  return (0, import_jsx_runtime11.jsx)(Primitive.div, { tabIndex: -1, ...scopeProps, ref: composedRefs, onKeyDown: handleKeyDown });
});
FocusScope.displayName = FOCUS_SCOPE_NAME;
function focusFirst(candidates, { select = false } = {}) {
  const previouslyFocusedElement = document.activeElement;
  for (const candidate of candidates) {
    focus(candidate, { select });
    if (document.activeElement !== previouslyFocusedElement) return;
  }
}
function getTabbableEdges(container) {
  const candidates = getTabbableCandidates(container);
  const first = findVisible(candidates, container);
  const last = findVisible(candidates.reverse(), container);
  return [first, last];
}
function getTabbableCandidates(container) {
  const nodes = [];
  const walker = document.createTreeWalker(container, NodeFilter.SHOW_ELEMENT, {
    acceptNode: (node2) => {
      const isHiddenInput = node2.tagName === "INPUT" && node2.type === "hidden";
      if (node2.disabled || node2.hidden || isHiddenInput) return NodeFilter.FILTER_SKIP;
      return node2.tabIndex >= 0 ? NodeFilter.FILTER_ACCEPT : NodeFilter.FILTER_SKIP;
    }
  });
  while (walker.nextNode()) nodes.push(walker.currentNode);
  return nodes;
}
function findVisible(elements, container) {
  for (const element2 of elements) {
    if (!isHidden(element2, { upTo: container })) return element2;
  }
}
function isHidden(node2, { upTo }) {
  if (getComputedStyle(node2).visibility === "hidden") return true;
  while (node2) {
    if (upTo !== void 0 && node2 === upTo) return false;
    if (getComputedStyle(node2).display === "none") return true;
    node2 = node2.parentElement;
  }
  return false;
}
function isSelectableInput(element2) {
  return element2 instanceof HTMLInputElement && "select" in element2;
}
function focus(element2, { select = false } = {}) {
  if (element2 && element2.focus) {
    const previouslyFocusedElement = document.activeElement;
    element2.focus({ preventScroll: true });
    if (element2 !== previouslyFocusedElement && isSelectableInput(element2) && select)
      element2.select();
  }
}
var focusScopesStack = createFocusScopesStack();
function createFocusScopesStack() {
  let stack = [];
  return {
    add(focusScope) {
      const activeFocusScope = stack[0];
      if (focusScope !== activeFocusScope) {
        activeFocusScope == null ? void 0 : activeFocusScope.pause();
      }
      stack = arrayRemove(stack, focusScope);
      stack.unshift(focusScope);
    },
    remove(focusScope) {
      var _a2;
      stack = arrayRemove(stack, focusScope);
      (_a2 = stack[0]) == null ? void 0 : _a2.resume();
    }
  };
}
function arrayRemove(array, item) {
  const updatedArray = [...array];
  const index3 = updatedArray.indexOf(item);
  if (index3 !== -1) {
    updatedArray.splice(index3, 1);
  }
  return updatedArray;
}
function removeLinks(items) {
  return items.filter((item) => item.tagName !== "A");
}

// node_modules/@radix-ui/react-id/dist/index.mjs
var React12 = __toESM(require_react(), 1);

// node_modules/@radix-ui/react-use-layout-effect/dist/index.mjs
var React11 = __toESM(require_react(), 1);
var useLayoutEffect22 = Boolean(globalThis == null ? void 0 : globalThis.document) ? React11.useLayoutEffect : () => {
};

// node_modules/@radix-ui/react-id/dist/index.mjs
var useReactId = React12["useId".toString()] || (() => void 0);
var count2 = 0;
function useId(deterministicId) {
  const [id, setId] = React12.useState(useReactId());
  useLayoutEffect22(() => {
    if (!deterministicId) setId((reactId) => reactId ?? String(count2++));
  }, [deterministicId]);
  return deterministicId || (id ? `radix-${id}` : "");
}

// node_modules/@radix-ui/react-popper/dist/index.mjs
var React16 = __toESM(require_react(), 1);

// node_modules/@floating-ui/utils/dist/floating-ui.utils.mjs
var sides = ["top", "right", "bottom", "left"];
var alignments = ["start", "end"];
var placements = sides.reduce((acc, side) => acc.concat(side, side + "-" + alignments[0], side + "-" + alignments[1]), []);
var min = Math.min;
var max = Math.max;
var round = Math.round;
var floor = Math.floor;
var createCoords = (v3) => ({
  x: v3,
  y: v3
});
var oppositeSideMap = {
  left: "right",
  right: "left",
  bottom: "top",
  top: "bottom"
};
var oppositeAlignmentMap = {
  start: "end",
  end: "start"
};
function clamp(start2, value2, end) {
  return max(start2, min(value2, end));
}
function evaluate(value2, param) {
  return typeof value2 === "function" ? value2(param) : value2;
}
function getSide(placement) {
  return placement.split("-")[0];
}
function getAlignment(placement) {
  return placement.split("-")[1];
}
function getOppositeAxis(axis) {
  return axis === "x" ? "y" : "x";
}
function getAxisLength(axis) {
  return axis === "y" ? "height" : "width";
}
function getSideAxis(placement) {
  return ["top", "bottom"].includes(getSide(placement)) ? "y" : "x";
}
function getAlignmentAxis(placement) {
  return getOppositeAxis(getSideAxis(placement));
}
function getAlignmentSides(placement, rects, rtl) {
  if (rtl === void 0) {
    rtl = false;
  }
  const alignment = getAlignment(placement);
  const alignmentAxis = getAlignmentAxis(placement);
  const length = getAxisLength(alignmentAxis);
  let mainAlignmentSide = alignmentAxis === "x" ? alignment === (rtl ? "end" : "start") ? "right" : "left" : alignment === "start" ? "bottom" : "top";
  if (rects.reference[length] > rects.floating[length]) {
    mainAlignmentSide = getOppositePlacement(mainAlignmentSide);
  }
  return [mainAlignmentSide, getOppositePlacement(mainAlignmentSide)];
}
function getExpandedPlacements(placement) {
  const oppositePlacement = getOppositePlacement(placement);
  return [getOppositeAlignmentPlacement(placement), oppositePlacement, getOppositeAlignmentPlacement(oppositePlacement)];
}
function getOppositeAlignmentPlacement(placement) {
  return placement.replace(/start|end/g, (alignment) => oppositeAlignmentMap[alignment]);
}
function getSideList(side, isStart, rtl) {
  const lr = ["left", "right"];
  const rl = ["right", "left"];
  const tb = ["top", "bottom"];
  const bt = ["bottom", "top"];
  switch (side) {
    case "top":
    case "bottom":
      if (rtl) return isStart ? rl : lr;
      return isStart ? lr : rl;
    case "left":
    case "right":
      return isStart ? tb : bt;
    default:
      return [];
  }
}
function getOppositeAxisPlacements(placement, flipAlignment, direction, rtl) {
  const alignment = getAlignment(placement);
  let list4 = getSideList(getSide(placement), direction === "start", rtl);
  if (alignment) {
    list4 = list4.map((side) => side + "-" + alignment);
    if (flipAlignment) {
      list4 = list4.concat(list4.map(getOppositeAlignmentPlacement));
    }
  }
  return list4;
}
function getOppositePlacement(placement) {
  return placement.replace(/left|right|bottom|top/g, (side) => oppositeSideMap[side]);
}
function expandPaddingObject(padding) {
  return {
    top: 0,
    right: 0,
    bottom: 0,
    left: 0,
    ...padding
  };
}
function getPaddingObject(padding) {
  return typeof padding !== "number" ? expandPaddingObject(padding) : {
    top: padding,
    right: padding,
    bottom: padding,
    left: padding
  };
}
function rectToClientRect(rect) {
  const {
    x: x3,
    y: y2,
    width,
    height
  } = rect;
  return {
    width,
    height,
    top: y2,
    left: x3,
    right: x3 + width,
    bottom: y2 + height,
    x: x3,
    y: y2
  };
}

// node_modules/@floating-ui/core/dist/floating-ui.core.mjs
function computeCoordsFromPlacement(_ref, placement, rtl) {
  let {
    reference,
    floating
  } = _ref;
  const sideAxis = getSideAxis(placement);
  const alignmentAxis = getAlignmentAxis(placement);
  const alignLength = getAxisLength(alignmentAxis);
  const side = getSide(placement);
  const isVertical = sideAxis === "y";
  const commonX = reference.x + reference.width / 2 - floating.width / 2;
  const commonY = reference.y + reference.height / 2 - floating.height / 2;
  const commonAlign = reference[alignLength] / 2 - floating[alignLength] / 2;
  let coords;
  switch (side) {
    case "top":
      coords = {
        x: commonX,
        y: reference.y - floating.height
      };
      break;
    case "bottom":
      coords = {
        x: commonX,
        y: reference.y + reference.height
      };
      break;
    case "right":
      coords = {
        x: reference.x + reference.width,
        y: commonY
      };
      break;
    case "left":
      coords = {
        x: reference.x - floating.width,
        y: commonY
      };
      break;
    default:
      coords = {
        x: reference.x,
        y: reference.y
      };
  }
  switch (getAlignment(placement)) {
    case "start":
      coords[alignmentAxis] -= commonAlign * (rtl && isVertical ? -1 : 1);
      break;
    case "end":
      coords[alignmentAxis] += commonAlign * (rtl && isVertical ? -1 : 1);
      break;
  }
  return coords;
}
var computePosition = async (reference, floating, config) => {
  const {
    placement = "bottom",
    strategy = "absolute",
    middleware = [],
    platform: platform2
  } = config;
  const validMiddleware = middleware.filter(Boolean);
  const rtl = await (platform2.isRTL == null ? void 0 : platform2.isRTL(floating));
  let rects = await platform2.getElementRects({
    reference,
    floating,
    strategy
  });
  let {
    x: x3,
    y: y2
  } = computeCoordsFromPlacement(rects, placement, rtl);
  let statefulPlacement = placement;
  let middlewareData = {};
  let resetCount = 0;
  for (let i3 = 0; i3 < validMiddleware.length; i3++) {
    const {
      name: name2,
      fn
    } = validMiddleware[i3];
    const {
      x: nextX,
      y: nextY,
      data: data2,
      reset: reset2
    } = await fn({
      x: x3,
      y: y2,
      initialPlacement: placement,
      placement: statefulPlacement,
      strategy,
      middlewareData,
      rects,
      platform: platform2,
      elements: {
        reference,
        floating
      }
    });
    x3 = nextX != null ? nextX : x3;
    y2 = nextY != null ? nextY : y2;
    middlewareData = {
      ...middlewareData,
      [name2]: {
        ...middlewareData[name2],
        ...data2
      }
    };
    if (reset2 && resetCount <= 50) {
      resetCount++;
      if (typeof reset2 === "object") {
        if (reset2.placement) {
          statefulPlacement = reset2.placement;
        }
        if (reset2.rects) {
          rects = reset2.rects === true ? await platform2.getElementRects({
            reference,
            floating,
            strategy
          }) : reset2.rects;
        }
        ({
          x: x3,
          y: y2
        } = computeCoordsFromPlacement(rects, statefulPlacement, rtl));
      }
      i3 = -1;
    }
  }
  return {
    x: x3,
    y: y2,
    placement: statefulPlacement,
    strategy,
    middlewareData
  };
};
async function detectOverflow(state, options) {
  var _await$platform$isEle;
  if (options === void 0) {
    options = {};
  }
  const {
    x: x3,
    y: y2,
    platform: platform2,
    rects,
    elements,
    strategy
  } = state;
  const {
    boundary = "clippingAncestors",
    rootBoundary = "viewport",
    elementContext = "floating",
    altBoundary = false,
    padding = 0
  } = evaluate(options, state);
  const paddingObject = getPaddingObject(padding);
  const altContext = elementContext === "floating" ? "reference" : "floating";
  const element2 = elements[altBoundary ? altContext : elementContext];
  const clippingClientRect = rectToClientRect(await platform2.getClippingRect({
    element: ((_await$platform$isEle = await (platform2.isElement == null ? void 0 : platform2.isElement(element2))) != null ? _await$platform$isEle : true) ? element2 : element2.contextElement || await (platform2.getDocumentElement == null ? void 0 : platform2.getDocumentElement(elements.floating)),
    boundary,
    rootBoundary,
    strategy
  }));
  const rect = elementContext === "floating" ? {
    x: x3,
    y: y2,
    width: rects.floating.width,
    height: rects.floating.height
  } : rects.reference;
  const offsetParent = await (platform2.getOffsetParent == null ? void 0 : platform2.getOffsetParent(elements.floating));
  const offsetScale = await (platform2.isElement == null ? void 0 : platform2.isElement(offsetParent)) ? await (platform2.getScale == null ? void 0 : platform2.getScale(offsetParent)) || {
    x: 1,
    y: 1
  } : {
    x: 1,
    y: 1
  };
  const elementClientRect = rectToClientRect(platform2.convertOffsetParentRelativeRectToViewportRelativeRect ? await platform2.convertOffsetParentRelativeRectToViewportRelativeRect({
    elements,
    rect,
    offsetParent,
    strategy
  }) : rect);
  return {
    top: (clippingClientRect.top - elementClientRect.top + paddingObject.top) / offsetScale.y,
    bottom: (elementClientRect.bottom - clippingClientRect.bottom + paddingObject.bottom) / offsetScale.y,
    left: (clippingClientRect.left - elementClientRect.left + paddingObject.left) / offsetScale.x,
    right: (elementClientRect.right - clippingClientRect.right + paddingObject.right) / offsetScale.x
  };
}
var arrow = (options) => ({
  name: "arrow",
  options,
  async fn(state) {
    const {
      x: x3,
      y: y2,
      placement,
      rects,
      platform: platform2,
      elements,
      middlewareData
    } = state;
    const {
      element: element2,
      padding = 0
    } = evaluate(options, state) || {};
    if (element2 == null) {
      return {};
    }
    const paddingObject = getPaddingObject(padding);
    const coords = {
      x: x3,
      y: y2
    };
    const axis = getAlignmentAxis(placement);
    const length = getAxisLength(axis);
    const arrowDimensions = await platform2.getDimensions(element2);
    const isYAxis = axis === "y";
    const minProp = isYAxis ? "top" : "left";
    const maxProp = isYAxis ? "bottom" : "right";
    const clientProp = isYAxis ? "clientHeight" : "clientWidth";
    const endDiff = rects.reference[length] + rects.reference[axis] - coords[axis] - rects.floating[length];
    const startDiff = coords[axis] - rects.reference[axis];
    const arrowOffsetParent = await (platform2.getOffsetParent == null ? void 0 : platform2.getOffsetParent(element2));
    let clientSize = arrowOffsetParent ? arrowOffsetParent[clientProp] : 0;
    if (!clientSize || !await (platform2.isElement == null ? void 0 : platform2.isElement(arrowOffsetParent))) {
      clientSize = elements.floating[clientProp] || rects.floating[length];
    }
    const centerToReference = endDiff / 2 - startDiff / 2;
    const largestPossiblePadding = clientSize / 2 - arrowDimensions[length] / 2 - 1;
    const minPadding = min(paddingObject[minProp], largestPossiblePadding);
    const maxPadding = min(paddingObject[maxProp], largestPossiblePadding);
    const min$1 = minPadding;
    const max2 = clientSize - arrowDimensions[length] - maxPadding;
    const center = clientSize / 2 - arrowDimensions[length] / 2 + centerToReference;
    const offset5 = clamp(min$1, center, max2);
    const shouldAddOffset = !middlewareData.arrow && getAlignment(placement) != null && center !== offset5 && rects.reference[length] / 2 - (center < min$1 ? minPadding : maxPadding) - arrowDimensions[length] / 2 < 0;
    const alignmentOffset = shouldAddOffset ? center < min$1 ? center - min$1 : center - max2 : 0;
    return {
      [axis]: coords[axis] + alignmentOffset,
      data: {
        [axis]: offset5,
        centerOffset: center - offset5 - alignmentOffset,
        ...shouldAddOffset && {
          alignmentOffset
        }
      },
      reset: shouldAddOffset
    };
  }
});
var flip = function(options) {
  if (options === void 0) {
    options = {};
  }
  return {
    name: "flip",
    options,
    async fn(state) {
      var _middlewareData$arrow, _middlewareData$flip;
      const {
        placement,
        middlewareData,
        rects,
        initialPlacement,
        platform: platform2,
        elements
      } = state;
      const {
        mainAxis: checkMainAxis = true,
        crossAxis: checkCrossAxis = true,
        fallbackPlacements: specifiedFallbackPlacements,
        fallbackStrategy = "bestFit",
        fallbackAxisSideDirection = "none",
        flipAlignment = true,
        ...detectOverflowOptions
      } = evaluate(options, state);
      if ((_middlewareData$arrow = middlewareData.arrow) != null && _middlewareData$arrow.alignmentOffset) {
        return {};
      }
      const side = getSide(placement);
      const initialSideAxis = getSideAxis(initialPlacement);
      const isBasePlacement = getSide(initialPlacement) === initialPlacement;
      const rtl = await (platform2.isRTL == null ? void 0 : platform2.isRTL(elements.floating));
      const fallbackPlacements = specifiedFallbackPlacements || (isBasePlacement || !flipAlignment ? [getOppositePlacement(initialPlacement)] : getExpandedPlacements(initialPlacement));
      const hasFallbackAxisSideDirection = fallbackAxisSideDirection !== "none";
      if (!specifiedFallbackPlacements && hasFallbackAxisSideDirection) {
        fallbackPlacements.push(...getOppositeAxisPlacements(initialPlacement, flipAlignment, fallbackAxisSideDirection, rtl));
      }
      const placements2 = [initialPlacement, ...fallbackPlacements];
      const overflow = await detectOverflow(state, detectOverflowOptions);
      const overflows = [];
      let overflowsData = ((_middlewareData$flip = middlewareData.flip) == null ? void 0 : _middlewareData$flip.overflows) || [];
      if (checkMainAxis) {
        overflows.push(overflow[side]);
      }
      if (checkCrossAxis) {
        const sides2 = getAlignmentSides(placement, rects, rtl);
        overflows.push(overflow[sides2[0]], overflow[sides2[1]]);
      }
      overflowsData = [...overflowsData, {
        placement,
        overflows
      }];
      if (!overflows.every((side2) => side2 <= 0)) {
        var _middlewareData$flip2, _overflowsData$filter;
        const nextIndex2 = (((_middlewareData$flip2 = middlewareData.flip) == null ? void 0 : _middlewareData$flip2.index) || 0) + 1;
        const nextPlacement = placements2[nextIndex2];
        if (nextPlacement) {
          return {
            data: {
              index: nextIndex2,
              overflows: overflowsData
            },
            reset: {
              placement: nextPlacement
            }
          };
        }
        let resetPlacement = (_overflowsData$filter = overflowsData.filter((d3) => d3.overflows[0] <= 0).sort((a2, b3) => a2.overflows[1] - b3.overflows[1])[0]) == null ? void 0 : _overflowsData$filter.placement;
        if (!resetPlacement) {
          switch (fallbackStrategy) {
            case "bestFit": {
              var _overflowsData$filter2;
              const placement2 = (_overflowsData$filter2 = overflowsData.filter((d3) => {
                if (hasFallbackAxisSideDirection) {
                  const currentSideAxis = getSideAxis(d3.placement);
                  return currentSideAxis === initialSideAxis || // Create a bias to the `y` side axis due to horizontal
                  // reading directions favoring greater width.
                  currentSideAxis === "y";
                }
                return true;
              }).map((d3) => [d3.placement, d3.overflows.filter((overflow2) => overflow2 > 0).reduce((acc, overflow2) => acc + overflow2, 0)]).sort((a2, b3) => a2[1] - b3[1])[0]) == null ? void 0 : _overflowsData$filter2[0];
              if (placement2) {
                resetPlacement = placement2;
              }
              break;
            }
            case "initialPlacement":
              resetPlacement = initialPlacement;
              break;
          }
        }
        if (placement !== resetPlacement) {
          return {
            reset: {
              placement: resetPlacement
            }
          };
        }
      }
      return {};
    }
  };
};
function getSideOffsets(overflow, rect) {
  return {
    top: overflow.top - rect.height,
    right: overflow.right - rect.width,
    bottom: overflow.bottom - rect.height,
    left: overflow.left - rect.width
  };
}
function isAnySideFullyClipped(overflow) {
  return sides.some((side) => overflow[side] >= 0);
}
var hide = function(options) {
  if (options === void 0) {
    options = {};
  }
  return {
    name: "hide",
    options,
    async fn(state) {
      const {
        rects
      } = state;
      const {
        strategy = "referenceHidden",
        ...detectOverflowOptions
      } = evaluate(options, state);
      switch (strategy) {
        case "referenceHidden": {
          const overflow = await detectOverflow(state, {
            ...detectOverflowOptions,
            elementContext: "reference"
          });
          const offsets = getSideOffsets(overflow, rects.reference);
          return {
            data: {
              referenceHiddenOffsets: offsets,
              referenceHidden: isAnySideFullyClipped(offsets)
            }
          };
        }
        case "escaped": {
          const overflow = await detectOverflow(state, {
            ...detectOverflowOptions,
            altBoundary: true
          });
          const offsets = getSideOffsets(overflow, rects.floating);
          return {
            data: {
              escapedOffsets: offsets,
              escaped: isAnySideFullyClipped(offsets)
            }
          };
        }
        default: {
          return {};
        }
      }
    }
  };
};
async function convertValueToCoords(state, options) {
  const {
    placement,
    platform: platform2,
    elements
  } = state;
  const rtl = await (platform2.isRTL == null ? void 0 : platform2.isRTL(elements.floating));
  const side = getSide(placement);
  const alignment = getAlignment(placement);
  const isVertical = getSideAxis(placement) === "y";
  const mainAxisMulti = ["left", "top"].includes(side) ? -1 : 1;
  const crossAxisMulti = rtl && isVertical ? -1 : 1;
  const rawValue = evaluate(options, state);
  let {
    mainAxis,
    crossAxis,
    alignmentAxis
  } = typeof rawValue === "number" ? {
    mainAxis: rawValue,
    crossAxis: 0,
    alignmentAxis: null
  } : {
    mainAxis: rawValue.mainAxis || 0,
    crossAxis: rawValue.crossAxis || 0,
    alignmentAxis: rawValue.alignmentAxis
  };
  if (alignment && typeof alignmentAxis === "number") {
    crossAxis = alignment === "end" ? alignmentAxis * -1 : alignmentAxis;
  }
  return isVertical ? {
    x: crossAxis * crossAxisMulti,
    y: mainAxis * mainAxisMulti
  } : {
    x: mainAxis * mainAxisMulti,
    y: crossAxis * crossAxisMulti
  };
}
var offset = function(options) {
  if (options === void 0) {
    options = 0;
  }
  return {
    name: "offset",
    options,
    async fn(state) {
      var _middlewareData$offse, _middlewareData$arrow;
      const {
        x: x3,
        y: y2,
        placement,
        middlewareData
      } = state;
      const diffCoords = await convertValueToCoords(state, options);
      if (placement === ((_middlewareData$offse = middlewareData.offset) == null ? void 0 : _middlewareData$offse.placement) && (_middlewareData$arrow = middlewareData.arrow) != null && _middlewareData$arrow.alignmentOffset) {
        return {};
      }
      return {
        x: x3 + diffCoords.x,
        y: y2 + diffCoords.y,
        data: {
          ...diffCoords,
          placement
        }
      };
    }
  };
};
var shift = function(options) {
  if (options === void 0) {
    options = {};
  }
  return {
    name: "shift",
    options,
    async fn(state) {
      const {
        x: x3,
        y: y2,
        placement
      } = state;
      const {
        mainAxis: checkMainAxis = true,
        crossAxis: checkCrossAxis = false,
        limiter = {
          fn: (_ref) => {
            let {
              x: x4,
              y: y3
            } = _ref;
            return {
              x: x4,
              y: y3
            };
          }
        },
        ...detectOverflowOptions
      } = evaluate(options, state);
      const coords = {
        x: x3,
        y: y2
      };
      const overflow = await detectOverflow(state, detectOverflowOptions);
      const crossAxis = getSideAxis(getSide(placement));
      const mainAxis = getOppositeAxis(crossAxis);
      let mainAxisCoord = coords[mainAxis];
      let crossAxisCoord = coords[crossAxis];
      if (checkMainAxis) {
        const minSide = mainAxis === "y" ? "top" : "left";
        const maxSide = mainAxis === "y" ? "bottom" : "right";
        const min2 = mainAxisCoord + overflow[minSide];
        const max2 = mainAxisCoord - overflow[maxSide];
        mainAxisCoord = clamp(min2, mainAxisCoord, max2);
      }
      if (checkCrossAxis) {
        const minSide = crossAxis === "y" ? "top" : "left";
        const maxSide = crossAxis === "y" ? "bottom" : "right";
        const min2 = crossAxisCoord + overflow[minSide];
        const max2 = crossAxisCoord - overflow[maxSide];
        crossAxisCoord = clamp(min2, crossAxisCoord, max2);
      }
      const limitedCoords = limiter.fn({
        ...state,
        [mainAxis]: mainAxisCoord,
        [crossAxis]: crossAxisCoord
      });
      return {
        ...limitedCoords,
        data: {
          x: limitedCoords.x - x3,
          y: limitedCoords.y - y2,
          enabled: {
            [mainAxis]: checkMainAxis,
            [crossAxis]: checkCrossAxis
          }
        }
      };
    }
  };
};
var limitShift = function(options) {
  if (options === void 0) {
    options = {};
  }
  return {
    options,
    fn(state) {
      const {
        x: x3,
        y: y2,
        placement,
        rects,
        middlewareData
      } = state;
      const {
        offset: offset5 = 0,
        mainAxis: checkMainAxis = true,
        crossAxis: checkCrossAxis = true
      } = evaluate(options, state);
      const coords = {
        x: x3,
        y: y2
      };
      const crossAxis = getSideAxis(placement);
      const mainAxis = getOppositeAxis(crossAxis);
      let mainAxisCoord = coords[mainAxis];
      let crossAxisCoord = coords[crossAxis];
      const rawOffset = evaluate(offset5, state);
      const computedOffset = typeof rawOffset === "number" ? {
        mainAxis: rawOffset,
        crossAxis: 0
      } : {
        mainAxis: 0,
        crossAxis: 0,
        ...rawOffset
      };
      if (checkMainAxis) {
        const len = mainAxis === "y" ? "height" : "width";
        const limitMin = rects.reference[mainAxis] - rects.floating[len] + computedOffset.mainAxis;
        const limitMax = rects.reference[mainAxis] + rects.reference[len] - computedOffset.mainAxis;
        if (mainAxisCoord < limitMin) {
          mainAxisCoord = limitMin;
        } else if (mainAxisCoord > limitMax) {
          mainAxisCoord = limitMax;
        }
      }
      if (checkCrossAxis) {
        var _middlewareData$offse, _middlewareData$offse2;
        const len = mainAxis === "y" ? "width" : "height";
        const isOriginSide = ["top", "left"].includes(getSide(placement));
        const limitMin = rects.reference[crossAxis] - rects.floating[len] + (isOriginSide ? ((_middlewareData$offse = middlewareData.offset) == null ? void 0 : _middlewareData$offse[crossAxis]) || 0 : 0) + (isOriginSide ? 0 : computedOffset.crossAxis);
        const limitMax = rects.reference[crossAxis] + rects.reference[len] + (isOriginSide ? 0 : ((_middlewareData$offse2 = middlewareData.offset) == null ? void 0 : _middlewareData$offse2[crossAxis]) || 0) - (isOriginSide ? computedOffset.crossAxis : 0);
        if (crossAxisCoord < limitMin) {
          crossAxisCoord = limitMin;
        } else if (crossAxisCoord > limitMax) {
          crossAxisCoord = limitMax;
        }
      }
      return {
        [mainAxis]: mainAxisCoord,
        [crossAxis]: crossAxisCoord
      };
    }
  };
};
var size = function(options) {
  if (options === void 0) {
    options = {};
  }
  return {
    name: "size",
    options,
    async fn(state) {
      var _state$middlewareData, _state$middlewareData2;
      const {
        placement,
        rects,
        platform: platform2,
        elements
      } = state;
      const {
        apply = () => {
        },
        ...detectOverflowOptions
      } = evaluate(options, state);
      const overflow = await detectOverflow(state, detectOverflowOptions);
      const side = getSide(placement);
      const alignment = getAlignment(placement);
      const isYAxis = getSideAxis(placement) === "y";
      const {
        width,
        height
      } = rects.floating;
      let heightSide;
      let widthSide;
      if (side === "top" || side === "bottom") {
        heightSide = side;
        widthSide = alignment === (await (platform2.isRTL == null ? void 0 : platform2.isRTL(elements.floating)) ? "start" : "end") ? "left" : "right";
      } else {
        widthSide = side;
        heightSide = alignment === "end" ? "top" : "bottom";
      }
      const maximumClippingHeight = height - overflow.top - overflow.bottom;
      const maximumClippingWidth = width - overflow.left - overflow.right;
      const overflowAvailableHeight = min(height - overflow[heightSide], maximumClippingHeight);
      const overflowAvailableWidth = min(width - overflow[widthSide], maximumClippingWidth);
      const noShift = !state.middlewareData.shift;
      let availableHeight = overflowAvailableHeight;
      let availableWidth = overflowAvailableWidth;
      if ((_state$middlewareData = state.middlewareData.shift) != null && _state$middlewareData.enabled.x) {
        availableWidth = maximumClippingWidth;
      }
      if ((_state$middlewareData2 = state.middlewareData.shift) != null && _state$middlewareData2.enabled.y) {
        availableHeight = maximumClippingHeight;
      }
      if (noShift && !alignment) {
        const xMin = max(overflow.left, 0);
        const xMax = max(overflow.right, 0);
        const yMin = max(overflow.top, 0);
        const yMax = max(overflow.bottom, 0);
        if (isYAxis) {
          availableWidth = width - 2 * (xMin !== 0 || xMax !== 0 ? xMin + xMax : max(overflow.left, overflow.right));
        } else {
          availableHeight = height - 2 * (yMin !== 0 || yMax !== 0 ? yMin + yMax : max(overflow.top, overflow.bottom));
        }
      }
      await apply({
        ...state,
        availableWidth,
        availableHeight
      });
      const nextDimensions = await platform2.getDimensions(elements.floating);
      if (width !== nextDimensions.width || height !== nextDimensions.height) {
        return {
          reset: {
            rects: true
          }
        };
      }
      return {};
    }
  };
};

// node_modules/@floating-ui/utils/dist/floating-ui.utils.dom.mjs
function hasWindow() {
  return typeof window !== "undefined";
}
function getNodeName(node2) {
  if (isNode(node2)) {
    return (node2.nodeName || "").toLowerCase();
  }
  return "#document";
}
function getWindow2(node2) {
  var _node$ownerDocument;
  return (node2 == null || (_node$ownerDocument = node2.ownerDocument) == null ? void 0 : _node$ownerDocument.defaultView) || window;
}
function getDocumentElement(node2) {
  var _ref;
  return (_ref = (isNode(node2) ? node2.ownerDocument : node2.document) || window.document) == null ? void 0 : _ref.documentElement;
}
function isNode(value2) {
  if (!hasWindow()) {
    return false;
  }
  return value2 instanceof Node || value2 instanceof getWindow2(value2).Node;
}
function isElement(value2) {
  if (!hasWindow()) {
    return false;
  }
  return value2 instanceof Element || value2 instanceof getWindow2(value2).Element;
}
function isHTMLElement2(value2) {
  if (!hasWindow()) {
    return false;
  }
  return value2 instanceof HTMLElement || value2 instanceof getWindow2(value2).HTMLElement;
}
function isShadowRoot(value2) {
  if (!hasWindow() || typeof ShadowRoot === "undefined") {
    return false;
  }
  return value2 instanceof ShadowRoot || value2 instanceof getWindow2(value2).ShadowRoot;
}
function isOverflowElement(element2) {
  const {
    overflow,
    overflowX,
    overflowY,
    display
  } = getComputedStyle2(element2);
  return /auto|scroll|overlay|hidden|clip/.test(overflow + overflowY + overflowX) && !["inline", "contents"].includes(display);
}
function isTableElement(element2) {
  return ["table", "td", "th"].includes(getNodeName(element2));
}
function isTopLayer(element2) {
  return [":popover-open", ":modal"].some((selector) => {
    try {
      return element2.matches(selector);
    } catch (e2) {
      return false;
    }
  });
}
function isContainingBlock(elementOrCss) {
  const webkit = isWebKit();
  const css3 = isElement(elementOrCss) ? getComputedStyle2(elementOrCss) : elementOrCss;
  return ["transform", "translate", "scale", "rotate", "perspective"].some((value2) => css3[value2] ? css3[value2] !== "none" : false) || (css3.containerType ? css3.containerType !== "normal" : false) || !webkit && (css3.backdropFilter ? css3.backdropFilter !== "none" : false) || !webkit && (css3.filter ? css3.filter !== "none" : false) || ["transform", "translate", "scale", "rotate", "perspective", "filter"].some((value2) => (css3.willChange || "").includes(value2)) || ["paint", "layout", "strict", "content"].some((value2) => (css3.contain || "").includes(value2));
}
function getContainingBlock(element2) {
  let currentNode = getParentNode(element2);
  while (isHTMLElement2(currentNode) && !isLastTraversableNode(currentNode)) {
    if (isContainingBlock(currentNode)) {
      return currentNode;
    } else if (isTopLayer(currentNode)) {
      return null;
    }
    currentNode = getParentNode(currentNode);
  }
  return null;
}
function isWebKit() {
  if (typeof CSS === "undefined" || !CSS.supports) return false;
  return CSS.supports("-webkit-backdrop-filter", "none");
}
function isLastTraversableNode(node2) {
  return ["html", "body", "#document"].includes(getNodeName(node2));
}
function getComputedStyle2(element2) {
  return getWindow2(element2).getComputedStyle(element2);
}
function getNodeScroll(element2) {
  if (isElement(element2)) {
    return {
      scrollLeft: element2.scrollLeft,
      scrollTop: element2.scrollTop
    };
  }
  return {
    scrollLeft: element2.scrollX,
    scrollTop: element2.scrollY
  };
}
function getParentNode(node2) {
  if (getNodeName(node2) === "html") {
    return node2;
  }
  const result = (
    // Step into the shadow DOM of the parent of a slotted node.
    node2.assignedSlot || // DOM Element detected.
    node2.parentNode || // ShadowRoot detected.
    isShadowRoot(node2) && node2.host || // Fallback.
    getDocumentElement(node2)
  );
  return isShadowRoot(result) ? result.host : result;
}
function getNearestOverflowAncestor(node2) {
  const parentNode = getParentNode(node2);
  if (isLastTraversableNode(parentNode)) {
    return node2.ownerDocument ? node2.ownerDocument.body : node2.body;
  }
  if (isHTMLElement2(parentNode) && isOverflowElement(parentNode)) {
    return parentNode;
  }
  return getNearestOverflowAncestor(parentNode);
}
function getOverflowAncestors(node2, list4, traverseIframes) {
  var _node$ownerDocument2;
  if (list4 === void 0) {
    list4 = [];
  }
  if (traverseIframes === void 0) {
    traverseIframes = true;
  }
  const scrollableAncestor = getNearestOverflowAncestor(node2);
  const isBody = scrollableAncestor === ((_node$ownerDocument2 = node2.ownerDocument) == null ? void 0 : _node$ownerDocument2.body);
  const win = getWindow2(scrollableAncestor);
  if (isBody) {
    const frameElement = getFrameElement(win);
    return list4.concat(win, win.visualViewport || [], isOverflowElement(scrollableAncestor) ? scrollableAncestor : [], frameElement && traverseIframes ? getOverflowAncestors(frameElement) : []);
  }
  return list4.concat(scrollableAncestor, getOverflowAncestors(scrollableAncestor, [], traverseIframes));
}
function getFrameElement(win) {
  return win.parent && Object.getPrototypeOf(win.parent) ? win.frameElement : null;
}

// node_modules/@floating-ui/dom/dist/floating-ui.dom.mjs
function getCssDimensions(element2) {
  const css3 = getComputedStyle2(element2);
  let width = parseFloat(css3.width) || 0;
  let height = parseFloat(css3.height) || 0;
  const hasOffset = isHTMLElement2(element2);
  const offsetWidth = hasOffset ? element2.offsetWidth : width;
  const offsetHeight = hasOffset ? element2.offsetHeight : height;
  const shouldFallback = round(width) !== offsetWidth || round(height) !== offsetHeight;
  if (shouldFallback) {
    width = offsetWidth;
    height = offsetHeight;
  }
  return {
    width,
    height,
    $: shouldFallback
  };
}
function unwrapElement(element2) {
  return !isElement(element2) ? element2.contextElement : element2;
}
function getScale(element2) {
  const domElement = unwrapElement(element2);
  if (!isHTMLElement2(domElement)) {
    return createCoords(1);
  }
  const rect = domElement.getBoundingClientRect();
  const {
    width,
    height,
    $: $3
  } = getCssDimensions(domElement);
  let x3 = ($3 ? round(rect.width) : rect.width) / width;
  let y2 = ($3 ? round(rect.height) : rect.height) / height;
  if (!x3 || !Number.isFinite(x3)) {
    x3 = 1;
  }
  if (!y2 || !Number.isFinite(y2)) {
    y2 = 1;
  }
  return {
    x: x3,
    y: y2
  };
}
var noOffsets = createCoords(0);
function getVisualOffsets(element2) {
  const win = getWindow2(element2);
  if (!isWebKit() || !win.visualViewport) {
    return noOffsets;
  }
  return {
    x: win.visualViewport.offsetLeft,
    y: win.visualViewport.offsetTop
  };
}
function shouldAddVisualOffsets(element2, isFixed, floatingOffsetParent) {
  if (isFixed === void 0) {
    isFixed = false;
  }
  if (!floatingOffsetParent || isFixed && floatingOffsetParent !== getWindow2(element2)) {
    return false;
  }
  return isFixed;
}
function getBoundingClientRect(element2, includeScale, isFixedStrategy, offsetParent) {
  if (includeScale === void 0) {
    includeScale = false;
  }
  if (isFixedStrategy === void 0) {
    isFixedStrategy = false;
  }
  const clientRect = element2.getBoundingClientRect();
  const domElement = unwrapElement(element2);
  let scale = createCoords(1);
  if (includeScale) {
    if (offsetParent) {
      if (isElement(offsetParent)) {
        scale = getScale(offsetParent);
      }
    } else {
      scale = getScale(element2);
    }
  }
  const visualOffsets = shouldAddVisualOffsets(domElement, isFixedStrategy, offsetParent) ? getVisualOffsets(domElement) : createCoords(0);
  let x3 = (clientRect.left + visualOffsets.x) / scale.x;
  let y2 = (clientRect.top + visualOffsets.y) / scale.y;
  let width = clientRect.width / scale.x;
  let height = clientRect.height / scale.y;
  if (domElement) {
    const win = getWindow2(domElement);
    const offsetWin = offsetParent && isElement(offsetParent) ? getWindow2(offsetParent) : offsetParent;
    let currentWin = win;
    let currentIFrame = getFrameElement(currentWin);
    while (currentIFrame && offsetParent && offsetWin !== currentWin) {
      const iframeScale = getScale(currentIFrame);
      const iframeRect = currentIFrame.getBoundingClientRect();
      const css3 = getComputedStyle2(currentIFrame);
      const left = iframeRect.left + (currentIFrame.clientLeft + parseFloat(css3.paddingLeft)) * iframeScale.x;
      const top = iframeRect.top + (currentIFrame.clientTop + parseFloat(css3.paddingTop)) * iframeScale.y;
      x3 *= iframeScale.x;
      y2 *= iframeScale.y;
      width *= iframeScale.x;
      height *= iframeScale.y;
      x3 += left;
      y2 += top;
      currentWin = getWindow2(currentIFrame);
      currentIFrame = getFrameElement(currentWin);
    }
  }
  return rectToClientRect({
    width,
    height,
    x: x3,
    y: y2
  });
}
function getWindowScrollBarX(element2, rect) {
  const leftScroll = getNodeScroll(element2).scrollLeft;
  if (!rect) {
    return getBoundingClientRect(getDocumentElement(element2)).left + leftScroll;
  }
  return rect.left + leftScroll;
}
function getHTMLOffset(documentElement, scroll, ignoreScrollbarX) {
  if (ignoreScrollbarX === void 0) {
    ignoreScrollbarX = false;
  }
  const htmlRect = documentElement.getBoundingClientRect();
  const x3 = htmlRect.left + scroll.scrollLeft - (ignoreScrollbarX ? 0 : (
    // RTL <body> scrollbar.
    getWindowScrollBarX(documentElement, htmlRect)
  ));
  const y2 = htmlRect.top + scroll.scrollTop;
  return {
    x: x3,
    y: y2
  };
}
function convertOffsetParentRelativeRectToViewportRelativeRect(_ref) {
  let {
    elements,
    rect,
    offsetParent,
    strategy
  } = _ref;
  const isFixed = strategy === "fixed";
  const documentElement = getDocumentElement(offsetParent);
  const topLayer = elements ? isTopLayer(elements.floating) : false;
  if (offsetParent === documentElement || topLayer && isFixed) {
    return rect;
  }
  let scroll = {
    scrollLeft: 0,
    scrollTop: 0
  };
  let scale = createCoords(1);
  const offsets = createCoords(0);
  const isOffsetParentAnElement = isHTMLElement2(offsetParent);
  if (isOffsetParentAnElement || !isOffsetParentAnElement && !isFixed) {
    if (getNodeName(offsetParent) !== "body" || isOverflowElement(documentElement)) {
      scroll = getNodeScroll(offsetParent);
    }
    if (isHTMLElement2(offsetParent)) {
      const offsetRect = getBoundingClientRect(offsetParent);
      scale = getScale(offsetParent);
      offsets.x = offsetRect.x + offsetParent.clientLeft;
      offsets.y = offsetRect.y + offsetParent.clientTop;
    }
  }
  const htmlOffset = documentElement && !isOffsetParentAnElement && !isFixed ? getHTMLOffset(documentElement, scroll, true) : createCoords(0);
  return {
    width: rect.width * scale.x,
    height: rect.height * scale.y,
    x: rect.x * scale.x - scroll.scrollLeft * scale.x + offsets.x + htmlOffset.x,
    y: rect.y * scale.y - scroll.scrollTop * scale.y + offsets.y + htmlOffset.y
  };
}
function getClientRects(element2) {
  return Array.from(element2.getClientRects());
}
function getDocumentRect(element2) {
  const html3 = getDocumentElement(element2);
  const scroll = getNodeScroll(element2);
  const body = element2.ownerDocument.body;
  const width = max(html3.scrollWidth, html3.clientWidth, body.scrollWidth, body.clientWidth);
  const height = max(html3.scrollHeight, html3.clientHeight, body.scrollHeight, body.clientHeight);
  let x3 = -scroll.scrollLeft + getWindowScrollBarX(element2);
  const y2 = -scroll.scrollTop;
  if (getComputedStyle2(body).direction === "rtl") {
    x3 += max(html3.clientWidth, body.clientWidth) - width;
  }
  return {
    width,
    height,
    x: x3,
    y: y2
  };
}
function getViewportRect(element2, strategy) {
  const win = getWindow2(element2);
  const html3 = getDocumentElement(element2);
  const visualViewport = win.visualViewport;
  let width = html3.clientWidth;
  let height = html3.clientHeight;
  let x3 = 0;
  let y2 = 0;
  if (visualViewport) {
    width = visualViewport.width;
    height = visualViewport.height;
    const visualViewportBased = isWebKit();
    if (!visualViewportBased || visualViewportBased && strategy === "fixed") {
      x3 = visualViewport.offsetLeft;
      y2 = visualViewport.offsetTop;
    }
  }
  return {
    width,
    height,
    x: x3,
    y: y2
  };
}
function getInnerBoundingClientRect(element2, strategy) {
  const clientRect = getBoundingClientRect(element2, true, strategy === "fixed");
  const top = clientRect.top + element2.clientTop;
  const left = clientRect.left + element2.clientLeft;
  const scale = isHTMLElement2(element2) ? getScale(element2) : createCoords(1);
  const width = element2.clientWidth * scale.x;
  const height = element2.clientHeight * scale.y;
  const x3 = left * scale.x;
  const y2 = top * scale.y;
  return {
    width,
    height,
    x: x3,
    y: y2
  };
}
function getClientRectFromClippingAncestor(element2, clippingAncestor, strategy) {
  let rect;
  if (clippingAncestor === "viewport") {
    rect = getViewportRect(element2, strategy);
  } else if (clippingAncestor === "document") {
    rect = getDocumentRect(getDocumentElement(element2));
  } else if (isElement(clippingAncestor)) {
    rect = getInnerBoundingClientRect(clippingAncestor, strategy);
  } else {
    const visualOffsets = getVisualOffsets(element2);
    rect = {
      x: clippingAncestor.x - visualOffsets.x,
      y: clippingAncestor.y - visualOffsets.y,
      width: clippingAncestor.width,
      height: clippingAncestor.height
    };
  }
  return rectToClientRect(rect);
}
function hasFixedPositionAncestor(element2, stopNode) {
  const parentNode = getParentNode(element2);
  if (parentNode === stopNode || !isElement(parentNode) || isLastTraversableNode(parentNode)) {
    return false;
  }
  return getComputedStyle2(parentNode).position === "fixed" || hasFixedPositionAncestor(parentNode, stopNode);
}
function getClippingElementAncestors(element2, cache) {
  const cachedResult = cache.get(element2);
  if (cachedResult) {
    return cachedResult;
  }
  let result = getOverflowAncestors(element2, [], false).filter((el) => isElement(el) && getNodeName(el) !== "body");
  let currentContainingBlockComputedStyle = null;
  const elementIsFixed = getComputedStyle2(element2).position === "fixed";
  let currentNode = elementIsFixed ? getParentNode(element2) : element2;
  while (isElement(currentNode) && !isLastTraversableNode(currentNode)) {
    const computedStyle = getComputedStyle2(currentNode);
    const currentNodeIsContaining = isContainingBlock(currentNode);
    if (!currentNodeIsContaining && computedStyle.position === "fixed") {
      currentContainingBlockComputedStyle = null;
    }
    const shouldDropCurrentNode = elementIsFixed ? !currentNodeIsContaining && !currentContainingBlockComputedStyle : !currentNodeIsContaining && computedStyle.position === "static" && !!currentContainingBlockComputedStyle && ["absolute", "fixed"].includes(currentContainingBlockComputedStyle.position) || isOverflowElement(currentNode) && !currentNodeIsContaining && hasFixedPositionAncestor(element2, currentNode);
    if (shouldDropCurrentNode) {
      result = result.filter((ancestor) => ancestor !== currentNode);
    } else {
      currentContainingBlockComputedStyle = computedStyle;
    }
    currentNode = getParentNode(currentNode);
  }
  cache.set(element2, result);
  return result;
}
function getClippingRect(_ref) {
  let {
    element: element2,
    boundary,
    rootBoundary,
    strategy
  } = _ref;
  const elementClippingAncestors = boundary === "clippingAncestors" ? isTopLayer(element2) ? [] : getClippingElementAncestors(element2, this._c) : [].concat(boundary);
  const clippingAncestors = [...elementClippingAncestors, rootBoundary];
  const firstClippingAncestor = clippingAncestors[0];
  const clippingRect = clippingAncestors.reduce((accRect, clippingAncestor) => {
    const rect = getClientRectFromClippingAncestor(element2, clippingAncestor, strategy);
    accRect.top = max(rect.top, accRect.top);
    accRect.right = min(rect.right, accRect.right);
    accRect.bottom = min(rect.bottom, accRect.bottom);
    accRect.left = max(rect.left, accRect.left);
    return accRect;
  }, getClientRectFromClippingAncestor(element2, firstClippingAncestor, strategy));
  return {
    width: clippingRect.right - clippingRect.left,
    height: clippingRect.bottom - clippingRect.top,
    x: clippingRect.left,
    y: clippingRect.top
  };
}
function getDimensions(element2) {
  const {
    width,
    height
  } = getCssDimensions(element2);
  return {
    width,
    height
  };
}
function getRectRelativeToOffsetParent(element2, offsetParent, strategy) {
  const isOffsetParentAnElement = isHTMLElement2(offsetParent);
  const documentElement = getDocumentElement(offsetParent);
  const isFixed = strategy === "fixed";
  const rect = getBoundingClientRect(element2, true, isFixed, offsetParent);
  let scroll = {
    scrollLeft: 0,
    scrollTop: 0
  };
  const offsets = createCoords(0);
  if (isOffsetParentAnElement || !isOffsetParentAnElement && !isFixed) {
    if (getNodeName(offsetParent) !== "body" || isOverflowElement(documentElement)) {
      scroll = getNodeScroll(offsetParent);
    }
    if (isOffsetParentAnElement) {
      const offsetRect = getBoundingClientRect(offsetParent, true, isFixed, offsetParent);
      offsets.x = offsetRect.x + offsetParent.clientLeft;
      offsets.y = offsetRect.y + offsetParent.clientTop;
    } else if (documentElement) {
      offsets.x = getWindowScrollBarX(documentElement);
    }
  }
  const htmlOffset = documentElement && !isOffsetParentAnElement && !isFixed ? getHTMLOffset(documentElement, scroll) : createCoords(0);
  const x3 = rect.left + scroll.scrollLeft - offsets.x - htmlOffset.x;
  const y2 = rect.top + scroll.scrollTop - offsets.y - htmlOffset.y;
  return {
    x: x3,
    y: y2,
    width: rect.width,
    height: rect.height
  };
}
function isStaticPositioned(element2) {
  return getComputedStyle2(element2).position === "static";
}
function getTrueOffsetParent(element2, polyfill) {
  if (!isHTMLElement2(element2) || getComputedStyle2(element2).position === "fixed") {
    return null;
  }
  if (polyfill) {
    return polyfill(element2);
  }
  let rawOffsetParent = element2.offsetParent;
  if (getDocumentElement(element2) === rawOffsetParent) {
    rawOffsetParent = rawOffsetParent.ownerDocument.body;
  }
  return rawOffsetParent;
}
function getOffsetParent(element2, polyfill) {
  const win = getWindow2(element2);
  if (isTopLayer(element2)) {
    return win;
  }
  if (!isHTMLElement2(element2)) {
    let svgOffsetParent = getParentNode(element2);
    while (svgOffsetParent && !isLastTraversableNode(svgOffsetParent)) {
      if (isElement(svgOffsetParent) && !isStaticPositioned(svgOffsetParent)) {
        return svgOffsetParent;
      }
      svgOffsetParent = getParentNode(svgOffsetParent);
    }
    return win;
  }
  let offsetParent = getTrueOffsetParent(element2, polyfill);
  while (offsetParent && isTableElement(offsetParent) && isStaticPositioned(offsetParent)) {
    offsetParent = getTrueOffsetParent(offsetParent, polyfill);
  }
  if (offsetParent && isLastTraversableNode(offsetParent) && isStaticPositioned(offsetParent) && !isContainingBlock(offsetParent)) {
    return win;
  }
  return offsetParent || getContainingBlock(element2) || win;
}
var getElementRects = async function(data2) {
  const getOffsetParentFn = this.getOffsetParent || getOffsetParent;
  const getDimensionsFn = this.getDimensions;
  const floatingDimensions = await getDimensionsFn(data2.floating);
  return {
    reference: getRectRelativeToOffsetParent(data2.reference, await getOffsetParentFn(data2.floating), data2.strategy),
    floating: {
      x: 0,
      y: 0,
      width: floatingDimensions.width,
      height: floatingDimensions.height
    }
  };
};
function isRTL(element2) {
  return getComputedStyle2(element2).direction === "rtl";
}
var platform = {
  convertOffsetParentRelativeRectToViewportRelativeRect,
  getDocumentElement,
  getClippingRect,
  getOffsetParent,
  getElementRects,
  getClientRects,
  getDimensions,
  getScale,
  isElement,
  isRTL
};
function rectsAreEqual(a2, b3) {
  return a2.x === b3.x && a2.y === b3.y && a2.width === b3.width && a2.height === b3.height;
}
function observeMove(element2, onMove) {
  let io = null;
  let timeoutId;
  const root2 = getDocumentElement(element2);
  function cleanup() {
    var _io;
    clearTimeout(timeoutId);
    (_io = io) == null || _io.disconnect();
    io = null;
  }
  function refresh(skip, threshold) {
    if (skip === void 0) {
      skip = false;
    }
    if (threshold === void 0) {
      threshold = 1;
    }
    cleanup();
    const elementRectForRootMargin = element2.getBoundingClientRect();
    const {
      left,
      top,
      width,
      height
    } = elementRectForRootMargin;
    if (!skip) {
      onMove();
    }
    if (!width || !height) {
      return;
    }
    const insetTop = floor(top);
    const insetRight = floor(root2.clientWidth - (left + width));
    const insetBottom = floor(root2.clientHeight - (top + height));
    const insetLeft = floor(left);
    const rootMargin = -insetTop + "px " + -insetRight + "px " + -insetBottom + "px " + -insetLeft + "px";
    const options = {
      rootMargin,
      threshold: max(0, min(1, threshold)) || 1
    };
    let isFirstUpdate = true;
    function handleObserve(entries2) {
      const ratio = entries2[0].intersectionRatio;
      if (ratio !== threshold) {
        if (!isFirstUpdate) {
          return refresh();
        }
        if (!ratio) {
          timeoutId = setTimeout(() => {
            refresh(false, 1e-7);
          }, 1e3);
        } else {
          refresh(false, ratio);
        }
      }
      if (ratio === 1 && !rectsAreEqual(elementRectForRootMargin, element2.getBoundingClientRect())) {
        refresh();
      }
      isFirstUpdate = false;
    }
    try {
      io = new IntersectionObserver(handleObserve, {
        ...options,
        // Handle <iframe>s
        root: root2.ownerDocument
      });
    } catch (e2) {
      io = new IntersectionObserver(handleObserve, options);
    }
    io.observe(element2);
  }
  refresh(true);
  return cleanup;
}
function autoUpdate(reference, floating, update, options) {
  if (options === void 0) {
    options = {};
  }
  const {
    ancestorScroll = true,
    ancestorResize = true,
    elementResize = typeof ResizeObserver === "function",
    layoutShift = typeof IntersectionObserver === "function",
    animationFrame = false
  } = options;
  const referenceEl = unwrapElement(reference);
  const ancestors = ancestorScroll || ancestorResize ? [...referenceEl ? getOverflowAncestors(referenceEl) : [], ...getOverflowAncestors(floating)] : [];
  ancestors.forEach((ancestor) => {
    ancestorScroll && ancestor.addEventListener("scroll", update, {
      passive: true
    });
    ancestorResize && ancestor.addEventListener("resize", update);
  });
  const cleanupIo = referenceEl && layoutShift ? observeMove(referenceEl, update) : null;
  let reobserveFrame = -1;
  let resizeObserver = null;
  if (elementResize) {
    resizeObserver = new ResizeObserver((_ref) => {
      let [firstEntry] = _ref;
      if (firstEntry && firstEntry.target === referenceEl && resizeObserver) {
        resizeObserver.unobserve(floating);
        cancelAnimationFrame(reobserveFrame);
        reobserveFrame = requestAnimationFrame(() => {
          var _resizeObserver;
          (_resizeObserver = resizeObserver) == null || _resizeObserver.observe(floating);
        });
      }
      update();
    });
    if (referenceEl && !animationFrame) {
      resizeObserver.observe(referenceEl);
    }
    resizeObserver.observe(floating);
  }
  let frameId;
  let prevRefRect = animationFrame ? getBoundingClientRect(reference) : null;
  if (animationFrame) {
    frameLoop();
  }
  function frameLoop() {
    const nextRefRect = getBoundingClientRect(reference);
    if (prevRefRect && !rectsAreEqual(prevRefRect, nextRefRect)) {
      update();
    }
    prevRefRect = nextRefRect;
    frameId = requestAnimationFrame(frameLoop);
  }
  update();
  return () => {
    var _resizeObserver2;
    ancestors.forEach((ancestor) => {
      ancestorScroll && ancestor.removeEventListener("scroll", update);
      ancestorResize && ancestor.removeEventListener("resize", update);
    });
    cleanupIo == null || cleanupIo();
    (_resizeObserver2 = resizeObserver) == null || _resizeObserver2.disconnect();
    resizeObserver = null;
    if (animationFrame) {
      cancelAnimationFrame(frameId);
    }
  };
}
var offset2 = offset;
var shift2 = shift;
var flip2 = flip;
var size2 = size;
var hide2 = hide;
var arrow2 = arrow;
var limitShift2 = limitShift;
var computePosition2 = (reference, floating, options) => {
  const cache = /* @__PURE__ */ new Map();
  const mergedOptions = {
    platform,
    ...options
  };
  const platformWithCache = {
    ...mergedOptions.platform,
    _c: cache
  };
  return computePosition(reference, floating, {
    ...mergedOptions,
    platform: platformWithCache
  });
};

// node_modules/@floating-ui/react-dom/dist/floating-ui.react-dom.mjs
var React13 = __toESM(require_react(), 1);
var import_react18 = __toESM(require_react(), 1);
var ReactDOM2 = __toESM(require_react_dom(), 1);
var index2 = typeof document !== "undefined" ? import_react18.useLayoutEffect : import_react18.useEffect;
function deepEqual(a2, b3) {
  if (a2 === b3) {
    return true;
  }
  if (typeof a2 !== typeof b3) {
    return false;
  }
  if (typeof a2 === "function" && a2.toString() === b3.toString()) {
    return true;
  }
  let length;
  let i3;
  let keys;
  if (a2 && b3 && typeof a2 === "object") {
    if (Array.isArray(a2)) {
      length = a2.length;
      if (length !== b3.length) return false;
      for (i3 = length; i3-- !== 0; ) {
        if (!deepEqual(a2[i3], b3[i3])) {
          return false;
        }
      }
      return true;
    }
    keys = Object.keys(a2);
    length = keys.length;
    if (length !== Object.keys(b3).length) {
      return false;
    }
    for (i3 = length; i3-- !== 0; ) {
      if (!{}.hasOwnProperty.call(b3, keys[i3])) {
        return false;
      }
    }
    for (i3 = length; i3-- !== 0; ) {
      const key2 = keys[i3];
      if (key2 === "_owner" && a2.$$typeof) {
        continue;
      }
      if (!deepEqual(a2[key2], b3[key2])) {
        return false;
      }
    }
    return true;
  }
  return a2 !== a2 && b3 !== b3;
}
function getDPR(element2) {
  if (typeof window === "undefined") {
    return 1;
  }
  const win = element2.ownerDocument.defaultView || window;
  return win.devicePixelRatio || 1;
}
function roundByDPR(element2, value2) {
  const dpr = getDPR(element2);
  return Math.round(value2 * dpr) / dpr;
}
function useLatestRef(value2) {
  const ref2 = React13.useRef(value2);
  index2(() => {
    ref2.current = value2;
  });
  return ref2;
}
function useFloating(options) {
  if (options === void 0) {
    options = {};
  }
  const {
    placement = "bottom",
    strategy = "absolute",
    middleware = [],
    platform: platform2,
    elements: {
      reference: externalReference,
      floating: externalFloating
    } = {},
    transform = true,
    whileElementsMounted,
    open
  } = options;
  const [data2, setData] = React13.useState({
    x: 0,
    y: 0,
    strategy,
    placement,
    middlewareData: {},
    isPositioned: false
  });
  const [latestMiddleware, setLatestMiddleware] = React13.useState(middleware);
  if (!deepEqual(latestMiddleware, middleware)) {
    setLatestMiddleware(middleware);
  }
  const [_reference, _setReference] = React13.useState(null);
  const [_floating, _setFloating] = React13.useState(null);
  const setReference = React13.useCallback((node2) => {
    if (node2 !== referenceRef.current) {
      referenceRef.current = node2;
      _setReference(node2);
    }
  }, []);
  const setFloating = React13.useCallback((node2) => {
    if (node2 !== floatingRef.current) {
      floatingRef.current = node2;
      _setFloating(node2);
    }
  }, []);
  const referenceEl = externalReference || _reference;
  const floatingEl = externalFloating || _floating;
  const referenceRef = React13.useRef(null);
  const floatingRef = React13.useRef(null);
  const dataRef = React13.useRef(data2);
  const hasWhileElementsMounted = whileElementsMounted != null;
  const whileElementsMountedRef = useLatestRef(whileElementsMounted);
  const platformRef = useLatestRef(platform2);
  const openRef = useLatestRef(open);
  const update = React13.useCallback(() => {
    if (!referenceRef.current || !floatingRef.current) {
      return;
    }
    const config = {
      placement,
      strategy,
      middleware: latestMiddleware
    };
    if (platformRef.current) {
      config.platform = platformRef.current;
    }
    computePosition2(referenceRef.current, floatingRef.current, config).then((data3) => {
      const fullData = {
        ...data3,
        // The floating element's position may be recomputed while it's closed
        // but still mounted (such as when transitioning out). To ensure
        // `isPositioned` will be `false` initially on the next open, avoid
        // setting it to `true` when `open === false` (must be specified).
        isPositioned: openRef.current !== false
      };
      if (isMountedRef.current && !deepEqual(dataRef.current, fullData)) {
        dataRef.current = fullData;
        ReactDOM2.flushSync(() => {
          setData(fullData);
        });
      }
    });
  }, [latestMiddleware, placement, strategy, platformRef, openRef]);
  index2(() => {
    if (open === false && dataRef.current.isPositioned) {
      dataRef.current.isPositioned = false;
      setData((data3) => ({
        ...data3,
        isPositioned: false
      }));
    }
  }, [open]);
  const isMountedRef = React13.useRef(false);
  index2(() => {
    isMountedRef.current = true;
    return () => {
      isMountedRef.current = false;
    };
  }, []);
  index2(() => {
    if (referenceEl) referenceRef.current = referenceEl;
    if (floatingEl) floatingRef.current = floatingEl;
    if (referenceEl && floatingEl) {
      if (whileElementsMountedRef.current) {
        return whileElementsMountedRef.current(referenceEl, floatingEl, update);
      }
      update();
    }
  }, [referenceEl, floatingEl, update, whileElementsMountedRef, hasWhileElementsMounted]);
  const refs = React13.useMemo(() => ({
    reference: referenceRef,
    floating: floatingRef,
    setReference,
    setFloating
  }), [setReference, setFloating]);
  const elements = React13.useMemo(() => ({
    reference: referenceEl,
    floating: floatingEl
  }), [referenceEl, floatingEl]);
  const floatingStyles = React13.useMemo(() => {
    const initialStyles = {
      position: strategy,
      left: 0,
      top: 0
    };
    if (!elements.floating) {
      return initialStyles;
    }
    const x3 = roundByDPR(elements.floating, data2.x);
    const y2 = roundByDPR(elements.floating, data2.y);
    if (transform) {
      return {
        ...initialStyles,
        transform: "translate(" + x3 + "px, " + y2 + "px)",
        ...getDPR(elements.floating) >= 1.5 && {
          willChange: "transform"
        }
      };
    }
    return {
      position: strategy,
      left: x3,
      top: y2
    };
  }, [strategy, transform, elements.floating, data2.x, data2.y]);
  return React13.useMemo(() => ({
    ...data2,
    update,
    refs,
    elements,
    floatingStyles
  }), [data2, update, refs, elements, floatingStyles]);
}
var arrow$1 = (options) => {
  function isRef(value2) {
    return {}.hasOwnProperty.call(value2, "current");
  }
  return {
    name: "arrow",
    options,
    fn(state) {
      const {
        element: element2,
        padding
      } = typeof options === "function" ? options(state) : options;
      if (element2 && isRef(element2)) {
        if (element2.current != null) {
          return arrow2({
            element: element2.current,
            padding
          }).fn(state);
        }
        return {};
      }
      if (element2) {
        return arrow2({
          element: element2,
          padding
        }).fn(state);
      }
      return {};
    }
  };
};
var offset3 = (options, deps) => ({
  ...offset2(options),
  options: [options, deps]
});
var shift3 = (options, deps) => ({
  ...shift2(options),
  options: [options, deps]
});
var limitShift3 = (options, deps) => ({
  ...limitShift2(options),
  options: [options, deps]
});
var flip3 = (options, deps) => ({
  ...flip2(options),
  options: [options, deps]
});
var size3 = (options, deps) => ({
  ...size2(options),
  options: [options, deps]
});
var hide3 = (options, deps) => ({
  ...hide2(options),
  options: [options, deps]
});
var arrow3 = (options, deps) => ({
  ...arrow$1(options),
  options: [options, deps]
});

// node_modules/@radix-ui/react-arrow/dist/index.mjs
var React14 = __toESM(require_react(), 1);
var import_jsx_runtime12 = __toESM(require_jsx_runtime(), 1);
var NAME = "Arrow";
var Arrow = React14.forwardRef((props, forwardedRef) => {
  const { children, width = 10, height = 5, ...arrowProps } = props;
  return (0, import_jsx_runtime12.jsx)(
    Primitive.svg,
    {
      ...arrowProps,
      ref: forwardedRef,
      width,
      height,
      viewBox: "0 0 30 10",
      preserveAspectRatio: "none",
      children: props.asChild ? children : (0, import_jsx_runtime12.jsx)("polygon", { points: "0,0 30,0 15,10" })
    }
  );
});
Arrow.displayName = NAME;
var Root = Arrow;

// node_modules/@radix-ui/react-use-size/dist/index.mjs
var React15 = __toESM(require_react(), 1);
function useSize(element2) {
  const [size4, setSize] = React15.useState(void 0);
  useLayoutEffect22(() => {
    if (element2) {
      setSize({ width: element2.offsetWidth, height: element2.offsetHeight });
      const resizeObserver = new ResizeObserver((entries2) => {
        if (!Array.isArray(entries2)) {
          return;
        }
        if (!entries2.length) {
          return;
        }
        const entry = entries2[0];
        let width;
        let height;
        if ("borderBoxSize" in entry) {
          const borderSizeEntry = entry["borderBoxSize"];
          const borderSize = Array.isArray(borderSizeEntry) ? borderSizeEntry[0] : borderSizeEntry;
          width = borderSize["inlineSize"];
          height = borderSize["blockSize"];
        } else {
          width = element2.offsetWidth;
          height = element2.offsetHeight;
        }
        setSize({ width, height });
      });
      resizeObserver.observe(element2, { box: "border-box" });
      return () => resizeObserver.unobserve(element2);
    } else {
      setSize(void 0);
    }
  }, [element2]);
  return size4;
}

// node_modules/@radix-ui/react-popper/dist/index.mjs
var import_jsx_runtime13 = __toESM(require_jsx_runtime(), 1);
var POPPER_NAME = "Popper";
var [createPopperContext, createPopperScope] = createContextScope(POPPER_NAME);
var [PopperProvider, usePopperContext] = createPopperContext(POPPER_NAME);
var Popper = (props) => {
  const { __scopePopper, children } = props;
  const [anchor, setAnchor] = React16.useState(null);
  return (0, import_jsx_runtime13.jsx)(PopperProvider, { scope: __scopePopper, anchor, onAnchorChange: setAnchor, children });
};
Popper.displayName = POPPER_NAME;
var ANCHOR_NAME = "PopperAnchor";
var PopperAnchor = React16.forwardRef(
  (props, forwardedRef) => {
    const { __scopePopper, virtualRef, ...anchorProps } = props;
    const context = usePopperContext(ANCHOR_NAME, __scopePopper);
    const ref2 = React16.useRef(null);
    const composedRefs = useComposedRefs(forwardedRef, ref2);
    React16.useEffect(() => {
      context.onAnchorChange((virtualRef == null ? void 0 : virtualRef.current) || ref2.current);
    });
    return virtualRef ? null : (0, import_jsx_runtime13.jsx)(Primitive.div, { ...anchorProps, ref: composedRefs });
  }
);
PopperAnchor.displayName = ANCHOR_NAME;
var CONTENT_NAME = "PopperContent";
var [PopperContentProvider, useContentContext] = createPopperContext(CONTENT_NAME);
var PopperContent = React16.forwardRef(
  (props, forwardedRef) => {
    var _a2, _b2, _c2, _d, _e, _f;
    const {
      __scopePopper,
      side = "bottom",
      sideOffset = 0,
      align = "center",
      alignOffset = 0,
      arrowPadding = 0,
      avoidCollisions = true,
      collisionBoundary = [],
      collisionPadding: collisionPaddingProp = 0,
      sticky = "partial",
      hideWhenDetached = false,
      updatePositionStrategy = "optimized",
      onPlaced,
      ...contentProps
    } = props;
    const context = usePopperContext(CONTENT_NAME, __scopePopper);
    const [content3, setContent2] = React16.useState(null);
    const composedRefs = useComposedRefs(forwardedRef, (node2) => setContent2(node2));
    const [arrow4, setArrow] = React16.useState(null);
    const arrowSize = useSize(arrow4);
    const arrowWidth = (arrowSize == null ? void 0 : arrowSize.width) ?? 0;
    const arrowHeight = (arrowSize == null ? void 0 : arrowSize.height) ?? 0;
    const desiredPlacement = side + (align !== "center" ? "-" + align : "");
    const collisionPadding = typeof collisionPaddingProp === "number" ? collisionPaddingProp : { top: 0, right: 0, bottom: 0, left: 0, ...collisionPaddingProp };
    const boundary = Array.isArray(collisionBoundary) ? collisionBoundary : [collisionBoundary];
    const hasExplicitBoundaries = boundary.length > 0;
    const detectOverflowOptions = {
      padding: collisionPadding,
      boundary: boundary.filter(isNotNull),
      // with `strategy: 'fixed'`, this is the only way to get it to respect boundaries
      altBoundary: hasExplicitBoundaries
    };
    const { refs, floatingStyles, placement, isPositioned, middlewareData } = useFloating({
      // default to `fixed` strategy so users don't have to pick and we also avoid focus scroll issues
      strategy: "fixed",
      placement: desiredPlacement,
      whileElementsMounted: (...args) => {
        const cleanup = autoUpdate(...args, {
          animationFrame: updatePositionStrategy === "always"
        });
        return cleanup;
      },
      elements: {
        reference: context.anchor
      },
      middleware: [
        offset3({ mainAxis: sideOffset + arrowHeight, alignmentAxis: alignOffset }),
        avoidCollisions && shift3({
          mainAxis: true,
          crossAxis: false,
          limiter: sticky === "partial" ? limitShift3() : void 0,
          ...detectOverflowOptions
        }),
        avoidCollisions && flip3({ ...detectOverflowOptions }),
        size3({
          ...detectOverflowOptions,
          apply: ({ elements, rects, availableWidth, availableHeight }) => {
            const { width: anchorWidth, height: anchorHeight } = rects.reference;
            const contentStyle = elements.floating.style;
            contentStyle.setProperty("--radix-popper-available-width", `${availableWidth}px`);
            contentStyle.setProperty("--radix-popper-available-height", `${availableHeight}px`);
            contentStyle.setProperty("--radix-popper-anchor-width", `${anchorWidth}px`);
            contentStyle.setProperty("--radix-popper-anchor-height", `${anchorHeight}px`);
          }
        }),
        arrow4 && arrow3({ element: arrow4, padding: arrowPadding }),
        transformOrigin({ arrowWidth, arrowHeight }),
        hideWhenDetached && hide3({ strategy: "referenceHidden", ...detectOverflowOptions })
      ]
    });
    const [placedSide, placedAlign] = getSideAndAlignFromPlacement(placement);
    const handlePlaced = useCallbackRef(onPlaced);
    useLayoutEffect22(() => {
      if (isPositioned) {
        handlePlaced == null ? void 0 : handlePlaced();
      }
    }, [isPositioned, handlePlaced]);
    const arrowX = (_a2 = middlewareData.arrow) == null ? void 0 : _a2.x;
    const arrowY = (_b2 = middlewareData.arrow) == null ? void 0 : _b2.y;
    const cannotCenterArrow = ((_c2 = middlewareData.arrow) == null ? void 0 : _c2.centerOffset) !== 0;
    const [contentZIndex, setContentZIndex] = React16.useState();
    useLayoutEffect22(() => {
      if (content3) setContentZIndex(window.getComputedStyle(content3).zIndex);
    }, [content3]);
    return (0, import_jsx_runtime13.jsx)(
      "div",
      {
        ref: refs.setFloating,
        "data-radix-popper-content-wrapper": "",
        style: {
          ...floatingStyles,
          transform: isPositioned ? floatingStyles.transform : "translate(0, -200%)",
          // keep off the page when measuring
          minWidth: "max-content",
          zIndex: contentZIndex,
          ["--radix-popper-transform-origin"]: [
            (_d = middlewareData.transformOrigin) == null ? void 0 : _d.x,
            (_e = middlewareData.transformOrigin) == null ? void 0 : _e.y
          ].join(" "),
          // hide the content if using the hide middleware and should be hidden
          // set visibility to hidden and disable pointer events so the UI behaves
          // as if the PopperContent isn't there at all
          ...((_f = middlewareData.hide) == null ? void 0 : _f.referenceHidden) && {
            visibility: "hidden",
            pointerEvents: "none"
          }
        },
        dir: props.dir,
        children: (0, import_jsx_runtime13.jsx)(
          PopperContentProvider,
          {
            scope: __scopePopper,
            placedSide,
            onArrowChange: setArrow,
            arrowX,
            arrowY,
            shouldHideArrow: cannotCenterArrow,
            children: (0, import_jsx_runtime13.jsx)(
              Primitive.div,
              {
                "data-side": placedSide,
                "data-align": placedAlign,
                ...contentProps,
                ref: composedRefs,
                style: {
                  ...contentProps.style,
                  // if the PopperContent hasn't been placed yet (not all measurements done)
                  // we prevent animations so that users's animation don't kick in too early referring wrong sides
                  animation: !isPositioned ? "none" : void 0
                }
              }
            )
          }
        )
      }
    );
  }
);
PopperContent.displayName = CONTENT_NAME;
var ARROW_NAME = "PopperArrow";
var OPPOSITE_SIDE = {
  top: "bottom",
  right: "left",
  bottom: "top",
  left: "right"
};
var PopperArrow = React16.forwardRef(function PopperArrow2(props, forwardedRef) {
  const { __scopePopper, ...arrowProps } = props;
  const contentContext = useContentContext(ARROW_NAME, __scopePopper);
  const baseSide = OPPOSITE_SIDE[contentContext.placedSide];
  return (
    // we have to use an extra wrapper because `ResizeObserver` (used by `useSize`)
    // doesn't report size as we'd expect on SVG elements.
    // it reports their bounding box which is effectively the largest path inside the SVG.
    (0, import_jsx_runtime13.jsx)(
      "span",
      {
        ref: contentContext.onArrowChange,
        style: {
          position: "absolute",
          left: contentContext.arrowX,
          top: contentContext.arrowY,
          [baseSide]: 0,
          transformOrigin: {
            top: "",
            right: "0 0",
            bottom: "center 0",
            left: "100% 0"
          }[contentContext.placedSide],
          transform: {
            top: "translateY(100%)",
            right: "translateY(50%) rotate(90deg) translateX(-50%)",
            bottom: `rotate(180deg)`,
            left: "translateY(50%) rotate(-90deg) translateX(50%)"
          }[contentContext.placedSide],
          visibility: contentContext.shouldHideArrow ? "hidden" : void 0
        },
        children: (0, import_jsx_runtime13.jsx)(
          Root,
          {
            ...arrowProps,
            ref: forwardedRef,
            style: {
              ...arrowProps.style,
              // ensures the element can be measured correctly (mostly for if SVG)
              display: "block"
            }
          }
        )
      }
    )
  );
});
PopperArrow.displayName = ARROW_NAME;
function isNotNull(value2) {
  return value2 !== null;
}
var transformOrigin = (options) => ({
  name: "transformOrigin",
  options,
  fn(data2) {
    var _a2, _b2, _c2;
    const { placement, rects, middlewareData } = data2;
    const cannotCenterArrow = ((_a2 = middlewareData.arrow) == null ? void 0 : _a2.centerOffset) !== 0;
    const isArrowHidden = cannotCenterArrow;
    const arrowWidth = isArrowHidden ? 0 : options.arrowWidth;
    const arrowHeight = isArrowHidden ? 0 : options.arrowHeight;
    const [placedSide, placedAlign] = getSideAndAlignFromPlacement(placement);
    const noArrowAlign = { start: "0%", center: "50%", end: "100%" }[placedAlign];
    const arrowXCenter = (((_b2 = middlewareData.arrow) == null ? void 0 : _b2.x) ?? 0) + arrowWidth / 2;
    const arrowYCenter = (((_c2 = middlewareData.arrow) == null ? void 0 : _c2.y) ?? 0) + arrowHeight / 2;
    let x3 = "";
    let y2 = "";
    if (placedSide === "bottom") {
      x3 = isArrowHidden ? noArrowAlign : `${arrowXCenter}px`;
      y2 = `${-arrowHeight}px`;
    } else if (placedSide === "top") {
      x3 = isArrowHidden ? noArrowAlign : `${arrowXCenter}px`;
      y2 = `${rects.floating.height + arrowHeight}px`;
    } else if (placedSide === "right") {
      x3 = `${-arrowHeight}px`;
      y2 = isArrowHidden ? noArrowAlign : `${arrowYCenter}px`;
    } else if (placedSide === "left") {
      x3 = `${rects.floating.width + arrowHeight}px`;
      y2 = isArrowHidden ? noArrowAlign : `${arrowYCenter}px`;
    }
    return { data: { x: x3, y: y2 } };
  }
});
function getSideAndAlignFromPlacement(placement) {
  const [side, align = "center"] = placement.split("-");
  return [side, align];
}
var Root2 = Popper;
var Anchor = PopperAnchor;
var Content = PopperContent;
var Arrow2 = PopperArrow;

// node_modules/@radix-ui/react-portal/dist/index.mjs
var React17 = __toESM(require_react(), 1);
var import_react_dom3 = __toESM(require_react_dom(), 1);
var import_jsx_runtime14 = __toESM(require_jsx_runtime(), 1);
var PORTAL_NAME = "Portal";
var Portal = React17.forwardRef((props, forwardedRef) => {
  var _a2;
  const { container: containerProp, ...portalProps } = props;
  const [mounted, setMounted] = React17.useState(false);
  useLayoutEffect22(() => setMounted(true), []);
  const container = containerProp || mounted && ((_a2 = globalThis == null ? void 0 : globalThis.document) == null ? void 0 : _a2.body);
  return container ? import_react_dom3.default.createPortal((0, import_jsx_runtime14.jsx)(Primitive.div, { ...portalProps, ref: forwardedRef }), container) : null;
});
Portal.displayName = PORTAL_NAME;

// node_modules/@radix-ui/react-presence/dist/index.mjs
var React22 = __toESM(require_react(), 1);
var React18 = __toESM(require_react(), 1);
function useStateMachine(initialState2, machine) {
  return React18.useReducer((state, event) => {
    const nextState = machine[state][event];
    return nextState ?? state;
  }, initialState2);
}
var Presence = (props) => {
  const { present, children } = props;
  const presence = usePresence(present);
  const child = typeof children === "function" ? children({ present: presence.isPresent }) : React22.Children.only(children);
  const ref2 = useComposedRefs(presence.ref, getElementRef2(child));
  const forceMount = typeof children === "function";
  return forceMount || presence.isPresent ? React22.cloneElement(child, { ref: ref2 }) : null;
};
Presence.displayName = "Presence";
function usePresence(present) {
  const [node2, setNode] = React22.useState();
  const stylesRef = React22.useRef({});
  const prevPresentRef = React22.useRef(present);
  const prevAnimationNameRef = React22.useRef("none");
  const initialState2 = present ? "mounted" : "unmounted";
  const [state, send] = useStateMachine(initialState2, {
    mounted: {
      UNMOUNT: "unmounted",
      ANIMATION_OUT: "unmountSuspended"
    },
    unmountSuspended: {
      MOUNT: "mounted",
      ANIMATION_END: "unmounted"
    },
    unmounted: {
      MOUNT: "mounted"
    }
  });
  React22.useEffect(() => {
    const currentAnimationName = getAnimationName(stylesRef.current);
    prevAnimationNameRef.current = state === "mounted" ? currentAnimationName : "none";
  }, [state]);
  useLayoutEffect22(() => {
    const styles2 = stylesRef.current;
    const wasPresent = prevPresentRef.current;
    const hasPresentChanged = wasPresent !== present;
    if (hasPresentChanged) {
      const prevAnimationName = prevAnimationNameRef.current;
      const currentAnimationName = getAnimationName(styles2);
      if (present) {
        send("MOUNT");
      } else if (currentAnimationName === "none" || (styles2 == null ? void 0 : styles2.display) === "none") {
        send("UNMOUNT");
      } else {
        const isAnimating = prevAnimationName !== currentAnimationName;
        if (wasPresent && isAnimating) {
          send("ANIMATION_OUT");
        } else {
          send("UNMOUNT");
        }
      }
      prevPresentRef.current = present;
    }
  }, [present, send]);
  useLayoutEffect22(() => {
    if (node2) {
      let timeoutId;
      const ownerWindow = node2.ownerDocument.defaultView ?? window;
      const handleAnimationEnd = (event) => {
        const currentAnimationName = getAnimationName(stylesRef.current);
        const isCurrentAnimation = currentAnimationName.includes(event.animationName);
        if (event.target === node2 && isCurrentAnimation) {
          send("ANIMATION_END");
          if (!prevPresentRef.current) {
            const currentFillMode = node2.style.animationFillMode;
            node2.style.animationFillMode = "forwards";
            timeoutId = ownerWindow.setTimeout(() => {
              if (node2.style.animationFillMode === "forwards") {
                node2.style.animationFillMode = currentFillMode;
              }
            });
          }
        }
      };
      const handleAnimationStart = (event) => {
        if (event.target === node2) {
          prevAnimationNameRef.current = getAnimationName(stylesRef.current);
        }
      };
      node2.addEventListener("animationstart", handleAnimationStart);
      node2.addEventListener("animationcancel", handleAnimationEnd);
      node2.addEventListener("animationend", handleAnimationEnd);
      return () => {
        ownerWindow.clearTimeout(timeoutId);
        node2.removeEventListener("animationstart", handleAnimationStart);
        node2.removeEventListener("animationcancel", handleAnimationEnd);
        node2.removeEventListener("animationend", handleAnimationEnd);
      };
    } else {
      send("ANIMATION_END");
    }
  }, [node2, send]);
  return {
    isPresent: ["mounted", "unmountSuspended"].includes(state),
    ref: React22.useCallback((node22) => {
      if (node22) stylesRef.current = getComputedStyle(node22);
      setNode(node22);
    }, [])
  };
}
function getAnimationName(styles2) {
  return (styles2 == null ? void 0 : styles2.animationName) || "none";
}
function getElementRef2(element2) {
  var _a2, _b2;
  let getter = (_a2 = Object.getOwnPropertyDescriptor(element2.props, "ref")) == null ? void 0 : _a2.get;
  let mayWarn = getter && "isReactWarning" in getter && getter.isReactWarning;
  if (mayWarn) {
    return element2.ref;
  }
  getter = (_b2 = Object.getOwnPropertyDescriptor(element2, "ref")) == null ? void 0 : _b2.get;
  mayWarn = getter && "isReactWarning" in getter && getter.isReactWarning;
  if (mayWarn) {
    return element2.props.ref;
  }
  return element2.props.ref || element2.ref;
}

// node_modules/@radix-ui/react-use-controllable-state/dist/index.mjs
var React19 = __toESM(require_react(), 1);
function useControllableState({
  prop: prop2,
  defaultProp,
  onChange = () => {
  }
}) {
  const [uncontrolledProp, setUncontrolledProp] = useUncontrolledState({ defaultProp, onChange });
  const isControlled = prop2 !== void 0;
  const value2 = isControlled ? prop2 : uncontrolledProp;
  const handleChange = useCallbackRef(onChange);
  const setValue = React19.useCallback(
    (nextValue) => {
      if (isControlled) {
        const setter = nextValue;
        const value22 = typeof nextValue === "function" ? setter(prop2) : nextValue;
        if (value22 !== prop2) handleChange(value22);
      } else {
        setUncontrolledProp(nextValue);
      }
    },
    [isControlled, prop2, setUncontrolledProp, handleChange]
  );
  return [value2, setValue];
}
function useUncontrolledState({
  defaultProp,
  onChange
}) {
  const uncontrolledState = React19.useState(defaultProp);
  const [value2] = uncontrolledState;
  const prevValueRef = React19.useRef(value2);
  const handleChange = useCallbackRef(onChange);
  React19.useEffect(() => {
    if (prevValueRef.current !== value2) {
      handleChange(value2);
      prevValueRef.current = value2;
    }
  }, [value2, prevValueRef, handleChange]);
  return uncontrolledState;
}

// node_modules/aria-hidden/dist/es2015/index.js
var getDefaultParent = function(originalTarget) {
  if (typeof document === "undefined") {
    return null;
  }
  var sampleTarget = Array.isArray(originalTarget) ? originalTarget[0] : originalTarget;
  return sampleTarget.ownerDocument.body;
};
var counterMap = /* @__PURE__ */ new WeakMap();
var uncontrolledNodes = /* @__PURE__ */ new WeakMap();
var markerMap = {};
var lockCount = 0;
var unwrapHost = function(node2) {
  return node2 && (node2.host || unwrapHost(node2.parentNode));
};
var correctTargets = function(parent, targets) {
  return targets.map(function(target) {
    if (parent.contains(target)) {
      return target;
    }
    var correctedTarget = unwrapHost(target);
    if (correctedTarget && parent.contains(correctedTarget)) {
      return correctedTarget;
    }
    console.error("aria-hidden", target, "in not contained inside", parent, ". Doing nothing");
    return null;
  }).filter(function(x3) {
    return Boolean(x3);
  });
};
var applyAttributeToOthers = function(originalTarget, parentNode, markerName, controlAttribute) {
  var targets = correctTargets(parentNode, Array.isArray(originalTarget) ? originalTarget : [originalTarget]);
  if (!markerMap[markerName]) {
    markerMap[markerName] = /* @__PURE__ */ new WeakMap();
  }
  var markerCounter = markerMap[markerName];
  var hiddenNodes = [];
  var elementsToKeep = /* @__PURE__ */ new Set();
  var elementsToStop = new Set(targets);
  var keep = function(el) {
    if (!el || elementsToKeep.has(el)) {
      return;
    }
    elementsToKeep.add(el);
    keep(el.parentNode);
  };
  targets.forEach(keep);
  var deep = function(parent) {
    if (!parent || elementsToStop.has(parent)) {
      return;
    }
    Array.prototype.forEach.call(parent.children, function(node2) {
      if (elementsToKeep.has(node2)) {
        deep(node2);
      } else {
        try {
          var attr = node2.getAttribute(controlAttribute);
          var alreadyHidden = attr !== null && attr !== "false";
          var counterValue = (counterMap.get(node2) || 0) + 1;
          var markerValue = (markerCounter.get(node2) || 0) + 1;
          counterMap.set(node2, counterValue);
          markerCounter.set(node2, markerValue);
          hiddenNodes.push(node2);
          if (counterValue === 1 && alreadyHidden) {
            uncontrolledNodes.set(node2, true);
          }
          if (markerValue === 1) {
            node2.setAttribute(markerName, "true");
          }
          if (!alreadyHidden) {
            node2.setAttribute(controlAttribute, "true");
          }
        } catch (e2) {
          console.error("aria-hidden: cannot operate on ", node2, e2);
        }
      }
    });
  };
  deep(parentNode);
  elementsToKeep.clear();
  lockCount++;
  return function() {
    hiddenNodes.forEach(function(node2) {
      var counterValue = counterMap.get(node2) - 1;
      var markerValue = markerCounter.get(node2) - 1;
      counterMap.set(node2, counterValue);
      markerCounter.set(node2, markerValue);
      if (!counterValue) {
        if (!uncontrolledNodes.has(node2)) {
          node2.removeAttribute(controlAttribute);
        }
        uncontrolledNodes.delete(node2);
      }
      if (!markerValue) {
        node2.removeAttribute(markerName);
      }
    });
    lockCount--;
    if (!lockCount) {
      counterMap = /* @__PURE__ */ new WeakMap();
      counterMap = /* @__PURE__ */ new WeakMap();
      uncontrolledNodes = /* @__PURE__ */ new WeakMap();
      markerMap = {};
    }
  };
};
var hideOthers = function(originalTarget, parentNode, markerName) {
  if (markerName === void 0) {
    markerName = "data-aria-hidden";
  }
  var targets = Array.from(Array.isArray(originalTarget) ? originalTarget : [originalTarget]);
  var activeParentNode = parentNode || getDefaultParent(originalTarget);
  if (!activeParentNode) {
    return function() {
      return null;
    };
  }
  targets.push.apply(targets, Array.from(activeParentNode.querySelectorAll("[aria-live]")));
  return applyAttributeToOthers(targets, activeParentNode, markerName, "aria-hidden");
};

// node_modules/tslib/tslib.es6.mjs
var __assign = function() {
  __assign = Object.assign || function __assign3(t3) {
    for (var s2, i3 = 1, n3 = arguments.length; i3 < n3; i3++) {
      s2 = arguments[i3];
      for (var p2 in s2) if (Object.prototype.hasOwnProperty.call(s2, p2)) t3[p2] = s2[p2];
    }
    return t3;
  };
  return __assign.apply(this, arguments);
};
function __rest(s2, e2) {
  var t3 = {};
  for (var p2 in s2) if (Object.prototype.hasOwnProperty.call(s2, p2) && e2.indexOf(p2) < 0)
    t3[p2] = s2[p2];
  if (s2 != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i3 = 0, p2 = Object.getOwnPropertySymbols(s2); i3 < p2.length; i3++) {
      if (e2.indexOf(p2[i3]) < 0 && Object.prototype.propertyIsEnumerable.call(s2, p2[i3]))
        t3[p2[i3]] = s2[p2[i3]];
    }
  return t3;
}
function __spreadArray(to, from, pack) {
  if (pack || arguments.length === 2) for (var i3 = 0, l3 = from.length, ar; i3 < l3; i3++) {
    if (ar || !(i3 in from)) {
      if (!ar) ar = Array.prototype.slice.call(from, 0, i3);
      ar[i3] = from[i3];
    }
  }
  return to.concat(ar || Array.prototype.slice.call(from));
}

// node_modules/react-remove-scroll/dist/es2015/Combination.js
var React29 = __toESM(require_react());

// node_modules/react-remove-scroll/dist/es2015/UI.js
var React25 = __toESM(require_react());

// node_modules/react-remove-scroll-bar/dist/es2015/constants.js
var zeroRightClassName = "right-scroll-bar-position";
var fullWidthClassName = "width-before-scroll-bar";
var noScrollbarsClassName = "with-scroll-bars-hidden";
var removedBarSizeVariable = "--removed-body-scroll-bar-size";

// node_modules/use-callback-ref/dist/es2015/assignRef.js
function assignRef(ref2, value2) {
  if (typeof ref2 === "function") {
    ref2(value2);
  } else if (ref2) {
    ref2.current = value2;
  }
  return ref2;
}

// node_modules/use-callback-ref/dist/es2015/useRef.js
var import_react19 = __toESM(require_react());
function useCallbackRef2(initialValue, callback) {
  var ref2 = (0, import_react19.useState)(function() {
    return {
      // value
      value: initialValue,
      // last callback
      callback,
      // "memoized" public interface
      facade: {
        get current() {
          return ref2.value;
        },
        set current(value2) {
          var last = ref2.value;
          if (last !== value2) {
            ref2.value = value2;
            ref2.callback(value2, last);
          }
        }
      }
    };
  })[0];
  ref2.callback = callback;
  return ref2.facade;
}

// node_modules/use-callback-ref/dist/es2015/useMergeRef.js
var React20 = __toESM(require_react());
var useIsomorphicLayoutEffect = typeof window !== "undefined" ? React20.useLayoutEffect : React20.useEffect;
var currentValues = /* @__PURE__ */ new WeakMap();
function useMergeRefs(refs, defaultValue) {
  var callbackRef = useCallbackRef2(defaultValue || null, function(newValue) {
    return refs.forEach(function(ref2) {
      return assignRef(ref2, newValue);
    });
  });
  useIsomorphicLayoutEffect(function() {
    var oldValue = currentValues.get(callbackRef);
    if (oldValue) {
      var prevRefs_1 = new Set(oldValue);
      var nextRefs_1 = new Set(refs);
      var current_1 = callbackRef.current;
      prevRefs_1.forEach(function(ref2) {
        if (!nextRefs_1.has(ref2)) {
          assignRef(ref2, null);
        }
      });
      nextRefs_1.forEach(function(ref2) {
        if (!prevRefs_1.has(ref2)) {
          assignRef(ref2, current_1);
        }
      });
    }
    currentValues.set(callbackRef, refs);
  }, [refs]);
  return callbackRef;
}

// node_modules/use-sidecar/dist/es2015/hoc.js
var React21 = __toESM(require_react());

// node_modules/use-sidecar/dist/es2015/hook.js
var import_react20 = __toESM(require_react());

// node_modules/use-sidecar/dist/es2015/medium.js
function ItoI(a2) {
  return a2;
}
function innerCreateMedium(defaults, middleware) {
  if (middleware === void 0) {
    middleware = ItoI;
  }
  var buffer = [];
  var assigned = false;
  var medium = {
    read: function() {
      if (assigned) {
        throw new Error("Sidecar: could not `read` from an `assigned` medium. `read` could be used only with `useMedium`.");
      }
      if (buffer.length) {
        return buffer[buffer.length - 1];
      }
      return defaults;
    },
    useMedium: function(data2) {
      var item = middleware(data2, assigned);
      buffer.push(item);
      return function() {
        buffer = buffer.filter(function(x3) {
          return x3 !== item;
        });
      };
    },
    assignSyncMedium: function(cb) {
      assigned = true;
      while (buffer.length) {
        var cbs = buffer;
        buffer = [];
        cbs.forEach(cb);
      }
      buffer = {
        push: function(x3) {
          return cb(x3);
        },
        filter: function() {
          return buffer;
        }
      };
    },
    assignMedium: function(cb) {
      assigned = true;
      var pendingQueue = [];
      if (buffer.length) {
        var cbs = buffer;
        buffer = [];
        cbs.forEach(cb);
        pendingQueue = buffer;
      }
      var executeQueue = function() {
        var cbs2 = pendingQueue;
        pendingQueue = [];
        cbs2.forEach(cb);
      };
      var cycle = function() {
        return Promise.resolve().then(executeQueue);
      };
      cycle();
      buffer = {
        push: function(x3) {
          pendingQueue.push(x3);
          cycle();
        },
        filter: function(filter) {
          pendingQueue = pendingQueue.filter(filter);
          return buffer;
        }
      };
    }
  };
  return medium;
}
function createSidecarMedium(options) {
  if (options === void 0) {
    options = {};
  }
  var medium = innerCreateMedium(null);
  medium.options = __assign({ async: true, ssr: false }, options);
  return medium;
}

// node_modules/use-sidecar/dist/es2015/renderProp.js
var React23 = __toESM(require_react());
var import_react21 = __toESM(require_react());

// node_modules/use-sidecar/dist/es2015/exports.js
var React24 = __toESM(require_react());
var SideCar = function(_a2) {
  var sideCar = _a2.sideCar, rest = __rest(_a2, ["sideCar"]);
  if (!sideCar) {
    throw new Error("Sidecar: please provide `sideCar` property to import the right car");
  }
  var Target = sideCar.read();
  if (!Target) {
    throw new Error("Sidecar medium not found");
  }
  return React24.createElement(Target, __assign({}, rest));
};
SideCar.isSideCarExport = true;
function exportSidecar(medium, exported) {
  medium.useMedium(exported);
  return SideCar;
}

// node_modules/react-remove-scroll/dist/es2015/medium.js
var effectCar = createSidecarMedium();

// node_modules/react-remove-scroll/dist/es2015/UI.js
var nothing = function() {
  return;
};
var RemoveScroll = React25.forwardRef(function(props, parentRef) {
  var ref2 = React25.useRef(null);
  var _a2 = React25.useState({
    onScrollCapture: nothing,
    onWheelCapture: nothing,
    onTouchMoveCapture: nothing
  }), callbacks = _a2[0], setCallbacks = _a2[1];
  var forwardProps = props.forwardProps, children = props.children, className = props.className, removeScrollBar = props.removeScrollBar, enabled = props.enabled, shards = props.shards, sideCar = props.sideCar, noIsolation = props.noIsolation, inert = props.inert, allowPinchZoom = props.allowPinchZoom, _b2 = props.as, Container = _b2 === void 0 ? "div" : _b2, gapMode = props.gapMode, rest = __rest(props, ["forwardProps", "children", "className", "removeScrollBar", "enabled", "shards", "sideCar", "noIsolation", "inert", "allowPinchZoom", "as", "gapMode"]);
  var SideCar2 = sideCar;
  var containerRef = useMergeRefs([ref2, parentRef]);
  var containerProps = __assign(__assign({}, rest), callbacks);
  return React25.createElement(
    React25.Fragment,
    null,
    enabled && React25.createElement(SideCar2, { sideCar: effectCar, removeScrollBar, shards, noIsolation, inert, setCallbacks, allowPinchZoom: !!allowPinchZoom, lockRef: ref2, gapMode }),
    forwardProps ? React25.cloneElement(React25.Children.only(children), __assign(__assign({}, containerProps), { ref: containerRef })) : React25.createElement(Container, __assign({}, containerProps, { className, ref: containerRef }), children)
  );
});
RemoveScroll.defaultProps = {
  enabled: true,
  removeScrollBar: true,
  inert: false
};
RemoveScroll.classNames = {
  fullWidth: fullWidthClassName,
  zeroRight: zeroRightClassName
};

// node_modules/react-remove-scroll/dist/es2015/SideEffect.js
var React28 = __toESM(require_react());

// node_modules/react-remove-scroll-bar/dist/es2015/component.js
var React27 = __toESM(require_react());

// node_modules/react-style-singleton/dist/es2015/hook.js
var React26 = __toESM(require_react());

// node_modules/get-nonce/dist/es2015/index.js
var currentNonce;
var getNonce = function() {
  if (currentNonce) {
    return currentNonce;
  }
  if (typeof __webpack_nonce__ !== "undefined") {
    return __webpack_nonce__;
  }
  return void 0;
};

// node_modules/react-style-singleton/dist/es2015/singleton.js
function makeStyleTag() {
  if (!document)
    return null;
  var tag = document.createElement("style");
  tag.type = "text/css";
  var nonce = getNonce();
  if (nonce) {
    tag.setAttribute("nonce", nonce);
  }
  return tag;
}
function injectStyles(tag, css3) {
  if (tag.styleSheet) {
    tag.styleSheet.cssText = css3;
  } else {
    tag.appendChild(document.createTextNode(css3));
  }
}
function insertStyleTag(tag) {
  var head = document.head || document.getElementsByTagName("head")[0];
  head.appendChild(tag);
}
var stylesheetSingleton = function() {
  var counter = 0;
  var stylesheet = null;
  return {
    add: function(style) {
      if (counter == 0) {
        if (stylesheet = makeStyleTag()) {
          injectStyles(stylesheet, style);
          insertStyleTag(stylesheet);
        }
      }
      counter++;
    },
    remove: function() {
      counter--;
      if (!counter && stylesheet) {
        stylesheet.parentNode && stylesheet.parentNode.removeChild(stylesheet);
        stylesheet = null;
      }
    }
  };
};

// node_modules/react-style-singleton/dist/es2015/hook.js
var styleHookSingleton = function() {
  var sheet = stylesheetSingleton();
  return function(styles2, isDynamic) {
    React26.useEffect(function() {
      sheet.add(styles2);
      return function() {
        sheet.remove();
      };
    }, [styles2 && isDynamic]);
  };
};

// node_modules/react-style-singleton/dist/es2015/component.js
var styleSingleton = function() {
  var useStyle = styleHookSingleton();
  var Sheet = function(_a2) {
    var styles2 = _a2.styles, dynamic = _a2.dynamic;
    useStyle(styles2, dynamic);
    return null;
  };
  return Sheet;
};

// node_modules/react-remove-scroll-bar/dist/es2015/utils.js
var zeroGap = {
  left: 0,
  top: 0,
  right: 0,
  gap: 0
};
var parse2 = function(x3) {
  return parseInt(x3 || "", 10) || 0;
};
var getOffset = function(gapMode) {
  var cs = window.getComputedStyle(document.body);
  var left = cs[gapMode === "padding" ? "paddingLeft" : "marginLeft"];
  var top = cs[gapMode === "padding" ? "paddingTop" : "marginTop"];
  var right = cs[gapMode === "padding" ? "paddingRight" : "marginRight"];
  return [parse2(left), parse2(top), parse2(right)];
};
var getGapWidth = function(gapMode) {
  if (gapMode === void 0) {
    gapMode = "margin";
  }
  if (typeof window === "undefined") {
    return zeroGap;
  }
  var offsets = getOffset(gapMode);
  var documentWidth = document.documentElement.clientWidth;
  var windowWidth = window.innerWidth;
  return {
    left: offsets[0],
    top: offsets[1],
    right: offsets[2],
    gap: Math.max(0, windowWidth - documentWidth + offsets[2] - offsets[0])
  };
};

// node_modules/react-remove-scroll-bar/dist/es2015/component.js
var Style = styleSingleton();
var lockAttribute = "data-scroll-locked";
var getStyles = function(_a2, allowRelative, gapMode, important) {
  var left = _a2.left, top = _a2.top, right = _a2.right, gap = _a2.gap;
  if (gapMode === void 0) {
    gapMode = "margin";
  }
  return "\n  .".concat(noScrollbarsClassName, " {\n   overflow: hidden ").concat(important, ";\n   padding-right: ").concat(gap, "px ").concat(important, ";\n  }\n  body[").concat(lockAttribute, "] {\n    overflow: hidden ").concat(important, ";\n    overscroll-behavior: contain;\n    ").concat([
    allowRelative && "position: relative ".concat(important, ";"),
    gapMode === "margin" && "\n    padding-left: ".concat(left, "px;\n    padding-top: ").concat(top, "px;\n    padding-right: ").concat(right, "px;\n    margin-left:0;\n    margin-top:0;\n    margin-right: ").concat(gap, "px ").concat(important, ";\n    "),
    gapMode === "padding" && "padding-right: ".concat(gap, "px ").concat(important, ";")
  ].filter(Boolean).join(""), "\n  }\n  \n  .").concat(zeroRightClassName, " {\n    right: ").concat(gap, "px ").concat(important, ";\n  }\n  \n  .").concat(fullWidthClassName, " {\n    margin-right: ").concat(gap, "px ").concat(important, ";\n  }\n  \n  .").concat(zeroRightClassName, " .").concat(zeroRightClassName, " {\n    right: 0 ").concat(important, ";\n  }\n  \n  .").concat(fullWidthClassName, " .").concat(fullWidthClassName, " {\n    margin-right: 0 ").concat(important, ";\n  }\n  \n  body[").concat(lockAttribute, "] {\n    ").concat(removedBarSizeVariable, ": ").concat(gap, "px;\n  }\n");
};
var getCurrentUseCounter = function() {
  var counter = parseInt(document.body.getAttribute(lockAttribute) || "0", 10);
  return isFinite(counter) ? counter : 0;
};
var useLockAttribute = function() {
  React27.useEffect(function() {
    document.body.setAttribute(lockAttribute, (getCurrentUseCounter() + 1).toString());
    return function() {
      var newCounter = getCurrentUseCounter() - 1;
      if (newCounter <= 0) {
        document.body.removeAttribute(lockAttribute);
      } else {
        document.body.setAttribute(lockAttribute, newCounter.toString());
      }
    };
  }, []);
};
var RemoveScrollBar = function(_a2) {
  var noRelative = _a2.noRelative, noImportant = _a2.noImportant, _b2 = _a2.gapMode, gapMode = _b2 === void 0 ? "margin" : _b2;
  useLockAttribute();
  var gap = React27.useMemo(function() {
    return getGapWidth(gapMode);
  }, [gapMode]);
  return React27.createElement(Style, { styles: getStyles(gap, !noRelative, gapMode, !noImportant ? "!important" : "") });
};

// node_modules/react-remove-scroll/dist/es2015/aggresiveCapture.js
var passiveSupported = false;
if (typeof window !== "undefined") {
  try {
    options = Object.defineProperty({}, "passive", {
      get: function() {
        passiveSupported = true;
        return true;
      }
    });
    window.addEventListener("test", options, options);
    window.removeEventListener("test", options, options);
  } catch (err) {
    passiveSupported = false;
  }
}
var options;
var nonPassive = passiveSupported ? { passive: false } : false;

// node_modules/react-remove-scroll/dist/es2015/handleScroll.js
var alwaysContainsScroll = function(node2) {
  return node2.tagName === "TEXTAREA";
};
var elementCanBeScrolled = function(node2, overflow) {
  if (!(node2 instanceof Element)) {
    return false;
  }
  var styles2 = window.getComputedStyle(node2);
  return (
    // not-not-scrollable
    styles2[overflow] !== "hidden" && // contains scroll inside self
    !(styles2.overflowY === styles2.overflowX && !alwaysContainsScroll(node2) && styles2[overflow] === "visible")
  );
};
var elementCouldBeVScrolled = function(node2) {
  return elementCanBeScrolled(node2, "overflowY");
};
var elementCouldBeHScrolled = function(node2) {
  return elementCanBeScrolled(node2, "overflowX");
};
var locationCouldBeScrolled = function(axis, node2) {
  var ownerDocument = node2.ownerDocument;
  var current2 = node2;
  do {
    if (typeof ShadowRoot !== "undefined" && current2 instanceof ShadowRoot) {
      current2 = current2.host;
    }
    var isScrollable = elementCouldBeScrolled(axis, current2);
    if (isScrollable) {
      var _a2 = getScrollVariables(axis, current2), scrollHeight = _a2[1], clientHeight = _a2[2];
      if (scrollHeight > clientHeight) {
        return true;
      }
    }
    current2 = current2.parentNode;
  } while (current2 && current2 !== ownerDocument.body);
  return false;
};
var getVScrollVariables = function(_a2) {
  var scrollTop = _a2.scrollTop, scrollHeight = _a2.scrollHeight, clientHeight = _a2.clientHeight;
  return [
    scrollTop,
    scrollHeight,
    clientHeight
  ];
};
var getHScrollVariables = function(_a2) {
  var scrollLeft = _a2.scrollLeft, scrollWidth = _a2.scrollWidth, clientWidth = _a2.clientWidth;
  return [
    scrollLeft,
    scrollWidth,
    clientWidth
  ];
};
var elementCouldBeScrolled = function(axis, node2) {
  return axis === "v" ? elementCouldBeVScrolled(node2) : elementCouldBeHScrolled(node2);
};
var getScrollVariables = function(axis, node2) {
  return axis === "v" ? getVScrollVariables(node2) : getHScrollVariables(node2);
};
var getDirectionFactor = function(axis, direction) {
  return axis === "h" && direction === "rtl" ? -1 : 1;
};
var handleScroll = function(axis, endTarget, event, sourceDelta, noOverscroll) {
  var directionFactor = getDirectionFactor(axis, window.getComputedStyle(endTarget).direction);
  var delta = directionFactor * sourceDelta;
  var target = event.target;
  var targetInLock = endTarget.contains(target);
  var shouldCancelScroll = false;
  var isDeltaPositive = delta > 0;
  var availableScroll = 0;
  var availableScrollTop = 0;
  do {
    var _a2 = getScrollVariables(axis, target), position2 = _a2[0], scroll_1 = _a2[1], capacity = _a2[2];
    var elementScroll = scroll_1 - capacity - directionFactor * position2;
    if (position2 || elementScroll) {
      if (elementCouldBeScrolled(axis, target)) {
        availableScroll += elementScroll;
        availableScrollTop += position2;
      }
    }
    if (target instanceof ShadowRoot) {
      target = target.host;
    } else {
      target = target.parentNode;
    }
  } while (
    // portaled content
    !targetInLock && target !== document.body || // self content
    targetInLock && (endTarget.contains(target) || endTarget === target)
  );
  if (isDeltaPositive && (noOverscroll && Math.abs(availableScroll) < 1 || !noOverscroll && delta > availableScroll)) {
    shouldCancelScroll = true;
  } else if (!isDeltaPositive && (noOverscroll && Math.abs(availableScrollTop) < 1 || !noOverscroll && -delta > availableScrollTop)) {
    shouldCancelScroll = true;
  }
  return shouldCancelScroll;
};

// node_modules/react-remove-scroll/dist/es2015/SideEffect.js
var getTouchXY = function(event) {
  return "changedTouches" in event ? [event.changedTouches[0].clientX, event.changedTouches[0].clientY] : [0, 0];
};
var getDeltaXY = function(event) {
  return [event.deltaX, event.deltaY];
};
var extractRef = function(ref2) {
  return ref2 && "current" in ref2 ? ref2.current : ref2;
};
var deltaCompare = function(x3, y2) {
  return x3[0] === y2[0] && x3[1] === y2[1];
};
var generateStyle = function(id) {
  return "\n  .block-interactivity-".concat(id, " {pointer-events: none;}\n  .allow-interactivity-").concat(id, " {pointer-events: all;}\n");
};
var idCounter = 0;
var lockStack = [];
function RemoveScrollSideCar(props) {
  var shouldPreventQueue = React28.useRef([]);
  var touchStartRef = React28.useRef([0, 0]);
  var activeAxis = React28.useRef();
  var id = React28.useState(idCounter++)[0];
  var Style2 = React28.useState(styleSingleton)[0];
  var lastProps = React28.useRef(props);
  React28.useEffect(function() {
    lastProps.current = props;
  }, [props]);
  React28.useEffect(function() {
    if (props.inert) {
      document.body.classList.add("block-interactivity-".concat(id));
      var allow_1 = __spreadArray([props.lockRef.current], (props.shards || []).map(extractRef), true).filter(Boolean);
      allow_1.forEach(function(el) {
        return el.classList.add("allow-interactivity-".concat(id));
      });
      return function() {
        document.body.classList.remove("block-interactivity-".concat(id));
        allow_1.forEach(function(el) {
          return el.classList.remove("allow-interactivity-".concat(id));
        });
      };
    }
    return;
  }, [props.inert, props.lockRef.current, props.shards]);
  var shouldCancelEvent = React28.useCallback(function(event, parent) {
    if ("touches" in event && event.touches.length === 2 || event.type === "wheel" && event.ctrlKey) {
      return !lastProps.current.allowPinchZoom;
    }
    var touch = getTouchXY(event);
    var touchStart = touchStartRef.current;
    var deltaX = "deltaX" in event ? event.deltaX : touchStart[0] - touch[0];
    var deltaY = "deltaY" in event ? event.deltaY : touchStart[1] - touch[1];
    var currentAxis;
    var target = event.target;
    var moveDirection = Math.abs(deltaX) > Math.abs(deltaY) ? "h" : "v";
    if ("touches" in event && moveDirection === "h" && target.type === "range") {
      return false;
    }
    var canBeScrolledInMainDirection = locationCouldBeScrolled(moveDirection, target);
    if (!canBeScrolledInMainDirection) {
      return true;
    }
    if (canBeScrolledInMainDirection) {
      currentAxis = moveDirection;
    } else {
      currentAxis = moveDirection === "v" ? "h" : "v";
      canBeScrolledInMainDirection = locationCouldBeScrolled(moveDirection, target);
    }
    if (!canBeScrolledInMainDirection) {
      return false;
    }
    if (!activeAxis.current && "changedTouches" in event && (deltaX || deltaY)) {
      activeAxis.current = currentAxis;
    }
    if (!currentAxis) {
      return true;
    }
    var cancelingAxis = activeAxis.current || currentAxis;
    return handleScroll(cancelingAxis, parent, event, cancelingAxis === "h" ? deltaX : deltaY, true);
  }, []);
  var shouldPrevent = React28.useCallback(function(_event) {
    var event = _event;
    if (!lockStack.length || lockStack[lockStack.length - 1] !== Style2) {
      return;
    }
    var delta = "deltaY" in event ? getDeltaXY(event) : getTouchXY(event);
    var sourceEvent = shouldPreventQueue.current.filter(function(e2) {
      return e2.name === event.type && (e2.target === event.target || event.target === e2.shadowParent) && deltaCompare(e2.delta, delta);
    })[0];
    if (sourceEvent && sourceEvent.should) {
      if (event.cancelable) {
        event.preventDefault();
      }
      return;
    }
    if (!sourceEvent) {
      var shardNodes = (lastProps.current.shards || []).map(extractRef).filter(Boolean).filter(function(node2) {
        return node2.contains(event.target);
      });
      var shouldStop = shardNodes.length > 0 ? shouldCancelEvent(event, shardNodes[0]) : !lastProps.current.noIsolation;
      if (shouldStop) {
        if (event.cancelable) {
          event.preventDefault();
        }
      }
    }
  }, []);
  var shouldCancel = React28.useCallback(function(name2, delta, target, should) {
    var event = { name: name2, delta, target, should, shadowParent: getOutermostShadowParent(target) };
    shouldPreventQueue.current.push(event);
    setTimeout(function() {
      shouldPreventQueue.current = shouldPreventQueue.current.filter(function(e2) {
        return e2 !== event;
      });
    }, 1);
  }, []);
  var scrollTouchStart = React28.useCallback(function(event) {
    touchStartRef.current = getTouchXY(event);
    activeAxis.current = void 0;
  }, []);
  var scrollWheel = React28.useCallback(function(event) {
    shouldCancel(event.type, getDeltaXY(event), event.target, shouldCancelEvent(event, props.lockRef.current));
  }, []);
  var scrollTouchMove = React28.useCallback(function(event) {
    shouldCancel(event.type, getTouchXY(event), event.target, shouldCancelEvent(event, props.lockRef.current));
  }, []);
  React28.useEffect(function() {
    lockStack.push(Style2);
    props.setCallbacks({
      onScrollCapture: scrollWheel,
      onWheelCapture: scrollWheel,
      onTouchMoveCapture: scrollTouchMove
    });
    document.addEventListener("wheel", shouldPrevent, nonPassive);
    document.addEventListener("touchmove", shouldPrevent, nonPassive);
    document.addEventListener("touchstart", scrollTouchStart, nonPassive);
    return function() {
      lockStack = lockStack.filter(function(inst) {
        return inst !== Style2;
      });
      document.removeEventListener("wheel", shouldPrevent, nonPassive);
      document.removeEventListener("touchmove", shouldPrevent, nonPassive);
      document.removeEventListener("touchstart", scrollTouchStart, nonPassive);
    };
  }, []);
  var removeScrollBar = props.removeScrollBar, inert = props.inert;
  return React28.createElement(
    React28.Fragment,
    null,
    inert ? React28.createElement(Style2, { styles: generateStyle(id) }) : null,
    removeScrollBar ? React28.createElement(RemoveScrollBar, { gapMode: props.gapMode }) : null
  );
}
function getOutermostShadowParent(node2) {
  var shadowParent = null;
  while (node2 !== null) {
    if (node2 instanceof ShadowRoot) {
      shadowParent = node2.host;
      node2 = node2.host;
    }
    node2 = node2.parentNode;
  }
  return shadowParent;
}

// node_modules/react-remove-scroll/dist/es2015/sidecar.js
var sidecar_default = exportSidecar(effectCar, RemoveScrollSideCar);

// node_modules/react-remove-scroll/dist/es2015/Combination.js
var ReactRemoveScroll = React29.forwardRef(function(props, ref2) {
  return React29.createElement(RemoveScroll, __assign({}, props, { ref: ref2, sideCar: sidecar_default }));
});
ReactRemoveScroll.classNames = RemoveScroll.classNames;
var Combination_default = ReactRemoveScroll;

// node_modules/@radix-ui/react-popover/dist/index.mjs
var import_jsx_runtime15 = __toESM(require_jsx_runtime(), 1);
var POPOVER_NAME = "Popover";
var [createPopoverContext, createPopoverScope] = createContextScope(POPOVER_NAME, [
  createPopperScope
]);
var usePopperScope = createPopperScope();
var [PopoverProvider, usePopoverContext] = createPopoverContext(POPOVER_NAME);
var Popover = (props) => {
  const {
    __scopePopover,
    children,
    open: openProp,
    defaultOpen,
    onOpenChange,
    modal = false
  } = props;
  const popperScope = usePopperScope(__scopePopover);
  const triggerRef = React30.useRef(null);
  const [hasCustomAnchor, setHasCustomAnchor] = React30.useState(false);
  const [open = false, setOpen] = useControllableState({
    prop: openProp,
    defaultProp: defaultOpen,
    onChange: onOpenChange
  });
  return (0, import_jsx_runtime15.jsx)(Root2, { ...popperScope, children: (0, import_jsx_runtime15.jsx)(
    PopoverProvider,
    {
      scope: __scopePopover,
      contentId: useId(),
      triggerRef,
      open,
      onOpenChange: setOpen,
      onOpenToggle: React30.useCallback(() => setOpen((prevOpen) => !prevOpen), [setOpen]),
      hasCustomAnchor,
      onCustomAnchorAdd: React30.useCallback(() => setHasCustomAnchor(true), []),
      onCustomAnchorRemove: React30.useCallback(() => setHasCustomAnchor(false), []),
      modal,
      children
    }
  ) });
};
Popover.displayName = POPOVER_NAME;
var ANCHOR_NAME2 = "PopoverAnchor";
var PopoverAnchor = React30.forwardRef(
  (props, forwardedRef) => {
    const { __scopePopover, ...anchorProps } = props;
    const context = usePopoverContext(ANCHOR_NAME2, __scopePopover);
    const popperScope = usePopperScope(__scopePopover);
    const { onCustomAnchorAdd, onCustomAnchorRemove } = context;
    React30.useEffect(() => {
      onCustomAnchorAdd();
      return () => onCustomAnchorRemove();
    }, [onCustomAnchorAdd, onCustomAnchorRemove]);
    return (0, import_jsx_runtime15.jsx)(Anchor, { ...popperScope, ...anchorProps, ref: forwardedRef });
  }
);
PopoverAnchor.displayName = ANCHOR_NAME2;
var TRIGGER_NAME = "PopoverTrigger";
var PopoverTrigger = React30.forwardRef(
  (props, forwardedRef) => {
    const { __scopePopover, ...triggerProps } = props;
    const context = usePopoverContext(TRIGGER_NAME, __scopePopover);
    const popperScope = usePopperScope(__scopePopover);
    const composedTriggerRef = useComposedRefs(forwardedRef, context.triggerRef);
    const trigger = (0, import_jsx_runtime15.jsx)(
      Primitive.button,
      {
        type: "button",
        "aria-haspopup": "dialog",
        "aria-expanded": context.open,
        "aria-controls": context.contentId,
        "data-state": getState(context.open),
        ...triggerProps,
        ref: composedTriggerRef,
        onClick: composeEventHandlers(props.onClick, context.onOpenToggle)
      }
    );
    return context.hasCustomAnchor ? trigger : (0, import_jsx_runtime15.jsx)(Anchor, { asChild: true, ...popperScope, children: trigger });
  }
);
PopoverTrigger.displayName = TRIGGER_NAME;
var PORTAL_NAME2 = "PopoverPortal";
var [PortalProvider, usePortalContext] = createPopoverContext(PORTAL_NAME2, {
  forceMount: void 0
});
var PopoverPortal = (props) => {
  const { __scopePopover, forceMount, children, container } = props;
  const context = usePopoverContext(PORTAL_NAME2, __scopePopover);
  return (0, import_jsx_runtime15.jsx)(PortalProvider, { scope: __scopePopover, forceMount, children: (0, import_jsx_runtime15.jsx)(Presence, { present: forceMount || context.open, children: (0, import_jsx_runtime15.jsx)(Portal, { asChild: true, container, children }) }) });
};
PopoverPortal.displayName = PORTAL_NAME2;
var CONTENT_NAME2 = "PopoverContent";
var PopoverContent = React30.forwardRef(
  (props, forwardedRef) => {
    const portalContext = usePortalContext(CONTENT_NAME2, props.__scopePopover);
    const { forceMount = portalContext.forceMount, ...contentProps } = props;
    const context = usePopoverContext(CONTENT_NAME2, props.__scopePopover);
    return (0, import_jsx_runtime15.jsx)(Presence, { present: forceMount || context.open, children: context.modal ? (0, import_jsx_runtime15.jsx)(PopoverContentModal, { ...contentProps, ref: forwardedRef }) : (0, import_jsx_runtime15.jsx)(PopoverContentNonModal, { ...contentProps, ref: forwardedRef }) });
  }
);
PopoverContent.displayName = CONTENT_NAME2;
var PopoverContentModal = React30.forwardRef(
  (props, forwardedRef) => {
    const context = usePopoverContext(CONTENT_NAME2, props.__scopePopover);
    const contentRef = React30.useRef(null);
    const composedRefs = useComposedRefs(forwardedRef, contentRef);
    const isRightClickOutsideRef = React30.useRef(false);
    React30.useEffect(() => {
      const content3 = contentRef.current;
      if (content3) return hideOthers(content3);
    }, []);
    return (0, import_jsx_runtime15.jsx)(Combination_default, { as: Slot, allowPinchZoom: true, children: (0, import_jsx_runtime15.jsx)(
      PopoverContentImpl,
      {
        ...props,
        ref: composedRefs,
        trapFocus: context.open,
        disableOutsidePointerEvents: true,
        onCloseAutoFocus: composeEventHandlers(props.onCloseAutoFocus, (event) => {
          var _a2;
          event.preventDefault();
          if (!isRightClickOutsideRef.current) (_a2 = context.triggerRef.current) == null ? void 0 : _a2.focus();
        }),
        onPointerDownOutside: composeEventHandlers(
          props.onPointerDownOutside,
          (event) => {
            const originalEvent = event.detail.originalEvent;
            const ctrlLeftClick = originalEvent.button === 0 && originalEvent.ctrlKey === true;
            const isRightClick = originalEvent.button === 2 || ctrlLeftClick;
            isRightClickOutsideRef.current = isRightClick;
          },
          { checkForDefaultPrevented: false }
        ),
        onFocusOutside: composeEventHandlers(
          props.onFocusOutside,
          (event) => event.preventDefault(),
          { checkForDefaultPrevented: false }
        )
      }
    ) });
  }
);
var PopoverContentNonModal = React30.forwardRef(
  (props, forwardedRef) => {
    const context = usePopoverContext(CONTENT_NAME2, props.__scopePopover);
    const hasInteractedOutsideRef = React30.useRef(false);
    const hasPointerDownOutsideRef = React30.useRef(false);
    return (0, import_jsx_runtime15.jsx)(
      PopoverContentImpl,
      {
        ...props,
        ref: forwardedRef,
        trapFocus: false,
        disableOutsidePointerEvents: false,
        onCloseAutoFocus: (event) => {
          var _a2, _b2;
          (_a2 = props.onCloseAutoFocus) == null ? void 0 : _a2.call(props, event);
          if (!event.defaultPrevented) {
            if (!hasInteractedOutsideRef.current) (_b2 = context.triggerRef.current) == null ? void 0 : _b2.focus();
            event.preventDefault();
          }
          hasInteractedOutsideRef.current = false;
          hasPointerDownOutsideRef.current = false;
        },
        onInteractOutside: (event) => {
          var _a2, _b2;
          (_a2 = props.onInteractOutside) == null ? void 0 : _a2.call(props, event);
          if (!event.defaultPrevented) {
            hasInteractedOutsideRef.current = true;
            if (event.detail.originalEvent.type === "pointerdown") {
              hasPointerDownOutsideRef.current = true;
            }
          }
          const target = event.target;
          const targetIsTrigger = (_b2 = context.triggerRef.current) == null ? void 0 : _b2.contains(target);
          if (targetIsTrigger) event.preventDefault();
          if (event.detail.originalEvent.type === "focusin" && hasPointerDownOutsideRef.current) {
            event.preventDefault();
          }
        }
      }
    );
  }
);
var PopoverContentImpl = React30.forwardRef(
  (props, forwardedRef) => {
    const {
      __scopePopover,
      trapFocus,
      onOpenAutoFocus,
      onCloseAutoFocus,
      disableOutsidePointerEvents,
      onEscapeKeyDown,
      onPointerDownOutside,
      onFocusOutside,
      onInteractOutside,
      ...contentProps
    } = props;
    const context = usePopoverContext(CONTENT_NAME2, __scopePopover);
    const popperScope = usePopperScope(__scopePopover);
    useFocusGuards();
    return (0, import_jsx_runtime15.jsx)(
      FocusScope,
      {
        asChild: true,
        loop: true,
        trapped: trapFocus,
        onMountAutoFocus: onOpenAutoFocus,
        onUnmountAutoFocus: onCloseAutoFocus,
        children: (0, import_jsx_runtime15.jsx)(
          DismissableLayer,
          {
            asChild: true,
            disableOutsidePointerEvents,
            onInteractOutside,
            onEscapeKeyDown,
            onPointerDownOutside,
            onFocusOutside,
            onDismiss: () => context.onOpenChange(false),
            children: (0, import_jsx_runtime15.jsx)(
              Content,
              {
                "data-state": getState(context.open),
                role: "dialog",
                id: context.contentId,
                ...popperScope,
                ...contentProps,
                ref: forwardedRef,
                style: {
                  ...contentProps.style,
                  // re-namespace exposed content custom properties
                  ...{
                    "--radix-popover-content-transform-origin": "var(--radix-popper-transform-origin)",
                    "--radix-popover-content-available-width": "var(--radix-popper-available-width)",
                    "--radix-popover-content-available-height": "var(--radix-popper-available-height)",
                    "--radix-popover-trigger-width": "var(--radix-popper-anchor-width)",
                    "--radix-popover-trigger-height": "var(--radix-popper-anchor-height)"
                  }
                }
              }
            )
          }
        )
      }
    );
  }
);
var CLOSE_NAME = "PopoverClose";
var PopoverClose = React30.forwardRef(
  (props, forwardedRef) => {
    const { __scopePopover, ...closeProps } = props;
    const context = usePopoverContext(CLOSE_NAME, __scopePopover);
    return (0, import_jsx_runtime15.jsx)(
      Primitive.button,
      {
        type: "button",
        ...closeProps,
        ref: forwardedRef,
        onClick: composeEventHandlers(props.onClick, () => context.onOpenChange(false))
      }
    );
  }
);
PopoverClose.displayName = CLOSE_NAME;
var ARROW_NAME2 = "PopoverArrow";
var PopoverArrow = React30.forwardRef(
  (props, forwardedRef) => {
    const { __scopePopover, ...arrowProps } = props;
    const popperScope = usePopperScope(__scopePopover);
    return (0, import_jsx_runtime15.jsx)(Arrow2, { ...popperScope, ...arrowProps, ref: forwardedRef });
  }
);
PopoverArrow.displayName = ARROW_NAME2;
function getState(open) {
  return open ? "open" : "closed";
}
var Root22 = Popover;
var Anchor2 = PopoverAnchor;
var Trigger = PopoverTrigger;
var Portal2 = PopoverPortal;
var Content2 = PopoverContent;
var Arrow22 = PopoverArrow;

// node_modules/@mdxeditor/editor/dist/plugins/table/TableEditor.js
var import_react24 = __toESM(require_react(), 1);

// node_modules/@radix-ui/react-toolbar/dist/index.mjs
var React37 = __toESM(require_react(), 1);

// node_modules/@radix-ui/react-roving-focus/dist/index.mjs
var React33 = __toESM(require_react(), 1);

// node_modules/@radix-ui/react-collection/dist/index.mjs
var import_react22 = __toESM(require_react(), 1);
var import_jsx_runtime16 = __toESM(require_jsx_runtime(), 1);
function createCollection(name2) {
  const PROVIDER_NAME2 = name2 + "CollectionProvider";
  const [createCollectionContext, createCollectionScope3] = createContextScope(PROVIDER_NAME2);
  const [CollectionProviderImpl, useCollectionContext] = createCollectionContext(
    PROVIDER_NAME2,
    { collectionRef: { current: null }, itemMap: /* @__PURE__ */ new Map() }
  );
  const CollectionProvider = (props) => {
    const { scope, children } = props;
    const ref2 = import_react22.default.useRef(null);
    const itemMap = import_react22.default.useRef(/* @__PURE__ */ new Map()).current;
    return (0, import_jsx_runtime16.jsx)(CollectionProviderImpl, { scope, itemMap, collectionRef: ref2, children });
  };
  CollectionProvider.displayName = PROVIDER_NAME2;
  const COLLECTION_SLOT_NAME = name2 + "CollectionSlot";
  const CollectionSlot = import_react22.default.forwardRef(
    (props, forwardedRef) => {
      const { scope, children } = props;
      const context = useCollectionContext(COLLECTION_SLOT_NAME, scope);
      const composedRefs = useComposedRefs(forwardedRef, context.collectionRef);
      return (0, import_jsx_runtime16.jsx)(Slot, { ref: composedRefs, children });
    }
  );
  CollectionSlot.displayName = COLLECTION_SLOT_NAME;
  const ITEM_SLOT_NAME = name2 + "CollectionItemSlot";
  const ITEM_DATA_ATTR = "data-radix-collection-item";
  const CollectionItemSlot = import_react22.default.forwardRef(
    (props, forwardedRef) => {
      const { scope, children, ...itemData } = props;
      const ref2 = import_react22.default.useRef(null);
      const composedRefs = useComposedRefs(forwardedRef, ref2);
      const context = useCollectionContext(ITEM_SLOT_NAME, scope);
      import_react22.default.useEffect(() => {
        context.itemMap.set(ref2, { ref: ref2, ...itemData });
        return () => void context.itemMap.delete(ref2);
      });
      return (0, import_jsx_runtime16.jsx)(Slot, { ...{ [ITEM_DATA_ATTR]: "" }, ref: composedRefs, children });
    }
  );
  CollectionItemSlot.displayName = ITEM_SLOT_NAME;
  function useCollection3(scope) {
    const context = useCollectionContext(name2 + "CollectionConsumer", scope);
    const getItems = import_react22.default.useCallback(() => {
      const collectionNode = context.collectionRef.current;
      if (!collectionNode) return [];
      const orderedNodes = Array.from(collectionNode.querySelectorAll(`[${ITEM_DATA_ATTR}]`));
      const items = Array.from(context.itemMap.values());
      const orderedItems = items.sort(
        (a2, b3) => orderedNodes.indexOf(a2.ref.current) - orderedNodes.indexOf(b3.ref.current)
      );
      return orderedItems;
    }, [context.collectionRef, context.itemMap]);
    return getItems;
  }
  return [
    { Provider: CollectionProvider, Slot: CollectionSlot, ItemSlot: CollectionItemSlot },
    useCollection3,
    createCollectionScope3
  ];
}

// node_modules/@radix-ui/react-direction/dist/index.mjs
var React32 = __toESM(require_react(), 1);
var import_jsx_runtime17 = __toESM(require_jsx_runtime(), 1);
var DirectionContext = React32.createContext(void 0);
function useDirection(localDir) {
  const globalDir = React32.useContext(DirectionContext);
  return localDir || globalDir || "ltr";
}

// node_modules/@radix-ui/react-roving-focus/dist/index.mjs
var import_jsx_runtime18 = __toESM(require_jsx_runtime(), 1);
var ENTRY_FOCUS = "rovingFocusGroup.onEntryFocus";
var EVENT_OPTIONS2 = { bubbles: false, cancelable: true };
var GROUP_NAME = "RovingFocusGroup";
var [Collection, useCollection, createCollectionScope] = createCollection(GROUP_NAME);
var [createRovingFocusGroupContext, createRovingFocusGroupScope] = createContextScope(
  GROUP_NAME,
  [createCollectionScope]
);
var [RovingFocusProvider, useRovingFocusContext] = createRovingFocusGroupContext(GROUP_NAME);
var RovingFocusGroup = React33.forwardRef(
  (props, forwardedRef) => {
    return (0, import_jsx_runtime18.jsx)(Collection.Provider, { scope: props.__scopeRovingFocusGroup, children: (0, import_jsx_runtime18.jsx)(Collection.Slot, { scope: props.__scopeRovingFocusGroup, children: (0, import_jsx_runtime18.jsx)(RovingFocusGroupImpl, { ...props, ref: forwardedRef }) }) });
  }
);
RovingFocusGroup.displayName = GROUP_NAME;
var RovingFocusGroupImpl = React33.forwardRef((props, forwardedRef) => {
  const {
    __scopeRovingFocusGroup,
    orientation,
    loop = false,
    dir,
    currentTabStopId: currentTabStopIdProp,
    defaultCurrentTabStopId,
    onCurrentTabStopIdChange,
    onEntryFocus,
    preventScrollOnEntryFocus = false,
    ...groupProps
  } = props;
  const ref2 = React33.useRef(null);
  const composedRefs = useComposedRefs(forwardedRef, ref2);
  const direction = useDirection(dir);
  const [currentTabStopId = null, setCurrentTabStopId] = useControllableState({
    prop: currentTabStopIdProp,
    defaultProp: defaultCurrentTabStopId,
    onChange: onCurrentTabStopIdChange
  });
  const [isTabbingBackOut, setIsTabbingBackOut] = React33.useState(false);
  const handleEntryFocus = useCallbackRef(onEntryFocus);
  const getItems = useCollection(__scopeRovingFocusGroup);
  const isClickFocusRef = React33.useRef(false);
  const [focusableItemsCount, setFocusableItemsCount] = React33.useState(0);
  React33.useEffect(() => {
    const node2 = ref2.current;
    if (node2) {
      node2.addEventListener(ENTRY_FOCUS, handleEntryFocus);
      return () => node2.removeEventListener(ENTRY_FOCUS, handleEntryFocus);
    }
  }, [handleEntryFocus]);
  return (0, import_jsx_runtime18.jsx)(
    RovingFocusProvider,
    {
      scope: __scopeRovingFocusGroup,
      orientation,
      dir: direction,
      loop,
      currentTabStopId,
      onItemFocus: React33.useCallback(
        (tabStopId) => setCurrentTabStopId(tabStopId),
        [setCurrentTabStopId]
      ),
      onItemShiftTab: React33.useCallback(() => setIsTabbingBackOut(true), []),
      onFocusableItemAdd: React33.useCallback(
        () => setFocusableItemsCount((prevCount) => prevCount + 1),
        []
      ),
      onFocusableItemRemove: React33.useCallback(
        () => setFocusableItemsCount((prevCount) => prevCount - 1),
        []
      ),
      children: (0, import_jsx_runtime18.jsx)(
        Primitive.div,
        {
          tabIndex: isTabbingBackOut || focusableItemsCount === 0 ? -1 : 0,
          "data-orientation": orientation,
          ...groupProps,
          ref: composedRefs,
          style: { outline: "none", ...props.style },
          onMouseDown: composeEventHandlers(props.onMouseDown, () => {
            isClickFocusRef.current = true;
          }),
          onFocus: composeEventHandlers(props.onFocus, (event) => {
            const isKeyboardFocus = !isClickFocusRef.current;
            if (event.target === event.currentTarget && isKeyboardFocus && !isTabbingBackOut) {
              const entryFocusEvent = new CustomEvent(ENTRY_FOCUS, EVENT_OPTIONS2);
              event.currentTarget.dispatchEvent(entryFocusEvent);
              if (!entryFocusEvent.defaultPrevented) {
                const items = getItems().filter((item) => item.focusable);
                const activeItem = items.find((item) => item.active);
                const currentItem = items.find((item) => item.id === currentTabStopId);
                const candidateItems = [activeItem, currentItem, ...items].filter(
                  Boolean
                );
                const candidateNodes = candidateItems.map((item) => item.ref.current);
                focusFirst2(candidateNodes, preventScrollOnEntryFocus);
              }
            }
            isClickFocusRef.current = false;
          }),
          onBlur: composeEventHandlers(props.onBlur, () => setIsTabbingBackOut(false))
        }
      )
    }
  );
});
var ITEM_NAME = "RovingFocusGroupItem";
var RovingFocusGroupItem = React33.forwardRef(
  (props, forwardedRef) => {
    const {
      __scopeRovingFocusGroup,
      focusable = true,
      active = false,
      tabStopId,
      ...itemProps
    } = props;
    const autoId = useId();
    const id = tabStopId || autoId;
    const context = useRovingFocusContext(ITEM_NAME, __scopeRovingFocusGroup);
    const isCurrentTabStop = context.currentTabStopId === id;
    const getItems = useCollection(__scopeRovingFocusGroup);
    const { onFocusableItemAdd, onFocusableItemRemove } = context;
    React33.useEffect(() => {
      if (focusable) {
        onFocusableItemAdd();
        return () => onFocusableItemRemove();
      }
    }, [focusable, onFocusableItemAdd, onFocusableItemRemove]);
    return (0, import_jsx_runtime18.jsx)(
      Collection.ItemSlot,
      {
        scope: __scopeRovingFocusGroup,
        id,
        focusable,
        active,
        children: (0, import_jsx_runtime18.jsx)(
          Primitive.span,
          {
            tabIndex: isCurrentTabStop ? 0 : -1,
            "data-orientation": context.orientation,
            ...itemProps,
            ref: forwardedRef,
            onMouseDown: composeEventHandlers(props.onMouseDown, (event) => {
              if (!focusable) event.preventDefault();
              else context.onItemFocus(id);
            }),
            onFocus: composeEventHandlers(props.onFocus, () => context.onItemFocus(id)),
            onKeyDown: composeEventHandlers(props.onKeyDown, (event) => {
              if (event.key === "Tab" && event.shiftKey) {
                context.onItemShiftTab();
                return;
              }
              if (event.target !== event.currentTarget) return;
              const focusIntent = getFocusIntent(event, context.orientation, context.dir);
              if (focusIntent !== void 0) {
                if (event.metaKey || event.ctrlKey || event.altKey || event.shiftKey) return;
                event.preventDefault();
                const items = getItems().filter((item) => item.focusable);
                let candidateNodes = items.map((item) => item.ref.current);
                if (focusIntent === "last") candidateNodes.reverse();
                else if (focusIntent === "prev" || focusIntent === "next") {
                  if (focusIntent === "prev") candidateNodes.reverse();
                  const currentIndex = candidateNodes.indexOf(event.currentTarget);
                  candidateNodes = context.loop ? wrapArray(candidateNodes, currentIndex + 1) : candidateNodes.slice(currentIndex + 1);
                }
                setTimeout(() => focusFirst2(candidateNodes));
              }
            })
          }
        )
      }
    );
  }
);
RovingFocusGroupItem.displayName = ITEM_NAME;
var MAP_KEY_TO_FOCUS_INTENT = {
  ArrowLeft: "prev",
  ArrowUp: "prev",
  ArrowRight: "next",
  ArrowDown: "next",
  PageUp: "first",
  Home: "first",
  PageDown: "last",
  End: "last"
};
function getDirectionAwareKey(key2, dir) {
  if (dir !== "rtl") return key2;
  return key2 === "ArrowLeft" ? "ArrowRight" : key2 === "ArrowRight" ? "ArrowLeft" : key2;
}
function getFocusIntent(event, orientation, dir) {
  const key2 = getDirectionAwareKey(event.key, dir);
  if (orientation === "vertical" && ["ArrowLeft", "ArrowRight"].includes(key2)) return void 0;
  if (orientation === "horizontal" && ["ArrowUp", "ArrowDown"].includes(key2)) return void 0;
  return MAP_KEY_TO_FOCUS_INTENT[key2];
}
function focusFirst2(candidates, preventScroll = false) {
  const PREVIOUSLY_FOCUSED_ELEMENT = document.activeElement;
  for (const candidate of candidates) {
    if (candidate === PREVIOUSLY_FOCUSED_ELEMENT) return;
    candidate.focus({ preventScroll });
    if (document.activeElement !== PREVIOUSLY_FOCUSED_ELEMENT) return;
  }
}
function wrapArray(array, startIndex) {
  return array.map((_2, index3) => array[(startIndex + index3) % array.length]);
}
var Root3 = RovingFocusGroup;
var Item = RovingFocusGroupItem;

// node_modules/@radix-ui/react-separator/dist/index.mjs
var React34 = __toESM(require_react(), 1);
var import_jsx_runtime19 = __toESM(require_jsx_runtime(), 1);
var NAME2 = "Separator";
var DEFAULT_ORIENTATION = "horizontal";
var ORIENTATIONS = ["horizontal", "vertical"];
var Separator = React34.forwardRef((props, forwardedRef) => {
  const { decorative, orientation: orientationProp = DEFAULT_ORIENTATION, ...domProps } = props;
  const orientation = isValidOrientation(orientationProp) ? orientationProp : DEFAULT_ORIENTATION;
  const ariaOrientation = orientation === "vertical" ? orientation : void 0;
  const semanticProps = decorative ? { role: "none" } : { "aria-orientation": ariaOrientation, role: "separator" };
  return (0, import_jsx_runtime19.jsx)(
    Primitive.div,
    {
      "data-orientation": orientation,
      ...semanticProps,
      ...domProps,
      ref: forwardedRef
    }
  );
});
Separator.displayName = NAME2;
function isValidOrientation(orientation) {
  return ORIENTATIONS.includes(orientation);
}
var Root4 = Separator;

// node_modules/@radix-ui/react-toggle-group/dist/index.mjs
var import_react23 = __toESM(require_react(), 1);

// node_modules/@radix-ui/react-toggle/dist/index.mjs
var React35 = __toESM(require_react(), 1);
var import_jsx_runtime20 = __toESM(require_jsx_runtime(), 1);
var NAME3 = "Toggle";
var Toggle = React35.forwardRef((props, forwardedRef) => {
  const { pressed: pressedProp, defaultPressed = false, onPressedChange, ...buttonProps } = props;
  const [pressed = false, setPressed] = useControllableState({
    prop: pressedProp,
    onChange: onPressedChange,
    defaultProp: defaultPressed
  });
  return (0, import_jsx_runtime20.jsx)(
    Primitive.button,
    {
      type: "button",
      "aria-pressed": pressed,
      "data-state": pressed ? "on" : "off",
      "data-disabled": props.disabled ? "" : void 0,
      ...buttonProps,
      ref: forwardedRef,
      onClick: composeEventHandlers(props.onClick, () => {
        if (!props.disabled) {
          setPressed(!pressed);
        }
      })
    }
  );
});
Toggle.displayName = NAME3;

// node_modules/@radix-ui/react-toggle-group/dist/index.mjs
var import_jsx_runtime21 = __toESM(require_jsx_runtime(), 1);
var TOGGLE_GROUP_NAME = "ToggleGroup";
var [createToggleGroupContext, createToggleGroupScope] = createContextScope(TOGGLE_GROUP_NAME, [
  createRovingFocusGroupScope
]);
var useRovingFocusGroupScope = createRovingFocusGroupScope();
var ToggleGroup = import_react23.default.forwardRef((props, forwardedRef) => {
  const { type: type2, ...toggleGroupProps } = props;
  if (type2 === "single") {
    const singleProps = toggleGroupProps;
    return (0, import_jsx_runtime21.jsx)(ToggleGroupImplSingle, { ...singleProps, ref: forwardedRef });
  }
  if (type2 === "multiple") {
    const multipleProps = toggleGroupProps;
    return (0, import_jsx_runtime21.jsx)(ToggleGroupImplMultiple, { ...multipleProps, ref: forwardedRef });
  }
  throw new Error(`Missing prop \`type\` expected on \`${TOGGLE_GROUP_NAME}\``);
});
ToggleGroup.displayName = TOGGLE_GROUP_NAME;
var [ToggleGroupValueProvider, useToggleGroupValueContext] = createToggleGroupContext(TOGGLE_GROUP_NAME);
var ToggleGroupImplSingle = import_react23.default.forwardRef((props, forwardedRef) => {
  const {
    value: valueProp,
    defaultValue,
    onValueChange = () => {
    },
    ...toggleGroupSingleProps
  } = props;
  const [value2, setValue] = useControllableState({
    prop: valueProp,
    defaultProp: defaultValue,
    onChange: onValueChange
  });
  return (0, import_jsx_runtime21.jsx)(
    ToggleGroupValueProvider,
    {
      scope: props.__scopeToggleGroup,
      type: "single",
      value: value2 ? [value2] : [],
      onItemActivate: setValue,
      onItemDeactivate: import_react23.default.useCallback(() => setValue(""), [setValue]),
      children: (0, import_jsx_runtime21.jsx)(ToggleGroupImpl, { ...toggleGroupSingleProps, ref: forwardedRef })
    }
  );
});
var ToggleGroupImplMultiple = import_react23.default.forwardRef((props, forwardedRef) => {
  const {
    value: valueProp,
    defaultValue,
    onValueChange = () => {
    },
    ...toggleGroupMultipleProps
  } = props;
  const [value2 = [], setValue] = useControllableState({
    prop: valueProp,
    defaultProp: defaultValue,
    onChange: onValueChange
  });
  const handleButtonActivate = import_react23.default.useCallback(
    (itemValue) => setValue((prevValue = []) => [...prevValue, itemValue]),
    [setValue]
  );
  const handleButtonDeactivate = import_react23.default.useCallback(
    (itemValue) => setValue((prevValue = []) => prevValue.filter((value22) => value22 !== itemValue)),
    [setValue]
  );
  return (0, import_jsx_runtime21.jsx)(
    ToggleGroupValueProvider,
    {
      scope: props.__scopeToggleGroup,
      type: "multiple",
      value: value2,
      onItemActivate: handleButtonActivate,
      onItemDeactivate: handleButtonDeactivate,
      children: (0, import_jsx_runtime21.jsx)(ToggleGroupImpl, { ...toggleGroupMultipleProps, ref: forwardedRef })
    }
  );
});
ToggleGroup.displayName = TOGGLE_GROUP_NAME;
var [ToggleGroupContext, useToggleGroupContext] = createToggleGroupContext(TOGGLE_GROUP_NAME);
var ToggleGroupImpl = import_react23.default.forwardRef(
  (props, forwardedRef) => {
    const {
      __scopeToggleGroup,
      disabled = false,
      rovingFocus = true,
      orientation,
      dir,
      loop = true,
      ...toggleGroupProps
    } = props;
    const rovingFocusGroupScope = useRovingFocusGroupScope(__scopeToggleGroup);
    const direction = useDirection(dir);
    const commonProps = { role: "group", dir: direction, ...toggleGroupProps };
    return (0, import_jsx_runtime21.jsx)(ToggleGroupContext, { scope: __scopeToggleGroup, rovingFocus, disabled, children: rovingFocus ? (0, import_jsx_runtime21.jsx)(
      Root3,
      {
        asChild: true,
        ...rovingFocusGroupScope,
        orientation,
        dir: direction,
        loop,
        children: (0, import_jsx_runtime21.jsx)(Primitive.div, { ...commonProps, ref: forwardedRef })
      }
    ) : (0, import_jsx_runtime21.jsx)(Primitive.div, { ...commonProps, ref: forwardedRef }) });
  }
);
var ITEM_NAME2 = "ToggleGroupItem";
var ToggleGroupItem = import_react23.default.forwardRef(
  (props, forwardedRef) => {
    const valueContext = useToggleGroupValueContext(ITEM_NAME2, props.__scopeToggleGroup);
    const context = useToggleGroupContext(ITEM_NAME2, props.__scopeToggleGroup);
    const rovingFocusGroupScope = useRovingFocusGroupScope(props.__scopeToggleGroup);
    const pressed = valueContext.value.includes(props.value);
    const disabled = context.disabled || props.disabled;
    const commonProps = { ...props, pressed, disabled };
    const ref2 = import_react23.default.useRef(null);
    return context.rovingFocus ? (0, import_jsx_runtime21.jsx)(
      Item,
      {
        asChild: true,
        ...rovingFocusGroupScope,
        focusable: !disabled,
        active: pressed,
        ref: ref2,
        children: (0, import_jsx_runtime21.jsx)(ToggleGroupItemImpl, { ...commonProps, ref: forwardedRef })
      }
    ) : (0, import_jsx_runtime21.jsx)(ToggleGroupItemImpl, { ...commonProps, ref: forwardedRef });
  }
);
ToggleGroupItem.displayName = ITEM_NAME2;
var ToggleGroupItemImpl = import_react23.default.forwardRef(
  (props, forwardedRef) => {
    const { __scopeToggleGroup, value: value2, ...itemProps } = props;
    const valueContext = useToggleGroupValueContext(ITEM_NAME2, __scopeToggleGroup);
    const singleProps = { role: "radio", "aria-checked": props.pressed, "aria-pressed": void 0 };
    const typeProps = valueContext.type === "single" ? singleProps : void 0;
    return (0, import_jsx_runtime21.jsx)(
      Toggle,
      {
        ...typeProps,
        ...itemProps,
        ref: forwardedRef,
        onPressedChange: (pressed) => {
          if (pressed) {
            valueContext.onItemActivate(value2);
          } else {
            valueContext.onItemDeactivate(value2);
          }
        }
      }
    );
  }
);
var Root23 = ToggleGroup;
var Item2 = ToggleGroupItem;

// node_modules/@radix-ui/react-toolbar/dist/index.mjs
var import_jsx_runtime22 = __toESM(require_jsx_runtime(), 1);
var TOOLBAR_NAME = "Toolbar";
var [createToolbarContext, createToolbarScope] = createContextScope(TOOLBAR_NAME, [
  createRovingFocusGroupScope,
  createToggleGroupScope
]);
var useRovingFocusGroupScope2 = createRovingFocusGroupScope();
var useToggleGroupScope = createToggleGroupScope();
var [ToolbarProvider, useToolbarContext] = createToolbarContext(TOOLBAR_NAME);
var Toolbar = React37.forwardRef(
  (props, forwardedRef) => {
    const { __scopeToolbar, orientation = "horizontal", dir, loop = true, ...toolbarProps } = props;
    const rovingFocusGroupScope = useRovingFocusGroupScope2(__scopeToolbar);
    const direction = useDirection(dir);
    return (0, import_jsx_runtime22.jsx)(ToolbarProvider, { scope: __scopeToolbar, orientation, dir: direction, children: (0, import_jsx_runtime22.jsx)(
      Root3,
      {
        asChild: true,
        ...rovingFocusGroupScope,
        orientation,
        dir: direction,
        loop,
        children: (0, import_jsx_runtime22.jsx)(
          Primitive.div,
          {
            role: "toolbar",
            "aria-orientation": orientation,
            dir: direction,
            ...toolbarProps,
            ref: forwardedRef
          }
        )
      }
    ) });
  }
);
Toolbar.displayName = TOOLBAR_NAME;
var SEPARATOR_NAME = "ToolbarSeparator";
var ToolbarSeparator = React37.forwardRef(
  (props, forwardedRef) => {
    const { __scopeToolbar, ...separatorProps } = props;
    const context = useToolbarContext(SEPARATOR_NAME, __scopeToolbar);
    return (0, import_jsx_runtime22.jsx)(
      Root4,
      {
        orientation: context.orientation === "horizontal" ? "vertical" : "horizontal",
        ...separatorProps,
        ref: forwardedRef
      }
    );
  }
);
ToolbarSeparator.displayName = SEPARATOR_NAME;
var BUTTON_NAME = "ToolbarButton";
var ToolbarButton = React37.forwardRef(
  (props, forwardedRef) => {
    const { __scopeToolbar, ...buttonProps } = props;
    const rovingFocusGroupScope = useRovingFocusGroupScope2(__scopeToolbar);
    return (0, import_jsx_runtime22.jsx)(Item, { asChild: true, ...rovingFocusGroupScope, focusable: !props.disabled, children: (0, import_jsx_runtime22.jsx)(Primitive.button, { type: "button", ...buttonProps, ref: forwardedRef }) });
  }
);
ToolbarButton.displayName = BUTTON_NAME;
var LINK_NAME = "ToolbarLink";
var ToolbarLink = React37.forwardRef(
  (props, forwardedRef) => {
    const { __scopeToolbar, ...linkProps } = props;
    const rovingFocusGroupScope = useRovingFocusGroupScope2(__scopeToolbar);
    return (0, import_jsx_runtime22.jsx)(Item, { asChild: true, ...rovingFocusGroupScope, focusable: true, children: (0, import_jsx_runtime22.jsx)(
      Primitive.a,
      {
        ...linkProps,
        ref: forwardedRef,
        onKeyDown: composeEventHandlers(props.onKeyDown, (event) => {
          if (event.key === " ") event.currentTarget.click();
        })
      }
    ) });
  }
);
ToolbarLink.displayName = LINK_NAME;
var TOGGLE_GROUP_NAME2 = "ToolbarToggleGroup";
var ToolbarToggleGroup = React37.forwardRef(
  (props, forwardedRef) => {
    const { __scopeToolbar, ...toggleGroupProps } = props;
    const context = useToolbarContext(TOGGLE_GROUP_NAME2, __scopeToolbar);
    const toggleGroupScope = useToggleGroupScope(__scopeToolbar);
    return (0, import_jsx_runtime22.jsx)(
      Root23,
      {
        "data-orientation": context.orientation,
        dir: context.dir,
        ...toggleGroupScope,
        ...toggleGroupProps,
        ref: forwardedRef,
        rovingFocus: false
      }
    );
  }
);
ToolbarToggleGroup.displayName = TOGGLE_GROUP_NAME2;
var TOGGLE_ITEM_NAME = "ToolbarToggleItem";
var ToolbarToggleItem = React37.forwardRef(
  (props, forwardedRef) => {
    const { __scopeToolbar, ...toggleItemProps } = props;
    const toggleGroupScope = useToggleGroupScope(__scopeToolbar);
    const scope = { __scopeToolbar: props.__scopeToolbar };
    return (0, import_jsx_runtime22.jsx)(ToolbarButton, { asChild: true, ...scope, children: (0, import_jsx_runtime22.jsx)(Item2, { ...toggleGroupScope, ...toggleItemProps, ref: forwardedRef }) });
  }
);
ToolbarToggleItem.displayName = TOGGLE_ITEM_NAME;
var Root42 = Toolbar;
var Separator2 = ToolbarSeparator;
var Button = ToolbarButton;
var ToggleGroup2 = ToolbarToggleGroup;
var ToggleItem = ToolbarToggleItem;

// node_modules/@mdxeditor/editor/dist/plugins/table/TableEditor.js
var import_classnames2 = __toESM(require_classnames(), 1);

// node_modules/@mdxeditor/editor/dist/utils/isPartOftheEditorUI.js
function isPartOftheEditorUI(element2, editorRoot2) {
  if (element2 === null || element2 === editorRoot2) {
    return false;
  }
  if (element2.dataset.editorDialog !== void 0 || element2.dataset.toolbarItem !== void 0 || element2.dataset.editorDropdown) {
    return true;
  }
  return isPartOftheEditorUI(element2.parentElement, editorRoot2);
}

// node_modules/@mdxeditor/editor/dist/utils/uuid4.js
function uuidv4() {
  const hex = [...Array(256).keys()].map((index3) => index3.toString(16).padStart(2, "0"));
  const r2 = crypto.getRandomValues(new Uint8Array(16));
  r2[6] = r2[6] & 15 | 64;
  r2[8] = r2[8] & 63 | 128;
  return [...r2.entries()].map(([index3, int2]) => [4, 6, 8, 10].includes(index3) ? `-${hex[int2]}` : hex[int2]).join("");
}

// node_modules/@mdxeditor/editor/dist/plugins/table/TableEditor.js
var getCellType = (rowIndex) => {
  if (rowIndex === 0) {
    return "th";
  }
  return "td";
};
var AlignToTailwindClassMap = {
  center: styles.centeredCell,
  left: styles.leftAlignedCell,
  right: styles.rightAlignedCell
};
var TableEditor = ({ mdastNode, parentEditor, lexicalTable }) => {
  const [activeCell, setActiveCell] = import_react24.default.useState(null);
  const [iconComponentFor, readOnly] = X(iconComponentFor$, readOnly$);
  const getCellKey = import_react24.default.useMemo(() => {
    return (cell) => {
      if (!cell.__cacheKey) {
        cell.__cacheKey = uuidv4();
      }
      return cell.__cacheKey;
    };
  }, []);
  const setActiveCellWithBoundaries = import_react24.default.useCallback(
    (cell) => {
      const colCount = lexicalTable.getColCount();
      if (cell === null) {
        setActiveCell(null);
        return;
      }
      let [colIndex, rowIndex] = cell;
      if (colIndex > colCount - 1) {
        colIndex = 0;
        rowIndex++;
      }
      if (colIndex < 0) {
        colIndex = colCount - 1;
        rowIndex -= 1;
      }
      if (rowIndex > lexicalTable.getRowCount() - 1) {
        setActiveCell(null);
        parentEditor.update(() => {
          const nextSibling = lexicalTable.getLatest().getNextSibling();
          if (nextSibling) {
            lexicalTable.getLatest().selectNext();
          } else {
            const newParagraph = $createParagraphNode();
            lexicalTable.insertAfter(newParagraph);
            newParagraph.select();
          }
        });
        return;
      }
      if (rowIndex < 0) {
        setActiveCell(null);
        parentEditor.update(() => {
          lexicalTable.getLatest().selectPrevious();
        });
        return;
      }
      setActiveCell([colIndex, rowIndex]);
    },
    [lexicalTable, parentEditor]
  );
  import_react24.default.useEffect(() => {
    lexicalTable.focusEmitter.subscribe(setActiveCellWithBoundaries);
  }, [lexicalTable, setActiveCellWithBoundaries]);
  const addRowToBottom = import_react24.default.useCallback(
    (e2) => {
      e2.preventDefault();
      parentEditor.update(() => {
        lexicalTable.addRowToBottom();
        setActiveCell([0, lexicalTable.getRowCount()]);
      });
    },
    [parentEditor, lexicalTable]
  );
  const addColumnToRight = import_react24.default.useCallback(
    (e2) => {
      e2.preventDefault();
      parentEditor.update(() => {
        lexicalTable.addColumnToRight();
        setActiveCell([lexicalTable.getColCount(), 0]);
      });
    },
    [parentEditor, lexicalTable]
  );
  const [highlightedCoordinates, setHighlightedCoordinates] = import_react24.default.useState([-1, -1]);
  const onTableMouseOver = import_react24.default.useCallback((e2) => {
    let tableCell = e2.target;
    while (tableCell && !["TH", "TD"].includes(tableCell.tagName)) {
      if (tableCell === e2.currentTarget) {
        return;
      }
      tableCell = tableCell.parentElement;
    }
    if (tableCell === null) {
      return;
    }
    const tableRow = tableCell.parentElement;
    const tableContainer = tableRow.parentElement;
    const colIndex = tableContainer.tagName === "TFOOT" ? -1 : Array.from(tableRow.children).indexOf(tableCell);
    const rowIndex = tableCell.tagName === "TH" ? -1 : Array.from(tableRow.parentElement.children).indexOf(tableRow);
    setHighlightedCoordinates([colIndex, rowIndex]);
  }, []);
  const t3 = useTranslation();
  return import_react24.default.createElement(
    "table",
    {
      className: styles.tableEditor,
      onMouseOver: onTableMouseOver,
      onMouseLeave: () => {
        setHighlightedCoordinates([-1, -1]);
      }
    },
    import_react24.default.createElement("colgroup", null, readOnly ? null : import_react24.default.createElement("col", null), Array.from({ length: mdastNode.children[0].children.length }, (_2, colIndex) => {
      const align = mdastNode.align ?? [];
      const currentColumnAlign = align[colIndex] ?? "left";
      const className = AlignToTailwindClassMap[currentColumnAlign];
      return import_react24.default.createElement("col", { key: colIndex, className });
    }), readOnly ? null : import_react24.default.createElement("col", null)),
    readOnly || import_react24.default.createElement("thead", null, import_react24.default.createElement("tr", null, import_react24.default.createElement("th", { className: styles.tableToolsColumn }), Array.from({ length: mdastNode.children[0].children.length }, (_2, colIndex) => {
      return import_react24.default.createElement("th", { key: colIndex, "data-tool-cell": true }, import_react24.default.createElement(
        ColumnEditor,
        {
          ...{
            setActiveCellWithBoundaries,
            parentEditor,
            colIndex,
            highlightedCoordinates,
            lexicalTable,
            align: (mdastNode.align ?? [])[colIndex]
          }
        }
      ));
    }), import_react24.default.createElement("th", { className: styles.tableToolsColumn, "data-tool-cell": true }, import_react24.default.createElement(
      "button",
      {
        className: styles.iconButton,
        type: "button",
        title: t3("table.deleteTable", "Delete table"),
        onClick: (e2) => {
          e2.preventDefault();
          parentEditor.update(() => {
            lexicalTable.selectNext();
            lexicalTable.remove();
          });
        }
      },
      iconComponentFor("delete_small")
    )))),
    import_react24.default.createElement("tbody", null, mdastNode.children.map((row, rowIndex) => {
      const CellElement = getCellType(rowIndex);
      return import_react24.default.createElement("tr", { key: rowIndex }, readOnly || import_react24.default.createElement(CellElement, { className: styles.toolCell, "data-tool-cell": true }, import_react24.default.createElement(RowEditor, { ...{ setActiveCellWithBoundaries, parentEditor, rowIndex, highlightedCoordinates, lexicalTable } })), row.children.map((mdastCell, colIndex) => {
        var _a2;
        return import_react24.default.createElement(
          Cell,
          {
            align: (_a2 = mdastNode.align) == null ? void 0 : _a2[colIndex],
            key: getCellKey(mdastCell),
            contents: mdastCell.children,
            setActiveCell: setActiveCellWithBoundaries,
            ...{
              rowIndex,
              colIndex,
              lexicalTable,
              parentEditor,
              activeCell: readOnly ? [-1, -1] : activeCell
            }
          }
        );
      }), readOnly || rowIndex === 0 && import_react24.default.createElement("th", { rowSpan: lexicalTable.getRowCount(), "data-tool-cell": true }, import_react24.default.createElement("button", { type: "button", className: styles.addColumnButton, onClick: addColumnToRight }, iconComponentFor("add_column"))));
    })),
    readOnly || import_react24.default.createElement("tfoot", null, import_react24.default.createElement("tr", null, import_react24.default.createElement("th", null), import_react24.default.createElement("th", { colSpan: lexicalTable.getColCount() }, import_react24.default.createElement("button", { type: "button", className: styles.addRowButton, onClick: addRowToBottom }, iconComponentFor("add_row"))), import_react24.default.createElement("th", null)))
  );
};
var Cell = ({ align, ...props }) => {
  const { activeCell, setActiveCell } = props;
  const isActive = Boolean(activeCell && activeCell[0] === props.colIndex && activeCell[1] === props.rowIndex);
  const className = AlignToTailwindClassMap[align ?? "left"];
  const CellElement = getCellType(props.rowIndex);
  return import_react24.default.createElement(
    CellElement,
    {
      className,
      "data-active": isActive,
      onClick: () => {
        setActiveCell([props.colIndex, props.rowIndex]);
      }
    },
    import_react24.default.createElement(CellEditor, { ...props, focus: isActive })
  );
};
var CellEditor = ({ focus: focus2, setActiveCell, parentEditor, lexicalTable, contents, colIndex, rowIndex }) => {
  const [
    importVisitors,
    exportVisitors,
    usedLexicalNodes,
    jsxComponentDescriptors,
    directiveDescriptors,
    codeBlockEditorDescriptors,
    jsxIsAvailable,
    rootEditor
  ] = X(
    importVisitors$,
    exportVisitors$,
    usedLexicalNodes$,
    jsxComponentDescriptors$,
    directiveDescriptors$,
    codeBlockEditorDescriptors$,
    jsxIsAvailable$,
    rootEditor$
  );
  const [editor] = import_react24.default.useState(() => {
    const editor2 = createEditor({
      nodes: usedLexicalNodes,
      theme: lexicalTheme
    });
    editor2.update(() => {
      importMdastTreeToLexical({
        root: $getRoot(),
        mdastRoot: { type: "root", children: [{ type: "paragraph", children: contents }] },
        visitors: importVisitors,
        jsxComponentDescriptors,
        directiveDescriptors,
        codeBlockEditorDescriptors
      });
    });
    return editor2;
  });
  const saveAndFocus = import_react24.default.useCallback(
    (nextCell) => {
      editor.getEditorState().read(() => {
        const mdast = exportLexicalTreeToMdast({
          root: $getRoot(),
          jsxComponentDescriptors,
          visitors: exportVisitors,
          jsxIsAvailable
        });
        parentEditor.update(
          () => {
            lexicalTable.updateCellContents(colIndex, rowIndex, mdast.children[0].children);
          },
          { discrete: true }
        );
        parentEditor.dispatchCommand(NESTED_EDITOR_UPDATED_COMMAND, void 0);
      });
      setActiveCell(nextCell);
    },
    [colIndex, editor, exportVisitors, jsxComponentDescriptors, jsxIsAvailable, lexicalTable, parentEditor, rowIndex, setActiveCell]
  );
  import_react24.default.useEffect(() => {
    return mergeRegister(
      editor.registerCommand(
        KEY_TAB_COMMAND,
        (payload) => {
          payload.preventDefault();
          const nextCell = payload.shiftKey ? [colIndex - 1, rowIndex] : [colIndex + 1, rowIndex];
          saveAndFocus(nextCell);
          return true;
        },
        COMMAND_PRIORITY_CRITICAL
      ),
      editor.registerCommand(
        FOCUS_COMMAND,
        () => {
          setActiveCell([colIndex, rowIndex]);
          return false;
        },
        COMMAND_PRIORITY_LOW
      ),
      editor.registerCommand(
        KEY_ENTER_COMMAND,
        (payload) => {
          payload == null ? void 0 : payload.preventDefault();
          const nextCell = (payload == null ? void 0 : payload.shiftKey) ? [colIndex, rowIndex - 1] : [colIndex, rowIndex + 1];
          saveAndFocus(nextCell);
          return true;
        },
        COMMAND_PRIORITY_CRITICAL
      ),
      editor.registerCommand(
        BLUR_COMMAND,
        (payload) => {
          const relatedTarget = payload.relatedTarget;
          if (isPartOftheEditorUI(relatedTarget, rootEditor.getRootElement())) {
            return false;
          }
          saveAndFocus(null);
          return true;
        },
        COMMAND_PRIORITY_EDITOR
      ),
      editor.registerCommand(
        NESTED_EDITOR_UPDATED_COMMAND,
        () => {
          saveAndFocus(null);
          return true;
        },
        COMMAND_PRIORITY_EDITOR
      )
    );
  }, [colIndex, editor, rootEditor, rowIndex, saveAndFocus, setActiveCell]);
  import_react24.default.useEffect(() => {
    focus2 && editor.focus();
  }, [focus2, editor]);
  return import_react24.default.createElement(LexicalNestedComposer, { initialEditor: editor }, import_react24.default.createElement(RichTextPlugin, { contentEditable: import_react24.default.createElement(ContentEditable, null), placeholder: import_react24.default.createElement("div", null), ErrorBoundary: LexicalErrorBoundary }), import_react24.default.createElement(HistoryPlugin, null));
};
var ColumnEditor = ({
  parentEditor,
  highlightedCoordinates,
  align,
  lexicalTable,
  colIndex,
  setActiveCellWithBoundaries
}) => {
  const [editorRootElementRef, iconComponentFor] = X(editorRootElementRef$, iconComponentFor$);
  const insertColumnAt = import_react24.default.useCallback(
    (colIndex2) => {
      parentEditor.update(() => {
        lexicalTable.insertColumnAt(colIndex2);
      });
      setActiveCellWithBoundaries([colIndex2, 0]);
    },
    [parentEditor, lexicalTable, setActiveCellWithBoundaries]
  );
  const deleteColumnAt = import_react24.default.useCallback(
    (colIndex2) => {
      parentEditor.update(() => {
        lexicalTable.deleteColumnAt(colIndex2);
      });
    },
    [parentEditor, lexicalTable]
  );
  const setColumnAlign = import_react24.default.useCallback(
    (colIndex2, align2) => {
      parentEditor.update(() => {
        lexicalTable.setColumnAlign(colIndex2, align2);
      });
    },
    [parentEditor, lexicalTable]
  );
  const t3 = useTranslation();
  return import_react24.default.createElement(Root22, null, import_react24.default.createElement(
    PopoverTrigger,
    {
      className: styles.tableColumnEditorTrigger,
      "data-active": highlightedCoordinates[0] === colIndex + 1,
      title: t3("table.columnMenu", "Column menu")
    },
    iconComponentFor("more_horiz")
  ), import_react24.default.createElement(Portal2, { container: editorRootElementRef == null ? void 0 : editorRootElementRef.current }, import_react24.default.createElement(
    PopoverContent,
    {
      className: (0, import_classnames2.default)(styles.tableColumnEditorPopoverContent),
      onOpenAutoFocus: (e2) => {
        e2.preventDefault();
      },
      sideOffset: 5,
      side: "top"
    },
    import_react24.default.createElement(Root42, { className: styles.tableColumnEditorToolbar }, import_react24.default.createElement(
      ToggleGroup2,
      {
        className: styles.toggleGroupRoot,
        onValueChange: (value2) => {
          setColumnAlign(colIndex, value2);
        },
        value: align ?? "left",
        type: "single",
        "aria-label": t3("table.textAlignment", "Text alignment")
      },
      import_react24.default.createElement(ToggleItem, { value: "left", title: t3("table.alignLeft", "Align left") }, iconComponentFor("format_align_left")),
      import_react24.default.createElement(ToggleItem, { value: "center", title: t3("table.alignCenter", "Align center") }, iconComponentFor("format_align_center")),
      import_react24.default.createElement(ToggleItem, { value: "right", title: t3("table.alignRight", "Align right") }, iconComponentFor("format_align_right"))
    ), import_react24.default.createElement(Separator2, null), import_react24.default.createElement(
      Button,
      {
        onClick: insertColumnAt.bind(null, colIndex),
        title: t3("table.insertColumnLeft", "Insert a column to the left of this one")
      },
      iconComponentFor("insert_col_left")
    ), import_react24.default.createElement(
      Button,
      {
        onClick: insertColumnAt.bind(null, colIndex + 1),
        title: t3("table.insertColumnRight", "Insert a column to the right of this one")
      },
      iconComponentFor("insert_col_right")
    ), import_react24.default.createElement(Button, { onClick: deleteColumnAt.bind(null, colIndex), title: t3("table.deleteColumn", "Delete this column") }, iconComponentFor("delete_small"))),
    import_react24.default.createElement(Arrow22, { className: styles.popoverArrow })
  )));
};
var RowEditor = ({
  parentEditor,
  highlightedCoordinates,
  lexicalTable,
  rowIndex,
  setActiveCellWithBoundaries
}) => {
  const [editorRootElementRef, iconComponentFor] = X(editorRootElementRef$, iconComponentFor$);
  const insertRowAt = import_react24.default.useCallback(
    (rowIndex2) => {
      parentEditor.update(() => {
        lexicalTable.insertRowAt(rowIndex2);
      });
      setActiveCellWithBoundaries([0, rowIndex2]);
    },
    [parentEditor, lexicalTable, setActiveCellWithBoundaries]
  );
  const deleteRowAt = import_react24.default.useCallback(
    (rowIndex2) => {
      parentEditor.update(() => {
        lexicalTable.deleteRowAt(rowIndex2);
      });
    },
    [parentEditor, lexicalTable]
  );
  const t3 = useTranslation();
  return import_react24.default.createElement(Root22, null, import_react24.default.createElement(
    PopoverTrigger,
    {
      className: styles.tableColumnEditorTrigger,
      "data-active": highlightedCoordinates[1] === rowIndex,
      title: t3("table.rowMenu", "Row menu")
    },
    iconComponentFor("more_horiz")
  ), import_react24.default.createElement(Portal2, { container: editorRootElementRef == null ? void 0 : editorRootElementRef.current }, import_react24.default.createElement(
    PopoverContent,
    {
      className: (0, import_classnames2.default)(styles.tableColumnEditorPopoverContent),
      onOpenAutoFocus: (e2) => {
        e2.preventDefault();
      },
      sideOffset: 5,
      side: "bottom"
    },
    import_react24.default.createElement(Root42, { className: styles.tableColumnEditorToolbar }, import_react24.default.createElement(
      Button,
      {
        onClick: insertRowAt.bind(null, rowIndex),
        title: t3("table.insertRowAbove", "Insert a row above this one")
      },
      iconComponentFor("insert_row_above")
    ), import_react24.default.createElement(
      Button,
      {
        onClick: insertRowAt.bind(null, rowIndex + 1),
        title: t3("table.insertRowBelow", "Insert a row below this one")
      },
      iconComponentFor("insert_row_below")
    ), import_react24.default.createElement(Button, { onClick: deleteRowAt.bind(null, rowIndex), title: t3("table.deleteRow", "Delete this row") }, iconComponentFor("delete_small"))),
    import_react24.default.createElement(Arrow22, { className: styles.popoverArrow })
  )));
};

// node_modules/@mdxeditor/editor/dist/plugins/table/TableNode.js
var __defProp2 = Object.defineProperty;
var __defNormalProp2 = (obj, key2, value2) => key2 in obj ? __defProp2(obj, key2, { enumerable: true, configurable: true, writable: true, value: value2 }) : obj[key2] = value2;
var __publicField3 = (obj, key2, value2) => {
  __defNormalProp2(obj, typeof key2 !== "symbol" ? key2 + "" : key2, value2);
  return value2;
};
var EMPTY_CELL = { type: "tableCell", children: [] };
function coordinatesEmitter() {
  let subscription2 = noop;
  return {
    publish: (coords) => {
      subscription2(coords);
    },
    subscribe: (cb) => {
      subscription2 = cb;
    }
  };
}
var TableNode = class _TableNode extends DecoratorNode {
  /**
   * Constructs a new {@link TableNode} with the specified MDAST table node as the object to edit.
   * See {@link https://github.com/micromark/micromark-extension-gfm-table | micromark/micromark-extension-gfm-table} for more information on the MDAST table node.
   */
  constructor(mdastNode, key2) {
    super(key2);
    __publicField3(this, "__mdastNode");
    __publicField3(this, "focusEmitter", coordinatesEmitter());
    this.__mdastNode = mdastNode ?? { type: "table", children: [] };
  }
  /** @internal */
  static getType() {
    return "table";
  }
  /** @internal */
  static clone(node2) {
    return new _TableNode(structuredClone(node2.__mdastNode), node2.__key);
  }
  /** @internal */
  static importJSON(serializedNode) {
    return $createTableNode(serializedNode.mdastNode);
  }
  /** @internal */
  exportJSON() {
    return {
      mdastNode: structuredClone(this.__mdastNode),
      type: "table",
      version: 1
    };
  }
  /**
   * Returns the mdast node that this node is constructed from.
   */
  getMdastNode() {
    return this.__mdastNode;
  }
  /**
   * Returns the number of rows in the table.
   */
  getRowCount() {
    return this.__mdastNode.children.length;
  }
  /**
   * Returns the number of columns in the table.
   */
  getColCount() {
    var _a2;
    return ((_a2 = this.__mdastNode.children[0]) == null ? void 0 : _a2.children.length) || 0;
  }
  /** @internal */
  createDOM() {
    return document.createElement("div");
  }
  /** @internal */
  updateDOM() {
    return false;
  }
  /** @internal */
  updateCellContents(colIndex, rowIndex, children) {
    const self2 = this.getWritable();
    const table = self2.__mdastNode;
    const row = table.children[rowIndex];
    const cells = row.children;
    const cell = cells[colIndex];
    const cellsClone = Array.from(cells);
    const cellClone = { ...cell, children };
    const rowClone = { ...row, children: cellsClone };
    cellsClone[colIndex] = cellClone;
    table.children[rowIndex] = rowClone;
  }
  insertColumnAt(colIndex) {
    const self2 = this.getWritable();
    const table = self2.__mdastNode;
    for (let rowIndex = 0; rowIndex < table.children.length; rowIndex++) {
      const row = table.children[rowIndex];
      const cells = row.children;
      const cellsClone = Array.from(cells);
      const rowClone = { ...row, children: cellsClone };
      cellsClone.splice(colIndex, 0, structuredClone(EMPTY_CELL));
      table.children[rowIndex] = rowClone;
    }
    if (table.align && table.align.length > 0) {
      table.align.splice(colIndex, 0, "left");
    }
  }
  deleteColumnAt(colIndex) {
    const self2 = this.getWritable();
    const table = self2.__mdastNode;
    for (let rowIndex = 0; rowIndex < table.children.length; rowIndex++) {
      const row = table.children[rowIndex];
      const cells = row.children;
      const cellsClone = Array.from(cells);
      const rowClone = { ...row, children: cellsClone };
      cellsClone.splice(colIndex, 1);
      table.children[rowIndex] = rowClone;
    }
  }
  insertRowAt(y2) {
    const self2 = this.getWritable();
    const table = self2.__mdastNode;
    const newRow = {
      type: "tableRow",
      children: Array.from({ length: this.getColCount() }, () => structuredClone(EMPTY_CELL))
    };
    table.children.splice(y2, 0, newRow);
  }
  deleteRowAt(rowIndex) {
    if (this.getRowCount() === 1) {
      this.selectNext();
      this.remove();
    } else {
      this.getWritable().__mdastNode.children.splice(rowIndex, 1);
    }
  }
  addRowToBottom() {
    this.insertRowAt(this.getRowCount());
  }
  addColumnToRight() {
    this.insertColumnAt(this.getColCount());
  }
  setColumnAlign(colIndex, align) {
    const self2 = this.getWritable();
    const table = self2.__mdastNode;
    if (table.align == null) {
      table.align = [];
    }
    table.align[colIndex] = align;
  }
  /** @internal */
  decorate(parentEditor) {
    return import_react25.default.createElement(TableEditor, { lexicalTable: this, mdastNode: this.__mdastNode, parentEditor });
  }
  /**
   * Focuses the table cell at the specified coordinates.
   * Pass `undefined` to remove the focus.
   */
  select(coords) {
    this.focusEmitter.publish(coords ?? [0, 0]);
  }
  /** @internal */
  isInline() {
    return false;
  }
};
function $isTableNode(node2) {
  return node2 instanceof TableNode;
}
function $createTableNode(mdastNode) {
  return new TableNode(mdastNode);
}

// node_modules/@mdxeditor/editor/dist/plugins/table/LexicalTableVisitor.js
var LexicalTableVisitor = {
  testLexicalNode: $isTableNode,
  visitLexicalNode({ actions, mdastParent, lexicalNode }) {
    actions.appendToParent(mdastParent, lexicalNode.getMdastNode());
  }
};

// node_modules/@mdxeditor/editor/dist/plugins/table/MdastTableVisitor.js
var MdastTableVisitor = {
  testNode: "table",
  visitNode({ mdastNode, lexicalParent }) {
    lexicalParent.append($createTableNode(mdastNode));
  }
};

// node_modules/@mdxeditor/editor/dist/plugins/table/index.js
function seedTable(rows = 1, columns = 1) {
  const table = {
    type: "table",
    children: []
  };
  for (let i3 = 0; i3 < rows; i3++) {
    const tableRow = {
      type: "tableRow",
      children: []
    };
    for (let j3 = 0; j3 < columns; j3++) {
      const cell = {
        type: "tableCell",
        children: []
      };
      tableRow.children.push(cell);
    }
    table.children.push(tableRow);
  }
  return table;
}
var insertTable$ = K((r2) => {
  r2.link(
    r2.pipe(
      insertTable$,
      _(({ rows, columns }) => {
        return () => $createTableNode(seedTable(rows, columns));
      })
    ),
    insertDecoratorNode$
  );
});
var tablePlugin = realmPlugin({
  init(realm, params) {
    realm.pubIn({
      // import
      [addMdastExtension$]: gfmTableFromMarkdown(),
      [addSyntaxExtension$]: gfmTable(),
      [addImportVisitor$]: MdastTableVisitor,
      // export
      [addLexicalNode$]: TableNode,
      [addExportVisitor$]: LexicalTableVisitor,
      [addToMarkdownExtension$]: gfmTableToMarkdown({
        tableCellPadding: (params == null ? void 0 : params.tableCellPadding) ?? true,
        tablePipeAlign: (params == null ? void 0 : params.tablePipeAlign) ?? true
      })
    });
  }
});

// node_modules/@mdxeditor/editor/dist/plugins/link/index.js
var import_react29 = __toESM(require_react(), 1);

// node_modules/@lexical/link/LexicalLink.dev.mjs
var SUPPORTED_URL_PROTOCOLS = /* @__PURE__ */ new Set(["http:", "https:", "mailto:", "sms:", "tel:"]);
var LinkNode = class _LinkNode extends ElementNode {
  /** @internal */
  /** @internal */
  /** @internal */
  /** @internal */
  static getType() {
    return "link";
  }
  static clone(node2) {
    return new _LinkNode(node2.__url, {
      rel: node2.__rel,
      target: node2.__target,
      title: node2.__title
    }, node2.__key);
  }
  constructor(url = "", attributes4 = {}, key2) {
    super(key2);
    const {
      target = null,
      rel = null,
      title = null
    } = attributes4;
    this.__url = url;
    this.__target = target;
    this.__rel = rel;
    this.__title = title;
  }
  createDOM(config) {
    const element2 = document.createElement("a");
    element2.href = this.sanitizeUrl(this.__url);
    if (this.__target !== null) {
      element2.target = this.__target;
    }
    if (this.__rel !== null) {
      element2.rel = this.__rel;
    }
    if (this.__title !== null) {
      element2.title = this.__title;
    }
    addClassNamesToElement(element2, config.theme.link);
    return element2;
  }
  updateDOM(prevNode, anchor, config) {
    if (isHTMLAnchorElement(anchor)) {
      const url = this.__url;
      const target = this.__target;
      const rel = this.__rel;
      const title = this.__title;
      if (url !== prevNode.__url) {
        anchor.href = url;
      }
      if (target !== prevNode.__target) {
        if (target) {
          anchor.target = target;
        } else {
          anchor.removeAttribute("target");
        }
      }
      if (rel !== prevNode.__rel) {
        if (rel) {
          anchor.rel = rel;
        } else {
          anchor.removeAttribute("rel");
        }
      }
      if (title !== prevNode.__title) {
        if (title) {
          anchor.title = title;
        } else {
          anchor.removeAttribute("title");
        }
      }
    }
    return false;
  }
  static importDOM() {
    return {
      a: (node2) => ({
        conversion: $convertAnchorElement,
        priority: 1
      })
    };
  }
  static importJSON(serializedNode) {
    return $createLinkNode().updateFromJSON(serializedNode);
  }
  updateFromJSON(serializedNode) {
    return super.updateFromJSON(serializedNode).setURL(serializedNode.url).setRel(serializedNode.rel || null).setTarget(serializedNode.target || null).setTitle(serializedNode.title || null);
  }
  sanitizeUrl(url) {
    try {
      const parsedUrl = new URL(url);
      if (!SUPPORTED_URL_PROTOCOLS.has(parsedUrl.protocol)) {
        return "about:blank";
      }
    } catch (_unused) {
      return url;
    }
    return url;
  }
  exportJSON() {
    return {
      ...super.exportJSON(),
      rel: this.getRel(),
      target: this.getTarget(),
      title: this.getTitle(),
      url: this.getURL()
    };
  }
  getURL() {
    return this.getLatest().__url;
  }
  setURL(url) {
    const writable = this.getWritable();
    writable.__url = url;
    return writable;
  }
  getTarget() {
    return this.getLatest().__target;
  }
  setTarget(target) {
    const writable = this.getWritable();
    writable.__target = target;
    return writable;
  }
  getRel() {
    return this.getLatest().__rel;
  }
  setRel(rel) {
    const writable = this.getWritable();
    writable.__rel = rel;
    return writable;
  }
  getTitle() {
    return this.getLatest().__title;
  }
  setTitle(title) {
    const writable = this.getWritable();
    writable.__title = title;
    return writable;
  }
  insertNewAfter(_2, restoreSelection = true) {
    const linkNode = $createLinkNode(this.__url, {
      rel: this.__rel,
      target: this.__target,
      title: this.__title
    });
    this.insertAfter(linkNode, restoreSelection);
    return linkNode;
  }
  canInsertTextBefore() {
    return false;
  }
  canInsertTextAfter() {
    return false;
  }
  canBeEmpty() {
    return false;
  }
  isInline() {
    return true;
  }
  extractWithChild(child, selection2, destination) {
    if (!$isRangeSelection(selection2)) {
      return false;
    }
    const anchorNode = selection2.anchor.getNode();
    const focusNode = selection2.focus.getNode();
    return this.isParentOf(anchorNode) && this.isParentOf(focusNode) && selection2.getTextContent().length > 0;
  }
  isEmailURI() {
    return this.__url.startsWith("mailto:");
  }
  isWebSiteURI() {
    return this.__url.startsWith("https://") || this.__url.startsWith("http://");
  }
};
function $convertAnchorElement(domNode) {
  let node2 = null;
  if (isHTMLAnchorElement(domNode)) {
    const content3 = domNode.textContent;
    if (content3 !== null && content3 !== "" || domNode.children.length > 0) {
      node2 = $createLinkNode(domNode.getAttribute("href") || "", {
        rel: domNode.getAttribute("rel"),
        target: domNode.getAttribute("target"),
        title: domNode.getAttribute("title")
      });
    }
  }
  return {
    node: node2
  };
}
function $createLinkNode(url = "", attributes4) {
  return $applyNodeReplacement(new LinkNode(url, attributes4));
}
function $isLinkNode(node2) {
  return node2 instanceof LinkNode;
}
var AutoLinkNode = class _AutoLinkNode extends LinkNode {
  /** @internal */
  /** Indicates whether the autolink was ever unlinked. **/
  constructor(url = "", attributes4 = {}, key2) {
    super(url, attributes4, key2);
    this.__isUnlinked = attributes4.isUnlinked !== void 0 && attributes4.isUnlinked !== null ? attributes4.isUnlinked : false;
  }
  static getType() {
    return "autolink";
  }
  static clone(node2) {
    return new _AutoLinkNode(node2.__url, {
      isUnlinked: node2.__isUnlinked,
      rel: node2.__rel,
      target: node2.__target,
      title: node2.__title
    }, node2.__key);
  }
  getIsUnlinked() {
    return this.__isUnlinked;
  }
  setIsUnlinked(value2) {
    const self2 = this.getWritable();
    self2.__isUnlinked = value2;
    return self2;
  }
  createDOM(config) {
    if (this.__isUnlinked) {
      return document.createElement("span");
    } else {
      return super.createDOM(config);
    }
  }
  updateDOM(prevNode, anchor, config) {
    return super.updateDOM(prevNode, anchor, config) || prevNode.__isUnlinked !== this.__isUnlinked;
  }
  static importJSON(serializedNode) {
    return $createAutoLinkNode().updateFromJSON(serializedNode);
  }
  updateFromJSON(serializedNode) {
    return super.updateFromJSON(serializedNode).setIsUnlinked(serializedNode.isUnlinked || false);
  }
  static importDOM() {
    return null;
  }
  exportJSON() {
    return {
      ...super.exportJSON(),
      isUnlinked: this.__isUnlinked
    };
  }
  insertNewAfter(selection2, restoreSelection = true) {
    const element2 = this.getParentOrThrow().insertNewAfter(selection2, restoreSelection);
    if ($isElementNode(element2)) {
      const linkNode = $createAutoLinkNode(this.__url, {
        isUnlinked: this.__isUnlinked,
        rel: this.__rel,
        target: this.__target,
        title: this.__title
      });
      element2.append(linkNode);
      return linkNode;
    }
    return null;
  }
};
function $createAutoLinkNode(url = "", attributes4) {
  return $applyNodeReplacement(new AutoLinkNode(url, attributes4));
}
function $isAutoLinkNode(node2) {
  return node2 instanceof AutoLinkNode;
}
var TOGGLE_LINK_COMMAND = createCommand("TOGGLE_LINK_COMMAND");
function $getPointNode(point3, offset5) {
  if (point3.type === "element") {
    const node2 = point3.getNode();
    if (!$isElementNode(node2)) {
      throw Error(`$getPointNode: element point is not an ElementNode`);
    }
    const childNode = node2.getChildren()[point3.offset + offset5];
    return childNode || null;
  }
  return null;
}
function $withSelectedNodes($fn) {
  const initialSelection = $getSelection();
  if (!$isRangeSelection(initialSelection)) {
    return $fn();
  }
  const normalized = $normalizeSelection(initialSelection);
  const isBackwards = normalized.isBackward();
  const anchorNode = $getPointNode(normalized.anchor, isBackwards ? -1 : 0);
  const focusNode = $getPointNode(normalized.focus, isBackwards ? 0 : -1);
  const rval = $fn();
  if (anchorNode || focusNode) {
    const updatedSelection = $getSelection();
    if ($isRangeSelection(updatedSelection)) {
      const finalSelection = updatedSelection.clone();
      if (anchorNode) {
        const anchorParent = anchorNode.getParent();
        if (anchorParent) {
          finalSelection.anchor.set(anchorParent.getKey(), anchorNode.getIndexWithinParent() + (isBackwards ? 1 : 0), "element");
        }
      }
      if (focusNode) {
        const focusParent = focusNode.getParent();
        if (focusParent) {
          finalSelection.focus.set(focusParent.getKey(), focusNode.getIndexWithinParent() + (isBackwards ? 0 : 1), "element");
        }
      }
      $setSelection($normalizeSelection(finalSelection));
    }
  }
  return rval;
}
function $toggleLink(url, attributes4 = {}) {
  const {
    target,
    title
  } = attributes4;
  const rel = attributes4.rel === void 0 ? "noreferrer" : attributes4.rel;
  const selection2 = $getSelection();
  if (!$isRangeSelection(selection2)) {
    return;
  }
  const nodes = selection2.extract();
  if (url === null) {
    nodes.forEach((node2) => {
      const parentLink = $findMatchingParent(node2, (parent) => !$isAutoLinkNode(parent) && $isLinkNode(parent));
      if (parentLink) {
        const children = parentLink.getChildren();
        for (let i3 = 0; i3 < children.length; i3++) {
          parentLink.insertBefore(children[i3]);
        }
        parentLink.remove();
      }
    });
    return;
  }
  const updatedNodes = /* @__PURE__ */ new Set();
  const updateLinkNode = (linkNode) => {
    if (updatedNodes.has(linkNode.getKey())) {
      return;
    }
    updatedNodes.add(linkNode.getKey());
    linkNode.setURL(url);
    if (target !== void 0) {
      linkNode.setTarget(target);
    }
    if (rel !== void 0) {
      linkNode.setRel(rel);
    }
    if (title !== void 0) {
      linkNode.setTitle(title);
    }
  };
  if (nodes.length === 1) {
    const firstNode = nodes[0];
    const linkNode = $getAncestor3(firstNode, $isLinkNode);
    if (linkNode !== null) {
      return updateLinkNode(linkNode);
    }
  }
  $withSelectedNodes(() => {
    let linkNode = null;
    for (const node2 of nodes) {
      if (!node2.isAttached()) {
        continue;
      }
      const parentLinkNode = $getAncestor3(node2, $isLinkNode);
      if (parentLinkNode) {
        updateLinkNode(parentLinkNode);
        continue;
      }
      if ($isElementNode(node2)) {
        if (!node2.isInline()) {
          continue;
        }
        if ($isLinkNode(node2)) {
          if (!$isAutoLinkNode(node2) && (linkNode === null || !linkNode.getParentOrThrow().isParentOf(node2))) {
            updateLinkNode(node2);
            linkNode = node2;
            continue;
          }
          for (const child of node2.getChildren()) {
            node2.insertBefore(child);
          }
          node2.remove();
          continue;
        }
      }
      const prevLinkNode = node2.getPreviousSibling();
      if ($isLinkNode(prevLinkNode) && prevLinkNode.is(linkNode)) {
        prevLinkNode.append(node2);
        continue;
      }
      linkNode = $createLinkNode(url, {
        rel,
        target,
        title
      });
      node2.insertAfter(linkNode);
      linkNode.append(node2);
    }
  });
}
function $getAncestor3(node2, predicate) {
  let parent = node2;
  while (parent !== null && parent.getParent() !== null && !predicate(parent)) {
    parent = parent.getParentOrThrow();
  }
  return predicate(parent) ? parent : null;
}

// node_modules/@mdxeditor/editor/dist/plugins/link/MdastLinkVisitor.js
var MdastLinkVisitor = {
  testNode: "link",
  visitNode({ mdastNode, actions }) {
    actions.addAndStepInto(
      $createLinkNode(mdastNode.url, {
        title: mdastNode.title
      })
    );
  }
};

// node_modules/@mdxeditor/editor/dist/plugins/link/LexicalLinkVisitor.js
var LexicalLinkVisitor = {
  testLexicalNode: $isLinkNode,
  visitLexicalNode: ({ lexicalNode, actions }) => {
    actions.addAndStepInto("link", { url: lexicalNode.getURL(), title: lexicalNode.getTitle() });
  }
};

// node_modules/@lexical/react/LexicalLinkPlugin.dev.mjs
var import_react26 = __toESM(require_react(), 1);
function LinkPlugin({
  validateUrl,
  attributes: attributes4
}) {
  const [editor] = useLexicalComposerContext();
  (0, import_react26.useEffect)(() => {
    if (!editor.hasNodes([LinkNode])) {
      throw new Error("LinkPlugin: LinkNode not registered on editor");
    }
    return mergeRegister(editor.registerCommand(TOGGLE_LINK_COMMAND, (payload) => {
      if (payload === null) {
        $toggleLink(payload);
        return true;
      } else if (typeof payload === "string") {
        if (validateUrl === void 0 || validateUrl(payload)) {
          $toggleLink(payload, attributes4);
          return true;
        }
        return false;
      } else {
        const {
          url,
          target,
          rel,
          title
        } = payload;
        $toggleLink(url, {
          ...attributes4,
          rel,
          target,
          title
        });
        return true;
      }
    }, COMMAND_PRIORITY_LOW), validateUrl !== void 0 ? editor.registerCommand(PASTE_COMMAND, (event) => {
      const selection2 = $getSelection();
      if (!$isRangeSelection(selection2) || selection2.isCollapsed() || !objectKlassEquals(event, ClipboardEvent)) {
        return false;
      }
      const clipboardEvent = event;
      if (clipboardEvent.clipboardData === null) {
        return false;
      }
      const clipboardText = clipboardEvent.clipboardData.getData("text");
      if (!validateUrl(clipboardText)) {
        return false;
      }
      if (!selection2.getNodes().some((node2) => $isElementNode(node2))) {
        editor.dispatchCommand(TOGGLE_LINK_COMMAND, {
          ...attributes4,
          url: clipboardText
        });
        event.preventDefault();
        return true;
      }
      return false;
    }, COMMAND_PRIORITY_LOW) : () => {
    });
  }, [editor, validateUrl, attributes4]);
  return null;
}

// node_modules/@lexical/react/LexicalAutoLinkPlugin.dev.mjs
var import_react27 = __toESM(require_react(), 1);
function createLinkMatcherWithRegExp(regExp, urlTransformer = (text4) => text4) {
  return (text4) => {
    const match = regExp.exec(text4);
    if (match === null) {
      return null;
    }
    return {
      index: match.index,
      length: match[0].length,
      text: match[0],
      url: urlTransformer(match[0])
    };
  };
}
function findFirstMatch(text4, matchers) {
  for (let i3 = 0; i3 < matchers.length; i3++) {
    const match = matchers[i3](text4);
    if (match) {
      return match;
    }
  }
  return null;
}
var PUNCTUATION_OR_SPACE = /[.,;\s]/;
function isSeparator(char) {
  return PUNCTUATION_OR_SPACE.test(char);
}
function endsWithSeparator(textContent) {
  return isSeparator(textContent[textContent.length - 1]);
}
function startsWithSeparator(textContent) {
  return isSeparator(textContent[0]);
}
function startsWithTLD(textContent, isEmail) {
  if (isEmail) {
    return /^\.[a-zA-Z]{2,}/.test(textContent);
  } else {
    return /^\.[a-zA-Z0-9]{1,}/.test(textContent);
  }
}
function isPreviousNodeValid(node2) {
  let previousNode = node2.getPreviousSibling();
  if ($isElementNode(previousNode)) {
    previousNode = previousNode.getLastDescendant();
  }
  return previousNode === null || $isLineBreakNode(previousNode) || $isTextNode(previousNode) && endsWithSeparator(previousNode.getTextContent());
}
function isNextNodeValid(node2) {
  let nextNode = node2.getNextSibling();
  if ($isElementNode(nextNode)) {
    nextNode = nextNode.getFirstDescendant();
  }
  return nextNode === null || $isLineBreakNode(nextNode) || $isTextNode(nextNode) && startsWithSeparator(nextNode.getTextContent());
}
function isContentAroundIsValid(matchStart, matchEnd, text4, nodes) {
  const contentBeforeIsValid = matchStart > 0 ? isSeparator(text4[matchStart - 1]) : isPreviousNodeValid(nodes[0]);
  if (!contentBeforeIsValid) {
    return false;
  }
  const contentAfterIsValid = matchEnd < text4.length ? isSeparator(text4[matchEnd]) : isNextNodeValid(nodes[nodes.length - 1]);
  return contentAfterIsValid;
}
function extractMatchingNodes(nodes, startIndex, endIndex) {
  const unmodifiedBeforeNodes = [];
  const matchingNodes = [];
  const unmodifiedAfterNodes = [];
  let matchingOffset = 0;
  let currentOffset = 0;
  const currentNodes = [...nodes];
  while (currentNodes.length > 0) {
    const currentNode = currentNodes[0];
    const currentNodeText = currentNode.getTextContent();
    const currentNodeLength = currentNodeText.length;
    const currentNodeStart = currentOffset;
    const currentNodeEnd = currentOffset + currentNodeLength;
    if (currentNodeEnd <= startIndex) {
      unmodifiedBeforeNodes.push(currentNode);
      matchingOffset += currentNodeLength;
    } else if (currentNodeStart >= endIndex) {
      unmodifiedAfterNodes.push(currentNode);
    } else {
      matchingNodes.push(currentNode);
    }
    currentOffset += currentNodeLength;
    currentNodes.shift();
  }
  return [matchingOffset, unmodifiedBeforeNodes, matchingNodes, unmodifiedAfterNodes];
}
function $createAutoLinkNode_(nodes, startIndex, endIndex, match) {
  const linkNode = $createAutoLinkNode(match.url, match.attributes);
  if (nodes.length === 1) {
    let remainingTextNode = nodes[0];
    let linkTextNode;
    if (startIndex === 0) {
      [linkTextNode, remainingTextNode] = remainingTextNode.splitText(endIndex);
    } else {
      [, linkTextNode, remainingTextNode] = remainingTextNode.splitText(startIndex, endIndex);
    }
    const textNode = $createTextNode(match.text);
    textNode.setFormat(linkTextNode.getFormat());
    textNode.setDetail(linkTextNode.getDetail());
    textNode.setStyle(linkTextNode.getStyle());
    linkNode.append(textNode);
    linkTextNode.replace(linkNode);
    return remainingTextNode;
  } else if (nodes.length > 1) {
    const firstTextNode = nodes[0];
    let offset5 = firstTextNode.getTextContent().length;
    let firstLinkTextNode;
    if (startIndex === 0) {
      firstLinkTextNode = firstTextNode;
    } else {
      [, firstLinkTextNode] = firstTextNode.splitText(startIndex);
    }
    const linkNodes = [];
    let remainingTextNode;
    for (let i3 = 1; i3 < nodes.length; i3++) {
      const currentNode = nodes[i3];
      const currentNodeText = currentNode.getTextContent();
      const currentNodeLength = currentNodeText.length;
      const currentNodeStart = offset5;
      const currentNodeEnd = offset5 + currentNodeLength;
      if (currentNodeStart < endIndex) {
        if (currentNodeEnd <= endIndex) {
          linkNodes.push(currentNode);
        } else {
          const [linkTextNode, endNode] = currentNode.splitText(endIndex - currentNodeStart);
          linkNodes.push(linkTextNode);
          remainingTextNode = endNode;
        }
      }
      offset5 += currentNodeLength;
    }
    const selection2 = $getSelection();
    const selectedTextNode = selection2 ? selection2.getNodes().find($isTextNode) : void 0;
    const textNode = $createTextNode(firstLinkTextNode.getTextContent());
    textNode.setFormat(firstLinkTextNode.getFormat());
    textNode.setDetail(firstLinkTextNode.getDetail());
    textNode.setStyle(firstLinkTextNode.getStyle());
    linkNode.append(textNode, ...linkNodes);
    if (selectedTextNode && selectedTextNode === firstLinkTextNode) {
      if ($isRangeSelection(selection2)) {
        textNode.select(selection2.anchor.offset, selection2.focus.offset);
      } else if ($isNodeSelection(selection2)) {
        textNode.select(0, textNode.getTextContent().length);
      }
    }
    firstLinkTextNode.replace(linkNode);
    return remainingTextNode;
  }
  return void 0;
}
function $handleLinkCreation(nodes, matchers, onChange) {
  let currentNodes = [...nodes];
  const initialText = currentNodes.map((node2) => node2.getTextContent()).join("");
  let text4 = initialText;
  let match;
  let invalidMatchEnd = 0;
  while ((match = findFirstMatch(text4, matchers)) && match !== null) {
    const matchStart = match.index;
    const matchLength = match.length;
    const matchEnd = matchStart + matchLength;
    const isValid = isContentAroundIsValid(invalidMatchEnd + matchStart, invalidMatchEnd + matchEnd, initialText, currentNodes);
    if (isValid) {
      const [matchingOffset, , matchingNodes, unmodifiedAfterNodes] = extractMatchingNodes(currentNodes, invalidMatchEnd + matchStart, invalidMatchEnd + matchEnd);
      const actualMatchStart = invalidMatchEnd + matchStart - matchingOffset;
      const actualMatchEnd = invalidMatchEnd + matchEnd - matchingOffset;
      const remainingTextNode = $createAutoLinkNode_(matchingNodes, actualMatchStart, actualMatchEnd, match);
      currentNodes = remainingTextNode ? [remainingTextNode, ...unmodifiedAfterNodes] : unmodifiedAfterNodes;
      onChange(match.url, null);
      invalidMatchEnd = 0;
    } else {
      invalidMatchEnd += matchEnd;
    }
    text4 = text4.substring(matchEnd);
  }
}
function handleLinkEdit(linkNode, matchers, onChange) {
  const children = linkNode.getChildren();
  const childrenLength = children.length;
  for (let i3 = 0; i3 < childrenLength; i3++) {
    const child = children[i3];
    if (!$isTextNode(child) || !child.isSimpleText()) {
      replaceWithChildren(linkNode);
      onChange(null, linkNode.getURL());
      return;
    }
  }
  const text4 = linkNode.getTextContent();
  const match = findFirstMatch(text4, matchers);
  if (match === null || match.text !== text4) {
    replaceWithChildren(linkNode);
    onChange(null, linkNode.getURL());
    return;
  }
  if (!isPreviousNodeValid(linkNode) || !isNextNodeValid(linkNode)) {
    replaceWithChildren(linkNode);
    onChange(null, linkNode.getURL());
    return;
  }
  const url = linkNode.getURL();
  if (url !== match.url) {
    linkNode.setURL(match.url);
    onChange(match.url, url);
  }
  if (match.attributes) {
    const rel = linkNode.getRel();
    if (rel !== match.attributes.rel) {
      linkNode.setRel(match.attributes.rel || null);
      onChange(match.attributes.rel || null, rel);
    }
    const target = linkNode.getTarget();
    if (target !== match.attributes.target) {
      linkNode.setTarget(match.attributes.target || null);
      onChange(match.attributes.target || null, target);
    }
  }
}
function handleBadNeighbors(textNode, matchers, onChange) {
  const previousSibling = textNode.getPreviousSibling();
  const nextSibling = textNode.getNextSibling();
  const text4 = textNode.getTextContent();
  if ($isAutoLinkNode(previousSibling) && !previousSibling.getIsUnlinked() && (!startsWithSeparator(text4) || startsWithTLD(text4, previousSibling.isEmailURI()))) {
    previousSibling.append(textNode);
    handleLinkEdit(previousSibling, matchers, onChange);
    onChange(null, previousSibling.getURL());
  }
  if ($isAutoLinkNode(nextSibling) && !nextSibling.getIsUnlinked() && !endsWithSeparator(text4)) {
    replaceWithChildren(nextSibling);
    handleLinkEdit(nextSibling, matchers, onChange);
    onChange(null, nextSibling.getURL());
  }
}
function replaceWithChildren(node2) {
  const children = node2.getChildren();
  const childrenLength = children.length;
  for (let j3 = childrenLength - 1; j3 >= 0; j3--) {
    node2.insertAfter(children[j3]);
  }
  node2.remove();
  return children.map((child) => child.getLatest());
}
function getTextNodesToMatch(textNode) {
  const textNodesToMatch = [textNode];
  let nextSibling = textNode.getNextSibling();
  while (nextSibling !== null && $isTextNode(nextSibling) && nextSibling.isSimpleText()) {
    textNodesToMatch.push(nextSibling);
    if (/[\s]/.test(nextSibling.getTextContent())) {
      break;
    }
    nextSibling = nextSibling.getNextSibling();
  }
  return textNodesToMatch;
}
function useAutoLink(editor, matchers, onChange) {
  (0, import_react27.useEffect)(() => {
    if (!editor.hasNodes([AutoLinkNode])) {
      {
        throw Error(`LexicalAutoLinkPlugin: AutoLinkNode not registered on editor`);
      }
    }
    const onChangeWrapped = (url, prevUrl) => {
      if (onChange) {
        onChange(url, prevUrl);
      }
    };
    return mergeRegister(editor.registerNodeTransform(TextNode, (textNode) => {
      const parent = textNode.getParentOrThrow();
      const previous3 = textNode.getPreviousSibling();
      if ($isAutoLinkNode(parent) && !parent.getIsUnlinked()) {
        handleLinkEdit(parent, matchers, onChangeWrapped);
      } else if (!$isLinkNode(parent)) {
        if (textNode.isSimpleText() && (startsWithSeparator(textNode.getTextContent()) || !$isAutoLinkNode(previous3))) {
          const textNodesToMatch = getTextNodesToMatch(textNode);
          $handleLinkCreation(textNodesToMatch, matchers, onChangeWrapped);
        }
        handleBadNeighbors(textNode, matchers, onChangeWrapped);
      }
    }), editor.registerCommand(TOGGLE_LINK_COMMAND, (payload) => {
      const selection2 = $getSelection();
      if (payload !== null || !$isRangeSelection(selection2)) {
        return false;
      }
      const nodes = selection2.extract();
      nodes.forEach((node2) => {
        const parent = node2.getParent();
        if ($isAutoLinkNode(parent)) {
          parent.setIsUnlinked(!parent.getIsUnlinked());
          parent.markDirty();
          return true;
        }
      });
      return false;
    }, COMMAND_PRIORITY_LOW));
  }, [editor, matchers, onChange]);
}
function AutoLinkPlugin({
  matchers,
  onChange
}) {
  const [editor] = useLexicalComposerContext();
  useAutoLink(editor, matchers, onChange);
  return null;
}

// node_modules/@mdxeditor/editor/dist/plugins/link/AutoLinkPlugin.js
var import_react28 = __toESM(require_react(), 1);
var URL_REGEX = /((https?:\/\/(www\.)?)|(www\.))[-a-zA-Z0-9@:%._+~#=]{1,256}\.[a-zA-Z0-9()]{1,6}\b([-a-zA-Z0-9()@:%_+.~#?&//=]*)/;
var EMAIL_REGEX = /(([^<>()[\]\\.,;:\s@"]+(\.[^<>()[\]\\.,;:\s@"]+)*)|(".+"))@((\[[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}\])|(([a-zA-Z\-0-9]+\.)+[a-zA-Z]{2,}))/;
var MATCHERS = [
  createLinkMatcherWithRegExp(URL_REGEX, (text4) => {
    return text4.startsWith("http") ? text4 : `https://${text4}`;
  }),
  createLinkMatcherWithRegExp(EMAIL_REGEX, (text4) => {
    return `mailto:${text4}`;
  })
];
var LexicalAutoLinkPlugin = () => {
  return import_react28.default.createElement(AutoLinkPlugin, { matchers: MATCHERS });
};

// node_modules/@mdxeditor/editor/dist/plugins/link/index.js
var disableAutoLink$ = $(false);
var linkPlugin = realmPlugin({
  init(realm, params) {
    const disableAutoLink = Boolean(params == null ? void 0 : params.disableAutoLink);
    const linkPluginProps = (params == null ? void 0 : params.validateUrl) ? { validateUrl: params.validateUrl } : {};
    realm.pubIn({
      [addActivePlugin$]: "link",
      [addImportVisitor$]: MdastLinkVisitor,
      [addLexicalNode$]: [LinkNode, AutoLinkNode],
      [addExportVisitor$]: LexicalLinkVisitor,
      [disableAutoLink$]: disableAutoLink,
      [addComposerChild$]: () => import_react29.default.createElement(import_react29.default.Fragment, null, import_react29.default.createElement(LinkPlugin, { ...linkPluginProps }), disableAutoLink ? null : import_react29.default.createElement(LexicalAutoLinkPlugin, null))
    });
  }
});

// node_modules/@radix-ui/react-dialog/dist/index.mjs
var React38 = __toESM(require_react(), 1);
var import_jsx_runtime23 = __toESM(require_jsx_runtime(), 1);
var DIALOG_NAME = "Dialog";
var [createDialogContext, createDialogScope] = createContextScope(DIALOG_NAME);
var [DialogProvider, useDialogContext] = createDialogContext(DIALOG_NAME);
var Dialog = (props) => {
  const {
    __scopeDialog,
    children,
    open: openProp,
    defaultOpen,
    onOpenChange,
    modal = true
  } = props;
  const triggerRef = React38.useRef(null);
  const contentRef = React38.useRef(null);
  const [open = false, setOpen] = useControllableState({
    prop: openProp,
    defaultProp: defaultOpen,
    onChange: onOpenChange
  });
  return (0, import_jsx_runtime23.jsx)(
    DialogProvider,
    {
      scope: __scopeDialog,
      triggerRef,
      contentRef,
      contentId: useId(),
      titleId: useId(),
      descriptionId: useId(),
      open,
      onOpenChange: setOpen,
      onOpenToggle: React38.useCallback(() => setOpen((prevOpen) => !prevOpen), [setOpen]),
      modal,
      children
    }
  );
};
Dialog.displayName = DIALOG_NAME;
var TRIGGER_NAME2 = "DialogTrigger";
var DialogTrigger = React38.forwardRef(
  (props, forwardedRef) => {
    const { __scopeDialog, ...triggerProps } = props;
    const context = useDialogContext(TRIGGER_NAME2, __scopeDialog);
    const composedTriggerRef = useComposedRefs(forwardedRef, context.triggerRef);
    return (0, import_jsx_runtime23.jsx)(
      Primitive.button,
      {
        type: "button",
        "aria-haspopup": "dialog",
        "aria-expanded": context.open,
        "aria-controls": context.contentId,
        "data-state": getState2(context.open),
        ...triggerProps,
        ref: composedTriggerRef,
        onClick: composeEventHandlers(props.onClick, context.onOpenToggle)
      }
    );
  }
);
DialogTrigger.displayName = TRIGGER_NAME2;
var PORTAL_NAME3 = "DialogPortal";
var [PortalProvider2, usePortalContext2] = createDialogContext(PORTAL_NAME3, {
  forceMount: void 0
});
var DialogPortal = (props) => {
  const { __scopeDialog, forceMount, children, container } = props;
  const context = useDialogContext(PORTAL_NAME3, __scopeDialog);
  return (0, import_jsx_runtime23.jsx)(PortalProvider2, { scope: __scopeDialog, forceMount, children: React38.Children.map(children, (child) => (0, import_jsx_runtime23.jsx)(Presence, { present: forceMount || context.open, children: (0, import_jsx_runtime23.jsx)(Portal, { asChild: true, container, children: child }) })) });
};
DialogPortal.displayName = PORTAL_NAME3;
var OVERLAY_NAME = "DialogOverlay";
var DialogOverlay = React38.forwardRef(
  (props, forwardedRef) => {
    const portalContext = usePortalContext2(OVERLAY_NAME, props.__scopeDialog);
    const { forceMount = portalContext.forceMount, ...overlayProps } = props;
    const context = useDialogContext(OVERLAY_NAME, props.__scopeDialog);
    return context.modal ? (0, import_jsx_runtime23.jsx)(Presence, { present: forceMount || context.open, children: (0, import_jsx_runtime23.jsx)(DialogOverlayImpl, { ...overlayProps, ref: forwardedRef }) }) : null;
  }
);
DialogOverlay.displayName = OVERLAY_NAME;
var DialogOverlayImpl = React38.forwardRef(
  (props, forwardedRef) => {
    const { __scopeDialog, ...overlayProps } = props;
    const context = useDialogContext(OVERLAY_NAME, __scopeDialog);
    return (
      // Make sure `Content` is scrollable even when it doesn't live inside `RemoveScroll`
      // ie. when `Overlay` and `Content` are siblings
      (0, import_jsx_runtime23.jsx)(Combination_default, { as: Slot, allowPinchZoom: true, shards: [context.contentRef], children: (0, import_jsx_runtime23.jsx)(
        Primitive.div,
        {
          "data-state": getState2(context.open),
          ...overlayProps,
          ref: forwardedRef,
          style: { pointerEvents: "auto", ...overlayProps.style }
        }
      ) })
    );
  }
);
var CONTENT_NAME3 = "DialogContent";
var DialogContent = React38.forwardRef(
  (props, forwardedRef) => {
    const portalContext = usePortalContext2(CONTENT_NAME3, props.__scopeDialog);
    const { forceMount = portalContext.forceMount, ...contentProps } = props;
    const context = useDialogContext(CONTENT_NAME3, props.__scopeDialog);
    return (0, import_jsx_runtime23.jsx)(Presence, { present: forceMount || context.open, children: context.modal ? (0, import_jsx_runtime23.jsx)(DialogContentModal, { ...contentProps, ref: forwardedRef }) : (0, import_jsx_runtime23.jsx)(DialogContentNonModal, { ...contentProps, ref: forwardedRef }) });
  }
);
DialogContent.displayName = CONTENT_NAME3;
var DialogContentModal = React38.forwardRef(
  (props, forwardedRef) => {
    const context = useDialogContext(CONTENT_NAME3, props.__scopeDialog);
    const contentRef = React38.useRef(null);
    const composedRefs = useComposedRefs(forwardedRef, context.contentRef, contentRef);
    React38.useEffect(() => {
      const content3 = contentRef.current;
      if (content3) return hideOthers(content3);
    }, []);
    return (0, import_jsx_runtime23.jsx)(
      DialogContentImpl,
      {
        ...props,
        ref: composedRefs,
        trapFocus: context.open,
        disableOutsidePointerEvents: true,
        onCloseAutoFocus: composeEventHandlers(props.onCloseAutoFocus, (event) => {
          var _a2;
          event.preventDefault();
          (_a2 = context.triggerRef.current) == null ? void 0 : _a2.focus();
        }),
        onPointerDownOutside: composeEventHandlers(props.onPointerDownOutside, (event) => {
          const originalEvent = event.detail.originalEvent;
          const ctrlLeftClick = originalEvent.button === 0 && originalEvent.ctrlKey === true;
          const isRightClick = originalEvent.button === 2 || ctrlLeftClick;
          if (isRightClick) event.preventDefault();
        }),
        onFocusOutside: composeEventHandlers(
          props.onFocusOutside,
          (event) => event.preventDefault()
        )
      }
    );
  }
);
var DialogContentNonModal = React38.forwardRef(
  (props, forwardedRef) => {
    const context = useDialogContext(CONTENT_NAME3, props.__scopeDialog);
    const hasInteractedOutsideRef = React38.useRef(false);
    const hasPointerDownOutsideRef = React38.useRef(false);
    return (0, import_jsx_runtime23.jsx)(
      DialogContentImpl,
      {
        ...props,
        ref: forwardedRef,
        trapFocus: false,
        disableOutsidePointerEvents: false,
        onCloseAutoFocus: (event) => {
          var _a2, _b2;
          (_a2 = props.onCloseAutoFocus) == null ? void 0 : _a2.call(props, event);
          if (!event.defaultPrevented) {
            if (!hasInteractedOutsideRef.current) (_b2 = context.triggerRef.current) == null ? void 0 : _b2.focus();
            event.preventDefault();
          }
          hasInteractedOutsideRef.current = false;
          hasPointerDownOutsideRef.current = false;
        },
        onInteractOutside: (event) => {
          var _a2, _b2;
          (_a2 = props.onInteractOutside) == null ? void 0 : _a2.call(props, event);
          if (!event.defaultPrevented) {
            hasInteractedOutsideRef.current = true;
            if (event.detail.originalEvent.type === "pointerdown") {
              hasPointerDownOutsideRef.current = true;
            }
          }
          const target = event.target;
          const targetIsTrigger = (_b2 = context.triggerRef.current) == null ? void 0 : _b2.contains(target);
          if (targetIsTrigger) event.preventDefault();
          if (event.detail.originalEvent.type === "focusin" && hasPointerDownOutsideRef.current) {
            event.preventDefault();
          }
        }
      }
    );
  }
);
var DialogContentImpl = React38.forwardRef(
  (props, forwardedRef) => {
    const { __scopeDialog, trapFocus, onOpenAutoFocus, onCloseAutoFocus, ...contentProps } = props;
    const context = useDialogContext(CONTENT_NAME3, __scopeDialog);
    const contentRef = React38.useRef(null);
    const composedRefs = useComposedRefs(forwardedRef, contentRef);
    useFocusGuards();
    return (0, import_jsx_runtime23.jsxs)(import_jsx_runtime23.Fragment, { children: [
      (0, import_jsx_runtime23.jsx)(
        FocusScope,
        {
          asChild: true,
          loop: true,
          trapped: trapFocus,
          onMountAutoFocus: onOpenAutoFocus,
          onUnmountAutoFocus: onCloseAutoFocus,
          children: (0, import_jsx_runtime23.jsx)(
            DismissableLayer,
            {
              role: "dialog",
              id: context.contentId,
              "aria-describedby": context.descriptionId,
              "aria-labelledby": context.titleId,
              "data-state": getState2(context.open),
              ...contentProps,
              ref: composedRefs,
              onDismiss: () => context.onOpenChange(false)
            }
          )
        }
      ),
      (0, import_jsx_runtime23.jsxs)(import_jsx_runtime23.Fragment, { children: [
        (0, import_jsx_runtime23.jsx)(TitleWarning, { titleId: context.titleId }),
        (0, import_jsx_runtime23.jsx)(DescriptionWarning, { contentRef, descriptionId: context.descriptionId })
      ] })
    ] });
  }
);
var TITLE_NAME = "DialogTitle";
var DialogTitle = React38.forwardRef(
  (props, forwardedRef) => {
    const { __scopeDialog, ...titleProps } = props;
    const context = useDialogContext(TITLE_NAME, __scopeDialog);
    return (0, import_jsx_runtime23.jsx)(Primitive.h2, { id: context.titleId, ...titleProps, ref: forwardedRef });
  }
);
DialogTitle.displayName = TITLE_NAME;
var DESCRIPTION_NAME = "DialogDescription";
var DialogDescription = React38.forwardRef(
  (props, forwardedRef) => {
    const { __scopeDialog, ...descriptionProps } = props;
    const context = useDialogContext(DESCRIPTION_NAME, __scopeDialog);
    return (0, import_jsx_runtime23.jsx)(Primitive.p, { id: context.descriptionId, ...descriptionProps, ref: forwardedRef });
  }
);
DialogDescription.displayName = DESCRIPTION_NAME;
var CLOSE_NAME2 = "DialogClose";
var DialogClose = React38.forwardRef(
  (props, forwardedRef) => {
    const { __scopeDialog, ...closeProps } = props;
    const context = useDialogContext(CLOSE_NAME2, __scopeDialog);
    return (0, import_jsx_runtime23.jsx)(
      Primitive.button,
      {
        type: "button",
        ...closeProps,
        ref: forwardedRef,
        onClick: composeEventHandlers(props.onClick, () => context.onOpenChange(false))
      }
    );
  }
);
DialogClose.displayName = CLOSE_NAME2;
function getState2(open) {
  return open ? "open" : "closed";
}
var TITLE_WARNING_NAME = "DialogTitleWarning";
var [WarningProvider, useWarningContext] = createContext22(TITLE_WARNING_NAME, {
  contentName: CONTENT_NAME3,
  titleName: TITLE_NAME,
  docsSlug: "dialog"
});
var TitleWarning = ({ titleId }) => {
  const titleWarningContext = useWarningContext(TITLE_WARNING_NAME);
  const MESSAGE = `\`${titleWarningContext.contentName}\` requires a \`${titleWarningContext.titleName}\` for the component to be accessible for screen reader users.

If you want to hide the \`${titleWarningContext.titleName}\`, you can wrap it with our VisuallyHidden component.

For more information, see https://radix-ui.com/primitives/docs/components/${titleWarningContext.docsSlug}`;
  React38.useEffect(() => {
    if (titleId) {
      const hasTitle = document.getElementById(titleId);
      if (!hasTitle) console.error(MESSAGE);
    }
  }, [MESSAGE, titleId]);
  return null;
};
var DESCRIPTION_WARNING_NAME = "DialogDescriptionWarning";
var DescriptionWarning = ({ contentRef, descriptionId }) => {
  const descriptionWarningContext = useWarningContext(DESCRIPTION_WARNING_NAME);
  const MESSAGE = `Warning: Missing \`Description\` or \`aria-describedby={undefined}\` for {${descriptionWarningContext.contentName}}.`;
  React38.useEffect(() => {
    var _a2;
    const describedById = (_a2 = contentRef.current) == null ? void 0 : _a2.getAttribute("aria-describedby");
    if (descriptionId && describedById) {
      const hasDescription = document.getElementById(descriptionId);
      if (!hasDescription) console.warn(MESSAGE);
    }
  }, [MESSAGE, contentRef, descriptionId]);
  return null;
};
var Root5 = Dialog;
var Trigger2 = DialogTrigger;
var Portal3 = DialogPortal;
var Overlay = DialogOverlay;
var Content3 = DialogContent;
var Title = DialogTitle;
var Close = DialogClose;

// node_modules/@mdxeditor/editor/dist/plugins/image/ImageDialog.js
var import_classnames3 = __toESM(require_classnames(), 1);
var import_react33 = __toESM(require_react(), 1);

// node_modules/react-hook-form/dist/index.esm.mjs
var import_react30 = __toESM(require_react(), 1);
var isCheckBoxInput = (element2) => element2.type === "checkbox";
var isDateObject = (value2) => value2 instanceof Date;
var isNullOrUndefined = (value2) => value2 == null;
var isObjectType = (value2) => typeof value2 === "object";
var isObject = (value2) => !isNullOrUndefined(value2) && !Array.isArray(value2) && isObjectType(value2) && !isDateObject(value2);
var getEventValue = (event) => isObject(event) && event.target ? isCheckBoxInput(event.target) ? event.target.checked : event.target.value : event;
var getNodeParentName = (name2) => name2.substring(0, name2.search(/\.\d+(\.|$)/)) || name2;
var isNameInFieldArray = (names, name2) => names.has(getNodeParentName(name2));
var isPlainObject = (tempObject) => {
  const prototypeCopy = tempObject.constructor && tempObject.constructor.prototype;
  return isObject(prototypeCopy) && prototypeCopy.hasOwnProperty("isPrototypeOf");
};
var isWeb = typeof window !== "undefined" && typeof window.HTMLElement !== "undefined" && typeof document !== "undefined";
function cloneObject(data2) {
  let copy;
  const isArray2 = Array.isArray(data2);
  const isFileListInstance = typeof FileList !== "undefined" ? data2 instanceof FileList : false;
  if (data2 instanceof Date) {
    copy = new Date(data2);
  } else if (data2 instanceof Set) {
    copy = new Set(data2);
  } else if (!(isWeb && (data2 instanceof Blob || isFileListInstance)) && (isArray2 || isObject(data2))) {
    copy = isArray2 ? [] : {};
    if (!isArray2 && !isPlainObject(data2)) {
      copy = data2;
    } else {
      for (const key2 in data2) {
        if (data2.hasOwnProperty(key2)) {
          copy[key2] = cloneObject(data2[key2]);
        }
      }
    }
  } else {
    return data2;
  }
  return copy;
}
var compact = (value2) => Array.isArray(value2) ? value2.filter(Boolean) : [];
var isUndefined = (val) => val === void 0;
var get = (object, path, defaultValue) => {
  if (!path || !isObject(object)) {
    return defaultValue;
  }
  const result = compact(path.split(/[,[\].]+?/)).reduce((result2, key2) => isNullOrUndefined(result2) ? result2 : result2[key2], object);
  return isUndefined(result) || result === object ? isUndefined(object[path]) ? defaultValue : object[path] : result;
};
var isBoolean = (value2) => typeof value2 === "boolean";
var isKey = (value2) => /^\w*$/.test(value2);
var stringToPath = (input) => compact(input.replace(/["|']|\]/g, "").split(/\.|\[/));
var set = (object, path, value2) => {
  let index3 = -1;
  const tempPath = isKey(path) ? [path] : stringToPath(path);
  const length = tempPath.length;
  const lastIndex = length - 1;
  while (++index3 < length) {
    const key2 = tempPath[index3];
    let newValue = value2;
    if (index3 !== lastIndex) {
      const objValue = object[key2];
      newValue = isObject(objValue) || Array.isArray(objValue) ? objValue : !isNaN(+tempPath[index3 + 1]) ? [] : {};
    }
    if (key2 === "__proto__" || key2 === "constructor" || key2 === "prototype") {
      return;
    }
    object[key2] = newValue;
    object = object[key2];
  }
  return object;
};
var EVENTS = {
  BLUR: "blur",
  FOCUS_OUT: "focusout",
  CHANGE: "change"
};
var VALIDATION_MODE = {
  onBlur: "onBlur",
  onChange: "onChange",
  onSubmit: "onSubmit",
  onTouched: "onTouched",
  all: "all"
};
var INPUT_VALIDATION_RULES = {
  max: "max",
  min: "min",
  maxLength: "maxLength",
  minLength: "minLength",
  pattern: "pattern",
  required: "required",
  validate: "validate"
};
var HookFormContext = import_react30.default.createContext(null);
var useFormContext = () => import_react30.default.useContext(HookFormContext);
var getProxyFormState = (formState, control, localProxyFormState, isRoot = true) => {
  const result = {
    defaultValues: control._defaultValues
  };
  for (const key2 in formState) {
    Object.defineProperty(result, key2, {
      get: () => {
        const _key = key2;
        if (control._proxyFormState[_key] !== VALIDATION_MODE.all) {
          control._proxyFormState[_key] = !isRoot || VALIDATION_MODE.all;
        }
        localProxyFormState && (localProxyFormState[_key] = true);
        return formState[_key];
      }
    });
  }
  return result;
};
var isEmptyObject = (value2) => isObject(value2) && !Object.keys(value2).length;
var shouldRenderFormState = (formStateData, _proxyFormState, updateFormState, isRoot) => {
  updateFormState(formStateData);
  const { name: name2, ...formState } = formStateData;
  return isEmptyObject(formState) || Object.keys(formState).length >= Object.keys(_proxyFormState).length || Object.keys(formState).find((key2) => _proxyFormState[key2] === (!isRoot || VALIDATION_MODE.all));
};
var convertToArrayPayload = (value2) => Array.isArray(value2) ? value2 : [value2];
var shouldSubscribeByName = (name2, signalName, exact) => !name2 || !signalName || name2 === signalName || convertToArrayPayload(name2).some((currentName) => currentName && (exact ? currentName === signalName : currentName.startsWith(signalName) || signalName.startsWith(currentName)));
function useSubscribe(props) {
  const _props = import_react30.default.useRef(props);
  _props.current = props;
  import_react30.default.useEffect(() => {
    const subscription2 = !props.disabled && _props.current.subject && _props.current.subject.subscribe({
      next: _props.current.next
    });
    return () => {
      subscription2 && subscription2.unsubscribe();
    };
  }, [props.disabled]);
}
function useFormState(props) {
  const methods = useFormContext();
  const { control = methods.control, disabled, name: name2, exact } = props || {};
  const [formState, updateFormState] = import_react30.default.useState(control._formState);
  const _mounted = import_react30.default.useRef(true);
  const _localProxyFormState = import_react30.default.useRef({
    isDirty: false,
    isLoading: false,
    dirtyFields: false,
    touchedFields: false,
    validatingFields: false,
    isValidating: false,
    isValid: false,
    errors: false
  });
  const _name = import_react30.default.useRef(name2);
  _name.current = name2;
  useSubscribe({
    disabled,
    next: (value2) => _mounted.current && shouldSubscribeByName(_name.current, value2.name, exact) && shouldRenderFormState(value2, _localProxyFormState.current, control._updateFormState) && updateFormState({
      ...control._formState,
      ...value2
    }),
    subject: control._subjects.state
  });
  import_react30.default.useEffect(() => {
    _mounted.current = true;
    _localProxyFormState.current.isValid && control._updateValid(true);
    return () => {
      _mounted.current = false;
    };
  }, [control]);
  return import_react30.default.useMemo(() => getProxyFormState(formState, control, _localProxyFormState.current, false), [formState, control]);
}
var isString = (value2) => typeof value2 === "string";
var generateWatchOutput = (names, _names, formValues, isGlobal, defaultValue) => {
  if (isString(names)) {
    isGlobal && _names.watch.add(names);
    return get(formValues, names, defaultValue);
  }
  if (Array.isArray(names)) {
    return names.map((fieldName) => (isGlobal && _names.watch.add(fieldName), get(formValues, fieldName)));
  }
  isGlobal && (_names.watchAll = true);
  return formValues;
};
function useWatch(props) {
  const methods = useFormContext();
  const { control = methods.control, name: name2, defaultValue, disabled, exact } = props || {};
  const _name = import_react30.default.useRef(name2);
  _name.current = name2;
  useSubscribe({
    disabled,
    subject: control._subjects.values,
    next: (formState) => {
      if (shouldSubscribeByName(_name.current, formState.name, exact)) {
        updateValue(cloneObject(generateWatchOutput(_name.current, control._names, formState.values || control._formValues, false, defaultValue)));
      }
    }
  });
  const [value2, updateValue] = import_react30.default.useState(control._getWatch(name2, defaultValue));
  import_react30.default.useEffect(() => control._removeUnmounted());
  return value2;
}
function useController(props) {
  const methods = useFormContext();
  const { name: name2, disabled, control = methods.control, shouldUnregister } = props;
  const isArrayField = isNameInFieldArray(control._names.array, name2);
  const value2 = useWatch({
    control,
    name: name2,
    defaultValue: get(control._formValues, name2, get(control._defaultValues, name2, props.defaultValue)),
    exact: true
  });
  const formState = useFormState({
    control,
    name: name2,
    exact: true
  });
  const _registerProps = import_react30.default.useRef(control.register(name2, {
    ...props.rules,
    value: value2,
    ...isBoolean(props.disabled) ? { disabled: props.disabled } : {}
  }));
  const fieldState = import_react30.default.useMemo(() => Object.defineProperties({}, {
    invalid: {
      enumerable: true,
      get: () => !!get(formState.errors, name2)
    },
    isDirty: {
      enumerable: true,
      get: () => !!get(formState.dirtyFields, name2)
    },
    isTouched: {
      enumerable: true,
      get: () => !!get(formState.touchedFields, name2)
    },
    isValidating: {
      enumerable: true,
      get: () => !!get(formState.validatingFields, name2)
    },
    error: {
      enumerable: true,
      get: () => get(formState.errors, name2)
    }
  }), [formState, name2]);
  const field = import_react30.default.useMemo(() => ({
    name: name2,
    value: value2,
    ...isBoolean(disabled) || formState.disabled ? { disabled: formState.disabled || disabled } : {},
    onChange: (event) => _registerProps.current.onChange({
      target: {
        value: getEventValue(event),
        name: name2
      },
      type: EVENTS.CHANGE
    }),
    onBlur: () => _registerProps.current.onBlur({
      target: {
        value: get(control._formValues, name2),
        name: name2
      },
      type: EVENTS.BLUR
    }),
    ref: (elm) => {
      const field2 = get(control._fields, name2);
      if (field2 && elm) {
        field2._f.ref = {
          focus: () => elm.focus(),
          select: () => elm.select(),
          setCustomValidity: (message) => elm.setCustomValidity(message),
          reportValidity: () => elm.reportValidity()
        };
      }
    }
  }), [
    name2,
    control._formValues,
    disabled,
    formState.disabled,
    value2,
    control._fields
  ]);
  import_react30.default.useEffect(() => {
    const _shouldUnregisterField = control._options.shouldUnregister || shouldUnregister;
    const updateMounted = (name3, value3) => {
      const field2 = get(control._fields, name3);
      if (field2 && field2._f) {
        field2._f.mount = value3;
      }
    };
    updateMounted(name2, true);
    if (_shouldUnregisterField) {
      const value3 = cloneObject(get(control._options.defaultValues, name2));
      set(control._defaultValues, name2, value3);
      if (isUndefined(get(control._formValues, name2))) {
        set(control._formValues, name2, value3);
      }
    }
    !isArrayField && control.register(name2);
    return () => {
      (isArrayField ? _shouldUnregisterField && !control._state.action : _shouldUnregisterField) ? control.unregister(name2) : updateMounted(name2, false);
    };
  }, [name2, control, isArrayField, shouldUnregister]);
  import_react30.default.useEffect(() => {
    control._updateDisabledField({
      disabled,
      fields: control._fields,
      name: name2
    });
  }, [disabled, name2, control]);
  return import_react30.default.useMemo(() => ({
    field,
    formState,
    fieldState
  }), [field, formState, fieldState]);
}
var Controller = (props) => props.render(useController(props));
var appendErrors = (name2, validateAllFieldCriteria, errors, type2, message) => validateAllFieldCriteria ? {
  ...errors[name2],
  types: {
    ...errors[name2] && errors[name2].types ? errors[name2].types : {},
    [type2]: message || true
  }
} : {};
var generateId = () => {
  const d3 = typeof performance === "undefined" ? Date.now() : performance.now() * 1e3;
  return "xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx".replace(/[xy]/g, (c2) => {
    const r2 = (Math.random() * 16 + d3) % 16 | 0;
    return (c2 == "x" ? r2 : r2 & 3 | 8).toString(16);
  });
};
var getFocusFieldName = (name2, index3, options = {}) => options.shouldFocus || isUndefined(options.shouldFocus) ? options.focusName || `${name2}.${isUndefined(options.focusIndex) ? index3 : options.focusIndex}.` : "";
var getValidationModes = (mode) => ({
  isOnSubmit: !mode || mode === VALIDATION_MODE.onSubmit,
  isOnBlur: mode === VALIDATION_MODE.onBlur,
  isOnChange: mode === VALIDATION_MODE.onChange,
  isOnAll: mode === VALIDATION_MODE.all,
  isOnTouch: mode === VALIDATION_MODE.onTouched
});
var isWatched = (name2, _names, isBlurEvent) => !isBlurEvent && (_names.watchAll || _names.watch.has(name2) || [..._names.watch].some((watchName) => name2.startsWith(watchName) && /^\.\w+/.test(name2.slice(watchName.length))));
var iterateFieldsByAction = (fields, action, fieldsNames, abortEarly) => {
  for (const key2 of fieldsNames || Object.keys(fields)) {
    const field = get(fields, key2);
    if (field) {
      const { _f, ...currentField } = field;
      if (_f) {
        if (_f.refs && _f.refs[0] && action(_f.refs[0], key2) && !abortEarly) {
          return true;
        } else if (_f.ref && action(_f.ref, _f.name) && !abortEarly) {
          return true;
        } else {
          if (iterateFieldsByAction(currentField, action)) {
            break;
          }
        }
      } else if (isObject(currentField)) {
        if (iterateFieldsByAction(currentField, action)) {
          break;
        }
      }
    }
  }
  return;
};
var updateFieldArrayRootError = (errors, error, name2) => {
  const fieldArrayErrors = convertToArrayPayload(get(errors, name2));
  set(fieldArrayErrors, "root", error[name2]);
  set(errors, name2, fieldArrayErrors);
  return errors;
};
var isFileInput = (element2) => element2.type === "file";
var isFunction = (value2) => typeof value2 === "function";
var isHTMLElement3 = (value2) => {
  if (!isWeb) {
    return false;
  }
  const owner = value2 ? value2.ownerDocument : 0;
  return value2 instanceof (owner && owner.defaultView ? owner.defaultView.HTMLElement : HTMLElement);
};
var isMessage = (value2) => isString(value2);
var isRadioInput = (element2) => element2.type === "radio";
var isRegex = (value2) => value2 instanceof RegExp;
var defaultResult = {
  value: false,
  isValid: false
};
var validResult = { value: true, isValid: true };
var getCheckboxValue = (options) => {
  if (Array.isArray(options)) {
    if (options.length > 1) {
      const values2 = options.filter((option) => option && option.checked && !option.disabled).map((option) => option.value);
      return { value: values2, isValid: !!values2.length };
    }
    return options[0].checked && !options[0].disabled ? (
      // @ts-expect-error expected to work in the browser
      options[0].attributes && !isUndefined(options[0].attributes.value) ? isUndefined(options[0].value) || options[0].value === "" ? validResult : { value: options[0].value, isValid: true } : validResult
    ) : defaultResult;
  }
  return defaultResult;
};
var defaultReturn = {
  isValid: false,
  value: null
};
var getRadioValue = (options) => Array.isArray(options) ? options.reduce((previous3, option) => option && option.checked && !option.disabled ? {
  isValid: true,
  value: option.value
} : previous3, defaultReturn) : defaultReturn;
function getValidateError(result, ref2, type2 = "validate") {
  if (isMessage(result) || Array.isArray(result) && result.every(isMessage) || isBoolean(result) && !result) {
    return {
      type: type2,
      message: isMessage(result) ? result : "",
      ref: ref2
    };
  }
}
var getValueAndMessage = (validationData) => isObject(validationData) && !isRegex(validationData) ? validationData : {
  value: validationData,
  message: ""
};
var validateField = async (field, disabledFieldNames, formValues, validateAllFieldCriteria, shouldUseNativeValidation, isFieldArray) => {
  const { ref: ref2, refs, required, maxLength, minLength, min: min2, max: max2, pattern, validate, name: name2, valueAsNumber, mount } = field._f;
  const inputValue = get(formValues, name2);
  if (!mount || disabledFieldNames.has(name2)) {
    return {};
  }
  const inputRef = refs ? refs[0] : ref2;
  const setCustomValidity = (message) => {
    if (shouldUseNativeValidation && inputRef.reportValidity) {
      inputRef.setCustomValidity(isBoolean(message) ? "" : message || "");
      inputRef.reportValidity();
    }
  };
  const error = {};
  const isRadio = isRadioInput(ref2);
  const isCheckBox = isCheckBoxInput(ref2);
  const isRadioOrCheckbox2 = isRadio || isCheckBox;
  const isEmpty = (valueAsNumber || isFileInput(ref2)) && isUndefined(ref2.value) && isUndefined(inputValue) || isHTMLElement3(ref2) && ref2.value === "" || inputValue === "" || Array.isArray(inputValue) && !inputValue.length;
  const appendErrorsCurry = appendErrors.bind(null, name2, validateAllFieldCriteria, error);
  const getMinMaxMessage = (exceedMax, maxLengthMessage, minLengthMessage, maxType = INPUT_VALIDATION_RULES.maxLength, minType = INPUT_VALIDATION_RULES.minLength) => {
    const message = exceedMax ? maxLengthMessage : minLengthMessage;
    error[name2] = {
      type: exceedMax ? maxType : minType,
      message,
      ref: ref2,
      ...appendErrorsCurry(exceedMax ? maxType : minType, message)
    };
  };
  if (isFieldArray ? !Array.isArray(inputValue) || !inputValue.length : required && (!isRadioOrCheckbox2 && (isEmpty || isNullOrUndefined(inputValue)) || isBoolean(inputValue) && !inputValue || isCheckBox && !getCheckboxValue(refs).isValid || isRadio && !getRadioValue(refs).isValid)) {
    const { value: value2, message } = isMessage(required) ? { value: !!required, message: required } : getValueAndMessage(required);
    if (value2) {
      error[name2] = {
        type: INPUT_VALIDATION_RULES.required,
        message,
        ref: inputRef,
        ...appendErrorsCurry(INPUT_VALIDATION_RULES.required, message)
      };
      if (!validateAllFieldCriteria) {
        setCustomValidity(message);
        return error;
      }
    }
  }
  if (!isEmpty && (!isNullOrUndefined(min2) || !isNullOrUndefined(max2))) {
    let exceedMax;
    let exceedMin;
    const maxOutput = getValueAndMessage(max2);
    const minOutput = getValueAndMessage(min2);
    if (!isNullOrUndefined(inputValue) && !isNaN(inputValue)) {
      const valueNumber = ref2.valueAsNumber || (inputValue ? +inputValue : inputValue);
      if (!isNullOrUndefined(maxOutput.value)) {
        exceedMax = valueNumber > maxOutput.value;
      }
      if (!isNullOrUndefined(minOutput.value)) {
        exceedMin = valueNumber < minOutput.value;
      }
    } else {
      const valueDate = ref2.valueAsDate || new Date(inputValue);
      const convertTimeToDate = (time) => /* @__PURE__ */ new Date((/* @__PURE__ */ new Date()).toDateString() + " " + time);
      const isTime = ref2.type == "time";
      const isWeek = ref2.type == "week";
      if (isString(maxOutput.value) && inputValue) {
        exceedMax = isTime ? convertTimeToDate(inputValue) > convertTimeToDate(maxOutput.value) : isWeek ? inputValue > maxOutput.value : valueDate > new Date(maxOutput.value);
      }
      if (isString(minOutput.value) && inputValue) {
        exceedMin = isTime ? convertTimeToDate(inputValue) < convertTimeToDate(minOutput.value) : isWeek ? inputValue < minOutput.value : valueDate < new Date(minOutput.value);
      }
    }
    if (exceedMax || exceedMin) {
      getMinMaxMessage(!!exceedMax, maxOutput.message, minOutput.message, INPUT_VALIDATION_RULES.max, INPUT_VALIDATION_RULES.min);
      if (!validateAllFieldCriteria) {
        setCustomValidity(error[name2].message);
        return error;
      }
    }
  }
  if ((maxLength || minLength) && !isEmpty && (isString(inputValue) || isFieldArray && Array.isArray(inputValue))) {
    const maxLengthOutput = getValueAndMessage(maxLength);
    const minLengthOutput = getValueAndMessage(minLength);
    const exceedMax = !isNullOrUndefined(maxLengthOutput.value) && inputValue.length > +maxLengthOutput.value;
    const exceedMin = !isNullOrUndefined(minLengthOutput.value) && inputValue.length < +minLengthOutput.value;
    if (exceedMax || exceedMin) {
      getMinMaxMessage(exceedMax, maxLengthOutput.message, minLengthOutput.message);
      if (!validateAllFieldCriteria) {
        setCustomValidity(error[name2].message);
        return error;
      }
    }
  }
  if (pattern && !isEmpty && isString(inputValue)) {
    const { value: patternValue, message } = getValueAndMessage(pattern);
    if (isRegex(patternValue) && !inputValue.match(patternValue)) {
      error[name2] = {
        type: INPUT_VALIDATION_RULES.pattern,
        message,
        ref: ref2,
        ...appendErrorsCurry(INPUT_VALIDATION_RULES.pattern, message)
      };
      if (!validateAllFieldCriteria) {
        setCustomValidity(message);
        return error;
      }
    }
  }
  if (validate) {
    if (isFunction(validate)) {
      const result = await validate(inputValue, formValues);
      const validateError = getValidateError(result, inputRef);
      if (validateError) {
        error[name2] = {
          ...validateError,
          ...appendErrorsCurry(INPUT_VALIDATION_RULES.validate, validateError.message)
        };
        if (!validateAllFieldCriteria) {
          setCustomValidity(validateError.message);
          return error;
        }
      }
    } else if (isObject(validate)) {
      let validationResult = {};
      for (const key2 in validate) {
        if (!isEmptyObject(validationResult) && !validateAllFieldCriteria) {
          break;
        }
        const validateError = getValidateError(await validate[key2](inputValue, formValues), inputRef, key2);
        if (validateError) {
          validationResult = {
            ...validateError,
            ...appendErrorsCurry(key2, validateError.message)
          };
          setCustomValidity(validateError.message);
          if (validateAllFieldCriteria) {
            error[name2] = validationResult;
          }
        }
      }
      if (!isEmptyObject(validationResult)) {
        error[name2] = {
          ref: inputRef,
          ...validationResult
        };
        if (!validateAllFieldCriteria) {
          return error;
        }
      }
    }
  }
  setCustomValidity(true);
  return error;
};
var appendAt = (data2, value2) => [
  ...data2,
  ...convertToArrayPayload(value2)
];
var fillEmptyArray = (value2) => Array.isArray(value2) ? value2.map(() => void 0) : void 0;
function insert(data2, index3, value2) {
  return [
    ...data2.slice(0, index3),
    ...convertToArrayPayload(value2),
    ...data2.slice(index3)
  ];
}
var moveArrayAt = (data2, from, to) => {
  if (!Array.isArray(data2)) {
    return [];
  }
  if (isUndefined(data2[to])) {
    data2[to] = void 0;
  }
  data2.splice(to, 0, data2.splice(from, 1)[0]);
  return data2;
};
var prependAt = (data2, value2) => [
  ...convertToArrayPayload(value2),
  ...convertToArrayPayload(data2)
];
function removeAtIndexes(data2, indexes) {
  let i3 = 0;
  const temp = [...data2];
  for (const index3 of indexes) {
    temp.splice(index3 - i3, 1);
    i3++;
  }
  return compact(temp).length ? temp : [];
}
var removeArrayAt = (data2, index3) => isUndefined(index3) ? [] : removeAtIndexes(data2, convertToArrayPayload(index3).sort((a2, b3) => a2 - b3));
var swapArrayAt = (data2, indexA, indexB) => {
  [data2[indexA], data2[indexB]] = [data2[indexB], data2[indexA]];
};
function baseGet(object, updatePath) {
  const length = updatePath.slice(0, -1).length;
  let index3 = 0;
  while (index3 < length) {
    object = isUndefined(object) ? index3++ : object[updatePath[index3++]];
  }
  return object;
}
function isEmptyArray(obj) {
  for (const key2 in obj) {
    if (obj.hasOwnProperty(key2) && !isUndefined(obj[key2])) {
      return false;
    }
  }
  return true;
}
function unset(object, path) {
  const paths = Array.isArray(path) ? path : isKey(path) ? [path] : stringToPath(path);
  const childObject = paths.length === 1 ? object : baseGet(object, paths);
  const index3 = paths.length - 1;
  const key2 = paths[index3];
  if (childObject) {
    delete childObject[key2];
  }
  if (index3 !== 0 && (isObject(childObject) && isEmptyObject(childObject) || Array.isArray(childObject) && isEmptyArray(childObject))) {
    unset(object, paths.slice(0, -1));
  }
  return object;
}
var updateAt = (fieldValues, index3, value2) => {
  fieldValues[index3] = value2;
  return fieldValues;
};
function useFieldArray(props) {
  const methods = useFormContext();
  const { control = methods.control, name: name2, keyName = "id", shouldUnregister, rules } = props;
  const [fields, setFields] = import_react30.default.useState(control._getFieldArray(name2));
  const ids = import_react30.default.useRef(control._getFieldArray(name2).map(generateId));
  const _fieldIds = import_react30.default.useRef(fields);
  const _name = import_react30.default.useRef(name2);
  const _actioned = import_react30.default.useRef(false);
  _name.current = name2;
  _fieldIds.current = fields;
  control._names.array.add(name2);
  rules && control.register(name2, rules);
  useSubscribe({
    next: ({ values: values2, name: fieldArrayName }) => {
      if (fieldArrayName === _name.current || !fieldArrayName) {
        const fieldValues = get(values2, _name.current);
        if (Array.isArray(fieldValues)) {
          setFields(fieldValues);
          ids.current = fieldValues.map(generateId);
        }
      }
    },
    subject: control._subjects.array
  });
  const updateValues = import_react30.default.useCallback((updatedFieldArrayValues) => {
    _actioned.current = true;
    control._updateFieldArray(name2, updatedFieldArrayValues);
  }, [control, name2]);
  const append2 = (value2, options) => {
    const appendValue = convertToArrayPayload(cloneObject(value2));
    const updatedFieldArrayValues = appendAt(control._getFieldArray(name2), appendValue);
    control._names.focus = getFocusFieldName(name2, updatedFieldArrayValues.length - 1, options);
    ids.current = appendAt(ids.current, appendValue.map(generateId));
    updateValues(updatedFieldArrayValues);
    setFields(updatedFieldArrayValues);
    control._updateFieldArray(name2, updatedFieldArrayValues, appendAt, {
      argA: fillEmptyArray(value2)
    });
  };
  const prepend = (value2, options) => {
    const prependValue = convertToArrayPayload(cloneObject(value2));
    const updatedFieldArrayValues = prependAt(control._getFieldArray(name2), prependValue);
    control._names.focus = getFocusFieldName(name2, 0, options);
    ids.current = prependAt(ids.current, prependValue.map(generateId));
    updateValues(updatedFieldArrayValues);
    setFields(updatedFieldArrayValues);
    control._updateFieldArray(name2, updatedFieldArrayValues, prependAt, {
      argA: fillEmptyArray(value2)
    });
  };
  const remove = (index3) => {
    const updatedFieldArrayValues = removeArrayAt(control._getFieldArray(name2), index3);
    ids.current = removeArrayAt(ids.current, index3);
    updateValues(updatedFieldArrayValues);
    setFields(updatedFieldArrayValues);
    !Array.isArray(get(control._fields, name2)) && set(control._fields, name2, void 0);
    control._updateFieldArray(name2, updatedFieldArrayValues, removeArrayAt, {
      argA: index3
    });
  };
  const insert$1 = (index3, value2, options) => {
    const insertValue = convertToArrayPayload(cloneObject(value2));
    const updatedFieldArrayValues = insert(control._getFieldArray(name2), index3, insertValue);
    control._names.focus = getFocusFieldName(name2, index3, options);
    ids.current = insert(ids.current, index3, insertValue.map(generateId));
    updateValues(updatedFieldArrayValues);
    setFields(updatedFieldArrayValues);
    control._updateFieldArray(name2, updatedFieldArrayValues, insert, {
      argA: index3,
      argB: fillEmptyArray(value2)
    });
  };
  const swap = (indexA, indexB) => {
    const updatedFieldArrayValues = control._getFieldArray(name2);
    swapArrayAt(updatedFieldArrayValues, indexA, indexB);
    swapArrayAt(ids.current, indexA, indexB);
    updateValues(updatedFieldArrayValues);
    setFields(updatedFieldArrayValues);
    control._updateFieldArray(name2, updatedFieldArrayValues, swapArrayAt, {
      argA: indexA,
      argB: indexB
    }, false);
  };
  const move = (from, to) => {
    const updatedFieldArrayValues = control._getFieldArray(name2);
    moveArrayAt(updatedFieldArrayValues, from, to);
    moveArrayAt(ids.current, from, to);
    updateValues(updatedFieldArrayValues);
    setFields(updatedFieldArrayValues);
    control._updateFieldArray(name2, updatedFieldArrayValues, moveArrayAt, {
      argA: from,
      argB: to
    }, false);
  };
  const update = (index3, value2) => {
    const updateValue = cloneObject(value2);
    const updatedFieldArrayValues = updateAt(control._getFieldArray(name2), index3, updateValue);
    ids.current = [...updatedFieldArrayValues].map((item, i3) => !item || i3 === index3 ? generateId() : ids.current[i3]);
    updateValues(updatedFieldArrayValues);
    setFields([...updatedFieldArrayValues]);
    control._updateFieldArray(name2, updatedFieldArrayValues, updateAt, {
      argA: index3,
      argB: updateValue
    }, true, false);
  };
  const replace2 = (value2) => {
    const updatedFieldArrayValues = convertToArrayPayload(cloneObject(value2));
    ids.current = updatedFieldArrayValues.map(generateId);
    updateValues([...updatedFieldArrayValues]);
    setFields([...updatedFieldArrayValues]);
    control._updateFieldArray(name2, [...updatedFieldArrayValues], (data2) => data2, {}, true, false);
  };
  import_react30.default.useEffect(() => {
    control._state.action = false;
    isWatched(name2, control._names) && control._subjects.state.next({
      ...control._formState
    });
    if (_actioned.current && (!getValidationModes(control._options.mode).isOnSubmit || control._formState.isSubmitted)) {
      if (control._options.resolver) {
        control._executeSchema([name2]).then((result) => {
          const error = get(result.errors, name2);
          const existingError = get(control._formState.errors, name2);
          if (existingError ? !error && existingError.type || error && (existingError.type !== error.type || existingError.message !== error.message) : error && error.type) {
            error ? set(control._formState.errors, name2, error) : unset(control._formState.errors, name2);
            control._subjects.state.next({
              errors: control._formState.errors
            });
          }
        });
      } else {
        const field = get(control._fields, name2);
        if (field && field._f && !(getValidationModes(control._options.reValidateMode).isOnSubmit && getValidationModes(control._options.mode).isOnSubmit)) {
          validateField(field, control._names.disabled, control._formValues, control._options.criteriaMode === VALIDATION_MODE.all, control._options.shouldUseNativeValidation, true).then((error) => !isEmptyObject(error) && control._subjects.state.next({
            errors: updateFieldArrayRootError(control._formState.errors, error, name2)
          }));
        }
      }
    }
    control._subjects.values.next({
      name: name2,
      values: { ...control._formValues }
    });
    control._names.focus && iterateFieldsByAction(control._fields, (ref2, key2) => {
      if (control._names.focus && key2.startsWith(control._names.focus) && ref2.focus) {
        ref2.focus();
        return 1;
      }
      return;
    });
    control._names.focus = "";
    control._updateValid();
    _actioned.current = false;
  }, [fields, name2, control]);
  import_react30.default.useEffect(() => {
    !get(control._formValues, name2) && control._updateFieldArray(name2);
    return () => {
      (control._options.shouldUnregister || shouldUnregister) && control.unregister(name2);
    };
  }, [name2, control, keyName, shouldUnregister]);
  return {
    swap: import_react30.default.useCallback(swap, [updateValues, name2, control]),
    move: import_react30.default.useCallback(move, [updateValues, name2, control]),
    prepend: import_react30.default.useCallback(prepend, [updateValues, name2, control]),
    append: import_react30.default.useCallback(append2, [updateValues, name2, control]),
    remove: import_react30.default.useCallback(remove, [updateValues, name2, control]),
    insert: import_react30.default.useCallback(insert$1, [updateValues, name2, control]),
    update: import_react30.default.useCallback(update, [updateValues, name2, control]),
    replace: import_react30.default.useCallback(replace2, [updateValues, name2, control]),
    fields: import_react30.default.useMemo(() => fields.map((field, index3) => ({
      ...field,
      [keyName]: ids.current[index3] || generateId()
    })), [fields, keyName])
  };
}
var createSubject = () => {
  let _observers = [];
  const next = (value2) => {
    for (const observer of _observers) {
      observer.next && observer.next(value2);
    }
  };
  const subscribe = (observer) => {
    _observers.push(observer);
    return {
      unsubscribe: () => {
        _observers = _observers.filter((o3) => o3 !== observer);
      }
    };
  };
  const unsubscribe = () => {
    _observers = [];
  };
  return {
    get observers() {
      return _observers;
    },
    next,
    subscribe,
    unsubscribe
  };
};
var isPrimitive = (value2) => isNullOrUndefined(value2) || !isObjectType(value2);
function deepEqual2(object1, object2) {
  if (isPrimitive(object1) || isPrimitive(object2)) {
    return object1 === object2;
  }
  if (isDateObject(object1) && isDateObject(object2)) {
    return object1.getTime() === object2.getTime();
  }
  const keys1 = Object.keys(object1);
  const keys2 = Object.keys(object2);
  if (keys1.length !== keys2.length) {
    return false;
  }
  for (const key2 of keys1) {
    const val1 = object1[key2];
    if (!keys2.includes(key2)) {
      return false;
    }
    if (key2 !== "ref") {
      const val2 = object2[key2];
      if (isDateObject(val1) && isDateObject(val2) || isObject(val1) && isObject(val2) || Array.isArray(val1) && Array.isArray(val2) ? !deepEqual2(val1, val2) : val1 !== val2) {
        return false;
      }
    }
  }
  return true;
}
var isMultipleSelect = (element2) => element2.type === `select-multiple`;
var isRadioOrCheckbox = (ref2) => isRadioInput(ref2) || isCheckBoxInput(ref2);
var live = (ref2) => isHTMLElement3(ref2) && ref2.isConnected;
var objectHasFunction = (data2) => {
  for (const key2 in data2) {
    if (isFunction(data2[key2])) {
      return true;
    }
  }
  return false;
};
function markFieldsDirty(data2, fields = {}) {
  const isParentNodeArray = Array.isArray(data2);
  if (isObject(data2) || isParentNodeArray) {
    for (const key2 in data2) {
      if (Array.isArray(data2[key2]) || isObject(data2[key2]) && !objectHasFunction(data2[key2])) {
        fields[key2] = Array.isArray(data2[key2]) ? [] : {};
        markFieldsDirty(data2[key2], fields[key2]);
      } else if (!isNullOrUndefined(data2[key2])) {
        fields[key2] = true;
      }
    }
  }
  return fields;
}
function getDirtyFieldsFromDefaultValues(data2, formValues, dirtyFieldsFromValues) {
  const isParentNodeArray = Array.isArray(data2);
  if (isObject(data2) || isParentNodeArray) {
    for (const key2 in data2) {
      if (Array.isArray(data2[key2]) || isObject(data2[key2]) && !objectHasFunction(data2[key2])) {
        if (isUndefined(formValues) || isPrimitive(dirtyFieldsFromValues[key2])) {
          dirtyFieldsFromValues[key2] = Array.isArray(data2[key2]) ? markFieldsDirty(data2[key2], []) : { ...markFieldsDirty(data2[key2]) };
        } else {
          getDirtyFieldsFromDefaultValues(data2[key2], isNullOrUndefined(formValues) ? {} : formValues[key2], dirtyFieldsFromValues[key2]);
        }
      } else {
        dirtyFieldsFromValues[key2] = !deepEqual2(data2[key2], formValues[key2]);
      }
    }
  }
  return dirtyFieldsFromValues;
}
var getDirtyFields = (defaultValues, formValues) => getDirtyFieldsFromDefaultValues(defaultValues, formValues, markFieldsDirty(formValues));
var getFieldValueAs = (value2, { valueAsNumber, valueAsDate, setValueAs }) => isUndefined(value2) ? value2 : valueAsNumber ? value2 === "" ? NaN : value2 ? +value2 : value2 : valueAsDate && isString(value2) ? new Date(value2) : setValueAs ? setValueAs(value2) : value2;
function getFieldValue(_f) {
  const ref2 = _f.ref;
  if (isFileInput(ref2)) {
    return ref2.files;
  }
  if (isRadioInput(ref2)) {
    return getRadioValue(_f.refs).value;
  }
  if (isMultipleSelect(ref2)) {
    return [...ref2.selectedOptions].map(({ value: value2 }) => value2);
  }
  if (isCheckBoxInput(ref2)) {
    return getCheckboxValue(_f.refs).value;
  }
  return getFieldValueAs(isUndefined(ref2.value) ? _f.ref.value : ref2.value, _f);
}
var getResolverOptions = (fieldsNames, _fields, criteriaMode, shouldUseNativeValidation) => {
  const fields = {};
  for (const name2 of fieldsNames) {
    const field = get(_fields, name2);
    field && set(fields, name2, field._f);
  }
  return {
    criteriaMode,
    names: [...fieldsNames],
    fields,
    shouldUseNativeValidation
  };
};
var getRuleValue = (rule) => isUndefined(rule) ? rule : isRegex(rule) ? rule.source : isObject(rule) ? isRegex(rule.value) ? rule.value.source : rule.value : rule;
var ASYNC_FUNCTION = "AsyncFunction";
var hasPromiseValidation = (fieldReference) => !!fieldReference && !!fieldReference.validate && !!(isFunction(fieldReference.validate) && fieldReference.validate.constructor.name === ASYNC_FUNCTION || isObject(fieldReference.validate) && Object.values(fieldReference.validate).find((validateFunction) => validateFunction.constructor.name === ASYNC_FUNCTION));
var hasValidation = (options) => options.mount && (options.required || options.min || options.max || options.maxLength || options.minLength || options.pattern || options.validate);
function schemaErrorLookup(errors, _fields, name2) {
  const error = get(errors, name2);
  if (error || isKey(name2)) {
    return {
      error,
      name: name2
    };
  }
  const names = name2.split(".");
  while (names.length) {
    const fieldName = names.join(".");
    const field = get(_fields, fieldName);
    const foundError = get(errors, fieldName);
    if (field && !Array.isArray(field) && name2 !== fieldName) {
      return { name: name2 };
    }
    if (foundError && foundError.type) {
      return {
        name: fieldName,
        error: foundError
      };
    }
    names.pop();
  }
  return {
    name: name2
  };
}
var skipValidation = (isBlurEvent, isTouched, isSubmitted, reValidateMode, mode) => {
  if (mode.isOnAll) {
    return false;
  } else if (!isSubmitted && mode.isOnTouch) {
    return !(isTouched || isBlurEvent);
  } else if (isSubmitted ? reValidateMode.isOnBlur : mode.isOnBlur) {
    return !isBlurEvent;
  } else if (isSubmitted ? reValidateMode.isOnChange : mode.isOnChange) {
    return isBlurEvent;
  }
  return true;
};
var unsetEmptyArray = (ref2, name2) => !compact(get(ref2, name2)).length && unset(ref2, name2);
var defaultOptions = {
  mode: VALIDATION_MODE.onSubmit,
  reValidateMode: VALIDATION_MODE.onChange,
  shouldFocusError: true
};
function createFormControl(props = {}) {
  let _options = {
    ...defaultOptions,
    ...props
  };
  let _formState = {
    submitCount: 0,
    isDirty: false,
    isLoading: isFunction(_options.defaultValues),
    isValidating: false,
    isSubmitted: false,
    isSubmitting: false,
    isSubmitSuccessful: false,
    isValid: false,
    touchedFields: {},
    dirtyFields: {},
    validatingFields: {},
    errors: _options.errors || {},
    disabled: _options.disabled || false
  };
  let _fields = {};
  let _defaultValues = isObject(_options.defaultValues) || isObject(_options.values) ? cloneObject(_options.defaultValues || _options.values) || {} : {};
  let _formValues = _options.shouldUnregister ? {} : cloneObject(_defaultValues);
  let _state = {
    action: false,
    mount: false,
    watch: false
  };
  let _names = {
    mount: /* @__PURE__ */ new Set(),
    disabled: /* @__PURE__ */ new Set(),
    unMount: /* @__PURE__ */ new Set(),
    array: /* @__PURE__ */ new Set(),
    watch: /* @__PURE__ */ new Set()
  };
  let delayErrorCallback;
  let timer = 0;
  const _proxyFormState = {
    isDirty: false,
    dirtyFields: false,
    validatingFields: false,
    touchedFields: false,
    isValidating: false,
    isValid: false,
    errors: false
  };
  const _subjects = {
    values: createSubject(),
    array: createSubject(),
    state: createSubject()
  };
  const validationModeBeforeSubmit = getValidationModes(_options.mode);
  const validationModeAfterSubmit = getValidationModes(_options.reValidateMode);
  const shouldDisplayAllAssociatedErrors = _options.criteriaMode === VALIDATION_MODE.all;
  const debounce2 = (callback) => (wait) => {
    clearTimeout(timer);
    timer = setTimeout(callback, wait);
  };
  const _updateValid = async (shouldUpdateValid) => {
    if (!_options.disabled && (_proxyFormState.isValid || shouldUpdateValid)) {
      const isValid = _options.resolver ? isEmptyObject((await _executeSchema()).errors) : await executeBuiltInValidation(_fields, true);
      if (isValid !== _formState.isValid) {
        _subjects.state.next({
          isValid
        });
      }
    }
  };
  const _updateIsValidating = (names, isValidating) => {
    if (!_options.disabled && (_proxyFormState.isValidating || _proxyFormState.validatingFields)) {
      (names || Array.from(_names.mount)).forEach((name2) => {
        if (name2) {
          isValidating ? set(_formState.validatingFields, name2, isValidating) : unset(_formState.validatingFields, name2);
        }
      });
      _subjects.state.next({
        validatingFields: _formState.validatingFields,
        isValidating: !isEmptyObject(_formState.validatingFields)
      });
    }
  };
  const _updateFieldArray = (name2, values2 = [], method, args, shouldSetValues = true, shouldUpdateFieldsAndState = true) => {
    if (args && method && !_options.disabled) {
      _state.action = true;
      if (shouldUpdateFieldsAndState && Array.isArray(get(_fields, name2))) {
        const fieldValues = method(get(_fields, name2), args.argA, args.argB);
        shouldSetValues && set(_fields, name2, fieldValues);
      }
      if (shouldUpdateFieldsAndState && Array.isArray(get(_formState.errors, name2))) {
        const errors = method(get(_formState.errors, name2), args.argA, args.argB);
        shouldSetValues && set(_formState.errors, name2, errors);
        unsetEmptyArray(_formState.errors, name2);
      }
      if (_proxyFormState.touchedFields && shouldUpdateFieldsAndState && Array.isArray(get(_formState.touchedFields, name2))) {
        const touchedFields = method(get(_formState.touchedFields, name2), args.argA, args.argB);
        shouldSetValues && set(_formState.touchedFields, name2, touchedFields);
      }
      if (_proxyFormState.dirtyFields) {
        _formState.dirtyFields = getDirtyFields(_defaultValues, _formValues);
      }
      _subjects.state.next({
        name: name2,
        isDirty: _getDirty(name2, values2),
        dirtyFields: _formState.dirtyFields,
        errors: _formState.errors,
        isValid: _formState.isValid
      });
    } else {
      set(_formValues, name2, values2);
    }
  };
  const updateErrors = (name2, error) => {
    set(_formState.errors, name2, error);
    _subjects.state.next({
      errors: _formState.errors
    });
  };
  const _setErrors = (errors) => {
    _formState.errors = errors;
    _subjects.state.next({
      errors: _formState.errors,
      isValid: false
    });
  };
  const updateValidAndValue = (name2, shouldSkipSetValueAs, value2, ref2) => {
    const field = get(_fields, name2);
    if (field) {
      const defaultValue = get(_formValues, name2, isUndefined(value2) ? get(_defaultValues, name2) : value2);
      isUndefined(defaultValue) || ref2 && ref2.defaultChecked || shouldSkipSetValueAs ? set(_formValues, name2, shouldSkipSetValueAs ? defaultValue : getFieldValue(field._f)) : setFieldValue(name2, defaultValue);
      _state.mount && _updateValid();
    }
  };
  const updateTouchAndDirty = (name2, fieldValue, isBlurEvent, shouldDirty, shouldRender) => {
    let shouldUpdateField = false;
    let isPreviousDirty = false;
    const output = {
      name: name2
    };
    if (!_options.disabled) {
      const disabledField = !!(get(_fields, name2) && get(_fields, name2)._f && get(_fields, name2)._f.disabled);
      if (!isBlurEvent || shouldDirty) {
        if (_proxyFormState.isDirty) {
          isPreviousDirty = _formState.isDirty;
          _formState.isDirty = output.isDirty = _getDirty();
          shouldUpdateField = isPreviousDirty !== output.isDirty;
        }
        const isCurrentFieldPristine = disabledField || deepEqual2(get(_defaultValues, name2), fieldValue);
        isPreviousDirty = !!(!disabledField && get(_formState.dirtyFields, name2));
        isCurrentFieldPristine || disabledField ? unset(_formState.dirtyFields, name2) : set(_formState.dirtyFields, name2, true);
        output.dirtyFields = _formState.dirtyFields;
        shouldUpdateField = shouldUpdateField || _proxyFormState.dirtyFields && isPreviousDirty !== !isCurrentFieldPristine;
      }
      if (isBlurEvent) {
        const isPreviousFieldTouched = get(_formState.touchedFields, name2);
        if (!isPreviousFieldTouched) {
          set(_formState.touchedFields, name2, isBlurEvent);
          output.touchedFields = _formState.touchedFields;
          shouldUpdateField = shouldUpdateField || _proxyFormState.touchedFields && isPreviousFieldTouched !== isBlurEvent;
        }
      }
      shouldUpdateField && shouldRender && _subjects.state.next(output);
    }
    return shouldUpdateField ? output : {};
  };
  const shouldRenderByError = (name2, isValid, error, fieldState) => {
    const previousFieldError = get(_formState.errors, name2);
    const shouldUpdateValid = _proxyFormState.isValid && isBoolean(isValid) && _formState.isValid !== isValid;
    if (_options.delayError && error) {
      delayErrorCallback = debounce2(() => updateErrors(name2, error));
      delayErrorCallback(_options.delayError);
    } else {
      clearTimeout(timer);
      delayErrorCallback = null;
      error ? set(_formState.errors, name2, error) : unset(_formState.errors, name2);
    }
    if ((error ? !deepEqual2(previousFieldError, error) : previousFieldError) || !isEmptyObject(fieldState) || shouldUpdateValid) {
      const updatedFormState = {
        ...fieldState,
        ...shouldUpdateValid && isBoolean(isValid) ? { isValid } : {},
        errors: _formState.errors,
        name: name2
      };
      _formState = {
        ..._formState,
        ...updatedFormState
      };
      _subjects.state.next(updatedFormState);
    }
  };
  const _executeSchema = async (name2) => {
    _updateIsValidating(name2, true);
    const result = await _options.resolver(_formValues, _options.context, getResolverOptions(name2 || _names.mount, _fields, _options.criteriaMode, _options.shouldUseNativeValidation));
    _updateIsValidating(name2);
    return result;
  };
  const executeSchemaAndUpdateState = async (names) => {
    const { errors } = await _executeSchema(names);
    if (names) {
      for (const name2 of names) {
        const error = get(errors, name2);
        error ? set(_formState.errors, name2, error) : unset(_formState.errors, name2);
      }
    } else {
      _formState.errors = errors;
    }
    return errors;
  };
  const executeBuiltInValidation = async (fields, shouldOnlyCheckValid, context = {
    valid: true
  }) => {
    for (const name2 in fields) {
      const field = fields[name2];
      if (field) {
        const { _f, ...fieldValue } = field;
        if (_f) {
          const isFieldArrayRoot = _names.array.has(_f.name);
          const isPromiseFunction = field._f && hasPromiseValidation(field._f);
          if (isPromiseFunction && _proxyFormState.validatingFields) {
            _updateIsValidating([name2], true);
          }
          const fieldError = await validateField(field, _names.disabled, _formValues, shouldDisplayAllAssociatedErrors, _options.shouldUseNativeValidation && !shouldOnlyCheckValid, isFieldArrayRoot);
          if (isPromiseFunction && _proxyFormState.validatingFields) {
            _updateIsValidating([name2]);
          }
          if (fieldError[_f.name]) {
            context.valid = false;
            if (shouldOnlyCheckValid) {
              break;
            }
          }
          !shouldOnlyCheckValid && (get(fieldError, _f.name) ? isFieldArrayRoot ? updateFieldArrayRootError(_formState.errors, fieldError, _f.name) : set(_formState.errors, _f.name, fieldError[_f.name]) : unset(_formState.errors, _f.name));
        }
        !isEmptyObject(fieldValue) && await executeBuiltInValidation(fieldValue, shouldOnlyCheckValid, context);
      }
    }
    return context.valid;
  };
  const _removeUnmounted = () => {
    for (const name2 of _names.unMount) {
      const field = get(_fields, name2);
      field && (field._f.refs ? field._f.refs.every((ref2) => !live(ref2)) : !live(field._f.ref)) && unregister(name2);
    }
    _names.unMount = /* @__PURE__ */ new Set();
  };
  const _getDirty = (name2, data2) => !_options.disabled && (name2 && data2 && set(_formValues, name2, data2), !deepEqual2(getValues(), _defaultValues));
  const _getWatch = (names, defaultValue, isGlobal) => generateWatchOutput(names, _names, {
    ..._state.mount ? _formValues : isUndefined(defaultValue) ? _defaultValues : isString(names) ? { [names]: defaultValue } : defaultValue
  }, isGlobal, defaultValue);
  const _getFieldArray = (name2) => compact(get(_state.mount ? _formValues : _defaultValues, name2, _options.shouldUnregister ? get(_defaultValues, name2, []) : []));
  const setFieldValue = (name2, value2, options = {}) => {
    const field = get(_fields, name2);
    let fieldValue = value2;
    if (field) {
      const fieldReference = field._f;
      if (fieldReference) {
        !fieldReference.disabled && set(_formValues, name2, getFieldValueAs(value2, fieldReference));
        fieldValue = isHTMLElement3(fieldReference.ref) && isNullOrUndefined(value2) ? "" : value2;
        if (isMultipleSelect(fieldReference.ref)) {
          [...fieldReference.ref.options].forEach((optionRef) => optionRef.selected = fieldValue.includes(optionRef.value));
        } else if (fieldReference.refs) {
          if (isCheckBoxInput(fieldReference.ref)) {
            fieldReference.refs.length > 1 ? fieldReference.refs.forEach((checkboxRef) => (!checkboxRef.defaultChecked || !checkboxRef.disabled) && (checkboxRef.checked = Array.isArray(fieldValue) ? !!fieldValue.find((data2) => data2 === checkboxRef.value) : fieldValue === checkboxRef.value)) : fieldReference.refs[0] && (fieldReference.refs[0].checked = !!fieldValue);
          } else {
            fieldReference.refs.forEach((radioRef) => radioRef.checked = radioRef.value === fieldValue);
          }
        } else if (isFileInput(fieldReference.ref)) {
          fieldReference.ref.value = "";
        } else {
          fieldReference.ref.value = fieldValue;
          if (!fieldReference.ref.type) {
            _subjects.values.next({
              name: name2,
              values: { ..._formValues }
            });
          }
        }
      }
    }
    (options.shouldDirty || options.shouldTouch) && updateTouchAndDirty(name2, fieldValue, options.shouldTouch, options.shouldDirty, true);
    options.shouldValidate && trigger(name2);
  };
  const setValues = (name2, value2, options) => {
    for (const fieldKey in value2) {
      const fieldValue = value2[fieldKey];
      const fieldName = `${name2}.${fieldKey}`;
      const field = get(_fields, fieldName);
      (_names.array.has(name2) || isObject(fieldValue) || field && !field._f) && !isDateObject(fieldValue) ? setValues(fieldName, fieldValue, options) : setFieldValue(fieldName, fieldValue, options);
    }
  };
  const setValue = (name2, value2, options = {}) => {
    const field = get(_fields, name2);
    const isFieldArray = _names.array.has(name2);
    const cloneValue = cloneObject(value2);
    set(_formValues, name2, cloneValue);
    if (isFieldArray) {
      _subjects.array.next({
        name: name2,
        values: { ..._formValues }
      });
      if ((_proxyFormState.isDirty || _proxyFormState.dirtyFields) && options.shouldDirty) {
        _subjects.state.next({
          name: name2,
          dirtyFields: getDirtyFields(_defaultValues, _formValues),
          isDirty: _getDirty(name2, cloneValue)
        });
      }
    } else {
      field && !field._f && !isNullOrUndefined(cloneValue) ? setValues(name2, cloneValue, options) : setFieldValue(name2, cloneValue, options);
    }
    isWatched(name2, _names) && _subjects.state.next({ ..._formState });
    _subjects.values.next({
      name: _state.mount ? name2 : void 0,
      values: { ..._formValues }
    });
  };
  const onChange = async (event) => {
    _state.mount = true;
    const target = event.target;
    let name2 = target.name;
    let isFieldValueUpdated = true;
    const field = get(_fields, name2);
    const getCurrentFieldValue = () => target.type ? getFieldValue(field._f) : getEventValue(event);
    const _updateIsFieldValueUpdated = (fieldValue) => {
      isFieldValueUpdated = Number.isNaN(fieldValue) || isDateObject(fieldValue) && isNaN(fieldValue.getTime()) || deepEqual2(fieldValue, get(_formValues, name2, fieldValue));
    };
    if (field) {
      let error;
      let isValid;
      const fieldValue = getCurrentFieldValue();
      const isBlurEvent = event.type === EVENTS.BLUR || event.type === EVENTS.FOCUS_OUT;
      const shouldSkipValidation = !hasValidation(field._f) && !_options.resolver && !get(_formState.errors, name2) && !field._f.deps || skipValidation(isBlurEvent, get(_formState.touchedFields, name2), _formState.isSubmitted, validationModeAfterSubmit, validationModeBeforeSubmit);
      const watched = isWatched(name2, _names, isBlurEvent);
      set(_formValues, name2, fieldValue);
      if (isBlurEvent) {
        field._f.onBlur && field._f.onBlur(event);
        delayErrorCallback && delayErrorCallback(0);
      } else if (field._f.onChange) {
        field._f.onChange(event);
      }
      const fieldState = updateTouchAndDirty(name2, fieldValue, isBlurEvent, false);
      const shouldRender = !isEmptyObject(fieldState) || watched;
      !isBlurEvent && _subjects.values.next({
        name: name2,
        type: event.type,
        values: { ..._formValues }
      });
      if (shouldSkipValidation) {
        if (_proxyFormState.isValid) {
          if (_options.mode === "onBlur" && isBlurEvent) {
            _updateValid();
          } else if (!isBlurEvent) {
            _updateValid();
          }
        }
        return shouldRender && _subjects.state.next({ name: name2, ...watched ? {} : fieldState });
      }
      !isBlurEvent && watched && _subjects.state.next({ ..._formState });
      if (_options.resolver) {
        const { errors } = await _executeSchema([name2]);
        _updateIsFieldValueUpdated(fieldValue);
        if (isFieldValueUpdated) {
          const previousErrorLookupResult = schemaErrorLookup(_formState.errors, _fields, name2);
          const errorLookupResult = schemaErrorLookup(errors, _fields, previousErrorLookupResult.name || name2);
          error = errorLookupResult.error;
          name2 = errorLookupResult.name;
          isValid = isEmptyObject(errors);
        }
      } else {
        _updateIsValidating([name2], true);
        error = (await validateField(field, _names.disabled, _formValues, shouldDisplayAllAssociatedErrors, _options.shouldUseNativeValidation))[name2];
        _updateIsValidating([name2]);
        _updateIsFieldValueUpdated(fieldValue);
        if (isFieldValueUpdated) {
          if (error) {
            isValid = false;
          } else if (_proxyFormState.isValid) {
            isValid = await executeBuiltInValidation(_fields, true);
          }
        }
      }
      if (isFieldValueUpdated) {
        field._f.deps && trigger(field._f.deps);
        shouldRenderByError(name2, isValid, error, fieldState);
      }
    }
  };
  const _focusInput = (ref2, key2) => {
    if (get(_formState.errors, key2) && ref2.focus) {
      ref2.focus();
      return 1;
    }
    return;
  };
  const trigger = async (name2, options = {}) => {
    let isValid;
    let validationResult;
    const fieldNames = convertToArrayPayload(name2);
    if (_options.resolver) {
      const errors = await executeSchemaAndUpdateState(isUndefined(name2) ? name2 : fieldNames);
      isValid = isEmptyObject(errors);
      validationResult = name2 ? !fieldNames.some((name3) => get(errors, name3)) : isValid;
    } else if (name2) {
      validationResult = (await Promise.all(fieldNames.map(async (fieldName) => {
        const field = get(_fields, fieldName);
        return await executeBuiltInValidation(field && field._f ? { [fieldName]: field } : field);
      }))).every(Boolean);
      !(!validationResult && !_formState.isValid) && _updateValid();
    } else {
      validationResult = isValid = await executeBuiltInValidation(_fields);
    }
    _subjects.state.next({
      ...!isString(name2) || _proxyFormState.isValid && isValid !== _formState.isValid ? {} : { name: name2 },
      ..._options.resolver || !name2 ? { isValid } : {},
      errors: _formState.errors
    });
    options.shouldFocus && !validationResult && iterateFieldsByAction(_fields, _focusInput, name2 ? fieldNames : _names.mount);
    return validationResult;
  };
  const getValues = (fieldNames) => {
    const values2 = {
      ..._state.mount ? _formValues : _defaultValues
    };
    return isUndefined(fieldNames) ? values2 : isString(fieldNames) ? get(values2, fieldNames) : fieldNames.map((name2) => get(values2, name2));
  };
  const getFieldState = (name2, formState) => ({
    invalid: !!get((formState || _formState).errors, name2),
    isDirty: !!get((formState || _formState).dirtyFields, name2),
    error: get((formState || _formState).errors, name2),
    isValidating: !!get(_formState.validatingFields, name2),
    isTouched: !!get((formState || _formState).touchedFields, name2)
  });
  const clearErrors = (name2) => {
    name2 && convertToArrayPayload(name2).forEach((inputName) => unset(_formState.errors, inputName));
    _subjects.state.next({
      errors: name2 ? _formState.errors : {}
    });
  };
  const setError = (name2, error, options) => {
    const ref2 = (get(_fields, name2, { _f: {} })._f || {}).ref;
    const currentError = get(_formState.errors, name2) || {};
    const { ref: currentRef, message, type: type2, ...restOfErrorTree } = currentError;
    set(_formState.errors, name2, {
      ...restOfErrorTree,
      ...error,
      ref: ref2
    });
    _subjects.state.next({
      name: name2,
      errors: _formState.errors,
      isValid: false
    });
    options && options.shouldFocus && ref2 && ref2.focus && ref2.focus();
  };
  const watch = (name2, defaultValue) => isFunction(name2) ? _subjects.values.subscribe({
    next: (payload) => name2(_getWatch(void 0, defaultValue), payload)
  }) : _getWatch(name2, defaultValue, true);
  const unregister = (name2, options = {}) => {
    for (const fieldName of name2 ? convertToArrayPayload(name2) : _names.mount) {
      _names.mount.delete(fieldName);
      _names.array.delete(fieldName);
      if (!options.keepValue) {
        unset(_fields, fieldName);
        unset(_formValues, fieldName);
      }
      !options.keepError && unset(_formState.errors, fieldName);
      !options.keepDirty && unset(_formState.dirtyFields, fieldName);
      !options.keepTouched && unset(_formState.touchedFields, fieldName);
      !options.keepIsValidating && unset(_formState.validatingFields, fieldName);
      !_options.shouldUnregister && !options.keepDefaultValue && unset(_defaultValues, fieldName);
    }
    _subjects.values.next({
      values: { ..._formValues }
    });
    _subjects.state.next({
      ..._formState,
      ...!options.keepDirty ? {} : { isDirty: _getDirty() }
    });
    !options.keepIsValid && _updateValid();
  };
  const _updateDisabledField = ({ disabled, name: name2, field, fields }) => {
    if (isBoolean(disabled) && _state.mount || !!disabled || _names.disabled.has(name2)) {
      disabled ? _names.disabled.add(name2) : _names.disabled.delete(name2);
      updateTouchAndDirty(name2, getFieldValue(field ? field._f : get(fields, name2)._f), false, false, true);
    }
  };
  const register = (name2, options = {}) => {
    let field = get(_fields, name2);
    const disabledIsDefined = isBoolean(options.disabled) || isBoolean(_options.disabled);
    set(_fields, name2, {
      ...field || {},
      _f: {
        ...field && field._f ? field._f : { ref: { name: name2 } },
        name: name2,
        mount: true,
        ...options
      }
    });
    _names.mount.add(name2);
    if (field) {
      _updateDisabledField({
        field,
        disabled: isBoolean(options.disabled) ? options.disabled : _options.disabled,
        name: name2
      });
    } else {
      updateValidAndValue(name2, true, options.value);
    }
    return {
      ...disabledIsDefined ? { disabled: options.disabled || _options.disabled } : {},
      ..._options.progressive ? {
        required: !!options.required,
        min: getRuleValue(options.min),
        max: getRuleValue(options.max),
        minLength: getRuleValue(options.minLength),
        maxLength: getRuleValue(options.maxLength),
        pattern: getRuleValue(options.pattern)
      } : {},
      name: name2,
      onChange,
      onBlur: onChange,
      ref: (ref2) => {
        if (ref2) {
          register(name2, options);
          field = get(_fields, name2);
          const fieldRef = isUndefined(ref2.value) ? ref2.querySelectorAll ? ref2.querySelectorAll("input,select,textarea")[0] || ref2 : ref2 : ref2;
          const radioOrCheckbox = isRadioOrCheckbox(fieldRef);
          const refs = field._f.refs || [];
          if (radioOrCheckbox ? refs.find((option) => option === fieldRef) : fieldRef === field._f.ref) {
            return;
          }
          set(_fields, name2, {
            _f: {
              ...field._f,
              ...radioOrCheckbox ? {
                refs: [
                  ...refs.filter(live),
                  fieldRef,
                  ...Array.isArray(get(_defaultValues, name2)) ? [{}] : []
                ],
                ref: { type: fieldRef.type, name: name2 }
              } : { ref: fieldRef }
            }
          });
          updateValidAndValue(name2, false, void 0, fieldRef);
        } else {
          field = get(_fields, name2, {});
          if (field._f) {
            field._f.mount = false;
          }
          (_options.shouldUnregister || options.shouldUnregister) && !(isNameInFieldArray(_names.array, name2) && _state.action) && _names.unMount.add(name2);
        }
      }
    };
  };
  const _focusError = () => _options.shouldFocusError && iterateFieldsByAction(_fields, _focusInput, _names.mount);
  const _disableForm = (disabled) => {
    if (isBoolean(disabled)) {
      _subjects.state.next({ disabled });
      iterateFieldsByAction(_fields, (ref2, name2) => {
        const currentField = get(_fields, name2);
        if (currentField) {
          ref2.disabled = currentField._f.disabled || disabled;
          if (Array.isArray(currentField._f.refs)) {
            currentField._f.refs.forEach((inputRef) => {
              inputRef.disabled = currentField._f.disabled || disabled;
            });
          }
        }
      }, 0, false);
    }
  };
  const handleSubmit = (onValid, onInvalid) => async (e2) => {
    let onValidError = void 0;
    if (e2) {
      e2.preventDefault && e2.preventDefault();
      e2.persist && e2.persist();
    }
    let fieldValues = cloneObject(_formValues);
    if (_names.disabled.size) {
      for (const name2 of _names.disabled) {
        set(fieldValues, name2, void 0);
      }
    }
    _subjects.state.next({
      isSubmitting: true
    });
    if (_options.resolver) {
      const { errors, values: values2 } = await _executeSchema();
      _formState.errors = errors;
      fieldValues = values2;
    } else {
      await executeBuiltInValidation(_fields);
    }
    unset(_formState.errors, "root");
    if (isEmptyObject(_formState.errors)) {
      _subjects.state.next({
        errors: {}
      });
      try {
        await onValid(fieldValues, e2);
      } catch (error) {
        onValidError = error;
      }
    } else {
      if (onInvalid) {
        await onInvalid({ ..._formState.errors }, e2);
      }
      _focusError();
      setTimeout(_focusError);
    }
    _subjects.state.next({
      isSubmitted: true,
      isSubmitting: false,
      isSubmitSuccessful: isEmptyObject(_formState.errors) && !onValidError,
      submitCount: _formState.submitCount + 1,
      errors: _formState.errors
    });
    if (onValidError) {
      throw onValidError;
    }
  };
  const resetField = (name2, options = {}) => {
    if (get(_fields, name2)) {
      if (isUndefined(options.defaultValue)) {
        setValue(name2, cloneObject(get(_defaultValues, name2)));
      } else {
        setValue(name2, options.defaultValue);
        set(_defaultValues, name2, cloneObject(options.defaultValue));
      }
      if (!options.keepTouched) {
        unset(_formState.touchedFields, name2);
      }
      if (!options.keepDirty) {
        unset(_formState.dirtyFields, name2);
        _formState.isDirty = options.defaultValue ? _getDirty(name2, cloneObject(get(_defaultValues, name2))) : _getDirty();
      }
      if (!options.keepError) {
        unset(_formState.errors, name2);
        _proxyFormState.isValid && _updateValid();
      }
      _subjects.state.next({ ..._formState });
    }
  };
  const _reset = (formValues, keepStateOptions = {}) => {
    const updatedValues = formValues ? cloneObject(formValues) : _defaultValues;
    const cloneUpdatedValues = cloneObject(updatedValues);
    const isEmptyResetValues = isEmptyObject(formValues);
    const values2 = isEmptyResetValues ? _defaultValues : cloneUpdatedValues;
    if (!keepStateOptions.keepDefaultValues) {
      _defaultValues = updatedValues;
    }
    if (!keepStateOptions.keepValues) {
      if (keepStateOptions.keepDirtyValues) {
        const fieldsToCheck = /* @__PURE__ */ new Set([
          ..._names.mount,
          ...Object.keys(getDirtyFields(_defaultValues, _formValues))
        ]);
        for (const fieldName of Array.from(fieldsToCheck)) {
          get(_formState.dirtyFields, fieldName) ? set(values2, fieldName, get(_formValues, fieldName)) : setValue(fieldName, get(values2, fieldName));
        }
      } else {
        if (isWeb && isUndefined(formValues)) {
          for (const name2 of _names.mount) {
            const field = get(_fields, name2);
            if (field && field._f) {
              const fieldReference = Array.isArray(field._f.refs) ? field._f.refs[0] : field._f.ref;
              if (isHTMLElement3(fieldReference)) {
                const form = fieldReference.closest("form");
                if (form) {
                  form.reset();
                  break;
                }
              }
            }
          }
        }
        _fields = {};
      }
      _formValues = _options.shouldUnregister ? keepStateOptions.keepDefaultValues ? cloneObject(_defaultValues) : {} : cloneObject(values2);
      _subjects.array.next({
        values: { ...values2 }
      });
      _subjects.values.next({
        values: { ...values2 }
      });
    }
    _names = {
      mount: keepStateOptions.keepDirtyValues ? _names.mount : /* @__PURE__ */ new Set(),
      unMount: /* @__PURE__ */ new Set(),
      array: /* @__PURE__ */ new Set(),
      disabled: /* @__PURE__ */ new Set(),
      watch: /* @__PURE__ */ new Set(),
      watchAll: false,
      focus: ""
    };
    _state.mount = !_proxyFormState.isValid || !!keepStateOptions.keepIsValid || !!keepStateOptions.keepDirtyValues;
    _state.watch = !!_options.shouldUnregister;
    _subjects.state.next({
      submitCount: keepStateOptions.keepSubmitCount ? _formState.submitCount : 0,
      isDirty: isEmptyResetValues ? false : keepStateOptions.keepDirty ? _formState.isDirty : !!(keepStateOptions.keepDefaultValues && !deepEqual2(formValues, _defaultValues)),
      isSubmitted: keepStateOptions.keepIsSubmitted ? _formState.isSubmitted : false,
      dirtyFields: isEmptyResetValues ? {} : keepStateOptions.keepDirtyValues ? keepStateOptions.keepDefaultValues && _formValues ? getDirtyFields(_defaultValues, _formValues) : _formState.dirtyFields : keepStateOptions.keepDefaultValues && formValues ? getDirtyFields(_defaultValues, formValues) : keepStateOptions.keepDirty ? _formState.dirtyFields : {},
      touchedFields: keepStateOptions.keepTouched ? _formState.touchedFields : {},
      errors: keepStateOptions.keepErrors ? _formState.errors : {},
      isSubmitSuccessful: keepStateOptions.keepIsSubmitSuccessful ? _formState.isSubmitSuccessful : false,
      isSubmitting: false
    });
  };
  const reset2 = (formValues, keepStateOptions) => _reset(isFunction(formValues) ? formValues(_formValues) : formValues, keepStateOptions);
  const setFocus = (name2, options = {}) => {
    const field = get(_fields, name2);
    const fieldReference = field && field._f;
    if (fieldReference) {
      const fieldRef = fieldReference.refs ? fieldReference.refs[0] : fieldReference.ref;
      if (fieldRef.focus) {
        fieldRef.focus();
        options.shouldSelect && isFunction(fieldRef.select) && fieldRef.select();
      }
    }
  };
  const _updateFormState = (updatedFormState) => {
    _formState = {
      ..._formState,
      ...updatedFormState
    };
  };
  const _resetDefaultValues = () => isFunction(_options.defaultValues) && _options.defaultValues().then((values2) => {
    reset2(values2, _options.resetOptions);
    _subjects.state.next({
      isLoading: false
    });
  });
  return {
    control: {
      register,
      unregister,
      getFieldState,
      handleSubmit,
      setError,
      _executeSchema,
      _getWatch,
      _getDirty,
      _updateValid,
      _removeUnmounted,
      _updateFieldArray,
      _updateDisabledField,
      _getFieldArray,
      _reset,
      _resetDefaultValues,
      _updateFormState,
      _disableForm,
      _subjects,
      _proxyFormState,
      _setErrors,
      get _fields() {
        return _fields;
      },
      get _formValues() {
        return _formValues;
      },
      get _state() {
        return _state;
      },
      set _state(value2) {
        _state = value2;
      },
      get _defaultValues() {
        return _defaultValues;
      },
      get _names() {
        return _names;
      },
      set _names(value2) {
        _names = value2;
      },
      get _formState() {
        return _formState;
      },
      set _formState(value2) {
        _formState = value2;
      },
      get _options() {
        return _options;
      },
      set _options(value2) {
        _options = {
          ..._options,
          ...value2
        };
      }
    },
    trigger,
    register,
    handleSubmit,
    watch,
    setValue,
    getValues,
    reset: reset2,
    resetField,
    clearErrors,
    unregister,
    setError,
    setFocus,
    getFieldState
  };
}
function useForm(props = {}) {
  const _formControl = import_react30.default.useRef(void 0);
  const _values = import_react30.default.useRef(void 0);
  const [formState, updateFormState] = import_react30.default.useState({
    isDirty: false,
    isValidating: false,
    isLoading: isFunction(props.defaultValues),
    isSubmitted: false,
    isSubmitting: false,
    isSubmitSuccessful: false,
    isValid: false,
    submitCount: 0,
    dirtyFields: {},
    touchedFields: {},
    validatingFields: {},
    errors: props.errors || {},
    disabled: props.disabled || false,
    defaultValues: isFunction(props.defaultValues) ? void 0 : props.defaultValues
  });
  if (!_formControl.current) {
    _formControl.current = {
      ...createFormControl(props),
      formState
    };
  }
  const control = _formControl.current.control;
  control._options = props;
  useSubscribe({
    subject: control._subjects.state,
    next: (value2) => {
      if (shouldRenderFormState(value2, control._proxyFormState, control._updateFormState, true)) {
        updateFormState({ ...control._formState });
      }
    }
  });
  import_react30.default.useEffect(() => control._disableForm(props.disabled), [control, props.disabled]);
  import_react30.default.useEffect(() => {
    if (control._proxyFormState.isDirty) {
      const isDirty = control._getDirty();
      if (isDirty !== formState.isDirty) {
        control._subjects.state.next({
          isDirty
        });
      }
    }
  }, [control, formState.isDirty]);
  import_react30.default.useEffect(() => {
    if (props.values && !deepEqual2(props.values, _values.current)) {
      control._reset(props.values, control._options.resetOptions);
      _values.current = props.values;
      updateFormState((state) => ({ ...state }));
    } else {
      control._resetDefaultValues();
    }
  }, [props.values, control]);
  import_react30.default.useEffect(() => {
    if (props.errors) {
      control._setErrors(props.errors);
    }
  }, [props.errors, control]);
  import_react30.default.useEffect(() => {
    if (!control._state.mount) {
      control._updateValid();
      control._state.mount = true;
    }
    if (control._state.watch) {
      control._state.watch = false;
      control._subjects.state.next({ ...control._formState });
    }
    control._removeUnmounted();
  });
  import_react30.default.useEffect(() => {
    props.shouldUnregister && control._subjects.values.next({
      values: control._getWatch()
    });
  }, [props.shouldUnregister, control]);
  _formControl.current.formState = getProxyFormState(formState, control);
  return _formControl.current;
}

// node_modules/@babel/runtime/helpers/esm/objectWithoutPropertiesLoose.js
function _objectWithoutPropertiesLoose(r2, e2) {
  if (null == r2) return {};
  var t3 = {};
  for (var n3 in r2) if ({}.hasOwnProperty.call(r2, n3)) {
    if (-1 !== e2.indexOf(n3)) continue;
    t3[n3] = r2[n3];
  }
  return t3;
}

// node_modules/@babel/runtime/helpers/esm/extends.js
function _extends() {
  return _extends = Object.assign ? Object.assign.bind() : function(n3) {
    for (var e2 = 1; e2 < arguments.length; e2++) {
      var t3 = arguments[e2];
      for (var r2 in t3) ({}).hasOwnProperty.call(t3, r2) && (n3[r2] = t3[r2]);
    }
    return n3;
  }, _extends.apply(null, arguments);
}

// node_modules/@babel/runtime/helpers/esm/assertThisInitialized.js
function _assertThisInitialized(e2) {
  if (void 0 === e2) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  return e2;
}

// node_modules/@babel/runtime/helpers/esm/setPrototypeOf.js
function _setPrototypeOf2(t3, e2) {
  return _setPrototypeOf2 = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function(t4, e3) {
    return t4.__proto__ = e3, t4;
  }, _setPrototypeOf2(t3, e2);
}

// node_modules/@babel/runtime/helpers/esm/inheritsLoose.js
function _inheritsLoose2(t3, o3) {
  t3.prototype = Object.create(o3.prototype), t3.prototype.constructor = t3, _setPrototypeOf2(t3, o3);
}

// node_modules/downshift/dist/downshift.esm.js
var import_prop_types = __toESM(require_prop_types());
var import_react31 = __toESM(require_react());
var import_react_is = __toESM(require_react_is2());

// node_modules/compute-scroll-into-view/dist/index.js
var e = (e2) => "object" == typeof e2 && null != e2 && 1 === e2.nodeType;
var t = (e2, t3) => (!t3 || "hidden" !== e2) && ("visible" !== e2 && "clip" !== e2);
var n = (e2, n3) => {
  if (e2.clientHeight < e2.scrollHeight || e2.clientWidth < e2.scrollWidth) {
    let l3 = getComputedStyle(e2, null);
    return t(l3.overflowY, n3) || t(l3.overflowX, n3) || ((e3) => {
      let t3 = ((e4) => {
        if (!e4.ownerDocument || !e4.ownerDocument.defaultView) return null;
        try {
          return e4.ownerDocument.defaultView.frameElement;
        } catch (e5) {
          return null;
        }
      })(e3);
      return !!t3 && (t3.clientHeight < e3.scrollHeight || t3.clientWidth < e3.scrollWidth);
    })(e2);
  }
  return false;
};
var l = (e2, t3, n3, l3, i3, o3, r2, d3) => o3 < e2 && r2 > t3 || o3 > e2 && r2 < t3 ? 0 : o3 <= e2 && d3 <= n3 || r2 >= t3 && d3 >= n3 ? o3 - e2 - l3 : r2 > t3 && d3 < n3 || o3 < e2 && d3 > n3 ? r2 - t3 + i3 : 0;
var i = (e2) => {
  let t3 = e2.parentElement;
  return null == t3 ? e2.getRootNode().host || null : t3;
};
var o = (t3, o3) => {
  var r2, d3, h2, f3, u2, s2;
  if ("undefined" == typeof document) return [];
  let { scrollMode: a2, block: c2, inline: g3, boundary: m2, skipOverflowHiddenElements: p2 } = o3, w3 = "function" == typeof m2 ? m2 : (e2) => e2 !== m2;
  if (!e(t3)) throw new TypeError("Invalid target");
  let W2 = document.scrollingElement || document.documentElement, H3 = [], b3 = t3;
  for (; e(b3) && w3(b3); ) {
    if (b3 = i(b3), b3 === W2) {
      H3.push(b3);
      break;
    }
    null != b3 && b3 === document.body && n(b3) && !n(document.documentElement) || null != b3 && n(b3, p2) && H3.push(b3);
  }
  let v3 = null != (d3 = null == (r2 = window.visualViewport) ? void 0 : r2.width) ? d3 : innerWidth, y2 = null != (f3 = null == (h2 = window.visualViewport) ? void 0 : h2.height) ? f3 : innerHeight, E3 = null != (u2 = window.scrollX) ? u2 : pageXOffset, M3 = null != (s2 = window.scrollY) ? s2 : pageYOffset, { height: x3, width: I3, top: C3, right: R3, bottom: T3, left: V3 } = t3.getBoundingClientRect(), k3 = "start" === c2 || "nearest" === c2 ? C3 : "end" === c2 ? T3 : C3 + x3 / 2, B3 = "center" === g3 ? V3 + I3 / 2 : "end" === g3 ? R3 : V3, D3 = [];
  for (let e2 = 0; e2 < H3.length; e2++) {
    let t4 = H3[e2], { height: n3, width: i3, top: o4, right: r3, bottom: d4, left: h3 } = t4.getBoundingClientRect();
    if ("if-needed" === a2 && C3 >= 0 && V3 >= 0 && T3 <= y2 && R3 <= v3 && C3 >= o4 && T3 <= d4 && V3 >= h3 && R3 <= r3) return D3;
    let f4 = getComputedStyle(t4), u3 = parseInt(f4.borderLeftWidth, 10), s3 = parseInt(f4.borderTopWidth, 10), m3 = parseInt(f4.borderRightWidth, 10), p3 = parseInt(f4.borderBottomWidth, 10), w4 = 0, b4 = 0, O3 = "offsetWidth" in t4 ? t4.offsetWidth - t4.clientWidth - u3 - m3 : 0, X3 = "offsetHeight" in t4 ? t4.offsetHeight - t4.clientHeight - s3 - p3 : 0, Y2 = "offsetWidth" in t4 ? 0 === t4.offsetWidth ? 0 : i3 / t4.offsetWidth : 0, L2 = "offsetHeight" in t4 ? 0 === t4.offsetHeight ? 0 : n3 / t4.offsetHeight : 0;
    if (W2 === t4) w4 = "start" === c2 ? k3 : "end" === c2 ? k3 - y2 : "nearest" === c2 ? l(M3, M3 + y2, y2, s3, p3, M3 + k3, M3 + k3 + x3, x3) : k3 - y2 / 2, b4 = "start" === g3 ? B3 : "center" === g3 ? B3 - v3 / 2 : "end" === g3 ? B3 - v3 : l(E3, E3 + v3, v3, u3, m3, E3 + B3, E3 + B3 + I3, I3), w4 = Math.max(0, w4 + M3), b4 = Math.max(0, b4 + E3);
    else {
      w4 = "start" === c2 ? k3 - o4 - s3 : "end" === c2 ? k3 - d4 + p3 + X3 : "nearest" === c2 ? l(o4, d4, n3, s3, p3 + X3, k3, k3 + x3, x3) : k3 - (o4 + n3 / 2) + X3 / 2, b4 = "start" === g3 ? B3 - h3 - u3 : "center" === g3 ? B3 - (h3 + i3 / 2) + O3 / 2 : "end" === g3 ? B3 - r3 + m3 + O3 : l(h3, r3, i3, u3, m3 + O3, B3, B3 + I3, I3);
      let { scrollLeft: e3, scrollTop: f5 } = t4;
      w4 = Math.max(0, Math.min(f5 + w4 / L2, t4.scrollHeight - n3 / L2 + X3)), b4 = Math.max(0, Math.min(e3 + b4 / Y2, t4.scrollWidth - i3 / Y2 + O3)), k3 += f5 - w4, B3 += e3 - b4;
    }
    D3.push({ el: t4, top: w4, left: b4 });
  }
  return D3;
};

// node_modules/downshift/dist/downshift.esm.js
var idCounter2 = 0;
function cbToCb(cb) {
  return typeof cb === "function" ? cb : noop2;
}
function noop2() {
}
function scrollIntoView(node2, menuNode) {
  if (!node2) {
    return;
  }
  var actions = o(node2, {
    boundary: menuNode,
    block: "nearest",
    scrollMode: "if-needed"
  });
  actions.forEach(function(_ref) {
    var el = _ref.el, top = _ref.top, left = _ref.left;
    el.scrollTop = top;
    el.scrollLeft = left;
  });
}
function isOrContainsNode(parent, child, environment) {
  var result = parent === child || child instanceof environment.Node && parent.contains && parent.contains(child);
  return result;
}
function debounce(fn, time) {
  var timeoutId;
  function cancel() {
    if (timeoutId) {
      clearTimeout(timeoutId);
    }
  }
  function wrapper() {
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    cancel();
    timeoutId = setTimeout(function() {
      timeoutId = null;
      fn.apply(void 0, args);
    }, time);
  }
  wrapper.cancel = cancel;
  return wrapper;
}
function callAllEventHandlers() {
  for (var _len2 = arguments.length, fns = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
    fns[_key2] = arguments[_key2];
  }
  return function(event) {
    for (var _len3 = arguments.length, args = new Array(_len3 > 1 ? _len3 - 1 : 0), _key3 = 1; _key3 < _len3; _key3++) {
      args[_key3 - 1] = arguments[_key3];
    }
    return fns.some(function(fn) {
      if (fn) {
        fn.apply(void 0, [event].concat(args));
      }
      return event.preventDownshiftDefault || event.hasOwnProperty("nativeEvent") && event.nativeEvent.preventDownshiftDefault;
    });
  };
}
function handleRefs() {
  for (var _len4 = arguments.length, refs = new Array(_len4), _key4 = 0; _key4 < _len4; _key4++) {
    refs[_key4] = arguments[_key4];
  }
  return function(node2) {
    refs.forEach(function(ref2) {
      if (typeof ref2 === "function") {
        ref2(node2);
      } else if (ref2) {
        ref2.current = node2;
      }
    });
  };
}
function generateId2() {
  return String(idCounter2++);
}
function getA11yStatusMessage$1(_ref2) {
  var isOpen = _ref2.isOpen, resultCount = _ref2.resultCount, previousResultCount = _ref2.previousResultCount;
  if (!isOpen) {
    return "";
  }
  if (!resultCount) {
    return "No results are available.";
  }
  if (resultCount !== previousResultCount) {
    return resultCount + " result" + (resultCount === 1 ? " is" : "s are") + " available, use up and down arrow keys to navigate. Press Enter key to select.";
  }
  return "";
}
function unwrapArray(arg, defaultValue) {
  arg = Array.isArray(arg) ? (
    /* istanbul ignore next (preact) */
    arg[0]
  ) : arg;
  if (!arg && defaultValue) {
    return defaultValue;
  } else {
    return arg;
  }
}
function isDOMElement(element2) {
  return typeof element2.type === "string";
}
function getElementProps(element2) {
  return element2.props;
}
function requiredProp(fnName, propName) {
  console.error('The property "' + propName + '" is required in "' + fnName + '"');
}
var stateKeys = ["highlightedIndex", "inputValue", "isOpen", "selectedItem", "type"];
function pickState(state) {
  if (state === void 0) {
    state = {};
  }
  var result = {};
  stateKeys.forEach(function(k3) {
    if (state.hasOwnProperty(k3)) {
      result[k3] = state[k3];
    }
  });
  return result;
}
function getState3(state, props) {
  return Object.keys(state).reduce(function(prevState, key2) {
    prevState[key2] = isControlledProp(props, key2) ? props[key2] : state[key2];
    return prevState;
  }, {});
}
function isControlledProp(props, key2) {
  return props[key2] !== void 0;
}
function normalizeArrowKey(event) {
  var key2 = event.key, keyCode = event.keyCode;
  if (keyCode >= 37 && keyCode <= 40 && key2.indexOf("Arrow") !== 0) {
    return "Arrow" + key2;
  }
  return key2;
}
function isPlainObject2(obj) {
  return Object.prototype.toString.call(obj) === "[object Object]";
}
function getNextWrappingIndex(moveAmount, baseIndex, itemCount, getItemNodeFromIndex, circular) {
  if (circular === void 0) {
    circular = true;
  }
  if (itemCount === 0) {
    return -1;
  }
  var itemsLastIndex = itemCount - 1;
  if (typeof baseIndex !== "number" || baseIndex < 0 || baseIndex >= itemCount) {
    baseIndex = moveAmount > 0 ? -1 : itemsLastIndex + 1;
  }
  var newIndex = baseIndex + moveAmount;
  if (newIndex < 0) {
    newIndex = circular ? itemsLastIndex : 0;
  } else if (newIndex > itemsLastIndex) {
    newIndex = circular ? 0 : itemsLastIndex;
  }
  var nonDisabledNewIndex = getNextNonDisabledIndex(moveAmount, newIndex, itemCount, getItemNodeFromIndex, circular);
  if (nonDisabledNewIndex === -1) {
    return baseIndex >= itemCount ? -1 : baseIndex;
  }
  return nonDisabledNewIndex;
}
function getNextNonDisabledIndex(moveAmount, baseIndex, itemCount, getItemNodeFromIndex, circular) {
  var currentElementNode = getItemNodeFromIndex(baseIndex);
  if (!currentElementNode || !currentElementNode.hasAttribute("disabled")) {
    return baseIndex;
  }
  if (moveAmount > 0) {
    for (var index3 = baseIndex + 1; index3 < itemCount; index3++) {
      if (!getItemNodeFromIndex(index3).hasAttribute("disabled")) {
        return index3;
      }
    }
  } else {
    for (var _index = baseIndex - 1; _index >= 0; _index--) {
      if (!getItemNodeFromIndex(_index).hasAttribute("disabled")) {
        return _index;
      }
    }
  }
  if (circular) {
    return moveAmount > 0 ? getNextNonDisabledIndex(1, 0, itemCount, getItemNodeFromIndex, false) : getNextNonDisabledIndex(-1, itemCount - 1, itemCount, getItemNodeFromIndex, false);
  }
  return -1;
}
function targetWithinDownshift(target, downshiftElements, environment, checkActiveElement) {
  if (checkActiveElement === void 0) {
    checkActiveElement = true;
  }
  return downshiftElements.some(function(contextNode) {
    return contextNode && (isOrContainsNode(contextNode, target, environment) || checkActiveElement && isOrContainsNode(contextNode, environment.document.activeElement, environment));
  });
}
var validateControlledUnchanged = noop2;
if (true) {
  validateControlledUnchanged = function validateControlledUnchanged2(state, prevProps, nextProps) {
    var warningDescription = "This prop should not switch from controlled to uncontrolled (or vice versa). Decide between using a controlled or uncontrolled Downshift element for the lifetime of the component. More info: https://github.com/downshift-js/downshift#control-props";
    Object.keys(state).forEach(function(propKey) {
      if (prevProps[propKey] !== void 0 && nextProps[propKey] === void 0) {
        console.error('downshift: A component has changed the controlled prop "' + propKey + '" to be uncontrolled. ' + warningDescription);
      } else if (prevProps[propKey] === void 0 && nextProps[propKey] !== void 0) {
        console.error('downshift: A component has changed the uncontrolled prop "' + propKey + '" to be controlled. ' + warningDescription);
      }
    });
  };
}
var cleanupStatus = debounce(function(documentProp) {
  getStatusDiv(documentProp).textContent = "";
}, 500);
function setStatus(status, documentProp) {
  var div = getStatusDiv(documentProp);
  if (!status) {
    return;
  }
  div.textContent = status;
  cleanupStatus(documentProp);
}
function getStatusDiv(documentProp) {
  if (documentProp === void 0) {
    documentProp = document;
  }
  var statusDiv = documentProp.getElementById("a11y-status-message");
  if (statusDiv) {
    return statusDiv;
  }
  statusDiv = documentProp.createElement("div");
  statusDiv.setAttribute("id", "a11y-status-message");
  statusDiv.setAttribute("role", "status");
  statusDiv.setAttribute("aria-live", "polite");
  statusDiv.setAttribute("aria-relevant", "additions text");
  Object.assign(statusDiv.style, {
    border: "0",
    clip: "rect(0 0 0 0)",
    height: "1px",
    margin: "-1px",
    overflow: "hidden",
    padding: "0",
    position: "absolute",
    width: "1px"
  });
  documentProp.body.appendChild(statusDiv);
  return statusDiv;
}
var unknown2 = true ? "__autocomplete_unknown__" : 0;
var mouseUp = true ? "__autocomplete_mouseup__" : 1;
var itemMouseEnter = true ? "__autocomplete_item_mouseenter__" : 2;
var keyDownArrowUp = true ? "__autocomplete_keydown_arrow_up__" : 3;
var keyDownArrowDown = true ? "__autocomplete_keydown_arrow_down__" : 4;
var keyDownEscape = true ? "__autocomplete_keydown_escape__" : 5;
var keyDownEnter = true ? "__autocomplete_keydown_enter__" : 6;
var keyDownHome = true ? "__autocomplete_keydown_home__" : 7;
var keyDownEnd = true ? "__autocomplete_keydown_end__" : 8;
var clickItem = true ? "__autocomplete_click_item__" : 9;
var blurInput = true ? "__autocomplete_blur_input__" : 10;
var changeInput = true ? "__autocomplete_change_input__" : 11;
var keyDownSpaceButton = true ? "__autocomplete_keydown_space_button__" : 12;
var clickButton = true ? "__autocomplete_click_button__" : 13;
var blurButton = true ? "__autocomplete_blur_button__" : 14;
var controlledPropUpdatedSelectedItem = true ? "__autocomplete_controlled_prop_updated_selected_item__" : 15;
var touchEnd = true ? "__autocomplete_touchend__" : 16;
var stateChangeTypes$3 = Object.freeze({
  __proto__: null,
  unknown: unknown2,
  mouseUp,
  itemMouseEnter,
  keyDownArrowUp,
  keyDownArrowDown,
  keyDownEscape,
  keyDownEnter,
  keyDownHome,
  keyDownEnd,
  clickItem,
  blurInput,
  changeInput,
  keyDownSpaceButton,
  clickButton,
  blurButton,
  controlledPropUpdatedSelectedItem,
  touchEnd
});
var _excluded$4 = ["refKey", "ref"];
var _excluded2$3 = ["onClick", "onPress", "onKeyDown", "onKeyUp", "onBlur"];
var _excluded3$2 = ["onKeyDown", "onBlur", "onChange", "onInput", "onChangeText"];
var _excluded4$1 = ["refKey", "ref"];
var _excluded5 = ["onMouseMove", "onMouseDown", "onClick", "onPress", "index", "item"];
var Downshift = function() {
  var Downshift2 = function(_Component) {
    _inheritsLoose2(Downshift3, _Component);
    function Downshift3(_props) {
      var _this;
      _this = _Component.call(this, _props) || this;
      _this.id = _this.props.id || "downshift-" + generateId2();
      _this.menuId = _this.props.menuId || _this.id + "-menu";
      _this.labelId = _this.props.labelId || _this.id + "-label";
      _this.inputId = _this.props.inputId || _this.id + "-input";
      _this.getItemId = _this.props.getItemId || function(index3) {
        return _this.id + "-item-" + index3;
      };
      _this.input = null;
      _this.items = [];
      _this.itemCount = null;
      _this.previousResultCount = 0;
      _this.timeoutIds = [];
      _this.internalSetTimeout = function(fn, time) {
        var id = setTimeout(function() {
          _this.timeoutIds = _this.timeoutIds.filter(function(i3) {
            return i3 !== id;
          });
          fn();
        }, time);
        _this.timeoutIds.push(id);
      };
      _this.setItemCount = function(count3) {
        _this.itemCount = count3;
      };
      _this.unsetItemCount = function() {
        _this.itemCount = null;
      };
      _this.setHighlightedIndex = function(highlightedIndex, otherStateToSet) {
        if (highlightedIndex === void 0) {
          highlightedIndex = _this.props.defaultHighlightedIndex;
        }
        if (otherStateToSet === void 0) {
          otherStateToSet = {};
        }
        otherStateToSet = pickState(otherStateToSet);
        _this.internalSetState(_extends({
          highlightedIndex
        }, otherStateToSet));
      };
      _this.clearSelection = function(cb) {
        _this.internalSetState({
          selectedItem: null,
          inputValue: "",
          highlightedIndex: _this.props.defaultHighlightedIndex,
          isOpen: _this.props.defaultIsOpen
        }, cb);
      };
      _this.selectItem = function(item, otherStateToSet, cb) {
        otherStateToSet = pickState(otherStateToSet);
        _this.internalSetState(_extends({
          isOpen: _this.props.defaultIsOpen,
          highlightedIndex: _this.props.defaultHighlightedIndex,
          selectedItem: item,
          inputValue: _this.props.itemToString(item)
        }, otherStateToSet), cb);
      };
      _this.selectItemAtIndex = function(itemIndex, otherStateToSet, cb) {
        var item = _this.items[itemIndex];
        if (item == null) {
          return;
        }
        _this.selectItem(item, otherStateToSet, cb);
      };
      _this.selectHighlightedItem = function(otherStateToSet, cb) {
        return _this.selectItemAtIndex(_this.getState().highlightedIndex, otherStateToSet, cb);
      };
      _this.internalSetState = function(stateToSet, cb) {
        var isItemSelected, onChangeArg;
        var onStateChangeArg = {};
        var isStateToSetFunction = typeof stateToSet === "function";
        if (!isStateToSetFunction && stateToSet.hasOwnProperty("inputValue")) {
          _this.props.onInputValueChange(stateToSet.inputValue, _extends({}, _this.getStateAndHelpers(), stateToSet));
        }
        return _this.setState(function(state) {
          state = _this.getState(state);
          var newStateToSet = isStateToSetFunction ? stateToSet(state) : stateToSet;
          newStateToSet = _this.props.stateReducer(state, newStateToSet);
          isItemSelected = newStateToSet.hasOwnProperty("selectedItem");
          var nextState = {};
          if (isItemSelected && newStateToSet.selectedItem !== state.selectedItem) {
            onChangeArg = newStateToSet.selectedItem;
          }
          newStateToSet.type = newStateToSet.type || unknown2;
          Object.keys(newStateToSet).forEach(function(key2) {
            if (state[key2] !== newStateToSet[key2]) {
              onStateChangeArg[key2] = newStateToSet[key2];
            }
            if (key2 === "type") {
              return;
            }
            newStateToSet[key2];
            if (!isControlledProp(_this.props, key2)) {
              nextState[key2] = newStateToSet[key2];
            }
          });
          if (isStateToSetFunction && newStateToSet.hasOwnProperty("inputValue")) {
            _this.props.onInputValueChange(newStateToSet.inputValue, _extends({}, _this.getStateAndHelpers(), newStateToSet));
          }
          return nextState;
        }, function() {
          cbToCb(cb)();
          var hasMoreStateThanType = Object.keys(onStateChangeArg).length > 1;
          if (hasMoreStateThanType) {
            _this.props.onStateChange(onStateChangeArg, _this.getStateAndHelpers());
          }
          if (isItemSelected) {
            _this.props.onSelect(stateToSet.selectedItem, _this.getStateAndHelpers());
          }
          if (onChangeArg !== void 0) {
            _this.props.onChange(onChangeArg, _this.getStateAndHelpers());
          }
          _this.props.onUserAction(onStateChangeArg, _this.getStateAndHelpers());
        });
      };
      _this.rootRef = function(node2) {
        return _this._rootNode = node2;
      };
      _this.getRootProps = function(_temp, _temp2) {
        var _extends2;
        var _ref = _temp === void 0 ? {} : _temp, _ref$refKey = _ref.refKey, refKey = _ref$refKey === void 0 ? "ref" : _ref$refKey, ref2 = _ref.ref, rest = _objectWithoutPropertiesLoose(_ref, _excluded$4);
        var _ref2 = _temp2 === void 0 ? {} : _temp2, _ref2$suppressRefErro = _ref2.suppressRefError, suppressRefError = _ref2$suppressRefErro === void 0 ? false : _ref2$suppressRefErro;
        _this.getRootProps.called = true;
        _this.getRootProps.refKey = refKey;
        _this.getRootProps.suppressRefError = suppressRefError;
        var _this$getState = _this.getState(), isOpen = _this$getState.isOpen;
        return _extends((_extends2 = {}, _extends2[refKey] = handleRefs(ref2, _this.rootRef), _extends2.role = "combobox", _extends2["aria-expanded"] = isOpen, _extends2["aria-haspopup"] = "listbox", _extends2["aria-owns"] = isOpen ? _this.menuId : null, _extends2["aria-labelledby"] = _this.labelId, _extends2), rest);
      };
      _this.keyDownHandlers = {
        ArrowDown: function ArrowDown(event) {
          var _this2 = this;
          event.preventDefault();
          if (this.getState().isOpen) {
            var amount = event.shiftKey ? 5 : 1;
            this.moveHighlightedIndex(amount, {
              type: keyDownArrowDown
            });
          } else {
            this.internalSetState({
              isOpen: true,
              type: keyDownArrowDown
            }, function() {
              var itemCount = _this2.getItemCount();
              if (itemCount > 0) {
                var _this2$getState = _this2.getState(), highlightedIndex = _this2$getState.highlightedIndex;
                var nextHighlightedIndex = getNextWrappingIndex(1, highlightedIndex, itemCount, function(index3) {
                  return _this2.getItemNodeFromIndex(index3);
                });
                _this2.setHighlightedIndex(nextHighlightedIndex, {
                  type: keyDownArrowDown
                });
              }
            });
          }
        },
        ArrowUp: function ArrowUp(event) {
          var _this3 = this;
          event.preventDefault();
          if (this.getState().isOpen) {
            var amount = event.shiftKey ? -5 : -1;
            this.moveHighlightedIndex(amount, {
              type: keyDownArrowUp
            });
          } else {
            this.internalSetState({
              isOpen: true,
              type: keyDownArrowUp
            }, function() {
              var itemCount = _this3.getItemCount();
              if (itemCount > 0) {
                var _this3$getState = _this3.getState(), highlightedIndex = _this3$getState.highlightedIndex;
                var nextHighlightedIndex = getNextWrappingIndex(-1, highlightedIndex, itemCount, function(index3) {
                  return _this3.getItemNodeFromIndex(index3);
                });
                _this3.setHighlightedIndex(nextHighlightedIndex, {
                  type: keyDownArrowUp
                });
              }
            });
          }
        },
        Enter: function Enter(event) {
          if (event.which === 229) {
            return;
          }
          var _this$getState2 = this.getState(), isOpen = _this$getState2.isOpen, highlightedIndex = _this$getState2.highlightedIndex;
          if (isOpen && highlightedIndex != null) {
            event.preventDefault();
            var item = this.items[highlightedIndex];
            var itemNode = this.getItemNodeFromIndex(highlightedIndex);
            if (item == null || itemNode && itemNode.hasAttribute("disabled")) {
              return;
            }
            this.selectHighlightedItem({
              type: keyDownEnter
            });
          }
        },
        Escape: function Escape(event) {
          event.preventDefault();
          this.reset(_extends({
            type: keyDownEscape
          }, !this.state.isOpen && {
            selectedItem: null,
            inputValue: ""
          }));
        }
      };
      _this.buttonKeyDownHandlers = _extends({}, _this.keyDownHandlers, {
        " ": function _2(event) {
          event.preventDefault();
          this.toggleMenu({
            type: keyDownSpaceButton
          });
        }
      });
      _this.inputKeyDownHandlers = _extends({}, _this.keyDownHandlers, {
        Home: function Home(event) {
          var _this4 = this;
          var _this$getState3 = this.getState(), isOpen = _this$getState3.isOpen;
          if (!isOpen) {
            return;
          }
          event.preventDefault();
          var itemCount = this.getItemCount();
          if (itemCount <= 0 || !isOpen) {
            return;
          }
          var newHighlightedIndex = getNextNonDisabledIndex(1, 0, itemCount, function(index3) {
            return _this4.getItemNodeFromIndex(index3);
          }, false);
          this.setHighlightedIndex(newHighlightedIndex, {
            type: keyDownHome
          });
        },
        End: function End(event) {
          var _this5 = this;
          var _this$getState4 = this.getState(), isOpen = _this$getState4.isOpen;
          if (!isOpen) {
            return;
          }
          event.preventDefault();
          var itemCount = this.getItemCount();
          if (itemCount <= 0 || !isOpen) {
            return;
          }
          var newHighlightedIndex = getNextNonDisabledIndex(-1, itemCount - 1, itemCount, function(index3) {
            return _this5.getItemNodeFromIndex(index3);
          }, false);
          this.setHighlightedIndex(newHighlightedIndex, {
            type: keyDownEnd
          });
        }
      });
      _this.getToggleButtonProps = function(_temp3) {
        var _ref3 = _temp3 === void 0 ? {} : _temp3, onClick2 = _ref3.onClick;
        _ref3.onPress;
        var onKeyDown2 = _ref3.onKeyDown, onKeyUp = _ref3.onKeyUp, onBlur = _ref3.onBlur, rest = _objectWithoutPropertiesLoose(_ref3, _excluded2$3);
        var _this$getState5 = _this.getState(), isOpen = _this$getState5.isOpen;
        var enabledEventHandlers = {
          onClick: callAllEventHandlers(onClick2, _this.buttonHandleClick),
          onKeyDown: callAllEventHandlers(onKeyDown2, _this.buttonHandleKeyDown),
          onKeyUp: callAllEventHandlers(onKeyUp, _this.buttonHandleKeyUp),
          onBlur: callAllEventHandlers(onBlur, _this.buttonHandleBlur)
        };
        var eventHandlers = rest.disabled ? {} : enabledEventHandlers;
        return _extends({
          type: "button",
          role: "button",
          "aria-label": isOpen ? "close menu" : "open menu",
          "aria-haspopup": true,
          "data-toggle": true
        }, eventHandlers, rest);
      };
      _this.buttonHandleKeyUp = function(event) {
        event.preventDefault();
      };
      _this.buttonHandleKeyDown = function(event) {
        var key2 = normalizeArrowKey(event);
        if (_this.buttonKeyDownHandlers[key2]) {
          _this.buttonKeyDownHandlers[key2].call(_assertThisInitialized(_this), event);
        }
      };
      _this.buttonHandleClick = function(event) {
        event.preventDefault();
        if (_this.props.environment.document.activeElement === _this.props.environment.document.body) {
          event.target.focus();
        }
        if (false) {
          _this.toggleMenu({
            type: clickButton
          });
        } else {
          _this.internalSetTimeout(function() {
            return _this.toggleMenu({
              type: clickButton
            });
          });
        }
      };
      _this.buttonHandleBlur = function(event) {
        var blurTarget = event.target;
        _this.internalSetTimeout(function() {
          if (!_this.isMouseDown && (_this.props.environment.document.activeElement == null || _this.props.environment.document.activeElement.id !== _this.inputId) && _this.props.environment.document.activeElement !== blurTarget) {
            _this.reset({
              type: blurButton
            });
          }
        });
      };
      _this.getLabelProps = function(props) {
        return _extends({
          htmlFor: _this.inputId,
          id: _this.labelId
        }, props);
      };
      _this.getInputProps = function(_temp4) {
        var _ref4 = _temp4 === void 0 ? {} : _temp4, onKeyDown2 = _ref4.onKeyDown, onBlur = _ref4.onBlur, onChange = _ref4.onChange, onInput2 = _ref4.onInput;
        _ref4.onChangeText;
        var rest = _objectWithoutPropertiesLoose(_ref4, _excluded3$2);
        var onChangeKey;
        var eventHandlers = {};
        {
          onChangeKey = "onChange";
        }
        var _this$getState6 = _this.getState(), inputValue = _this$getState6.inputValue, isOpen = _this$getState6.isOpen, highlightedIndex = _this$getState6.highlightedIndex;
        if (!rest.disabled) {
          var _eventHandlers;
          eventHandlers = (_eventHandlers = {}, _eventHandlers[onChangeKey] = callAllEventHandlers(onChange, onInput2, _this.inputHandleChange), _eventHandlers.onKeyDown = callAllEventHandlers(onKeyDown2, _this.inputHandleKeyDown), _eventHandlers.onBlur = callAllEventHandlers(onBlur, _this.inputHandleBlur), _eventHandlers);
        }
        return _extends({
          "aria-autocomplete": "list",
          "aria-activedescendant": isOpen && typeof highlightedIndex === "number" && highlightedIndex >= 0 ? _this.getItemId(highlightedIndex) : null,
          "aria-controls": isOpen ? _this.menuId : null,
          "aria-labelledby": rest && rest["aria-label"] ? void 0 : _this.labelId,
          // https://developer.mozilla.org/en-US/docs/Web/Security/Securing_your_site/Turning_off_form_autocompletion
          // revert back since autocomplete="nope" is ignored on latest Chrome and Opera
          autoComplete: "off",
          value: inputValue,
          id: _this.inputId
        }, eventHandlers, rest);
      };
      _this.inputHandleKeyDown = function(event) {
        var key2 = normalizeArrowKey(event);
        if (key2 && _this.inputKeyDownHandlers[key2]) {
          _this.inputKeyDownHandlers[key2].call(_assertThisInitialized(_this), event);
        }
      };
      _this.inputHandleChange = function(event) {
        _this.internalSetState({
          type: changeInput,
          isOpen: true,
          inputValue: event.target.value,
          highlightedIndex: _this.props.defaultHighlightedIndex
        });
      };
      _this.inputHandleBlur = function() {
        _this.internalSetTimeout(function() {
          var downshiftButtonIsActive = _this.props.environment.document && !!_this.props.environment.document.activeElement && !!_this.props.environment.document.activeElement.dataset && _this.props.environment.document.activeElement.dataset.toggle && _this._rootNode && _this._rootNode.contains(_this.props.environment.document.activeElement);
          if (!_this.isMouseDown && !downshiftButtonIsActive) {
            _this.reset({
              type: blurInput
            });
          }
        });
      };
      _this.menuRef = function(node2) {
        _this._menuNode = node2;
      };
      _this.getMenuProps = function(_temp5, _temp6) {
        var _extends3;
        var _ref5 = _temp5 === void 0 ? {} : _temp5, _ref5$refKey = _ref5.refKey, refKey = _ref5$refKey === void 0 ? "ref" : _ref5$refKey, ref2 = _ref5.ref, props = _objectWithoutPropertiesLoose(_ref5, _excluded4$1);
        var _ref6 = _temp6 === void 0 ? {} : _temp6, _ref6$suppressRefErro = _ref6.suppressRefError, suppressRefError = _ref6$suppressRefErro === void 0 ? false : _ref6$suppressRefErro;
        _this.getMenuProps.called = true;
        _this.getMenuProps.refKey = refKey;
        _this.getMenuProps.suppressRefError = suppressRefError;
        return _extends((_extends3 = {}, _extends3[refKey] = handleRefs(ref2, _this.menuRef), _extends3.role = "listbox", _extends3["aria-labelledby"] = props && props["aria-label"] ? null : _this.labelId, _extends3.id = _this.menuId, _extends3), props);
      };
      _this.getItemProps = function(_temp7) {
        var _enabledEventHandlers;
        var _ref7 = _temp7 === void 0 ? {} : _temp7, onMouseMove = _ref7.onMouseMove, onMouseDown = _ref7.onMouseDown, onClick2 = _ref7.onClick;
        _ref7.onPress;
        var index3 = _ref7.index, _ref7$item = _ref7.item, item = _ref7$item === void 0 ? false ? (
          /* istanbul ignore next */
          void 0
        ) : requiredProp("getItemProps", "item") : _ref7$item, rest = _objectWithoutPropertiesLoose(_ref7, _excluded5);
        if (index3 === void 0) {
          _this.items.push(item);
          index3 = _this.items.indexOf(item);
        } else {
          _this.items[index3] = item;
        }
        var onSelectKey = "onClick";
        var customClickHandler = onClick2;
        var enabledEventHandlers = (_enabledEventHandlers = {
          // onMouseMove is used over onMouseEnter here. onMouseMove
          // is only triggered on actual mouse movement while onMouseEnter
          // can fire on DOM changes, interrupting keyboard navigation
          onMouseMove: callAllEventHandlers(onMouseMove, function() {
            if (index3 === _this.getState().highlightedIndex) {
              return;
            }
            _this.setHighlightedIndex(index3, {
              type: itemMouseEnter
            });
            _this.avoidScrolling = true;
            _this.internalSetTimeout(function() {
              return _this.avoidScrolling = false;
            }, 250);
          }),
          onMouseDown: callAllEventHandlers(onMouseDown, function(event) {
            event.preventDefault();
          })
        }, _enabledEventHandlers[onSelectKey] = callAllEventHandlers(customClickHandler, function() {
          _this.selectItemAtIndex(index3, {
            type: clickItem
          });
        }), _enabledEventHandlers);
        var eventHandlers = rest.disabled ? {
          onMouseDown: enabledEventHandlers.onMouseDown
        } : enabledEventHandlers;
        return _extends({
          id: _this.getItemId(index3),
          role: "option",
          "aria-selected": _this.getState().highlightedIndex === index3
        }, eventHandlers, rest);
      };
      _this.clearItems = function() {
        _this.items = [];
      };
      _this.reset = function(otherStateToSet, cb) {
        if (otherStateToSet === void 0) {
          otherStateToSet = {};
        }
        otherStateToSet = pickState(otherStateToSet);
        _this.internalSetState(function(_ref8) {
          var selectedItem = _ref8.selectedItem;
          return _extends({
            isOpen: _this.props.defaultIsOpen,
            highlightedIndex: _this.props.defaultHighlightedIndex,
            inputValue: _this.props.itemToString(selectedItem)
          }, otherStateToSet);
        }, cb);
      };
      _this.toggleMenu = function(otherStateToSet, cb) {
        if (otherStateToSet === void 0) {
          otherStateToSet = {};
        }
        otherStateToSet = pickState(otherStateToSet);
        _this.internalSetState(function(_ref9) {
          var isOpen = _ref9.isOpen;
          return _extends({
            isOpen: !isOpen
          }, isOpen && {
            highlightedIndex: _this.props.defaultHighlightedIndex
          }, otherStateToSet);
        }, function() {
          var _this$getState7 = _this.getState(), isOpen = _this$getState7.isOpen, highlightedIndex = _this$getState7.highlightedIndex;
          if (isOpen) {
            if (_this.getItemCount() > 0 && typeof highlightedIndex === "number") {
              _this.setHighlightedIndex(highlightedIndex, otherStateToSet);
            }
          }
          cbToCb(cb)();
        });
      };
      _this.openMenu = function(cb) {
        _this.internalSetState({
          isOpen: true
        }, cb);
      };
      _this.closeMenu = function(cb) {
        _this.internalSetState({
          isOpen: false
        }, cb);
      };
      _this.updateStatus = debounce(function() {
        var state = _this.getState();
        var item = _this.items[state.highlightedIndex];
        var resultCount = _this.getItemCount();
        var status = _this.props.getA11yStatusMessage(_extends({
          itemToString: _this.props.itemToString,
          previousResultCount: _this.previousResultCount,
          resultCount,
          highlightedItem: item
        }, state));
        _this.previousResultCount = resultCount;
        setStatus(status, _this.props.environment.document);
      }, 200);
      var _this$props = _this.props, defaultHighlightedIndex = _this$props.defaultHighlightedIndex, _this$props$initialHi = _this$props.initialHighlightedIndex, _highlightedIndex = _this$props$initialHi === void 0 ? defaultHighlightedIndex : _this$props$initialHi, defaultIsOpen = _this$props.defaultIsOpen, _this$props$initialIs = _this$props.initialIsOpen, _isOpen = _this$props$initialIs === void 0 ? defaultIsOpen : _this$props$initialIs, _this$props$initialIn = _this$props.initialInputValue, _inputValue = _this$props$initialIn === void 0 ? "" : _this$props$initialIn, _this$props$initialSe = _this$props.initialSelectedItem, _selectedItem = _this$props$initialSe === void 0 ? null : _this$props$initialSe;
      var _state = _this.getState({
        highlightedIndex: _highlightedIndex,
        isOpen: _isOpen,
        inputValue: _inputValue,
        selectedItem: _selectedItem
      });
      if (_state.selectedItem != null && _this.props.initialInputValue === void 0) {
        _state.inputValue = _this.props.itemToString(_state.selectedItem);
      }
      _this.state = _state;
      return _this;
    }
    var _proto = Downshift3.prototype;
    _proto.internalClearTimeouts = function internalClearTimeouts() {
      this.timeoutIds.forEach(function(id) {
        clearTimeout(id);
      });
      this.timeoutIds = [];
    };
    _proto.getState = function getState$1(stateToMerge) {
      if (stateToMerge === void 0) {
        stateToMerge = this.state;
      }
      return getState3(stateToMerge, this.props);
    };
    _proto.getItemCount = function getItemCount() {
      var itemCount = this.items.length;
      if (this.itemCount != null) {
        itemCount = this.itemCount;
      } else if (this.props.itemCount !== void 0) {
        itemCount = this.props.itemCount;
      }
      return itemCount;
    };
    _proto.getItemNodeFromIndex = function getItemNodeFromIndex(index3) {
      return this.props.environment.document.getElementById(this.getItemId(index3));
    };
    _proto.scrollHighlightedItemIntoView = function scrollHighlightedItemIntoView() {
      {
        var node2 = this.getItemNodeFromIndex(this.getState().highlightedIndex);
        this.props.scrollIntoView(node2, this._menuNode);
      }
    };
    _proto.moveHighlightedIndex = function moveHighlightedIndex(amount, otherStateToSet) {
      var _this6 = this;
      var itemCount = this.getItemCount();
      var _this$getState8 = this.getState(), highlightedIndex = _this$getState8.highlightedIndex;
      if (itemCount > 0) {
        var nextHighlightedIndex = getNextWrappingIndex(amount, highlightedIndex, itemCount, function(index3) {
          return _this6.getItemNodeFromIndex(index3);
        });
        this.setHighlightedIndex(nextHighlightedIndex, otherStateToSet);
      }
    };
    _proto.getStateAndHelpers = function getStateAndHelpers() {
      var _this$getState9 = this.getState(), highlightedIndex = _this$getState9.highlightedIndex, inputValue = _this$getState9.inputValue, selectedItem = _this$getState9.selectedItem, isOpen = _this$getState9.isOpen;
      var itemToString2 = this.props.itemToString;
      var id = this.id;
      var getRootProps = this.getRootProps, getToggleButtonProps = this.getToggleButtonProps, getLabelProps = this.getLabelProps, getMenuProps = this.getMenuProps, getInputProps = this.getInputProps, getItemProps = this.getItemProps, openMenu = this.openMenu, closeMenu = this.closeMenu, toggleMenu = this.toggleMenu, selectItem2 = this.selectItem, selectItemAtIndex = this.selectItemAtIndex, selectHighlightedItem = this.selectHighlightedItem, setHighlightedIndex = this.setHighlightedIndex, clearSelection = this.clearSelection, clearItems = this.clearItems, reset2 = this.reset, setItemCount = this.setItemCount, unsetItemCount = this.unsetItemCount, setState = this.internalSetState;
      return {
        // prop getters
        getRootProps,
        getToggleButtonProps,
        getLabelProps,
        getMenuProps,
        getInputProps,
        getItemProps,
        // actions
        reset: reset2,
        openMenu,
        closeMenu,
        toggleMenu,
        selectItem: selectItem2,
        selectItemAtIndex,
        selectHighlightedItem,
        setHighlightedIndex,
        clearSelection,
        clearItems,
        setItemCount,
        unsetItemCount,
        setState,
        // props
        itemToString: itemToString2,
        // derived
        id,
        // state
        highlightedIndex,
        inputValue,
        isOpen,
        selectedItem
      };
    };
    _proto.componentDidMount = function componentDidMount() {
      var _this7 = this;
      if (this.getMenuProps.called && !this.getMenuProps.suppressRefError) {
        validateGetMenuPropsCalledCorrectly(this._menuNode, this.getMenuProps);
      }
      {
        var onMouseDown = function onMouseDown2() {
          _this7.isMouseDown = true;
        };
        var onMouseUp = function onMouseUp2(event) {
          _this7.isMouseDown = false;
          var contextWithinDownshift = targetWithinDownshift(event.target, [_this7._rootNode, _this7._menuNode], _this7.props.environment);
          if (!contextWithinDownshift && _this7.getState().isOpen) {
            _this7.reset({
              type: mouseUp
            }, function() {
              return _this7.props.onOuterClick(_this7.getStateAndHelpers());
            });
          }
        };
        var onTouchStart = function onTouchStart2() {
          _this7.isTouchMove = false;
        };
        var onTouchMove = function onTouchMove2() {
          _this7.isTouchMove = true;
        };
        var onTouchEnd = function onTouchEnd2(event) {
          var contextWithinDownshift = targetWithinDownshift(event.target, [_this7._rootNode, _this7._menuNode], _this7.props.environment, false);
          if (!_this7.isTouchMove && !contextWithinDownshift && _this7.getState().isOpen) {
            _this7.reset({
              type: touchEnd
            }, function() {
              return _this7.props.onOuterClick(_this7.getStateAndHelpers());
            });
          }
        };
        var environment = this.props.environment;
        environment.addEventListener("mousedown", onMouseDown);
        environment.addEventListener("mouseup", onMouseUp);
        environment.addEventListener("touchstart", onTouchStart);
        environment.addEventListener("touchmove", onTouchMove);
        environment.addEventListener("touchend", onTouchEnd);
        this.cleanup = function() {
          _this7.internalClearTimeouts();
          _this7.updateStatus.cancel();
          environment.removeEventListener("mousedown", onMouseDown);
          environment.removeEventListener("mouseup", onMouseUp);
          environment.removeEventListener("touchstart", onTouchStart);
          environment.removeEventListener("touchmove", onTouchMove);
          environment.removeEventListener("touchend", onTouchEnd);
        };
      }
    };
    _proto.shouldScroll = function shouldScroll(prevState, prevProps) {
      var _ref10 = this.props.highlightedIndex === void 0 ? this.getState() : this.props, currentHighlightedIndex = _ref10.highlightedIndex;
      var _ref11 = prevProps.highlightedIndex === void 0 ? prevState : prevProps, prevHighlightedIndex = _ref11.highlightedIndex;
      var scrollWhenOpen = currentHighlightedIndex && this.getState().isOpen && !prevState.isOpen;
      var scrollWhenNavigating = currentHighlightedIndex !== prevHighlightedIndex;
      return scrollWhenOpen || scrollWhenNavigating;
    };
    _proto.componentDidUpdate = function componentDidUpdate(prevProps, prevState) {
      if (true) {
        validateControlledUnchanged(this.state, prevProps, this.props);
        if (this.getMenuProps.called && !this.getMenuProps.suppressRefError) {
          validateGetMenuPropsCalledCorrectly(this._menuNode, this.getMenuProps);
        }
      }
      if (isControlledProp(this.props, "selectedItem") && this.props.selectedItemChanged(prevProps.selectedItem, this.props.selectedItem)) {
        this.internalSetState({
          type: controlledPropUpdatedSelectedItem,
          inputValue: this.props.itemToString(this.props.selectedItem)
        });
      }
      if (!this.avoidScrolling && this.shouldScroll(prevState, prevProps)) {
        this.scrollHighlightedItemIntoView();
      }
      {
        this.updateStatus();
      }
    };
    _proto.componentWillUnmount = function componentWillUnmount() {
      this.cleanup();
    };
    _proto.render = function render() {
      var children = unwrapArray(this.props.children, noop2);
      this.clearItems();
      this.getRootProps.called = false;
      this.getRootProps.refKey = void 0;
      this.getRootProps.suppressRefError = void 0;
      this.getMenuProps.called = false;
      this.getMenuProps.refKey = void 0;
      this.getMenuProps.suppressRefError = void 0;
      this.getLabelProps.called = false;
      this.getInputProps.called = false;
      var element2 = unwrapArray(children(this.getStateAndHelpers()));
      if (!element2) {
        return null;
      }
      if (this.getRootProps.called || this.props.suppressRefError) {
        if (!this.getRootProps.suppressRefError && !this.props.suppressRefError) {
          validateGetRootPropsCalledCorrectly(element2, this.getRootProps);
        }
        return element2;
      } else if (isDOMElement(element2)) {
        return (0, import_react31.cloneElement)(element2, this.getRootProps(getElementProps(element2)));
      }
      if (true) {
        throw new Error("downshift: If you return a non-DOM element, you must apply the getRootProps function");
      }
      return void 0;
    };
    return Downshift3;
  }(import_react31.Component);
  Downshift2.defaultProps = {
    defaultHighlightedIndex: null,
    defaultIsOpen: false,
    getA11yStatusMessage: getA11yStatusMessage$1,
    itemToString: function itemToString2(i3) {
      if (i3 == null) {
        return "";
      }
      if (isPlainObject2(i3) && !i3.hasOwnProperty("toString")) {
        console.warn("downshift: An object was passed to the default implementation of `itemToString`. You should probably provide your own `itemToString` implementation. Please refer to the `itemToString` API documentation.", "The object that was passed:", i3);
      }
      return String(i3);
    },
    onStateChange: noop2,
    onInputValueChange: noop2,
    onUserAction: noop2,
    onChange: noop2,
    onSelect: noop2,
    onOuterClick: noop2,
    selectedItemChanged: function selectedItemChanged2(prevItem, item) {
      return prevItem !== item;
    },
    environment: (
      /* istanbul ignore next (ssr) */
      typeof window === "undefined" ? {} : window
    ),
    stateReducer: function stateReducer2(state, stateToSet) {
      return stateToSet;
    },
    suppressRefError: false,
    scrollIntoView
  };
  Downshift2.stateChangeTypes = stateChangeTypes$3;
  return Downshift2;
}();
true ? Downshift.propTypes = {
  children: import_prop_types.default.func,
  defaultHighlightedIndex: import_prop_types.default.number,
  defaultIsOpen: import_prop_types.default.bool,
  initialHighlightedIndex: import_prop_types.default.number,
  initialSelectedItem: import_prop_types.default.any,
  initialInputValue: import_prop_types.default.string,
  initialIsOpen: import_prop_types.default.bool,
  getA11yStatusMessage: import_prop_types.default.func,
  itemToString: import_prop_types.default.func,
  onChange: import_prop_types.default.func,
  onSelect: import_prop_types.default.func,
  onStateChange: import_prop_types.default.func,
  onInputValueChange: import_prop_types.default.func,
  onUserAction: import_prop_types.default.func,
  onOuterClick: import_prop_types.default.func,
  selectedItemChanged: import_prop_types.default.func,
  stateReducer: import_prop_types.default.func,
  itemCount: import_prop_types.default.number,
  id: import_prop_types.default.string,
  environment: import_prop_types.default.shape({
    addEventListener: import_prop_types.default.func,
    removeEventListener: import_prop_types.default.func,
    document: import_prop_types.default.shape({
      getElementById: import_prop_types.default.func,
      activeElement: import_prop_types.default.any,
      body: import_prop_types.default.any
    })
  }),
  suppressRefError: import_prop_types.default.bool,
  scrollIntoView: import_prop_types.default.func,
  // things we keep in state for uncontrolled components
  // but can accept as props for controlled components
  /* eslint-disable react/no-unused-prop-types */
  selectedItem: import_prop_types.default.any,
  isOpen: import_prop_types.default.bool,
  inputValue: import_prop_types.default.string,
  highlightedIndex: import_prop_types.default.number,
  labelId: import_prop_types.default.string,
  inputId: import_prop_types.default.string,
  menuId: import_prop_types.default.string,
  getItemId: import_prop_types.default.func
  /* eslint-enable react/no-unused-prop-types */
} : void 0;
function validateGetMenuPropsCalledCorrectly(node2, _ref12) {
  var refKey = _ref12.refKey;
  if (!node2) {
    console.error('downshift: The ref prop "' + refKey + '" from getMenuProps was not applied correctly on your menu element.');
  }
}
function validateGetRootPropsCalledCorrectly(element2, _ref13) {
  var refKey = _ref13.refKey;
  var refKeySpecified = refKey !== "ref";
  var isComposite = !isDOMElement(element2);
  if (isComposite && !refKeySpecified && !(0, import_react_is.isForwardRef)(element2)) {
    console.error("downshift: You returned a non-DOM element. You must specify a refKey in getRootProps");
  } else if (!isComposite && refKeySpecified) {
    console.error('downshift: You returned a DOM element. You should not specify a refKey in getRootProps. You specified "' + refKey + '"');
  }
  if (!(0, import_react_is.isForwardRef)(element2) && !getElementProps(element2)[refKey]) {
    console.error('downshift: You must apply the ref prop "' + refKey + '" from getRootProps onto your root element.');
  }
}
var _excluded$3 = ["isInitialMount", "highlightedIndex", "items", "environment"];
var dropdownDefaultStateValues = {
  highlightedIndex: -1,
  isOpen: false,
  selectedItem: null,
  inputValue: ""
};
function callOnChangeProps(action, state, newState) {
  var props = action.props, type2 = action.type;
  var changes = {};
  Object.keys(state).forEach(function(key2) {
    invokeOnChangeHandler(key2, action, state, newState);
    if (newState[key2] !== state[key2]) {
      changes[key2] = newState[key2];
    }
  });
  if (props.onStateChange && Object.keys(changes).length) {
    props.onStateChange(_extends({
      type: type2
    }, changes));
  }
}
function invokeOnChangeHandler(key2, action, state, newState) {
  var props = action.props, type2 = action.type;
  var handler2 = "on" + capitalizeString(key2) + "Change";
  if (props[handler2] && newState[key2] !== void 0 && newState[key2] !== state[key2]) {
    props[handler2](_extends({
      type: type2
    }, newState));
  }
}
function stateReducer(s2, a2) {
  return a2.changes;
}
function getA11ySelectionMessage(selectionParameters) {
  var selectedItem = selectionParameters.selectedItem, itemToStringLocal = selectionParameters.itemToString;
  return selectedItem ? itemToStringLocal(selectedItem) + " has been selected." : "";
}
var updateA11yStatus = debounce(function(getA11yMessage, document4) {
  setStatus(getA11yMessage(), document4);
}, 200);
var useIsomorphicLayoutEffect2 = typeof window !== "undefined" && typeof window.document !== "undefined" && typeof window.document.createElement !== "undefined" ? import_react31.useLayoutEffect : import_react31.useEffect;
function useElementIds(_ref) {
  var _ref$id = _ref.id, id = _ref$id === void 0 ? "downshift-" + generateId2() : _ref$id, labelId = _ref.labelId, menuId = _ref.menuId, getItemId = _ref.getItemId, toggleButtonId = _ref.toggleButtonId, inputId = _ref.inputId;
  var elementIdsRef = (0, import_react31.useRef)({
    labelId: labelId || id + "-label",
    menuId: menuId || id + "-menu",
    getItemId: getItemId || function(index3) {
      return id + "-item-" + index3;
    },
    toggleButtonId: toggleButtonId || id + "-toggle-button",
    inputId: inputId || id + "-input"
  });
  return elementIdsRef.current;
}
function getItemAndIndex(itemProp, indexProp, items, errorMessage) {
  var item, index3;
  if (itemProp === void 0) {
    if (indexProp === void 0) {
      throw new Error(errorMessage);
    }
    item = items[indexProp];
    index3 = indexProp;
  } else {
    index3 = indexProp === void 0 ? items.indexOf(itemProp) : indexProp;
    item = itemProp;
  }
  return [item, index3];
}
function itemToString(item) {
  return item ? String(item) : "";
}
function isAcceptedCharacterKey(key2) {
  return /^\S{1}$/.test(key2);
}
function capitalizeString(string3) {
  return "" + string3.slice(0, 1).toUpperCase() + string3.slice(1);
}
function useLatestRef2(val) {
  var ref2 = (0, import_react31.useRef)(val);
  ref2.current = val;
  return ref2;
}
function useEnhancedReducer(reducer, initialState2, props) {
  var prevStateRef = (0, import_react31.useRef)();
  var actionRef = (0, import_react31.useRef)();
  var enhancedReducer = (0, import_react31.useCallback)(function(state2, action2) {
    actionRef.current = action2;
    state2 = getState3(state2, action2.props);
    var changes = reducer(state2, action2);
    var newState = action2.props.stateReducer(state2, _extends({}, action2, {
      changes
    }));
    return newState;
  }, [reducer]);
  var _useReducer = (0, import_react31.useReducer)(enhancedReducer, initialState2), state = _useReducer[0], dispatch = _useReducer[1];
  var propsRef = useLatestRef2(props);
  var dispatchWithProps = (0, import_react31.useCallback)(function(action2) {
    return dispatch(_extends({
      props: propsRef.current
    }, action2));
  }, [propsRef]);
  var action = actionRef.current;
  (0, import_react31.useEffect)(function() {
    if (action && prevStateRef.current && prevStateRef.current !== state) {
      callOnChangeProps(action, getState3(prevStateRef.current, action.props), state);
    }
    prevStateRef.current = state;
  }, [state, props, action]);
  return [state, dispatchWithProps];
}
function useControlledReducer$1(reducer, initialState2, props) {
  var _useEnhancedReducer = useEnhancedReducer(reducer, initialState2, props), state = _useEnhancedReducer[0], dispatch = _useEnhancedReducer[1];
  return [getState3(state, props), dispatch];
}
var defaultProps$3 = {
  itemToString,
  stateReducer,
  getA11ySelectionMessage,
  scrollIntoView,
  environment: (
    /* istanbul ignore next (ssr) */
    typeof window === "undefined" ? {} : window
  )
};
function getDefaultValue$1(props, propKey, defaultStateValues2) {
  if (defaultStateValues2 === void 0) {
    defaultStateValues2 = dropdownDefaultStateValues;
  }
  var defaultValue = props["default" + capitalizeString(propKey)];
  if (defaultValue !== void 0) {
    return defaultValue;
  }
  return defaultStateValues2[propKey];
}
function getInitialValue$1(props, propKey, defaultStateValues2) {
  if (defaultStateValues2 === void 0) {
    defaultStateValues2 = dropdownDefaultStateValues;
  }
  var value2 = props[propKey];
  if (value2 !== void 0) {
    return value2;
  }
  var initialValue = props["initial" + capitalizeString(propKey)];
  if (initialValue !== void 0) {
    return initialValue;
  }
  return getDefaultValue$1(props, propKey, defaultStateValues2);
}
function getInitialState$2(props) {
  var selectedItem = getInitialValue$1(props, "selectedItem");
  var isOpen = getInitialValue$1(props, "isOpen");
  var highlightedIndex = getInitialValue$1(props, "highlightedIndex");
  var inputValue = getInitialValue$1(props, "inputValue");
  return {
    highlightedIndex: highlightedIndex < 0 && selectedItem && isOpen ? props.items.indexOf(selectedItem) : highlightedIndex,
    isOpen,
    selectedItem,
    inputValue
  };
}
function getHighlightedIndexOnOpen(props, state, offset5) {
  var items = props.items, initialHighlightedIndex = props.initialHighlightedIndex, defaultHighlightedIndex = props.defaultHighlightedIndex;
  var selectedItem = state.selectedItem, highlightedIndex = state.highlightedIndex;
  if (items.length === 0) {
    return -1;
  }
  if (initialHighlightedIndex !== void 0 && highlightedIndex === initialHighlightedIndex) {
    return initialHighlightedIndex;
  }
  if (defaultHighlightedIndex !== void 0) {
    return defaultHighlightedIndex;
  }
  if (selectedItem) {
    return items.indexOf(selectedItem);
  }
  if (offset5 === 0) {
    return -1;
  }
  return offset5 < 0 ? items.length - 1 : 0;
}
function useMouseAndTouchTracker(isOpen, downshiftElementRefs, environment, handleBlur) {
  var mouseAndTouchTrackersRef = (0, import_react31.useRef)({
    isMouseDown: false,
    isTouchMove: false
  });
  (0, import_react31.useEffect)(function() {
    if ((environment == null ? void 0 : environment.addEventListener) == null) {
      return;
    }
    var onMouseDown = function onMouseDown2() {
      mouseAndTouchTrackersRef.current.isMouseDown = true;
    };
    var onMouseUp = function onMouseUp2(event) {
      mouseAndTouchTrackersRef.current.isMouseDown = false;
      if (isOpen && !targetWithinDownshift(event.target, downshiftElementRefs.map(function(ref2) {
        return ref2.current;
      }), environment)) {
        handleBlur();
      }
    };
    var onTouchStart = function onTouchStart2() {
      mouseAndTouchTrackersRef.current.isTouchMove = false;
    };
    var onTouchMove = function onTouchMove2() {
      mouseAndTouchTrackersRef.current.isTouchMove = true;
    };
    var onTouchEnd = function onTouchEnd2(event) {
      if (isOpen && !mouseAndTouchTrackersRef.current.isTouchMove && !targetWithinDownshift(event.target, downshiftElementRefs.map(function(ref2) {
        return ref2.current;
      }), environment, false)) {
        handleBlur();
      }
    };
    environment.addEventListener("mousedown", onMouseDown);
    environment.addEventListener("mouseup", onMouseUp);
    environment.addEventListener("touchstart", onTouchStart);
    environment.addEventListener("touchmove", onTouchMove);
    environment.addEventListener("touchend", onTouchEnd);
    return function cleanup() {
      environment.removeEventListener("mousedown", onMouseDown);
      environment.removeEventListener("mouseup", onMouseUp);
      environment.removeEventListener("touchstart", onTouchStart);
      environment.removeEventListener("touchmove", onTouchMove);
      environment.removeEventListener("touchend", onTouchEnd);
    };
  }, [isOpen, environment]);
  return mouseAndTouchTrackersRef;
}
var useGetterPropsCalledChecker = function useGetterPropsCalledChecker2() {
  return noop2;
};
if (true) {
  useGetterPropsCalledChecker = function useGetterPropsCalledChecker3() {
    var isInitialMountRef = (0, import_react31.useRef)(true);
    for (var _len = arguments.length, propKeys = new Array(_len), _key = 0; _key < _len; _key++) {
      propKeys[_key] = arguments[_key];
    }
    var getterPropsCalledRef = (0, import_react31.useRef)(propKeys.reduce(function(acc, propKey) {
      acc[propKey] = {};
      return acc;
    }, {}));
    (0, import_react31.useEffect)(function() {
      Object.keys(getterPropsCalledRef.current).forEach(function(propKey) {
        var propCallInfo = getterPropsCalledRef.current[propKey];
        if (isInitialMountRef.current) {
          if (!Object.keys(propCallInfo).length) {
            console.error("downshift: You forgot to call the " + propKey + " getter function on your component / element.");
            return;
          }
        }
        var suppressRefError = propCallInfo.suppressRefError, refKey = propCallInfo.refKey, elementRef = propCallInfo.elementRef;
        if ((!elementRef || !elementRef.current) && !suppressRefError) {
          console.error('downshift: The ref prop "' + refKey + '" from ' + propKey + " was not applied correctly on your element.");
        }
      });
      isInitialMountRef.current = false;
    });
    var setGetterPropCallInfo = (0, import_react31.useCallback)(function(propKey, suppressRefError, refKey, elementRef) {
      getterPropsCalledRef.current[propKey] = {
        suppressRefError,
        refKey,
        elementRef
      };
    }, []);
    return setGetterPropCallInfo;
  };
}
function useA11yMessageSetter(getA11yMessage, dependencyArray, _ref2) {
  var isInitialMount = _ref2.isInitialMount, highlightedIndex = _ref2.highlightedIndex, items = _ref2.items, environment = _ref2.environment, rest = _objectWithoutPropertiesLoose(_ref2, _excluded$3);
  (0, import_react31.useEffect)(function() {
    if (isInitialMount || false) {
      return;
    }
    updateA11yStatus(function() {
      return getA11yMessage(_extends({
        highlightedIndex,
        highlightedItem: items[highlightedIndex],
        resultCount: items.length
      }, rest));
    }, environment.document);
  }, dependencyArray);
}
function useScrollIntoView(_ref3) {
  var highlightedIndex = _ref3.highlightedIndex, isOpen = _ref3.isOpen, itemRefs = _ref3.itemRefs, getItemNodeFromIndex = _ref3.getItemNodeFromIndex, menuElement = _ref3.menuElement, scrollIntoViewProp = _ref3.scrollIntoView;
  var shouldScrollRef = (0, import_react31.useRef)(true);
  useIsomorphicLayoutEffect2(function() {
    if (highlightedIndex < 0 || !isOpen || !Object.keys(itemRefs.current).length) {
      return;
    }
    if (shouldScrollRef.current === false) {
      shouldScrollRef.current = true;
    } else {
      scrollIntoViewProp(getItemNodeFromIndex(highlightedIndex), menuElement);
    }
  }, [highlightedIndex]);
  return shouldScrollRef;
}
var useControlPropsValidator = noop2;
if (true) {
  useControlPropsValidator = function useControlPropsValidator2(_ref4) {
    var isInitialMount = _ref4.isInitialMount, props = _ref4.props, state = _ref4.state;
    var prevPropsRef = (0, import_react31.useRef)(props);
    (0, import_react31.useEffect)(function() {
      if (isInitialMount) {
        return;
      }
      validateControlledUnchanged(state, prevPropsRef.current, props);
      prevPropsRef.current = props;
    }, [state, props, isInitialMount]);
  };
}
function getChangesOnSelection(props, highlightedIndex, inputValue) {
  var _props$items;
  if (inputValue === void 0) {
    inputValue = true;
  }
  var shouldSelect = ((_props$items = props.items) == null ? void 0 : _props$items.length) && highlightedIndex >= 0;
  return _extends({
    isOpen: false,
    highlightedIndex: -1
  }, shouldSelect && _extends({
    selectedItem: props.items[highlightedIndex],
    isOpen: getDefaultValue$1(props, "isOpen"),
    highlightedIndex: getDefaultValue$1(props, "highlightedIndex")
  }, inputValue && {
    inputValue: props.itemToString(props.items[highlightedIndex])
  }));
}
function downshiftCommonReducer(state, action, stateChangeTypes2) {
  var type2 = action.type, props = action.props;
  var changes;
  switch (type2) {
    case stateChangeTypes2.ItemMouseMove:
      changes = {
        highlightedIndex: action.disabled ? -1 : action.index
      };
      break;
    case stateChangeTypes2.MenuMouseLeave:
      changes = {
        highlightedIndex: -1
      };
      break;
    case stateChangeTypes2.ToggleButtonClick:
    case stateChangeTypes2.FunctionToggleMenu:
      changes = {
        isOpen: !state.isOpen,
        highlightedIndex: state.isOpen ? -1 : getHighlightedIndexOnOpen(props, state, 0)
      };
      break;
    case stateChangeTypes2.FunctionOpenMenu:
      changes = {
        isOpen: true,
        highlightedIndex: getHighlightedIndexOnOpen(props, state, 0)
      };
      break;
    case stateChangeTypes2.FunctionCloseMenu:
      changes = {
        isOpen: false
      };
      break;
    case stateChangeTypes2.FunctionSetHighlightedIndex:
      changes = {
        highlightedIndex: action.highlightedIndex
      };
      break;
    case stateChangeTypes2.FunctionSetInputValue:
      changes = {
        inputValue: action.inputValue
      };
      break;
    case stateChangeTypes2.FunctionReset:
      changes = {
        highlightedIndex: getDefaultValue$1(props, "highlightedIndex"),
        isOpen: getDefaultValue$1(props, "isOpen"),
        selectedItem: getDefaultValue$1(props, "selectedItem"),
        inputValue: getDefaultValue$1(props, "inputValue")
      };
      break;
    default:
      throw new Error("Reducer called without proper action type.");
  }
  return _extends({}, state, changes);
}
function getItemIndexByCharacterKey(_a2) {
  var keysSoFar = _a2.keysSoFar, highlightedIndex = _a2.highlightedIndex, items = _a2.items, itemToString2 = _a2.itemToString, getItemNodeFromIndex = _a2.getItemNodeFromIndex;
  var lowerCasedKeysSoFar = keysSoFar.toLowerCase();
  for (var index3 = 0; index3 < items.length; index3++) {
    var offsetIndex = (index3 + highlightedIndex + (keysSoFar.length < 2 ? 1 : 0)) % items.length;
    var item = items[offsetIndex];
    if (item !== void 0 && itemToString2(item).toLowerCase().startsWith(lowerCasedKeysSoFar)) {
      var element2 = getItemNodeFromIndex(offsetIndex);
      if (!(element2 === null || element2 === void 0 ? void 0 : element2.hasAttribute("disabled"))) {
        return offsetIndex;
      }
    }
  }
  return highlightedIndex;
}
var propTypes$2 = {
  items: import_prop_types.default.array.isRequired,
  itemToString: import_prop_types.default.func,
  getA11yStatusMessage: import_prop_types.default.func,
  getA11ySelectionMessage: import_prop_types.default.func,
  highlightedIndex: import_prop_types.default.number,
  defaultHighlightedIndex: import_prop_types.default.number,
  initialHighlightedIndex: import_prop_types.default.number,
  isOpen: import_prop_types.default.bool,
  defaultIsOpen: import_prop_types.default.bool,
  initialIsOpen: import_prop_types.default.bool,
  selectedItem: import_prop_types.default.any,
  initialSelectedItem: import_prop_types.default.any,
  defaultSelectedItem: import_prop_types.default.any,
  id: import_prop_types.default.string,
  labelId: import_prop_types.default.string,
  menuId: import_prop_types.default.string,
  getItemId: import_prop_types.default.func,
  toggleButtonId: import_prop_types.default.string,
  stateReducer: import_prop_types.default.func,
  onSelectedItemChange: import_prop_types.default.func,
  onHighlightedIndexChange: import_prop_types.default.func,
  onStateChange: import_prop_types.default.func,
  onIsOpenChange: import_prop_types.default.func,
  environment: import_prop_types.default.shape({
    addEventListener: import_prop_types.default.func,
    removeEventListener: import_prop_types.default.func,
    document: import_prop_types.default.shape({
      getElementById: import_prop_types.default.func,
      activeElement: import_prop_types.default.any,
      body: import_prop_types.default.any
    })
  })
};
function getA11yStatusMessage(_a2) {
  var isOpen = _a2.isOpen, resultCount = _a2.resultCount, previousResultCount = _a2.previousResultCount;
  if (!isOpen) {
    return "";
  }
  if (!resultCount) {
    return "No results are available.";
  }
  if (resultCount !== previousResultCount) {
    return "".concat(resultCount, " result").concat(resultCount === 1 ? " is" : "s are", " available, use up and down arrow keys to navigate. Press Enter or Space Bar keys to select.");
  }
  return "";
}
var defaultProps$2 = __assign(__assign({}, defaultProps$3), { getA11yStatusMessage });
var validatePropTypes$2 = noop2;
if (true) {
  validatePropTypes$2 = function(options, caller) {
    import_prop_types.default.checkPropTypes(propTypes$2, options, "prop", caller.name);
  };
}
var ToggleButtonClick$1 = true ? "__togglebutton_click__" : 0;
var ToggleButtonKeyDownArrowDown = true ? "__togglebutton_keydown_arrow_down__" : 1;
var ToggleButtonKeyDownArrowUp = true ? "__togglebutton_keydown_arrow_up__" : 2;
var ToggleButtonKeyDownCharacter = true ? "__togglebutton_keydown_character__" : 3;
var ToggleButtonKeyDownEscape = true ? "__togglebutton_keydown_escape__" : 4;
var ToggleButtonKeyDownHome = true ? "__togglebutton_keydown_home__" : 5;
var ToggleButtonKeyDownEnd = true ? "__togglebutton_keydown_end__" : 6;
var ToggleButtonKeyDownEnter = true ? "__togglebutton_keydown_enter__" : 7;
var ToggleButtonKeyDownSpaceButton = true ? "__togglebutton_keydown_space_button__" : 8;
var ToggleButtonKeyDownPageUp = true ? "__togglebutton_keydown_page_up__" : 9;
var ToggleButtonKeyDownPageDown = true ? "__togglebutton_keydown_page_down__" : 10;
var ToggleButtonBlur = true ? "__togglebutton_blur__" : 11;
var MenuMouseLeave$1 = true ? "__menu_mouse_leave__" : 12;
var ItemMouseMove$1 = true ? "__item_mouse_move__" : 13;
var ItemClick$1 = true ? "__item_click__" : 14;
var FunctionToggleMenu$1 = true ? "__function_toggle_menu__" : 15;
var FunctionOpenMenu$1 = true ? "__function_open_menu__" : 16;
var FunctionCloseMenu$1 = true ? "__function_close_menu__" : 17;
var FunctionSetHighlightedIndex$1 = true ? "__function_set_highlighted_index__" : 18;
var FunctionSelectItem$1 = true ? "__function_select_item__" : 19;
var FunctionSetInputValue$1 = true ? "__function_set_input_value__" : 20;
var FunctionReset$2 = true ? "__function_reset__" : 21;
var stateChangeTypes$2 = Object.freeze({
  __proto__: null,
  ToggleButtonClick: ToggleButtonClick$1,
  ToggleButtonKeyDownArrowDown,
  ToggleButtonKeyDownArrowUp,
  ToggleButtonKeyDownCharacter,
  ToggleButtonKeyDownEscape,
  ToggleButtonKeyDownHome,
  ToggleButtonKeyDownEnd,
  ToggleButtonKeyDownEnter,
  ToggleButtonKeyDownSpaceButton,
  ToggleButtonKeyDownPageUp,
  ToggleButtonKeyDownPageDown,
  ToggleButtonBlur,
  MenuMouseLeave: MenuMouseLeave$1,
  ItemMouseMove: ItemMouseMove$1,
  ItemClick: ItemClick$1,
  FunctionToggleMenu: FunctionToggleMenu$1,
  FunctionOpenMenu: FunctionOpenMenu$1,
  FunctionCloseMenu: FunctionCloseMenu$1,
  FunctionSetHighlightedIndex: FunctionSetHighlightedIndex$1,
  FunctionSelectItem: FunctionSelectItem$1,
  FunctionSetInputValue: FunctionSetInputValue$1,
  FunctionReset: FunctionReset$2
});
function downshiftSelectReducer(state, action) {
  var _props$items;
  var type2 = action.type, props = action.props, altKey = action.altKey;
  var changes;
  switch (type2) {
    case ItemClick$1:
      changes = {
        isOpen: getDefaultValue$1(props, "isOpen"),
        highlightedIndex: getDefaultValue$1(props, "highlightedIndex"),
        selectedItem: props.items[action.index]
      };
      break;
    case ToggleButtonKeyDownCharacter:
      {
        var lowercasedKey = action.key;
        var inputValue = "" + state.inputValue + lowercasedKey;
        var prevHighlightedIndex = !state.isOpen && state.selectedItem ? props.items.indexOf(state.selectedItem) : state.highlightedIndex;
        var highlightedIndex = getItemIndexByCharacterKey({
          keysSoFar: inputValue,
          highlightedIndex: prevHighlightedIndex,
          items: props.items,
          itemToString: props.itemToString,
          getItemNodeFromIndex: action.getItemNodeFromIndex
        });
        changes = {
          inputValue,
          highlightedIndex,
          isOpen: true
        };
      }
      break;
    case ToggleButtonKeyDownArrowDown:
      {
        var _highlightedIndex = state.isOpen ? getNextWrappingIndex(1, state.highlightedIndex, props.items.length, action.getItemNodeFromIndex, false) : altKey && state.selectedItem == null ? -1 : getHighlightedIndexOnOpen(props, state, 1);
        changes = {
          highlightedIndex: _highlightedIndex,
          isOpen: true
        };
      }
      break;
    case ToggleButtonKeyDownArrowUp:
      if (state.isOpen && altKey) {
        changes = getChangesOnSelection(props, state.highlightedIndex, false);
      } else {
        var _highlightedIndex2 = state.isOpen ? getNextWrappingIndex(-1, state.highlightedIndex, props.items.length, action.getItemNodeFromIndex, false) : getHighlightedIndexOnOpen(props, state, -1);
        changes = {
          highlightedIndex: _highlightedIndex2,
          isOpen: true
        };
      }
      break;
    case ToggleButtonKeyDownEnter:
    case ToggleButtonKeyDownSpaceButton:
      changes = getChangesOnSelection(props, state.highlightedIndex, false);
      break;
    case ToggleButtonKeyDownHome:
      changes = {
        highlightedIndex: getNextNonDisabledIndex(1, 0, props.items.length, action.getItemNodeFromIndex, false),
        isOpen: true
      };
      break;
    case ToggleButtonKeyDownEnd:
      changes = {
        highlightedIndex: getNextNonDisabledIndex(-1, props.items.length - 1, props.items.length, action.getItemNodeFromIndex, false),
        isOpen: true
      };
      break;
    case ToggleButtonKeyDownPageUp:
      changes = {
        highlightedIndex: getNextWrappingIndex(-10, state.highlightedIndex, props.items.length, action.getItemNodeFromIndex, false)
      };
      break;
    case ToggleButtonKeyDownPageDown:
      changes = {
        highlightedIndex: getNextWrappingIndex(10, state.highlightedIndex, props.items.length, action.getItemNodeFromIndex, false)
      };
      break;
    case ToggleButtonKeyDownEscape:
      changes = {
        isOpen: false,
        highlightedIndex: -1
      };
      break;
    case ToggleButtonBlur:
      changes = _extends({
        isOpen: false,
        highlightedIndex: -1
      }, state.highlightedIndex >= 0 && ((_props$items = props.items) == null ? void 0 : _props$items.length) && {
        selectedItem: props.items[state.highlightedIndex]
      });
      break;
    case FunctionSelectItem$1:
      changes = {
        selectedItem: action.selectedItem
      };
      break;
    default:
      return downshiftCommonReducer(state, action, stateChangeTypes$2);
  }
  return _extends({}, state, changes);
}
var _excluded$2 = ["onMouseLeave", "refKey", "onKeyDown", "onBlur", "ref"];
var _excluded2$2 = ["onBlur", "onClick", "onPress", "onKeyDown", "refKey", "ref"];
var _excluded3$1 = ["item", "index", "onMouseMove", "onClick", "onPress", "refKey", "ref", "disabled"];
useSelect.stateChangeTypes = stateChangeTypes$2;
function useSelect(userProps) {
  if (userProps === void 0) {
    userProps = {};
  }
  validatePropTypes$2(userProps, useSelect);
  var props = _extends({}, defaultProps$2, userProps);
  var items = props.items, scrollIntoView2 = props.scrollIntoView, environment = props.environment, itemToString2 = props.itemToString, getA11ySelectionMessage2 = props.getA11ySelectionMessage, getA11yStatusMessage2 = props.getA11yStatusMessage;
  var initialState2 = getInitialState$2(props);
  var _useControlledReducer = useControlledReducer$1(downshiftSelectReducer, initialState2, props), state = _useControlledReducer[0], dispatch = _useControlledReducer[1];
  var isOpen = state.isOpen, highlightedIndex = state.highlightedIndex, selectedItem = state.selectedItem, inputValue = state.inputValue;
  var toggleButtonRef = (0, import_react31.useRef)(null);
  var menuRef = (0, import_react31.useRef)(null);
  var itemRefs = (0, import_react31.useRef)({});
  var clearTimeoutRef = (0, import_react31.useRef)(null);
  var elementIds = useElementIds(props);
  var previousResultCountRef = (0, import_react31.useRef)();
  var isInitialMountRef = (0, import_react31.useRef)(true);
  var latest = useLatestRef2({
    state,
    props
  });
  var getItemNodeFromIndex = (0, import_react31.useCallback)(function(index3) {
    return itemRefs.current[elementIds.getItemId(index3)];
  }, [elementIds]);
  useA11yMessageSetter(getA11yStatusMessage2, [isOpen, highlightedIndex, inputValue, items], _extends({
    isInitialMount: isInitialMountRef.current,
    previousResultCount: previousResultCountRef.current,
    items,
    environment,
    itemToString: itemToString2
  }, state));
  useA11yMessageSetter(getA11ySelectionMessage2, [selectedItem], _extends({
    isInitialMount: isInitialMountRef.current,
    previousResultCount: previousResultCountRef.current,
    items,
    environment,
    itemToString: itemToString2
  }, state));
  var shouldScrollRef = useScrollIntoView({
    menuElement: menuRef.current,
    highlightedIndex,
    isOpen,
    itemRefs,
    scrollIntoView: scrollIntoView2,
    getItemNodeFromIndex
  });
  (0, import_react31.useEffect)(function() {
    clearTimeoutRef.current = debounce(function(outerDispatch) {
      outerDispatch({
        type: FunctionSetInputValue$1,
        inputValue: ""
      });
    }, 500);
    return function() {
      clearTimeoutRef.current.cancel();
    };
  }, []);
  (0, import_react31.useEffect)(function() {
    if (!inputValue) {
      return;
    }
    clearTimeoutRef.current(dispatch);
  }, [dispatch, inputValue]);
  useControlPropsValidator({
    isInitialMount: isInitialMountRef.current,
    props,
    state
  });
  (0, import_react31.useEffect)(function() {
    if (isInitialMountRef.current) {
      return;
    }
    previousResultCountRef.current = items.length;
  });
  var mouseAndTouchTrackersRef = useMouseAndTouchTracker(isOpen, [menuRef, toggleButtonRef], environment, function() {
    dispatch({
      type: ToggleButtonBlur
    });
  });
  var setGetterPropCallInfo = useGetterPropsCalledChecker("getMenuProps", "getToggleButtonProps");
  (0, import_react31.useEffect)(function() {
    isInitialMountRef.current = false;
    return function() {
      isInitialMountRef.current = true;
    };
  }, []);
  (0, import_react31.useEffect)(function() {
    if (!isOpen) {
      itemRefs.current = {};
    }
  }, [isOpen]);
  var toggleButtonKeyDownHandlers = (0, import_react31.useMemo)(function() {
    return {
      ArrowDown: function ArrowDown(event) {
        event.preventDefault();
        dispatch({
          type: ToggleButtonKeyDownArrowDown,
          getItemNodeFromIndex,
          altKey: event.altKey
        });
      },
      ArrowUp: function ArrowUp(event) {
        event.preventDefault();
        dispatch({
          type: ToggleButtonKeyDownArrowUp,
          getItemNodeFromIndex,
          altKey: event.altKey
        });
      },
      Home: function Home(event) {
        event.preventDefault();
        dispatch({
          type: ToggleButtonKeyDownHome,
          getItemNodeFromIndex
        });
      },
      End: function End(event) {
        event.preventDefault();
        dispatch({
          type: ToggleButtonKeyDownEnd,
          getItemNodeFromIndex
        });
      },
      Escape: function Escape() {
        if (latest.current.state.isOpen) {
          dispatch({
            type: ToggleButtonKeyDownEscape
          });
        }
      },
      Enter: function Enter(event) {
        event.preventDefault();
        dispatch({
          type: latest.current.state.isOpen ? ToggleButtonKeyDownEnter : ToggleButtonClick$1
        });
      },
      PageUp: function PageUp(event) {
        if (latest.current.state.isOpen) {
          event.preventDefault();
          dispatch({
            type: ToggleButtonKeyDownPageUp,
            getItemNodeFromIndex
          });
        }
      },
      PageDown: function PageDown(event) {
        if (latest.current.state.isOpen) {
          event.preventDefault();
          dispatch({
            type: ToggleButtonKeyDownPageDown,
            getItemNodeFromIndex
          });
        }
      },
      " ": function _2(event) {
        event.preventDefault();
        var currentState = latest.current.state;
        if (!currentState.isOpen) {
          dispatch({
            type: ToggleButtonClick$1
          });
          return;
        }
        if (currentState.inputValue) {
          dispatch({
            type: ToggleButtonKeyDownCharacter,
            key: " ",
            getItemNodeFromIndex
          });
        } else {
          dispatch({
            type: ToggleButtonKeyDownSpaceButton
          });
        }
      }
    };
  }, [dispatch, getItemNodeFromIndex, latest]);
  var toggleMenu = (0, import_react31.useCallback)(function() {
    dispatch({
      type: FunctionToggleMenu$1
    });
  }, [dispatch]);
  var closeMenu = (0, import_react31.useCallback)(function() {
    dispatch({
      type: FunctionCloseMenu$1
    });
  }, [dispatch]);
  var openMenu = (0, import_react31.useCallback)(function() {
    dispatch({
      type: FunctionOpenMenu$1
    });
  }, [dispatch]);
  var setHighlightedIndex = (0, import_react31.useCallback)(function(newHighlightedIndex) {
    dispatch({
      type: FunctionSetHighlightedIndex$1,
      highlightedIndex: newHighlightedIndex
    });
  }, [dispatch]);
  var selectItem2 = (0, import_react31.useCallback)(function(newSelectedItem) {
    dispatch({
      type: FunctionSelectItem$1,
      selectedItem: newSelectedItem
    });
  }, [dispatch]);
  var reset2 = (0, import_react31.useCallback)(function() {
    dispatch({
      type: FunctionReset$2
    });
  }, [dispatch]);
  var setInputValue = (0, import_react31.useCallback)(function(newInputValue) {
    dispatch({
      type: FunctionSetInputValue$1,
      inputValue: newInputValue
    });
  }, [dispatch]);
  var getLabelProps = (0, import_react31.useCallback)(function(labelProps) {
    return _extends({
      id: elementIds.labelId,
      htmlFor: elementIds.toggleButtonId
    }, labelProps);
  }, [elementIds]);
  var getMenuProps = (0, import_react31.useCallback)(function(_temp, _temp2) {
    var _extends2;
    var _ref = _temp === void 0 ? {} : _temp, onMouseLeave = _ref.onMouseLeave, _ref$refKey = _ref.refKey, refKey = _ref$refKey === void 0 ? "ref" : _ref$refKey;
    _ref.onKeyDown;
    _ref.onBlur;
    var ref2 = _ref.ref, rest = _objectWithoutPropertiesLoose(_ref, _excluded$2);
    var _ref2 = _temp2 === void 0 ? {} : _temp2, _ref2$suppressRefErro = _ref2.suppressRefError, suppressRefError = _ref2$suppressRefErro === void 0 ? false : _ref2$suppressRefErro;
    var menuHandleMouseLeave = function menuHandleMouseLeave2() {
      dispatch({
        type: MenuMouseLeave$1
      });
    };
    setGetterPropCallInfo("getMenuProps", suppressRefError, refKey, menuRef);
    return _extends((_extends2 = {}, _extends2[refKey] = handleRefs(ref2, function(menuNode) {
      menuRef.current = menuNode;
    }), _extends2.id = elementIds.menuId, _extends2.role = "listbox", _extends2["aria-labelledby"] = rest && rest["aria-label"] ? void 0 : "" + elementIds.labelId, _extends2.onMouseLeave = callAllEventHandlers(onMouseLeave, menuHandleMouseLeave), _extends2), rest);
  }, [dispatch, setGetterPropCallInfo, elementIds]);
  var getToggleButtonProps = (0, import_react31.useCallback)(function(_temp3, _temp4) {
    var _extends3;
    var _ref3 = _temp3 === void 0 ? {} : _temp3, onBlur = _ref3.onBlur, onClick2 = _ref3.onClick;
    _ref3.onPress;
    var onKeyDown2 = _ref3.onKeyDown, _ref3$refKey = _ref3.refKey, refKey = _ref3$refKey === void 0 ? "ref" : _ref3$refKey, ref2 = _ref3.ref, rest = _objectWithoutPropertiesLoose(_ref3, _excluded2$2);
    var _ref4 = _temp4 === void 0 ? {} : _temp4, _ref4$suppressRefErro = _ref4.suppressRefError, suppressRefError = _ref4$suppressRefErro === void 0 ? false : _ref4$suppressRefErro;
    var latestState = latest.current.state;
    var toggleButtonHandleClick = function toggleButtonHandleClick2() {
      dispatch({
        type: ToggleButtonClick$1
      });
    };
    var toggleButtonHandleBlur = function toggleButtonHandleBlur2() {
      if (latestState.isOpen && !mouseAndTouchTrackersRef.current.isMouseDown) {
        dispatch({
          type: ToggleButtonBlur
        });
      }
    };
    var toggleButtonHandleKeyDown = function toggleButtonHandleKeyDown2(event) {
      var key2 = normalizeArrowKey(event);
      if (key2 && toggleButtonKeyDownHandlers[key2]) {
        toggleButtonKeyDownHandlers[key2](event);
      } else if (isAcceptedCharacterKey(key2)) {
        dispatch({
          type: ToggleButtonKeyDownCharacter,
          key: key2,
          getItemNodeFromIndex
        });
      }
    };
    var toggleProps = _extends((_extends3 = {}, _extends3[refKey] = handleRefs(ref2, function(toggleButtonNode) {
      toggleButtonRef.current = toggleButtonNode;
    }), _extends3["aria-activedescendant"] = latestState.isOpen && latestState.highlightedIndex > -1 ? elementIds.getItemId(latestState.highlightedIndex) : "", _extends3["aria-controls"] = elementIds.menuId, _extends3["aria-expanded"] = latest.current.state.isOpen, _extends3["aria-haspopup"] = "listbox", _extends3["aria-labelledby"] = rest && rest["aria-label"] ? void 0 : "" + elementIds.labelId, _extends3.id = elementIds.toggleButtonId, _extends3.role = "combobox", _extends3.tabIndex = 0, _extends3.onBlur = callAllEventHandlers(onBlur, toggleButtonHandleBlur), _extends3), rest);
    if (!rest.disabled) {
      {
        toggleProps.onClick = callAllEventHandlers(onClick2, toggleButtonHandleClick);
        toggleProps.onKeyDown = callAllEventHandlers(onKeyDown2, toggleButtonHandleKeyDown);
      }
    }
    setGetterPropCallInfo("getToggleButtonProps", suppressRefError, refKey, toggleButtonRef);
    return toggleProps;
  }, [latest, elementIds, setGetterPropCallInfo, dispatch, mouseAndTouchTrackersRef, toggleButtonKeyDownHandlers, getItemNodeFromIndex]);
  var getItemProps = (0, import_react31.useCallback)(function(_temp5) {
    var _extends4;
    var _ref5 = _temp5 === void 0 ? {} : _temp5, itemProp = _ref5.item, indexProp = _ref5.index, onMouseMove = _ref5.onMouseMove, onClick2 = _ref5.onClick;
    _ref5.onPress;
    var _ref5$refKey = _ref5.refKey, refKey = _ref5$refKey === void 0 ? "ref" : _ref5$refKey, ref2 = _ref5.ref, disabled = _ref5.disabled, rest = _objectWithoutPropertiesLoose(_ref5, _excluded3$1);
    var _latest$current = latest.current, latestState = _latest$current.state, latestProps = _latest$current.props;
    var _getItemAndIndex = getItemAndIndex(itemProp, indexProp, latestProps.items, "Pass either item or index to getItemProps!"), item = _getItemAndIndex[0], index3 = _getItemAndIndex[1];
    var itemHandleMouseMove = function itemHandleMouseMove2() {
      if (index3 === latestState.highlightedIndex) {
        return;
      }
      shouldScrollRef.current = false;
      dispatch({
        type: ItemMouseMove$1,
        index: index3,
        disabled
      });
    };
    var itemHandleClick = function itemHandleClick2() {
      dispatch({
        type: ItemClick$1,
        index: index3
      });
    };
    var itemProps = _extends((_extends4 = {
      disabled,
      role: "option",
      "aria-selected": "" + (item === selectedItem),
      id: elementIds.getItemId(index3)
    }, _extends4[refKey] = handleRefs(ref2, function(itemNode) {
      if (itemNode) {
        itemRefs.current[elementIds.getItemId(index3)] = itemNode;
      }
    }), _extends4), rest);
    if (!disabled) {
      {
        itemProps.onClick = callAllEventHandlers(onClick2, itemHandleClick);
      }
    }
    itemProps.onMouseMove = callAllEventHandlers(onMouseMove, itemHandleMouseMove);
    return itemProps;
  }, [latest, selectedItem, elementIds, shouldScrollRef, dispatch]);
  return {
    // prop getters.
    getToggleButtonProps,
    getLabelProps,
    getMenuProps,
    getItemProps,
    // actions.
    toggleMenu,
    openMenu,
    closeMenu,
    setHighlightedIndex,
    selectItem: selectItem2,
    reset: reset2,
    setInputValue,
    // state.
    highlightedIndex,
    isOpen,
    selectedItem,
    inputValue
  };
}
var InputKeyDownArrowDown = true ? "__input_keydown_arrow_down__" : 0;
var InputKeyDownArrowUp = true ? "__input_keydown_arrow_up__" : 1;
var InputKeyDownEscape = true ? "__input_keydown_escape__" : 2;
var InputKeyDownHome = true ? "__input_keydown_home__" : 3;
var InputKeyDownEnd = true ? "__input_keydown_end__" : 4;
var InputKeyDownPageUp = true ? "__input_keydown_page_up__" : 5;
var InputKeyDownPageDown = true ? "__input_keydown_page_down__" : 6;
var InputKeyDownEnter = true ? "__input_keydown_enter__" : 7;
var InputChange = true ? "__input_change__" : 8;
var InputBlur = true ? "__input_blur__" : 9;
var InputFocus = true ? "__input_focus__" : 10;
var MenuMouseLeave = true ? "__menu_mouse_leave__" : 11;
var ItemMouseMove = true ? "__item_mouse_move__" : 12;
var ItemClick = true ? "__item_click__" : 13;
var ToggleButtonClick = true ? "__togglebutton_click__" : 14;
var FunctionToggleMenu = true ? "__function_toggle_menu__" : 15;
var FunctionOpenMenu = true ? "__function_open_menu__" : 16;
var FunctionCloseMenu = true ? "__function_close_menu__" : 17;
var FunctionSetHighlightedIndex = true ? "__function_set_highlighted_index__" : 18;
var FunctionSelectItem = true ? "__function_select_item__" : 19;
var FunctionSetInputValue = true ? "__function_set_input_value__" : 20;
var FunctionReset$1 = true ? "__function_reset__" : 21;
var ControlledPropUpdatedSelectedItem = true ? "__controlled_prop_updated_selected_item__" : 22;
var stateChangeTypes$1 = Object.freeze({
  __proto__: null,
  InputKeyDownArrowDown,
  InputKeyDownArrowUp,
  InputKeyDownEscape,
  InputKeyDownHome,
  InputKeyDownEnd,
  InputKeyDownPageUp,
  InputKeyDownPageDown,
  InputKeyDownEnter,
  InputChange,
  InputBlur,
  InputFocus,
  MenuMouseLeave,
  ItemMouseMove,
  ItemClick,
  ToggleButtonClick,
  FunctionToggleMenu,
  FunctionOpenMenu,
  FunctionCloseMenu,
  FunctionSetHighlightedIndex,
  FunctionSelectItem,
  FunctionSetInputValue,
  FunctionReset: FunctionReset$1,
  ControlledPropUpdatedSelectedItem
});
function getInitialState$1(props) {
  var initialState2 = getInitialState$2(props);
  var selectedItem = initialState2.selectedItem;
  var inputValue = initialState2.inputValue;
  if (inputValue === "" && selectedItem && props.defaultInputValue === void 0 && props.initialInputValue === void 0 && props.inputValue === void 0) {
    inputValue = props.itemToString(selectedItem);
  }
  return _extends({}, initialState2, {
    inputValue
  });
}
var propTypes$1 = {
  items: import_prop_types.default.array.isRequired,
  itemToString: import_prop_types.default.func,
  selectedItemChanged: import_prop_types.default.func,
  getA11yStatusMessage: import_prop_types.default.func,
  getA11ySelectionMessage: import_prop_types.default.func,
  highlightedIndex: import_prop_types.default.number,
  defaultHighlightedIndex: import_prop_types.default.number,
  initialHighlightedIndex: import_prop_types.default.number,
  isOpen: import_prop_types.default.bool,
  defaultIsOpen: import_prop_types.default.bool,
  initialIsOpen: import_prop_types.default.bool,
  selectedItem: import_prop_types.default.any,
  initialSelectedItem: import_prop_types.default.any,
  defaultSelectedItem: import_prop_types.default.any,
  inputValue: import_prop_types.default.string,
  defaultInputValue: import_prop_types.default.string,
  initialInputValue: import_prop_types.default.string,
  id: import_prop_types.default.string,
  labelId: import_prop_types.default.string,
  menuId: import_prop_types.default.string,
  getItemId: import_prop_types.default.func,
  inputId: import_prop_types.default.string,
  toggleButtonId: import_prop_types.default.string,
  stateReducer: import_prop_types.default.func,
  onSelectedItemChange: import_prop_types.default.func,
  onHighlightedIndexChange: import_prop_types.default.func,
  onStateChange: import_prop_types.default.func,
  onIsOpenChange: import_prop_types.default.func,
  onInputValueChange: import_prop_types.default.func,
  environment: import_prop_types.default.shape({
    addEventListener: import_prop_types.default.func,
    removeEventListener: import_prop_types.default.func,
    document: import_prop_types.default.shape({
      getElementById: import_prop_types.default.func,
      activeElement: import_prop_types.default.any,
      body: import_prop_types.default.any
    })
  })
};
function useControlledReducer(reducer, initialState2, props) {
  var previousSelectedItemRef = (0, import_react31.useRef)();
  var _useEnhancedReducer = useEnhancedReducer(reducer, initialState2, props), state = _useEnhancedReducer[0], dispatch = _useEnhancedReducer[1];
  (0, import_react31.useEffect)(function() {
    if (!isControlledProp(props, "selectedItem")) {
      return;
    }
    if (props.selectedItemChanged(previousSelectedItemRef.current, props.selectedItem)) {
      dispatch({
        type: ControlledPropUpdatedSelectedItem,
        inputValue: props.itemToString(props.selectedItem)
      });
    }
    previousSelectedItemRef.current = state.selectedItem === previousSelectedItemRef.current ? props.selectedItem : state.selectedItem;
  }, [state.selectedItem, props.selectedItem]);
  return [getState3(state, props), dispatch];
}
var validatePropTypes$1 = noop2;
if (true) {
  validatePropTypes$1 = function validatePropTypes2(options, caller) {
    import_prop_types.default.checkPropTypes(propTypes$1, options, "prop", caller.name);
  };
}
var defaultProps$1 = _extends({}, defaultProps$3, {
  selectedItemChanged: function selectedItemChanged(prevItem, item) {
    return prevItem !== item;
  },
  getA11yStatusMessage: getA11yStatusMessage$1
});
function downshiftUseComboboxReducer(state, action) {
  var _props$items;
  var type2 = action.type, props = action.props, altKey = action.altKey;
  var changes;
  switch (type2) {
    case ItemClick:
      changes = {
        isOpen: getDefaultValue$1(props, "isOpen"),
        highlightedIndex: getDefaultValue$1(props, "highlightedIndex"),
        selectedItem: props.items[action.index],
        inputValue: props.itemToString(props.items[action.index])
      };
      break;
    case InputKeyDownArrowDown:
      if (state.isOpen) {
        changes = {
          highlightedIndex: getNextWrappingIndex(1, state.highlightedIndex, props.items.length, action.getItemNodeFromIndex, true)
        };
      } else {
        changes = {
          highlightedIndex: altKey && state.selectedItem == null ? -1 : getHighlightedIndexOnOpen(props, state, 1, action.getItemNodeFromIndex),
          isOpen: props.items.length >= 0
        };
      }
      break;
    case InputKeyDownArrowUp:
      if (state.isOpen) {
        if (altKey) {
          changes = getChangesOnSelection(props, state.highlightedIndex);
        } else {
          changes = {
            highlightedIndex: getNextWrappingIndex(-1, state.highlightedIndex, props.items.length, action.getItemNodeFromIndex, true)
          };
        }
      } else {
        changes = {
          highlightedIndex: getHighlightedIndexOnOpen(props, state, -1, action.getItemNodeFromIndex),
          isOpen: props.items.length >= 0
        };
      }
      break;
    case InputKeyDownEnter:
      changes = getChangesOnSelection(props, state.highlightedIndex);
      break;
    case InputKeyDownEscape:
      changes = _extends({
        isOpen: false,
        highlightedIndex: -1
      }, !state.isOpen && {
        selectedItem: null,
        inputValue: ""
      });
      break;
    case InputKeyDownPageUp:
      changes = {
        highlightedIndex: getNextWrappingIndex(-10, state.highlightedIndex, props.items.length, action.getItemNodeFromIndex, false)
      };
      break;
    case InputKeyDownPageDown:
      changes = {
        highlightedIndex: getNextWrappingIndex(10, state.highlightedIndex, props.items.length, action.getItemNodeFromIndex, false)
      };
      break;
    case InputKeyDownHome:
      changes = {
        highlightedIndex: getNextNonDisabledIndex(1, 0, props.items.length, action.getItemNodeFromIndex, false)
      };
      break;
    case InputKeyDownEnd:
      changes = {
        highlightedIndex: getNextNonDisabledIndex(-1, props.items.length - 1, props.items.length, action.getItemNodeFromIndex, false)
      };
      break;
    case InputBlur:
      changes = _extends({
        isOpen: false,
        highlightedIndex: -1
      }, state.highlightedIndex >= 0 && ((_props$items = props.items) == null ? void 0 : _props$items.length) && action.selectItem && {
        selectedItem: props.items[state.highlightedIndex],
        inputValue: props.itemToString(props.items[state.highlightedIndex])
      });
      break;
    case InputChange:
      changes = {
        isOpen: true,
        highlightedIndex: getDefaultValue$1(props, "highlightedIndex"),
        inputValue: action.inputValue
      };
      break;
    case InputFocus:
      changes = {
        isOpen: true,
        highlightedIndex: getHighlightedIndexOnOpen(props, state, 0)
      };
      break;
    case FunctionSelectItem:
      changes = {
        selectedItem: action.selectedItem,
        inputValue: props.itemToString(action.selectedItem)
      };
      break;
    case ControlledPropUpdatedSelectedItem:
      changes = {
        inputValue: action.inputValue
      };
      break;
    default:
      return downshiftCommonReducer(state, action, stateChangeTypes$1);
  }
  return _extends({}, state, changes);
}
var _excluded$1 = ["onMouseLeave", "refKey", "ref"];
var _excluded2$1 = ["item", "index", "refKey", "ref", "onMouseMove", "onMouseDown", "onClick", "onPress", "disabled"];
var _excluded3 = ["onClick", "onPress", "refKey", "ref"];
var _excluded4 = ["onKeyDown", "onChange", "onInput", "onFocus", "onBlur", "onChangeText", "refKey", "ref"];
useCombobox.stateChangeTypes = stateChangeTypes$1;
function useCombobox(userProps) {
  if (userProps === void 0) {
    userProps = {};
  }
  validatePropTypes$1(userProps, useCombobox);
  var props = _extends({}, defaultProps$1, userProps);
  var initialIsOpen = props.initialIsOpen, defaultIsOpen = props.defaultIsOpen, items = props.items, scrollIntoView2 = props.scrollIntoView, environment = props.environment, getA11yStatusMessage2 = props.getA11yStatusMessage, getA11ySelectionMessage2 = props.getA11ySelectionMessage, itemToString2 = props.itemToString;
  var initialState2 = getInitialState$1(props);
  var _useControlledReducer = useControlledReducer(downshiftUseComboboxReducer, initialState2, props), state = _useControlledReducer[0], dispatch = _useControlledReducer[1];
  var isOpen = state.isOpen, highlightedIndex = state.highlightedIndex, selectedItem = state.selectedItem, inputValue = state.inputValue;
  var menuRef = (0, import_react31.useRef)(null);
  var itemRefs = (0, import_react31.useRef)({});
  var inputRef = (0, import_react31.useRef)(null);
  var toggleButtonRef = (0, import_react31.useRef)(null);
  var isInitialMountRef = (0, import_react31.useRef)(true);
  var elementIds = useElementIds(props);
  var previousResultCountRef = (0, import_react31.useRef)();
  var latest = useLatestRef2({
    state,
    props
  });
  var getItemNodeFromIndex = (0, import_react31.useCallback)(function(index3) {
    return itemRefs.current[elementIds.getItemId(index3)];
  }, [elementIds]);
  useA11yMessageSetter(getA11yStatusMessage2, [isOpen, highlightedIndex, inputValue, items], _extends({
    isInitialMount: isInitialMountRef.current,
    previousResultCount: previousResultCountRef.current,
    items,
    environment,
    itemToString: itemToString2
  }, state));
  useA11yMessageSetter(getA11ySelectionMessage2, [selectedItem], _extends({
    isInitialMount: isInitialMountRef.current,
    previousResultCount: previousResultCountRef.current,
    items,
    environment,
    itemToString: itemToString2
  }, state));
  var shouldScrollRef = useScrollIntoView({
    menuElement: menuRef.current,
    highlightedIndex,
    isOpen,
    itemRefs,
    scrollIntoView: scrollIntoView2,
    getItemNodeFromIndex
  });
  useControlPropsValidator({
    isInitialMount: isInitialMountRef.current,
    props,
    state
  });
  (0, import_react31.useEffect)(function() {
    var focusOnOpen = initialIsOpen || defaultIsOpen || isOpen;
    if (focusOnOpen && inputRef.current) {
      inputRef.current.focus();
    }
  }, []);
  (0, import_react31.useEffect)(function() {
    if (isInitialMountRef.current) {
      return;
    }
    previousResultCountRef.current = items.length;
  });
  var mouseAndTouchTrackersRef = useMouseAndTouchTracker(isOpen, [inputRef, menuRef, toggleButtonRef], environment, function() {
    dispatch({
      type: InputBlur,
      selectItem: false
    });
  });
  var setGetterPropCallInfo = useGetterPropsCalledChecker("getInputProps", "getMenuProps");
  (0, import_react31.useEffect)(function() {
    isInitialMountRef.current = false;
    return function() {
      isInitialMountRef.current = true;
    };
  }, []);
  (0, import_react31.useEffect)(function() {
    var _environment$document;
    if (!isOpen) {
      itemRefs.current = {};
    } else if (((_environment$document = environment.document) == null ? void 0 : _environment$document.activeElement) !== inputRef.current) {
      var _inputRef$current;
      inputRef == null || (_inputRef$current = inputRef.current) == null ? void 0 : _inputRef$current.focus();
    }
  }, [isOpen, environment]);
  var inputKeyDownHandlers = (0, import_react31.useMemo)(function() {
    return {
      ArrowDown: function ArrowDown(event) {
        event.preventDefault();
        dispatch({
          type: InputKeyDownArrowDown,
          altKey: event.altKey,
          getItemNodeFromIndex
        });
      },
      ArrowUp: function ArrowUp(event) {
        event.preventDefault();
        dispatch({
          type: InputKeyDownArrowUp,
          altKey: event.altKey,
          getItemNodeFromIndex
        });
      },
      Home: function Home(event) {
        if (!latest.current.state.isOpen) {
          return;
        }
        event.preventDefault();
        dispatch({
          type: InputKeyDownHome,
          getItemNodeFromIndex
        });
      },
      End: function End(event) {
        if (!latest.current.state.isOpen) {
          return;
        }
        event.preventDefault();
        dispatch({
          type: InputKeyDownEnd,
          getItemNodeFromIndex
        });
      },
      Escape: function Escape(event) {
        var latestState = latest.current.state;
        if (latestState.isOpen || latestState.inputValue || latestState.selectedItem || latestState.highlightedIndex > -1) {
          event.preventDefault();
          dispatch({
            type: InputKeyDownEscape
          });
        }
      },
      Enter: function Enter(event) {
        var latestState = latest.current.state;
        if (!latestState.isOpen || event.which === 229) {
          return;
        }
        event.preventDefault();
        dispatch({
          type: InputKeyDownEnter,
          getItemNodeFromIndex
        });
      },
      PageUp: function PageUp(event) {
        if (latest.current.state.isOpen) {
          event.preventDefault();
          dispatch({
            type: InputKeyDownPageUp,
            getItemNodeFromIndex
          });
        }
      },
      PageDown: function PageDown(event) {
        if (latest.current.state.isOpen) {
          event.preventDefault();
          dispatch({
            type: InputKeyDownPageDown,
            getItemNodeFromIndex
          });
        }
      }
    };
  }, [dispatch, latest, getItemNodeFromIndex]);
  var getLabelProps = (0, import_react31.useCallback)(function(labelProps) {
    return _extends({
      id: elementIds.labelId,
      htmlFor: elementIds.inputId
    }, labelProps);
  }, [elementIds]);
  var getMenuProps = (0, import_react31.useCallback)(function(_temp, _temp2) {
    var _extends2;
    var _ref = _temp === void 0 ? {} : _temp, onMouseLeave = _ref.onMouseLeave, _ref$refKey = _ref.refKey, refKey = _ref$refKey === void 0 ? "ref" : _ref$refKey, ref2 = _ref.ref, rest = _objectWithoutPropertiesLoose(_ref, _excluded$1);
    var _ref2 = _temp2 === void 0 ? {} : _temp2, _ref2$suppressRefErro = _ref2.suppressRefError, suppressRefError = _ref2$suppressRefErro === void 0 ? false : _ref2$suppressRefErro;
    setGetterPropCallInfo("getMenuProps", suppressRefError, refKey, menuRef);
    return _extends((_extends2 = {}, _extends2[refKey] = handleRefs(ref2, function(menuNode) {
      menuRef.current = menuNode;
    }), _extends2.id = elementIds.menuId, _extends2.role = "listbox", _extends2["aria-labelledby"] = rest && rest["aria-label"] ? void 0 : "" + elementIds.labelId, _extends2.onMouseLeave = callAllEventHandlers(onMouseLeave, function() {
      dispatch({
        type: MenuMouseLeave
      });
    }), _extends2), rest);
  }, [dispatch, setGetterPropCallInfo, elementIds]);
  var getItemProps = (0, import_react31.useCallback)(function(_temp3) {
    var _extends3, _ref4;
    var _ref3 = _temp3 === void 0 ? {} : _temp3, itemProp = _ref3.item, indexProp = _ref3.index, _ref3$refKey = _ref3.refKey, refKey = _ref3$refKey === void 0 ? "ref" : _ref3$refKey, ref2 = _ref3.ref, onMouseMove = _ref3.onMouseMove, onMouseDown = _ref3.onMouseDown, onClick2 = _ref3.onClick;
    _ref3.onPress;
    var disabled = _ref3.disabled, rest = _objectWithoutPropertiesLoose(_ref3, _excluded2$1);
    var _latest$current = latest.current, latestProps = _latest$current.props, latestState = _latest$current.state;
    var _getItemAndIndex = getItemAndIndex(itemProp, indexProp, latestProps.items, "Pass either item or index to getItemProps!"), index3 = _getItemAndIndex[1];
    var onSelectKey = "onClick";
    var customClickHandler = onClick2;
    var itemHandleMouseMove = function itemHandleMouseMove2() {
      if (index3 === latestState.highlightedIndex) {
        return;
      }
      shouldScrollRef.current = false;
      dispatch({
        type: ItemMouseMove,
        index: index3,
        disabled
      });
    };
    var itemHandleClick = function itemHandleClick2() {
      dispatch({
        type: ItemClick,
        index: index3
      });
    };
    var itemHandleMouseDown = function itemHandleMouseDown2(e2) {
      return e2.preventDefault();
    };
    return _extends((_extends3 = {}, _extends3[refKey] = handleRefs(ref2, function(itemNode) {
      if (itemNode) {
        itemRefs.current[elementIds.getItemId(index3)] = itemNode;
      }
    }), _extends3.disabled = disabled, _extends3.role = "option", _extends3["aria-selected"] = "" + (index3 === latestState.highlightedIndex), _extends3.id = elementIds.getItemId(index3), _extends3), !disabled && (_ref4 = {}, _ref4[onSelectKey] = callAllEventHandlers(customClickHandler, itemHandleClick), _ref4), {
      onMouseMove: callAllEventHandlers(onMouseMove, itemHandleMouseMove),
      onMouseDown: callAllEventHandlers(onMouseDown, itemHandleMouseDown)
    }, rest);
  }, [dispatch, latest, shouldScrollRef, elementIds]);
  var getToggleButtonProps = (0, import_react31.useCallback)(function(_temp4) {
    var _extends4;
    var _ref5 = _temp4 === void 0 ? {} : _temp4, onClick2 = _ref5.onClick;
    _ref5.onPress;
    var _ref5$refKey = _ref5.refKey, refKey = _ref5$refKey === void 0 ? "ref" : _ref5$refKey, ref2 = _ref5.ref, rest = _objectWithoutPropertiesLoose(_ref5, _excluded3);
    var latestState = latest.current.state;
    var toggleButtonHandleClick = function toggleButtonHandleClick2() {
      dispatch({
        type: ToggleButtonClick
      });
    };
    return _extends((_extends4 = {}, _extends4[refKey] = handleRefs(ref2, function(toggleButtonNode) {
      toggleButtonRef.current = toggleButtonNode;
    }), _extends4["aria-controls"] = elementIds.menuId, _extends4["aria-expanded"] = latestState.isOpen, _extends4.id = elementIds.toggleButtonId, _extends4.tabIndex = -1, _extends4), !rest.disabled && _extends({}, {
      onClick: callAllEventHandlers(onClick2, toggleButtonHandleClick)
    }), rest);
  }, [dispatch, latest, elementIds]);
  var getInputProps = (0, import_react31.useCallback)(function(_temp5, _temp6) {
    var _extends5;
    var _ref6 = _temp5 === void 0 ? {} : _temp5, onKeyDown2 = _ref6.onKeyDown, onChange = _ref6.onChange, onInput2 = _ref6.onInput, onFocus = _ref6.onFocus, onBlur = _ref6.onBlur;
    _ref6.onChangeText;
    var _ref6$refKey = _ref6.refKey, refKey = _ref6$refKey === void 0 ? "ref" : _ref6$refKey, ref2 = _ref6.ref, rest = _objectWithoutPropertiesLoose(_ref6, _excluded4);
    var _ref7 = _temp6 === void 0 ? {} : _temp6, _ref7$suppressRefErro = _ref7.suppressRefError, suppressRefError = _ref7$suppressRefErro === void 0 ? false : _ref7$suppressRefErro;
    setGetterPropCallInfo("getInputProps", suppressRefError, refKey, inputRef);
    var latestState = latest.current.state;
    var inputHandleKeyDown = function inputHandleKeyDown2(event) {
      var key2 = normalizeArrowKey(event);
      if (key2 && inputKeyDownHandlers[key2]) {
        inputKeyDownHandlers[key2](event);
      }
    };
    var inputHandleChange = function inputHandleChange2(event) {
      dispatch({
        type: InputChange,
        inputValue: event.target.value
      });
    };
    var inputHandleBlur = function inputHandleBlur2(event) {
      if (latestState.isOpen && !mouseAndTouchTrackersRef.current.isMouseDown) {
        var isBlurByTabChange = event.relatedTarget === null && environment.document.activeElement !== environment.document.body;
        dispatch({
          type: InputBlur,
          selectItem: !isBlurByTabChange
        });
      }
    };
    var inputHandleFocus = function inputHandleFocus2() {
      if (!latestState.isOpen) {
        dispatch({
          type: InputFocus
        });
      }
    };
    var onChangeKey = "onChange";
    var eventHandlers = {};
    if (!rest.disabled) {
      var _eventHandlers;
      eventHandlers = (_eventHandlers = {}, _eventHandlers[onChangeKey] = callAllEventHandlers(onChange, onInput2, inputHandleChange), _eventHandlers.onKeyDown = callAllEventHandlers(onKeyDown2, inputHandleKeyDown), _eventHandlers.onBlur = callAllEventHandlers(onBlur, inputHandleBlur), _eventHandlers.onFocus = callAllEventHandlers(onFocus, inputHandleFocus), _eventHandlers);
    }
    return _extends((_extends5 = {}, _extends5[refKey] = handleRefs(ref2, function(inputNode) {
      inputRef.current = inputNode;
    }), _extends5["aria-activedescendant"] = latestState.isOpen && latestState.highlightedIndex > -1 ? elementIds.getItemId(latestState.highlightedIndex) : "", _extends5["aria-autocomplete"] = "list", _extends5["aria-controls"] = elementIds.menuId, _extends5["aria-expanded"] = latestState.isOpen, _extends5["aria-labelledby"] = rest && rest["aria-label"] ? void 0 : "" + elementIds.labelId, _extends5.autoComplete = "off", _extends5.id = elementIds.inputId, _extends5.role = "combobox", _extends5.value = latestState.inputValue, _extends5), eventHandlers, rest);
  }, [setGetterPropCallInfo, latest, elementIds, inputKeyDownHandlers, dispatch, mouseAndTouchTrackersRef, environment]);
  var toggleMenu = (0, import_react31.useCallback)(function() {
    dispatch({
      type: FunctionToggleMenu
    });
  }, [dispatch]);
  var closeMenu = (0, import_react31.useCallback)(function() {
    dispatch({
      type: FunctionCloseMenu
    });
  }, [dispatch]);
  var openMenu = (0, import_react31.useCallback)(function() {
    dispatch({
      type: FunctionOpenMenu
    });
  }, [dispatch]);
  var setHighlightedIndex = (0, import_react31.useCallback)(function(newHighlightedIndex) {
    dispatch({
      type: FunctionSetHighlightedIndex,
      highlightedIndex: newHighlightedIndex
    });
  }, [dispatch]);
  var selectItem2 = (0, import_react31.useCallback)(function(newSelectedItem) {
    dispatch({
      type: FunctionSelectItem,
      selectedItem: newSelectedItem
    });
  }, [dispatch]);
  var setInputValue = (0, import_react31.useCallback)(function(newInputValue) {
    dispatch({
      type: FunctionSetInputValue,
      inputValue: newInputValue
    });
  }, [dispatch]);
  var reset2 = (0, import_react31.useCallback)(function() {
    dispatch({
      type: FunctionReset$1
    });
  }, [dispatch]);
  return {
    // prop getters.
    getItemProps,
    getLabelProps,
    getMenuProps,
    getInputProps,
    getToggleButtonProps,
    // actions.
    toggleMenu,
    openMenu,
    closeMenu,
    setHighlightedIndex,
    setInputValue,
    selectItem: selectItem2,
    reset: reset2,
    // state.
    highlightedIndex,
    isOpen,
    selectedItem,
    inputValue
  };
}
var defaultStateValues = {
  activeIndex: -1,
  selectedItems: []
};
function getInitialValue(props, propKey) {
  return getInitialValue$1(props, propKey, defaultStateValues);
}
function getDefaultValue(props, propKey) {
  return getDefaultValue$1(props, propKey, defaultStateValues);
}
function getInitialState(props) {
  var activeIndex = getInitialValue(props, "activeIndex");
  var selectedItems = getInitialValue(props, "selectedItems");
  return {
    activeIndex,
    selectedItems
  };
}
function isKeyDownOperationPermitted(event) {
  if (event.shiftKey || event.metaKey || event.ctrlKey || event.altKey) {
    return false;
  }
  var element2 = event.target;
  if (element2 instanceof HTMLInputElement && // if element is a text input
  element2.value !== "" && // and we have text in it
  // and cursor is either not at the start or is currently highlighting text.
  (element2.selectionStart !== 0 || element2.selectionEnd !== 0)) {
    return false;
  }
  return true;
}
function getA11yRemovalMessage(selectionParameters) {
  var removedSelectedItem = selectionParameters.removedSelectedItem, itemToStringLocal = selectionParameters.itemToString;
  return itemToStringLocal(removedSelectedItem) + " has been removed.";
}
var propTypes = {
  selectedItems: import_prop_types.default.array,
  initialSelectedItems: import_prop_types.default.array,
  defaultSelectedItems: import_prop_types.default.array,
  itemToString: import_prop_types.default.func,
  getA11yRemovalMessage: import_prop_types.default.func,
  stateReducer: import_prop_types.default.func,
  activeIndex: import_prop_types.default.number,
  initialActiveIndex: import_prop_types.default.number,
  defaultActiveIndex: import_prop_types.default.number,
  onActiveIndexChange: import_prop_types.default.func,
  onSelectedItemsChange: import_prop_types.default.func,
  keyNavigationNext: import_prop_types.default.string,
  keyNavigationPrevious: import_prop_types.default.string,
  environment: import_prop_types.default.shape({
    addEventListener: import_prop_types.default.func,
    removeEventListener: import_prop_types.default.func,
    document: import_prop_types.default.shape({
      getElementById: import_prop_types.default.func,
      activeElement: import_prop_types.default.any,
      body: import_prop_types.default.any
    })
  })
};
var defaultProps = {
  itemToString: defaultProps$3.itemToString,
  stateReducer: defaultProps$3.stateReducer,
  environment: defaultProps$3.environment,
  getA11yRemovalMessage,
  keyNavigationNext: "ArrowRight",
  keyNavigationPrevious: "ArrowLeft"
};
var validatePropTypes = noop2;
if (true) {
  validatePropTypes = function validatePropTypes2(options, caller) {
    import_prop_types.default.checkPropTypes(propTypes, options, "prop", caller.name);
  };
}
var SelectedItemClick = true ? "__selected_item_click__" : 0;
var SelectedItemKeyDownDelete = true ? "__selected_item_keydown_delete__" : 1;
var SelectedItemKeyDownBackspace = true ? "__selected_item_keydown_backspace__" : 2;
var SelectedItemKeyDownNavigationNext = true ? "__selected_item_keydown_navigation_next__" : 3;
var SelectedItemKeyDownNavigationPrevious = true ? "__selected_item_keydown_navigation_previous__" : 4;
var DropdownKeyDownNavigationPrevious = true ? "__dropdown_keydown_navigation_previous__" : 5;
var DropdownKeyDownBackspace = true ? "__dropdown_keydown_backspace__" : 6;
var DropdownClick = true ? "__dropdown_click__" : 7;
var FunctionAddSelectedItem = true ? "__function_add_selected_item__" : 8;
var FunctionRemoveSelectedItem = true ? "__function_remove_selected_item__" : 9;
var FunctionSetSelectedItems = true ? "__function_set_selected_items__" : 10;
var FunctionSetActiveIndex = true ? "__function_set_active_index__" : 11;
var FunctionReset = true ? "__function_reset__" : 12;
var stateChangeTypes = Object.freeze({
  __proto__: null,
  SelectedItemClick,
  SelectedItemKeyDownDelete,
  SelectedItemKeyDownBackspace,
  SelectedItemKeyDownNavigationNext,
  SelectedItemKeyDownNavigationPrevious,
  DropdownKeyDownNavigationPrevious,
  DropdownKeyDownBackspace,
  DropdownClick,
  FunctionAddSelectedItem,
  FunctionRemoveSelectedItem,
  FunctionSetSelectedItems,
  FunctionSetActiveIndex,
  FunctionReset
});
function downshiftMultipleSelectionReducer(state, action) {
  var type2 = action.type, index3 = action.index, props = action.props, selectedItem = action.selectedItem;
  var activeIndex = state.activeIndex, selectedItems = state.selectedItems;
  var changes;
  switch (type2) {
    case SelectedItemClick:
      changes = {
        activeIndex: index3
      };
      break;
    case SelectedItemKeyDownNavigationPrevious:
      changes = {
        activeIndex: activeIndex - 1 < 0 ? 0 : activeIndex - 1
      };
      break;
    case SelectedItemKeyDownNavigationNext:
      changes = {
        activeIndex: activeIndex + 1 >= selectedItems.length ? -1 : activeIndex + 1
      };
      break;
    case SelectedItemKeyDownBackspace:
    case SelectedItemKeyDownDelete: {
      if (activeIndex < 0) {
        break;
      }
      var newActiveIndex = activeIndex;
      if (selectedItems.length === 1) {
        newActiveIndex = -1;
      } else if (activeIndex === selectedItems.length - 1) {
        newActiveIndex = selectedItems.length - 2;
      }
      changes = _extends({
        selectedItems: [].concat(selectedItems.slice(0, activeIndex), selectedItems.slice(activeIndex + 1))
      }, {
        activeIndex: newActiveIndex
      });
      break;
    }
    case DropdownKeyDownNavigationPrevious:
      changes = {
        activeIndex: selectedItems.length - 1
      };
      break;
    case DropdownKeyDownBackspace:
      changes = {
        selectedItems: selectedItems.slice(0, selectedItems.length - 1)
      };
      break;
    case FunctionAddSelectedItem:
      changes = {
        selectedItems: [].concat(selectedItems, [selectedItem])
      };
      break;
    case DropdownClick:
      changes = {
        activeIndex: -1
      };
      break;
    case FunctionRemoveSelectedItem: {
      var _newActiveIndex = activeIndex;
      var selectedItemIndex = selectedItems.indexOf(selectedItem);
      if (selectedItemIndex < 0) {
        break;
      }
      if (selectedItems.length === 1) {
        _newActiveIndex = -1;
      } else if (selectedItemIndex === selectedItems.length - 1) {
        _newActiveIndex = selectedItems.length - 2;
      }
      changes = {
        selectedItems: [].concat(selectedItems.slice(0, selectedItemIndex), selectedItems.slice(selectedItemIndex + 1)),
        activeIndex: _newActiveIndex
      };
      break;
    }
    case FunctionSetSelectedItems: {
      var newSelectedItems = action.selectedItems;
      changes = {
        selectedItems: newSelectedItems
      };
      break;
    }
    case FunctionSetActiveIndex: {
      var _newActiveIndex2 = action.activeIndex;
      changes = {
        activeIndex: _newActiveIndex2
      };
      break;
    }
    case FunctionReset:
      changes = {
        activeIndex: getDefaultValue(props, "activeIndex"),
        selectedItems: getDefaultValue(props, "selectedItems")
      };
      break;
    default:
      throw new Error("Reducer called without proper action type.");
  }
  return _extends({}, state, changes);
}
var _excluded = ["refKey", "ref", "onClick", "onKeyDown", "selectedItem", "index"];
var _excluded2 = ["refKey", "ref", "onKeyDown", "onClick", "preventKeyAction"];
useMultipleSelection.stateChangeTypes = stateChangeTypes;
function useMultipleSelection(userProps) {
  if (userProps === void 0) {
    userProps = {};
  }
  validatePropTypes(userProps, useMultipleSelection);
  var props = _extends({}, defaultProps, userProps);
  var getA11yRemovalMessage2 = props.getA11yRemovalMessage, itemToString2 = props.itemToString, environment = props.environment, keyNavigationNext = props.keyNavigationNext, keyNavigationPrevious = props.keyNavigationPrevious;
  var _useControlledReducer = useControlledReducer$1(downshiftMultipleSelectionReducer, getInitialState(props), props), state = _useControlledReducer[0], dispatch = _useControlledReducer[1];
  var activeIndex = state.activeIndex, selectedItems = state.selectedItems;
  var isInitialMountRef = (0, import_react31.useRef)(true);
  var dropdownRef = (0, import_react31.useRef)(null);
  var previousSelectedItemsRef = (0, import_react31.useRef)(selectedItems);
  var selectedItemRefs = (0, import_react31.useRef)();
  selectedItemRefs.current = [];
  var latest = useLatestRef2({
    state,
    props
  });
  (0, import_react31.useEffect)(function() {
    if (isInitialMountRef.current || false) {
      return;
    }
    if (selectedItems.length < previousSelectedItemsRef.current.length) {
      var removedSelectedItem = previousSelectedItemsRef.current.find(function(item) {
        return selectedItems.indexOf(item) < 0;
      });
      setStatus(getA11yRemovalMessage2({
        itemToString: itemToString2,
        resultCount: selectedItems.length,
        removedSelectedItem,
        activeIndex,
        activeSelectedItem: selectedItems[activeIndex]
      }), environment.document);
    }
    previousSelectedItemsRef.current = selectedItems;
  }, [selectedItems.length]);
  (0, import_react31.useEffect)(function() {
    if (isInitialMountRef.current) {
      return;
    }
    if (activeIndex === -1 && dropdownRef.current) {
      dropdownRef.current.focus();
    } else if (selectedItemRefs.current[activeIndex]) {
      selectedItemRefs.current[activeIndex].focus();
    }
  }, [activeIndex]);
  useControlPropsValidator({
    isInitialMount: isInitialMountRef.current,
    props,
    state
  });
  var setGetterPropCallInfo = useGetterPropsCalledChecker("getDropdownProps");
  (0, import_react31.useEffect)(function() {
    isInitialMountRef.current = false;
    return function() {
      isInitialMountRef.current = true;
    };
  }, []);
  var selectedItemKeyDownHandlers = (0, import_react31.useMemo)(function() {
    var _ref;
    return _ref = {}, _ref[keyNavigationPrevious] = function() {
      dispatch({
        type: SelectedItemKeyDownNavigationPrevious
      });
    }, _ref[keyNavigationNext] = function() {
      dispatch({
        type: SelectedItemKeyDownNavigationNext
      });
    }, _ref.Delete = function Delete() {
      dispatch({
        type: SelectedItemKeyDownDelete
      });
    }, _ref.Backspace = function Backspace() {
      dispatch({
        type: SelectedItemKeyDownBackspace
      });
    }, _ref;
  }, [dispatch, keyNavigationNext, keyNavigationPrevious]);
  var dropdownKeyDownHandlers = (0, import_react31.useMemo)(function() {
    var _ref2;
    return _ref2 = {}, _ref2[keyNavigationPrevious] = function(event) {
      if (isKeyDownOperationPermitted(event)) {
        dispatch({
          type: DropdownKeyDownNavigationPrevious
        });
      }
    }, _ref2.Backspace = function Backspace(event) {
      if (isKeyDownOperationPermitted(event)) {
        dispatch({
          type: DropdownKeyDownBackspace
        });
      }
    }, _ref2;
  }, [dispatch, keyNavigationPrevious]);
  var getSelectedItemProps = (0, import_react31.useCallback)(function(_temp) {
    var _extends2;
    var _ref3 = _temp === void 0 ? {} : _temp, _ref3$refKey = _ref3.refKey, refKey = _ref3$refKey === void 0 ? "ref" : _ref3$refKey, ref2 = _ref3.ref, onClick2 = _ref3.onClick, onKeyDown2 = _ref3.onKeyDown, selectedItemProp = _ref3.selectedItem, indexProp = _ref3.index, rest = _objectWithoutPropertiesLoose(_ref3, _excluded);
    var latestState = latest.current.state;
    var _getItemAndIndex = getItemAndIndex(selectedItemProp, indexProp, latestState.selectedItems, "Pass either item or index to getSelectedItemProps!"), index3 = _getItemAndIndex[1];
    var isFocusable = index3 > -1 && index3 === latestState.activeIndex;
    var selectedItemHandleClick = function selectedItemHandleClick2() {
      dispatch({
        type: SelectedItemClick,
        index: index3
      });
    };
    var selectedItemHandleKeyDown = function selectedItemHandleKeyDown2(event) {
      var key2 = normalizeArrowKey(event);
      if (key2 && selectedItemKeyDownHandlers[key2]) {
        selectedItemKeyDownHandlers[key2](event);
      }
    };
    return _extends((_extends2 = {}, _extends2[refKey] = handleRefs(ref2, function(selectedItemNode) {
      if (selectedItemNode) {
        selectedItemRefs.current.push(selectedItemNode);
      }
    }), _extends2.tabIndex = isFocusable ? 0 : -1, _extends2.onClick = callAllEventHandlers(onClick2, selectedItemHandleClick), _extends2.onKeyDown = callAllEventHandlers(onKeyDown2, selectedItemHandleKeyDown), _extends2), rest);
  }, [dispatch, latest, selectedItemKeyDownHandlers]);
  var getDropdownProps = (0, import_react31.useCallback)(function(_temp2, _temp3) {
    var _extends3;
    var _ref4 = _temp2 === void 0 ? {} : _temp2, _ref4$refKey = _ref4.refKey, refKey = _ref4$refKey === void 0 ? "ref" : _ref4$refKey, ref2 = _ref4.ref, onKeyDown2 = _ref4.onKeyDown, onClick2 = _ref4.onClick, _ref4$preventKeyActio = _ref4.preventKeyAction, preventKeyAction = _ref4$preventKeyActio === void 0 ? false : _ref4$preventKeyActio, rest = _objectWithoutPropertiesLoose(_ref4, _excluded2);
    var _ref5 = _temp3 === void 0 ? {} : _temp3, _ref5$suppressRefErro = _ref5.suppressRefError, suppressRefError = _ref5$suppressRefErro === void 0 ? false : _ref5$suppressRefErro;
    setGetterPropCallInfo("getDropdownProps", suppressRefError, refKey, dropdownRef);
    var dropdownHandleKeyDown = function dropdownHandleKeyDown2(event) {
      var key2 = normalizeArrowKey(event);
      if (key2 && dropdownKeyDownHandlers[key2]) {
        dropdownKeyDownHandlers[key2](event);
      }
    };
    var dropdownHandleClick = function dropdownHandleClick2() {
      dispatch({
        type: DropdownClick
      });
    };
    return _extends((_extends3 = {}, _extends3[refKey] = handleRefs(ref2, function(dropdownNode) {
      if (dropdownNode) {
        dropdownRef.current = dropdownNode;
      }
    }), _extends3), !preventKeyAction && {
      onKeyDown: callAllEventHandlers(onKeyDown2, dropdownHandleKeyDown),
      onClick: callAllEventHandlers(onClick2, dropdownHandleClick)
    }, rest);
  }, [dispatch, dropdownKeyDownHandlers, setGetterPropCallInfo]);
  var addSelectedItem = (0, import_react31.useCallback)(function(selectedItem) {
    dispatch({
      type: FunctionAddSelectedItem,
      selectedItem
    });
  }, [dispatch]);
  var removeSelectedItem = (0, import_react31.useCallback)(function(selectedItem) {
    dispatch({
      type: FunctionRemoveSelectedItem,
      selectedItem
    });
  }, [dispatch]);
  var setSelectedItems = (0, import_react31.useCallback)(function(newSelectedItems) {
    dispatch({
      type: FunctionSetSelectedItems,
      selectedItems: newSelectedItems
    });
  }, [dispatch]);
  var setActiveIndex = (0, import_react31.useCallback)(function(newActiveIndex) {
    dispatch({
      type: FunctionSetActiveIndex,
      activeIndex: newActiveIndex
    });
  }, [dispatch]);
  var reset2 = (0, import_react31.useCallback)(function() {
    dispatch({
      type: FunctionReset
    });
  }, [dispatch]);
  return {
    getSelectedItemProps,
    getDropdownProps,
    addSelectedItem,
    removeSelectedItem,
    setSelectedItems,
    setActiveIndex,
    reset: reset2,
    selectedItems,
    activeIndex
  };
}

// node_modules/@mdxeditor/editor/dist/plugins/core/ui/DownshiftAutoComplete.js
var import_react32 = __toESM(require_react(), 1);
var MAX_SUGGESTIONS = 20;
var DownshiftAutoComplete = (props) => {
  if (props.suggestions.length > 0) {
    return import_react32.default.createElement(DownshiftAutoCompleteWithSuggestions, { ...props });
  } else {
    return import_react32.default.createElement("input", { className: styles.textInput, size: 40, autoFocus: true, ...props.register(props.inputName) });
  }
};
var DownshiftAutoCompleteWithSuggestions = ({
  autofocus,
  suggestions,
  control,
  inputName,
  placeholder: placeholder2,
  initialInputValue,
  setValue
}) => {
  const [items, setItems] = import_react32.default.useState(suggestions.slice(0, MAX_SUGGESTIONS));
  const iconComponentFor = E(iconComponentFor$);
  const enableAutoComplete = suggestions.length > 0;
  const { isOpen, getToggleButtonProps, getMenuProps, getInputProps, highlightedIndex, getItemProps, selectedItem } = useCombobox({
    initialInputValue,
    onInputValueChange({ inputValue = "" }) {
      setValue(inputName, inputValue);
      inputValue = inputValue.toLowerCase() || "";
      const matchingItems = [];
      for (const suggestion of suggestions) {
        if (suggestion.toLowerCase().includes(inputValue)) {
          matchingItems.push(suggestion);
          if (matchingItems.length >= MAX_SUGGESTIONS) {
            break;
          }
        }
      }
      setItems(matchingItems);
    },
    items,
    itemToString(item) {
      return item ?? "";
    }
  });
  const dropdownIsVisible = isOpen && items.length > 0;
  return import_react32.default.createElement("div", { className: styles.downshiftAutocompleteContainer }, import_react32.default.createElement("div", { "data-visible-dropdown": dropdownIsVisible, className: styles.downshiftInputWrapper }, import_react32.default.createElement(
    Controller,
    {
      name: inputName,
      control,
      render: ({ field }) => {
        const downshiftSrcProps = getInputProps();
        return import_react32.default.createElement(
          "input",
          {
            ...downshiftSrcProps,
            name: field.name,
            placeholder: placeholder2,
            className: styles.downshiftInput,
            size: 30,
            "data-editor-dialog": true,
            autoFocus: autofocus
          }
        );
      }
    }
  ), enableAutoComplete && import_react32.default.createElement("button", { "aria-label": "toggle menu", type: "button", ...getToggleButtonProps() }, iconComponentFor("arrow_drop_down"))), import_react32.default.createElement("div", { className: styles.downshiftAutocompleteContainer }, import_react32.default.createElement("ul", { ...getMenuProps(), "data-visible": dropdownIsVisible }, items.map((item, index3) => import_react32.default.createElement(
    "li",
    {
      "data-selected": selectedItem === item,
      "data-highlighted": highlightedIndex === index3,
      key: `${item}${index3}`,
      ...getItemProps({ item, index: index3 })
    },
    item
  )))));
};

// node_modules/@mdxeditor/editor/dist/plugins/image/ImageDialog.js
var ImageDialog = () => {
  const [imageAutocompleteSuggestions, state, editorRootElementRef, imageUploadHandler] = X(
    imageAutocompleteSuggestions$,
    imageDialogState$,
    editorRootElementRef$,
    imageUploadHandler$
  );
  const saveImage = A(saveImage$);
  const closeImageDialog = A(closeImageDialog$);
  const t3 = useTranslation();
  const { register, handleSubmit, control, setValue, reset: reset2 } = useForm({
    // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment
    values: state.type === "editing" ? state.initialValues : {}
  });
  return import_react33.default.createElement(
    Root5,
    {
      open: state.type !== "inactive",
      onOpenChange: (open) => {
        if (!open) {
          closeImageDialog();
          reset2({ src: "", title: "", altText: "" });
        }
      }
    },
    import_react33.default.createElement(Portal3, { container: editorRootElementRef == null ? void 0 : editorRootElementRef.current }, import_react33.default.createElement(Overlay, { className: styles.dialogOverlay }), import_react33.default.createElement(
      Content3,
      {
        className: styles.dialogContent,
        onOpenAutoFocus: (e2) => {
          e2.preventDefault();
        }
      },
      import_react33.default.createElement(Title, null, t3("uploadImage.dialogTitle", "Upload an image")),
      import_react33.default.createElement(
        "form",
        {
          onSubmit: (e2) => {
            void handleSubmit(saveImage)(e2);
            reset2({ src: "", title: "", altText: "" });
            e2.preventDefault();
            e2.stopPropagation();
          },
          className: styles.multiFieldForm
        },
        imageUploadHandler === null ? import_react33.default.createElement("input", { type: "hidden", accept: "image/*", ...register("file") }) : import_react33.default.createElement("div", { className: styles.formField }, import_react33.default.createElement("label", { htmlFor: "file" }, t3("uploadImage.uploadInstructions", "Upload an image from your device:")), import_react33.default.createElement("input", { type: "file", accept: "image/*", ...register("file") })),
        import_react33.default.createElement("div", { className: styles.formField }, import_react33.default.createElement("label", { htmlFor: "src" }, imageUploadHandler !== null ? t3("uploadImage.addViaUrlInstructions", "Or add an image from an URL:") : t3("uploadImage.addViaUrlInstructionsNoUpload", "Add an image from an URL:")), import_react33.default.createElement(
          DownshiftAutoComplete,
          {
            register,
            initialInputValue: state.type === "editing" ? state.initialValues.src ?? "" : "",
            inputName: "src",
            suggestions: imageAutocompleteSuggestions,
            setValue,
            control,
            placeholder: t3("uploadImage.autoCompletePlaceholder", "Select or paste an image src")
          }
        )),
        import_react33.default.createElement("div", { className: styles.formField }, import_react33.default.createElement("label", { htmlFor: "alt" }, t3("uploadImage.alt", "Alt:")), import_react33.default.createElement("input", { type: "text", ...register("altText"), className: styles.textInput })),
        import_react33.default.createElement("div", { className: styles.formField }, import_react33.default.createElement("label", { htmlFor: "title" }, t3("uploadImage.title", "Title:")), import_react33.default.createElement("input", { type: "text", ...register("title"), className: styles.textInput })),
        import_react33.default.createElement("div", { style: { display: "flex", justifyContent: "flex-end", gap: "var(--spacing-2)" } }, import_react33.default.createElement(
          "button",
          {
            type: "submit",
            title: t3("dialogControls.save", "Save"),
            "aria-label": t3("dialogControls.save", "Save"),
            className: (0, import_classnames3.default)(styles.primaryButton)
          },
          t3("dialogControls.save", "Save")
        ), import_react33.default.createElement(Close, { asChild: true }, import_react33.default.createElement(
          "button",
          {
            type: "reset",
            title: t3("dialogControls.cancel", "Cancel"),
            "aria-label": t3("dialogControls.cancel", "Cancel"),
            className: (0, import_classnames3.default)(styles.secondaryButton)
          },
          t3("dialogControls.cancel", "Cancel")
        )))
      )
    ))
  );
};

// node_modules/@mdxeditor/editor/dist/plugins/image/ImageNode.js
var import_react36 = __toESM(require_react(), 1);

// node_modules/@mdxeditor/editor/dist/plugins/image/ImageEditor.js
var import_react35 = __toESM(require_react(), 1);
var import_classnames5 = __toESM(require_classnames(), 1);

// node_modules/@mdxeditor/editor/dist/plugins/image/ImageResizer.js
var React40 = __toESM(require_react(), 1);
var import_react34 = __toESM(require_react(), 1);
var import_classnames4 = __toESM(require_classnames(), 1);
function clamp2(value2, min2, max2) {
  return Math.min(Math.max(value2, min2), max2);
}
var Direction2 = {
  east: 1 << 0,
  north: 1 << 3,
  south: 1 << 1,
  west: 1 << 2
};
function ImageResizer({
  onResizeStart,
  onResizeEnd,
  imageRef,
  maxWidth,
  editor
}) {
  const controlWrapperRef = (0, import_react34.useRef)(null);
  const userSelect = (0, import_react34.useRef)({
    priority: "",
    value: "default"
  });
  const positioningRef = (0, import_react34.useRef)({
    currentHeight: 0,
    currentWidth: 0,
    direction: 0,
    isResizing: false,
    ratio: 0,
    startHeight: 0,
    startWidth: 0,
    startX: 0,
    startY: 0
  });
  const editorRootElement = editor.getRootElement();
  const maxWidthContainer = maxWidth ? maxWidth : editorRootElement !== null ? editorRootElement.getBoundingClientRect().width - 20 : 100;
  const maxHeightContainer = editorRootElement !== null ? editorRootElement.getBoundingClientRect().height - 20 : 100;
  const minWidth = 100;
  const minHeight = 100;
  const setStartCursor = (direction) => {
    const ew = direction === Direction2.east || direction === Direction2.west;
    const ns = direction === Direction2.north || direction === Direction2.south;
    const nwse = direction & Direction2.north && direction & Direction2.west || direction & Direction2.south && direction & Direction2.east;
    const cursorDir = ew ? "ew" : ns ? "ns" : nwse ? "nwse" : "nesw";
    if (editorRootElement !== null) {
      editorRootElement.style.setProperty("cursor", `${cursorDir}-resize`, "important");
    }
    if (document.body !== null) {
      document.body.style.setProperty("cursor", `${cursorDir}-resize`, "important");
      userSelect.current.value = document.body.style.getPropertyValue("-webkit-user-select");
      userSelect.current.priority = document.body.style.getPropertyPriority("-webkit-user-select");
      document.body.style.setProperty("-webkit-user-select", `none`, "important");
    }
  };
  const setEndCursor = () => {
    if (editorRootElement !== null) {
      editorRootElement.style.setProperty("cursor", "text");
    }
    if (document.body !== null) {
      document.body.style.setProperty("cursor", "default");
      document.body.style.setProperty("-webkit-user-select", userSelect.current.value, userSelect.current.priority);
    }
  };
  const handlePointerDown2 = (event, direction) => {
    if (!editor.isEditable()) {
      return;
    }
    const image2 = imageRef.current;
    const controlWrapper = controlWrapperRef.current;
    if (image2 !== null && controlWrapper !== null) {
      event.preventDefault();
      const { width, height } = image2.getBoundingClientRect();
      const positioning = positioningRef.current;
      positioning.startWidth = width;
      positioning.startHeight = height;
      positioning.ratio = width / height;
      positioning.currentWidth = width;
      positioning.currentHeight = height;
      positioning.startX = event.clientX;
      positioning.startY = event.clientY;
      positioning.isResizing = true;
      positioning.direction = direction;
      setStartCursor(direction);
      onResizeStart();
      controlWrapper.classList.add(styles.imageControlWrapperResizing);
      image2.style.height = `${height}px`;
      image2.style.width = `${width}px`;
      document.addEventListener("pointermove", handlePointerMove);
      document.addEventListener("pointerup", handlePointerUp);
    }
  };
  const handlePointerMove = (event) => {
    const image2 = imageRef.current;
    const positioning = positioningRef.current;
    const isHorizontal = positioning.direction & (Direction2.east | Direction2.west);
    const isVertical = positioning.direction & (Direction2.south | Direction2.north);
    if (image2 !== null && positioning.isResizing) {
      if (isHorizontal && isVertical) {
        let diff2 = Math.floor(positioning.startX - event.clientX);
        diff2 = positioning.direction & Direction2.east ? -diff2 : diff2;
        const width = clamp2(positioning.startWidth + diff2, minWidth, maxWidthContainer);
        const height = width / positioning.ratio;
        image2.style.width = `${width}px`;
        image2.style.height = `${height}px`;
        positioning.currentHeight = height;
        positioning.currentWidth = width;
      } else if (isVertical) {
        let diff2 = Math.floor(positioning.startY - event.clientY);
        diff2 = positioning.direction & Direction2.south ? -diff2 : diff2;
        const height = clamp2(positioning.startHeight + diff2, minHeight, maxHeightContainer);
        image2.style.height = `${height}px`;
        positioning.currentHeight = height;
      } else {
        let diff2 = Math.floor(positioning.startX - event.clientX);
        diff2 = positioning.direction & Direction2.east ? -diff2 : diff2;
        const width = clamp2(positioning.startWidth + diff2, minWidth, maxWidthContainer);
        image2.style.width = `${width}px`;
        positioning.currentWidth = width;
      }
    }
  };
  const handlePointerUp = () => {
    const image2 = imageRef.current;
    const positioning = positioningRef.current;
    const controlWrapper = controlWrapperRef.current;
    if (image2 !== null && controlWrapper !== null && positioning.isResizing) {
      const width = positioning.currentWidth;
      const height = positioning.currentHeight;
      positioning.startWidth = 0;
      positioning.startHeight = 0;
      positioning.ratio = 0;
      positioning.startX = 0;
      positioning.startY = 0;
      positioning.currentWidth = 0;
      positioning.currentHeight = 0;
      positioning.isResizing = false;
      controlWrapper.classList.remove(styles.imageControlWrapperResizing);
      setEndCursor();
      onResizeEnd(width, height);
      document.removeEventListener("pointermove", handlePointerMove);
      document.removeEventListener("pointerup", handlePointerUp);
    }
  };
  return React40.createElement("div", { ref: controlWrapperRef }, React40.createElement(
    "div",
    {
      className: (0, import_classnames4.default)(styles.imageResizer, styles.imageResizerN),
      onPointerDown: (event) => {
        handlePointerDown2(event, Direction2.north);
      }
    }
  ), React40.createElement(
    "div",
    {
      className: (0, import_classnames4.default)(styles.imageResizer, styles.imageResizerNe),
      onPointerDown: (event) => {
        handlePointerDown2(event, Direction2.north | Direction2.east);
      }
    }
  ), React40.createElement(
    "div",
    {
      className: (0, import_classnames4.default)(styles.imageResizer, styles.imageResizerE),
      onPointerDown: (event) => {
        handlePointerDown2(event, Direction2.east);
      }
    }
  ), React40.createElement(
    "div",
    {
      className: (0, import_classnames4.default)(styles.imageResizer, styles.imageResizerSe),
      onPointerDown: (event) => {
        handlePointerDown2(event, Direction2.south | Direction2.east);
      }
    }
  ), React40.createElement(
    "div",
    {
      className: (0, import_classnames4.default)(styles.imageResizer, styles.imageResizerS),
      onPointerDown: (event) => {
        handlePointerDown2(event, Direction2.south);
      }
    }
  ), React40.createElement(
    "div",
    {
      className: (0, import_classnames4.default)(styles.imageResizer, styles.imageResizerSw),
      onPointerDown: (event) => {
        handlePointerDown2(event, Direction2.south | Direction2.west);
      }
    }
  ), React40.createElement(
    "div",
    {
      className: (0, import_classnames4.default)(styles.imageResizer, styles.imageResizerW),
      onPointerDown: (event) => {
        handlePointerDown2(event, Direction2.west);
      }
    }
  ), React40.createElement(
    "div",
    {
      className: (0, import_classnames4.default)(styles.imageResizer, styles.imageResizerNw),
      onPointerDown: (event) => {
        handlePointerDown2(event, Direction2.north | Direction2.west);
      }
    }
  ));
}

// node_modules/@mdxeditor/editor/dist/plugins/image/ImageEditor.js
var imageCache = /* @__PURE__ */ new Set();
function useSuspenseImage(src) {
  if (!imageCache.has(src)) {
    throw new Promise((resolve) => {
      const img = new Image();
      img.src = src;
      img.onerror = img.onload = () => {
        imageCache.add(src);
        resolve(null);
      };
    });
  }
}
function LazyImage({
  title,
  alt,
  className,
  imageRef,
  src,
  width,
  height
}) {
  useSuspenseImage(src);
  return import_react35.default.createElement(
    "img",
    {
      className: className ?? void 0,
      alt,
      src,
      title,
      ref: imageRef,
      draggable: "false",
      width,
      height
    }
  );
}
function ImageEditor({ src, title, alt, nodeKey, width, height, rest }) {
  const [disableImageResize, disableImageSettingsButton, imagePreviewHandler, iconComponentFor, readOnly] = X(
    disableImageResize$,
    disableImageSettingsButton$,
    imagePreviewHandler$,
    iconComponentFor$,
    readOnly$
  );
  const openEditImageDialog = A(openEditImageDialog$);
  const imageRef = import_react35.default.useRef(null);
  const buttonRef = import_react35.default.useRef(null);
  const [isSelected, setSelected, clearSelection] = useLexicalNodeSelection(nodeKey);
  const [editor] = useLexicalComposerContext();
  const [selection2, setSelection] = import_react35.default.useState(null);
  const activeEditorRef = import_react35.default.useRef(null);
  const [isResizing, setIsResizing] = import_react35.default.useState(false);
  const [imageSource, setImageSource] = import_react35.default.useState(null);
  const [initialImagePath, setInitialImagePath] = import_react35.default.useState(null);
  const t3 = useTranslation();
  const onDelete = import_react35.default.useCallback(
    (payload) => {
      if (isSelected && $isNodeSelection($getSelection())) {
        const event = payload;
        event.preventDefault();
        const node2 = $getNodeByKey(nodeKey);
        if ($isImageNode(node2)) {
          node2.remove();
        }
      }
      return false;
    },
    [isSelected, nodeKey]
  );
  const onEnter = import_react35.default.useCallback(
    (event) => {
      const latestSelection = $getSelection();
      const buttonElem = buttonRef.current;
      if (isSelected && $isNodeSelection(latestSelection) && latestSelection.getNodes().length === 1) {
        if (buttonElem !== null && buttonElem !== document.activeElement) {
          event.preventDefault();
          buttonElem.focus();
          return true;
        }
      }
      return false;
    },
    [isSelected]
  );
  const onEscape = import_react35.default.useCallback(
    (event) => {
      if (buttonRef.current === event.target) {
        $setSelection(null);
        editor.update(() => {
          setSelected(true);
          const parentRootElement = editor.getRootElement();
          if (parentRootElement !== null) {
            parentRootElement.focus();
          }
        });
        return true;
      }
      return false;
    },
    [editor, setSelected]
  );
  import_react35.default.useEffect(() => {
    if (imagePreviewHandler) {
      const callPreviewHandler = async () => {
        if (!initialImagePath)
          setInitialImagePath(src);
        const updatedSrc = await imagePreviewHandler(src);
        setImageSource(updatedSrc);
      };
      callPreviewHandler().catch((e2) => {
        console.error(e2);
      });
    } else {
      setImageSource(src);
    }
  }, [src, imagePreviewHandler, initialImagePath]);
  import_react35.default.useEffect(() => {
    let isMounted = true;
    const unregister = mergeRegister(
      editor.registerUpdateListener(({ editorState }) => {
        if (isMounted) {
          setSelection(editorState.read(() => $getSelection()));
        }
      }),
      editor.registerCommand(
        SELECTION_CHANGE_COMMAND,
        (_2, activeEditor2) => {
          activeEditorRef.current = activeEditor2;
          return false;
        },
        COMMAND_PRIORITY_LOW
      ),
      editor.registerCommand(
        CLICK_COMMAND,
        (payload) => {
          const event = payload;
          if (isResizing) {
            return true;
          }
          if (event.target === imageRef.current) {
            if (event.shiftKey) {
              setSelected(!isSelected);
            } else {
              clearSelection();
              setSelected(true);
            }
            return true;
          }
          return false;
        },
        COMMAND_PRIORITY_LOW
      ),
      editor.registerCommand(
        DRAGSTART_COMMAND,
        (event) => {
          if (event.target === imageRef.current) {
            event.preventDefault();
            return true;
          }
          return false;
        },
        COMMAND_PRIORITY_LOW
      ),
      editor.registerCommand(KEY_DELETE_COMMAND, onDelete, COMMAND_PRIORITY_LOW),
      editor.registerCommand(KEY_BACKSPACE_COMMAND, onDelete, COMMAND_PRIORITY_LOW),
      editor.registerCommand(KEY_ENTER_COMMAND, onEnter, COMMAND_PRIORITY_LOW),
      editor.registerCommand(KEY_ESCAPE_COMMAND, onEscape, COMMAND_PRIORITY_LOW)
    );
    return () => {
      isMounted = false;
      unregister();
    };
  }, [clearSelection, editor, isResizing, isSelected, nodeKey, onDelete, onEnter, onEscape, setSelected]);
  const onResizeEnd = (nextWidth, nextHeight) => {
    setTimeout(() => {
      setIsResizing(false);
    }, 200);
    editor.update(() => {
      const node2 = $getNodeByKey(nodeKey);
      if ($isImageNode(node2)) {
        node2.setWidthAndHeight(nextWidth, nextHeight);
      }
    });
  };
  const onResizeStart = () => {
    setIsResizing(true);
  };
  const draggable = $isNodeSelection(selection2);
  const isFocused = isSelected;
  const passedClassName = import_react35.default.useMemo(() => {
    if (rest.length === 0) {
      return null;
    }
    const className = rest.find((attr) => attr.type === "mdxJsxAttribute" && (attr.name === "class" || attr.name === "className"));
    if (className) {
      return className.value;
    }
    return null;
  }, [rest]);
  return imageSource !== null ? import_react35.default.createElement(import_react35.default.Suspense, { fallback: null }, import_react35.default.createElement("div", { className: styles.imageWrapper, "data-editor-block-type": "image" }, import_react35.default.createElement("div", { draggable }, import_react35.default.createElement(
    LazyImage,
    {
      width,
      height,
      className: (0, import_classnames5.default)(
        {
          [styles.focusedImage]: isFocused
        },
        passedClassName
      ),
      src: imageSource,
      title: title ?? "",
      alt: alt ?? "",
      imageRef
    }
  )), draggable && isFocused && !disableImageResize && import_react35.default.createElement(ImageResizer, { editor, imageRef, onResizeStart, onResizeEnd }), readOnly || import_react35.default.createElement("div", { className: styles.editImageToolbar }, import_react35.default.createElement(
    "button",
    {
      className: styles.iconButton,
      type: "button",
      title: t3("imageEditor.deleteImage", "Delete image"),
      disabled: readOnly,
      onClick: (e2) => {
        e2.preventDefault();
        editor.update(() => {
          var _a2;
          (_a2 = $getNodeByKey(nodeKey)) == null ? void 0 : _a2.remove();
        });
      }
    },
    iconComponentFor("delete_small")
  ), !disableImageSettingsButton && import_react35.default.createElement(
    "button",
    {
      type: "button",
      className: (0, import_classnames5.default)(styles.iconButton, styles.editImageButton),
      title: t3("imageEditor.editImage", "Edit image"),
      disabled: readOnly,
      onClick: () => {
        openEditImageDialog({
          nodeKey,
          initialValues: {
            src: !initialImagePath ? imageSource : initialImagePath,
            title: title ?? "",
            altText: alt ?? ""
          }
        });
      }
    },
    iconComponentFor("settings")
  )))) : null;
}

// node_modules/@mdxeditor/editor/dist/plugins/image/ImageNode.js
var __defProp3 = Object.defineProperty;
var __defNormalProp3 = (obj, key2, value2) => key2 in obj ? __defProp3(obj, key2, { enumerable: true, configurable: true, writable: true, value: value2 }) : obj[key2] = value2;
var __publicField4 = (obj, key2, value2) => {
  __defNormalProp3(obj, typeof key2 !== "symbol" ? key2 + "" : key2, value2);
  return value2;
};
function convertImageElement(domNode) {
  if (domNode instanceof HTMLImageElement) {
    const { alt: altText, src, title, width, height } = domNode;
    const node2 = $createImageNode({ altText, src, title, width, height });
    return { node: node2 };
  }
  return null;
}
var ImageNode = class _ImageNode extends DecoratorNode {
  /**
   * Constructs a new {@link ImageNode} with the specified image parameters.
   * Use {@link $createImageNode} to construct one.
   */
  constructor(src, altText, title, width, height, rest, key2) {
    super(key2);
    __publicField4(this, "__src");
    __publicField4(this, "__altText");
    __publicField4(this, "__title");
    __publicField4(this, "__width");
    __publicField4(this, "__height");
    __publicField4(this, "__rest");
    this.__src = src;
    this.__title = title;
    this.__altText = altText;
    this.__width = width ? width : "inherit";
    this.__height = height ? height : "inherit";
    this.__rest = rest ?? [];
  }
  /** @internal */
  static getType() {
    return "image";
  }
  /** @internal */
  static clone(node2) {
    return new _ImageNode(node2.__src, node2.__altText, node2.__title, node2.__width, node2.__height, node2.__rest, node2.__key);
  }
  /** @internal */
  static importJSON(serializedNode) {
    const { altText, title, src, width, rest, height } = serializedNode;
    const node2 = $createImageNode({
      altText,
      title,
      src,
      height,
      width,
      rest
    });
    return node2;
  }
  /** @internal */
  exportDOM() {
    const element2 = document.createElement("img");
    element2.setAttribute("src", this.__src);
    element2.setAttribute("alt", this.__altText);
    if (this.__title) {
      element2.setAttribute("title", this.__title);
    }
    if (this.__width) {
      element2.setAttribute("width", this.__width.toString());
    }
    if (this.__height) {
      element2.setAttribute("height", this.__height.toString());
    }
    return { element: element2 };
  }
  /** @internal */
  static importDOM() {
    return {
      img: () => ({
        conversion: convertImageElement,
        priority: 0
      })
    };
  }
  /** @internal */
  exportJSON() {
    return {
      altText: this.getAltText(),
      title: this.getTitle(),
      height: this.__height === "inherit" ? 0 : this.__height,
      width: this.__width === "inherit" ? 0 : this.__width,
      src: this.getSrc(),
      rest: this.__rest,
      type: "image",
      version: 1
    };
  }
  /**
   * Sets the image dimensions
   */
  setWidthAndHeight(width, height) {
    const writable = this.getWritable();
    writable.__width = width;
    writable.__height = height;
  }
  /** @internal */
  createDOM(config) {
    const span = document.createElement("span");
    const theme = config.theme;
    const className = theme.image;
    if (className !== void 0) {
      span.className = className;
    }
    return span;
  }
  /** @internal */
  updateDOM() {
    return false;
  }
  getSrc() {
    return this.__src;
  }
  getAltText() {
    return this.__altText;
  }
  getTitle() {
    return this.__title;
  }
  getHeight() {
    return this.__height;
  }
  getWidth() {
    return this.__width;
  }
  getRest() {
    return this.__rest;
  }
  setTitle(title) {
    this.getWritable().__title = title;
  }
  setSrc(src) {
    this.getWritable().__src = src;
  }
  setAltText(altText) {
    this.getWritable().__altText = altText ?? "";
  }
  /** @internal */
  shouldBeSerializedAsElement() {
    return this.__width !== "inherit" || this.__height !== "inherit" || this.__rest.length > 0;
  }
  /** @internal */
  decorate(_parentEditor) {
    return import_react36.default.createElement(
      ImageEditor,
      {
        src: this.getSrc(),
        title: this.getTitle(),
        nodeKey: this.getKey(),
        width: this.__width,
        height: this.__height,
        alt: this.__altText,
        rest: this.__rest
      }
    );
  }
};
function $createImageNode(params) {
  const { altText, title, src, key: key2, width, height, rest } = params;
  return new ImageNode(src, altText, title, width, height, rest, key2);
}
function $isImageNode(node2) {
  return node2 instanceof ImageNode;
}

// node_modules/@mdxeditor/editor/dist/plugins/image/LexicalImageVisitor.js
var LexicalImageVisitor = {
  testLexicalNode: $isImageNode,
  visitLexicalNode({ mdastParent, lexicalNode, actions }) {
    if (lexicalNode.shouldBeSerializedAsElement()) {
      const img = new Image();
      if (lexicalNode.getHeight() !== "inherit") {
        img.height = lexicalNode.getHeight();
      }
      if (lexicalNode.getWidth() !== "inherit") {
        img.width = lexicalNode.getWidth();
      }
      if (lexicalNode.getAltText()) {
        img.alt = lexicalNode.getAltText();
      }
      if (lexicalNode.getTitle()) {
        img.title = lexicalNode.getTitle();
      }
      for (const attr of lexicalNode.getRest()) {
        if (attr.type === "mdxJsxAttribute") {
          if (typeof attr.value === "string") {
            img.setAttribute(attr.name, attr.value);
          }
        }
      }
      actions.appendToParent(mdastParent, {
        type: "html",
        value: img.outerHTML.replace(/>$/, ` src="${lexicalNode.getSrc()}" />`)
      });
    } else {
      actions.appendToParent(mdastParent, {
        type: "image",
        url: lexicalNode.getSrc(),
        alt: lexicalNode.getAltText(),
        title: lexicalNode.getTitle()
      });
    }
  }
};

// node_modules/@mdxeditor/editor/dist/plugins/image/MdastImageVisitor.js
var MdastImageVisitor = {
  testNode: "image",
  visitNode({ mdastNode, actions }) {
    actions.addAndStepInto(
      $createImageNode({
        src: mdastNode.url,
        altText: mdastNode.alt ?? "",
        title: mdastNode.title ?? ""
      })
    );
  }
};
var MdastHtmlImageVisitor = {
  testNode: (node2) => {
    return node2.type === "html" && node2.value.trim().startsWith("<img");
  },
  visitNode({ mdastNode, lexicalParent }) {
    const wrapper = document.createElement("div");
    wrapper.innerHTML = mdastNode.value;
    const img = wrapper.querySelector("img");
    if (!img) {
      throw new Error("Invalid HTML image");
    }
    const src = img.src;
    const altText = img.alt;
    const title = img.title;
    const width = img.width;
    const height = img.height;
    const image2 = $createImageNode({
      src: src || "",
      altText,
      title,
      width,
      height
    });
    if (lexicalParent.getType() === "root") {
      const paragraph2 = $createParagraphNode();
      paragraph2.append(image2);
      lexicalParent.append(paragraph2);
    } else {
      lexicalParent.append(image2);
    }
  }
};
function getAttributeValue(node2, attributeName) {
  const attribute = node2.attributes.find((a2) => a2.type === "mdxJsxAttribute" && a2.name === attributeName);
  if (!attribute) {
    return void 0;
  }
  return attribute.value;
}
var MdastJsxImageVisitor = {
  testNode: (node2) => {
    return (node2.type === "mdxJsxTextElement" || node2.type === "mdxJsxFlowElement") && node2.name === "img";
  },
  visitNode({ mdastNode, lexicalParent }) {
    const src = getAttributeValue(mdastNode, "src");
    if (!src) {
      return;
    }
    const altText = getAttributeValue(mdastNode, "alt") ?? "";
    const title = getAttributeValue(mdastNode, "title");
    const height = getAttributeValue(mdastNode, "height");
    const width = getAttributeValue(mdastNode, "width");
    const rest = mdastNode.attributes.filter((a2) => {
      return a2.type === "mdxJsxAttribute" && !["src", "alt", "title", "height", "width"].includes(a2.name);
    });
    const image2 = $createImageNode({
      src,
      altText,
      title,
      width: width ? parseInt(width, 10) : void 0,
      height: height ? parseInt(height, 10) : void 0,
      rest
    });
    if (lexicalParent.getType() === "root") {
      const paragraph2 = $createParagraphNode();
      paragraph2.append(image2);
      lexicalParent.append(paragraph2);
    } else {
      lexicalParent.append(image2);
    }
  }
};

// node_modules/@mdxeditor/editor/dist/plugins/image/index.js
var internalInsertImage$ = K((r2) => {
  r2.sub(r2.pipe(internalInsertImage$, tt(activeEditor$)), ([values2, theEditor]) => {
    theEditor == null ? void 0 : theEditor.update(() => {
      const imageNode = $createImageNode({ altText: values2.altText ?? "", src: values2.src, title: values2.title ?? "" });
      $insertNodes([imageNode]);
      if ($isRootOrShadowRoot(imageNode.getParentOrThrow())) {
        $wrapNodeInElement(imageNode, $createParagraphNode).selectEnd();
      }
    });
  });
});
var insertImage$ = K((r2) => {
  r2.sub(r2.pipe(insertImage$, tt(imageUploadHandler$)), ([values2, imageUploadHandler]) => {
    const handler2 = (src) => {
      r2.pub(internalInsertImage$, { ...values2, src });
    };
    if ("file" in values2) {
      imageUploadHandler == null ? void 0 : imageUploadHandler(values2.file).then(handler2).catch((e2) => {
        throw e2;
      });
    } else {
      handler2(values2.src);
    }
  });
});
var imageAutocompleteSuggestions$ = $([]);
var disableImageResize$ = $(false);
var imageUploadHandler$ = $(null);
var imagePreviewHandler$ = $(null);
var imageDialogState$ = $(
  { type: "inactive" },
  (r2) => {
    r2.sub(
      r2.pipe(saveImage$, tt(activeEditor$, imageUploadHandler$, imageDialogState$)),
      ([values2, theEditor, imageUploadHandler, dialogState]) => {
        const handler2 = dialogState.type === "editing" ? (src) => {
          theEditor == null ? void 0 : theEditor.update(() => {
            const { nodeKey } = dialogState;
            const imageNode = $getNodeByKey(nodeKey);
            imageNode.setTitle(values2.title);
            imageNode.setAltText(values2.altText);
            imageNode.setSrc(src);
          });
          r2.pub(imageDialogState$, { type: "inactive" });
        } : (src) => {
          r2.pub(internalInsertImage$, { ...values2, src });
          r2.pub(imageDialogState$, { type: "inactive" });
        };
        if (values2.file.length > 0) {
          imageUploadHandler == null ? void 0 : imageUploadHandler(values2.file.item(0)).then(handler2).catch((e2) => {
            throw e2;
          });
        } else if (values2.src) {
          handler2(values2.src);
        }
      }
    );
    r2.pub(createActiveEditorSubscription$, (editor) => {
      const theUploadHandler = r2.getValue(imageUploadHandler$);
      return mergeRegister(
        editor.registerCommand(
          INSERT_IMAGE_COMMAND,
          (payload) => {
            const imageNode = $createImageNode(payload);
            $insertNodes([imageNode]);
            if ($isRootOrShadowRoot(imageNode.getParentOrThrow())) {
              $wrapNodeInElement(imageNode, $createParagraphNode).selectEnd();
            }
            return true;
          },
          COMMAND_PRIORITY_EDITOR
        ),
        editor.registerCommand(
          DRAGSTART_COMMAND,
          (event) => {
            return onDragStart(event);
          },
          COMMAND_PRIORITY_HIGH
        ),
        editor.registerCommand(
          DRAGOVER_COMMAND,
          (event) => {
            return onDragover(event, !!theUploadHandler);
          },
          COMMAND_PRIORITY_LOW
        ),
        editor.registerCommand(
          DROP_COMMAND,
          (event) => {
            return onDrop(event, editor, r2.getValue(imageUploadHandler$));
          },
          COMMAND_PRIORITY_HIGH
        ),
        editor.registerCommand(
          PASTE_COMMAND,
          (event) => {
            var _a2, _b2;
            if (!theUploadHandler) {
              let fromWeb = Array.from(((_a2 = event.clipboardData) == null ? void 0 : _a2.items) ?? []);
              fromWeb = fromWeb.filter((i3) => i3.type.includes("text"));
              if (!fromWeb.length || fromWeb.length === 0) {
                return true;
              }
              return false;
            }
            const cbPayload = Array.from(((_b2 = event.clipboardData) == null ? void 0 : _b2.items) ?? []);
            const isMixedPayload = cbPayload.some((item) => !item.type.includes("image"));
            if (isMixedPayload)
              return false;
            if (!cbPayload.length || cbPayload.length === 0) {
              return false;
            }
            const imageUploadHandlerValue = r2.getValue(imageUploadHandler$);
            Promise.all(cbPayload.map((file) => imageUploadHandlerValue(file.getAsFile()))).then((urls) => {
              urls.forEach((url) => {
                editor.dispatchCommand(INSERT_IMAGE_COMMAND, {
                  src: url,
                  altText: ""
                });
              });
            }).catch((e2) => {
              throw e2;
            });
            return true;
          },
          COMMAND_PRIORITY_CRITICAL
        )
      );
    });
  }
);
var openNewImageDialog$ = q((r2) => {
  r2.link(r2.pipe(openNewImageDialog$, et({ type: "new" })), imageDialogState$);
});
var openEditImageDialog$ = K((r2) => {
  r2.link(
    r2.pipe(
      openEditImageDialog$,
      _((payload) => ({ type: "editing", ...payload }))
    ),
    imageDialogState$
  );
});
var closeImageDialog$ = q((r2) => {
  r2.link(r2.pipe(closeImageDialog$, et({ type: "inactive" })), imageDialogState$);
});
var disableImageSettingsButton$ = $(false);
var saveImage$ = K();
var imagePlugin = realmPlugin({
  init(realm, params) {
    realm.pubIn({
      [addImportVisitor$]: [MdastImageVisitor, MdastHtmlImageVisitor, MdastJsxImageVisitor],
      [addLexicalNode$]: ImageNode,
      [addExportVisitor$]: LexicalImageVisitor,
      [addComposerChild$]: (params == null ? void 0 : params.ImageDialog) ?? ImageDialog,
      [imageUploadHandler$]: (params == null ? void 0 : params.imageUploadHandler) ?? null,
      [imageAutocompleteSuggestions$]: (params == null ? void 0 : params.imageAutocompleteSuggestions) ?? [],
      [disableImageResize$]: Boolean(params == null ? void 0 : params.disableImageResize),
      [disableImageSettingsButton$]: Boolean(params == null ? void 0 : params.disableImageSettingsButton),
      [imagePreviewHandler$]: (params == null ? void 0 : params.imagePreviewHandler) ?? null
    });
  },
  update(realm, params) {
    realm.pubIn({
      [imageUploadHandler$]: (params == null ? void 0 : params.imageUploadHandler) ?? null,
      [imageAutocompleteSuggestions$]: (params == null ? void 0 : params.imageAutocompleteSuggestions) ?? [],
      [disableImageResize$]: Boolean(params == null ? void 0 : params.disableImageResize),
      [imagePreviewHandler$]: (params == null ? void 0 : params.imagePreviewHandler) ?? null
    });
  }
});
var getDOMSelection2 = (targetWindow) => CAN_USE_DOM7 ? (targetWindow ?? window).getSelection() : null;
var INSERT_IMAGE_COMMAND = createCommand("INSERT_IMAGE_COMMAND");
var TRANSPARENT_IMAGE = "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7";
function onDragStart(event) {
  const node2 = getImageNodeInSelection();
  if (!node2) {
    return false;
  }
  const dataTransfer = event.dataTransfer;
  if (!dataTransfer) {
    return false;
  }
  dataTransfer.setData("text/plain", "_");
  const img = document.createElement("img");
  img.src = TRANSPARENT_IMAGE;
  dataTransfer.setDragImage(img, 0, 0);
  dataTransfer.setData(
    "application/x-lexical-drag",
    JSON.stringify({
      data: {
        altText: node2.__altText,
        title: node2.__title,
        key: node2.getKey(),
        src: node2.__src
      },
      type: "image"
    })
  );
  return true;
}
function onDragover(event, hasUploadHandler) {
  var _a2;
  if (hasUploadHandler) {
    let cbPayload = Array.from(((_a2 = event.dataTransfer) == null ? void 0 : _a2.items) ?? []);
    cbPayload = cbPayload.filter((i3) => i3.type.includes("image"));
    if (cbPayload.length > 0) {
      event.preventDefault();
      return true;
    }
  }
  const node2 = getImageNodeInSelection();
  if (!node2) {
    return false;
  }
  if (!canDropImage(event)) {
    event.preventDefault();
  }
  return true;
}
function onDrop(event, editor, imageUploadHandler) {
  var _a2;
  let cbPayload = Array.from(((_a2 = event.dataTransfer) == null ? void 0 : _a2.items) ?? []);
  cbPayload = cbPayload.filter((i3) => i3.type.includes("image"));
  if (cbPayload.length > 0) {
    if (imageUploadHandler !== null) {
      event.preventDefault();
      Promise.all(cbPayload.map((image2) => imageUploadHandler(image2.getAsFile()))).then((urls) => {
        urls.forEach((url) => {
          editor.dispatchCommand(INSERT_IMAGE_COMMAND, {
            src: url,
            altText: ""
          });
        });
      }).catch((e2) => {
        throw e2;
      });
      return true;
    }
  }
  const node2 = getImageNodeInSelection();
  if (!node2) {
    return false;
  }
  const data2 = getDragImageData(event);
  if (!data2) {
    return false;
  }
  event.preventDefault();
  if (canDropImage(event)) {
    const range = getDragSelection(event);
    node2.remove();
    const rangeSelection = $createRangeSelection();
    if (range !== null && range !== void 0) {
      rangeSelection.applyDOMRange(range);
    }
    $setSelection(rangeSelection);
    editor.dispatchCommand(INSERT_IMAGE_COMMAND, data2);
  }
  return true;
}
function getImageNodeInSelection() {
  const selection2 = $getSelection();
  if (!$isNodeSelection(selection2)) {
    return null;
  }
  const nodes = selection2.getNodes();
  const node2 = nodes[0];
  return $isImageNode(node2) ? node2 : null;
}
function getDragImageData(event) {
  var _a2;
  const dragData = (_a2 = event.dataTransfer) == null ? void 0 : _a2.getData("application/x-lexical-drag");
  if (!dragData) {
    return null;
  }
  const { type: type2, data: data2 } = JSON.parse(dragData);
  if (type2 !== "image") {
    return null;
  }
  return data2;
}
function canDropImage(event) {
  const target = event.target;
  return !!(target && target instanceof HTMLElement && target.parentElement);
}
function getDragSelection(event) {
  let range;
  const target = event.target;
  const targetWindow = target == null ? null : target.nodeType === 9 ? target.defaultView : target.ownerDocument.defaultView;
  const domSelection = getDOMSelection2(targetWindow);
  if (document.caretRangeFromPoint) {
    range = document.caretRangeFromPoint(event.clientX, event.clientY);
  } else if (event.rangeParent && domSelection !== null) {
    domSelection.collapse(event.rangeParent, event.rangeOffset ?? 0);
    range = domSelection.getRangeAt(0);
  } else {
    throw Error(`Cannot get the selection when dragging`);
  }
  return range;
}

// node_modules/fault/index.js
var import_format = __toESM(require_format());
var fault = Object.assign(create(Error), {
  eval: create(EvalError),
  range: create(RangeError),
  reference: create(ReferenceError),
  syntax: create(SyntaxError),
  type: create(TypeError),
  uri: create(URIError)
});
function create(Constructor) {
  FormattedError.displayName = Constructor.displayName || Constructor.name;
  return FormattedError;
  function FormattedError(format, ...values2) {
    const reason = format ? (0, import_format.default)(format, ...values2) : format;
    return new Constructor(reason);
  }
}

// node_modules/micromark-extension-frontmatter/dev/lib/to-matters.js
var own6 = {}.hasOwnProperty;
var markers = { yaml: "-", toml: "+" };
function toMatters(options) {
  const result = [];
  let index3 = -1;
  const presetsOrMatters = Array.isArray(options) ? options : options ? [options] : ["yaml"];
  while (++index3 < presetsOrMatters.length) {
    result[index3] = matter(presetsOrMatters[index3]);
  }
  return result;
}
function matter(option) {
  let result = option;
  if (typeof result === "string") {
    if (!own6.call(markers, result)) {
      throw fault("Missing matter definition for `%s`", result);
    }
    result = { type: result, marker: markers[result] };
  } else if (typeof result !== "object") {
    throw fault("Expected matter to be an object, not `%j`", result);
  }
  if (!own6.call(result, "type")) {
    throw fault("Missing `type` in matter `%j`", result);
  }
  if (!own6.call(result, "fence") && !own6.call(result, "marker")) {
    throw fault("Missing `marker` or `fence` in matter `%j`", result);
  }
  return result;
}

// node_modules/micromark-extension-frontmatter/dev/lib/syntax.js
function frontmatter(options) {
  const matters = toMatters(options);
  const flow3 = {};
  let index3 = -1;
  while (++index3 < matters.length) {
    const matter2 = matters[index3];
    const code3 = fence(matter2, "open").charCodeAt(0);
    const construct = createConstruct(matter2);
    const existing = flow3[code3];
    if (Array.isArray(existing)) {
      existing.push(construct);
    } else {
      flow3[code3] = [construct];
    }
  }
  return { flow: flow3 };
}
function createConstruct(matter2) {
  const anywhere = matter2.anywhere;
  const frontmatterType = (
    /** @type {TokenType} */
    matter2.type
  );
  const fenceType = (
    /** @type {TokenType} */
    frontmatterType + "Fence"
  );
  const sequenceType = (
    /** @type {TokenType} */
    fenceType + "Sequence"
  );
  const valueType = (
    /** @type {TokenType} */
    frontmatterType + "Value"
  );
  const closingFenceConstruct = { tokenize: tokenizeClosingFence, partial: true };
  let buffer;
  let bufferIndex = 0;
  return { tokenize: tokenizeFrontmatter, concrete: true };
  function tokenizeFrontmatter(effects, ok3, nok) {
    const self2 = this;
    return start2;
    function start2(code3) {
      const position2 = self2.now();
      if (
        // Indent not allowed.
        position2.column === 1 && // Normally, only allowed in first line.
        (position2.line === 1 || anywhere)
      ) {
        buffer = fence(matter2, "open");
        bufferIndex = 0;
        if (code3 === buffer.charCodeAt(bufferIndex)) {
          effects.enter(frontmatterType);
          effects.enter(fenceType);
          effects.enter(sequenceType);
          return openSequence(code3);
        }
      }
      return nok(code3);
    }
    function openSequence(code3) {
      if (bufferIndex === buffer.length) {
        effects.exit(sequenceType);
        if (markdownSpace(code3)) {
          effects.enter(types.whitespace);
          return openSequenceWhitespace(code3);
        }
        return openAfter(code3);
      }
      if (code3 === buffer.charCodeAt(bufferIndex++)) {
        effects.consume(code3);
        return openSequence;
      }
      return nok(code3);
    }
    function openSequenceWhitespace(code3) {
      if (markdownSpace(code3)) {
        effects.consume(code3);
        return openSequenceWhitespace;
      }
      effects.exit(types.whitespace);
      return openAfter(code3);
    }
    function openAfter(code3) {
      if (markdownLineEnding(code3)) {
        effects.exit(fenceType);
        effects.enter(types.lineEnding);
        effects.consume(code3);
        effects.exit(types.lineEnding);
        buffer = fence(matter2, "close");
        bufferIndex = 0;
        return effects.attempt(closingFenceConstruct, after, contentStart);
      }
      return nok(code3);
    }
    function contentStart(code3) {
      if (code3 === codes.eof || markdownLineEnding(code3)) {
        return contentEnd(code3);
      }
      effects.enter(valueType);
      return contentInside(code3);
    }
    function contentInside(code3) {
      if (code3 === codes.eof || markdownLineEnding(code3)) {
        effects.exit(valueType);
        return contentEnd(code3);
      }
      effects.consume(code3);
      return contentInside;
    }
    function contentEnd(code3) {
      if (code3 === codes.eof) {
        return nok(code3);
      }
      effects.enter(types.lineEnding);
      effects.consume(code3);
      effects.exit(types.lineEnding);
      return effects.attempt(closingFenceConstruct, after, contentStart);
    }
    function after(code3) {
      effects.exit(frontmatterType);
      return ok3(code3);
    }
  }
  function tokenizeClosingFence(effects, ok3, nok) {
    let bufferIndex2 = 0;
    return closeStart;
    function closeStart(code3) {
      if (code3 === buffer.charCodeAt(bufferIndex2)) {
        effects.enter(fenceType);
        effects.enter(sequenceType);
        return closeSequence(code3);
      }
      return nok(code3);
    }
    function closeSequence(code3) {
      if (bufferIndex2 === buffer.length) {
        effects.exit(sequenceType);
        if (markdownSpace(code3)) {
          effects.enter(types.whitespace);
          return closeSequenceWhitespace(code3);
        }
        return closeAfter(code3);
      }
      if (code3 === buffer.charCodeAt(bufferIndex2++)) {
        effects.consume(code3);
        return closeSequence;
      }
      return nok(code3);
    }
    function closeSequenceWhitespace(code3) {
      if (markdownSpace(code3)) {
        effects.consume(code3);
        return closeSequenceWhitespace;
      }
      effects.exit(types.whitespace);
      return closeAfter(code3);
    }
    function closeAfter(code3) {
      if (code3 === codes.eof || markdownLineEnding(code3)) {
        effects.exit(fenceType);
        return ok3(code3);
      }
      return nok(code3);
    }
  }
}
function fence(matter2, prop2) {
  return matter2.marker ? pick(matter2.marker, prop2).repeat(3) : (
    // @ts-expect-error: They’re mutually exclusive.
    pick(matter2.fence, prop2)
  );
}
function pick(schema2, prop2) {
  return typeof schema2 === "string" ? schema2 : schema2[prop2];
}

// node_modules/mdast-util-frontmatter/node_modules/escape-string-regexp/index.js
function escapeStringRegexp(string3) {
  if (typeof string3 !== "string") {
    throw new TypeError("Expected a string");
  }
  return string3.replace(/[|\\{}()[\]^$+*?.]/g, "\\$&").replace(/-/g, "\\x2d");
}

// node_modules/mdast-util-frontmatter/lib/index.js
function frontmatterFromMarkdown(options) {
  const matters = toMatters(options);
  const enter2 = {};
  const exit4 = {};
  let index3 = -1;
  while (++index3 < matters.length) {
    const matter2 = matters[index3];
    enter2[matter2.type] = opener(matter2);
    exit4[matter2.type] = close;
    exit4[matter2.type + "Value"] = value;
  }
  return { enter: enter2, exit: exit4 };
}
function opener(matter2) {
  return open;
  function open(token) {
    this.enter({ type: matter2.type, value: "" }, token);
    this.buffer();
  }
}
function close(token) {
  const data2 = this.resume();
  const node2 = this.stack[this.stack.length - 1];
  ok("value" in node2);
  this.exit(token);
  node2.value = data2.replace(/^(\r?\n|\r)|(\r?\n|\r)$/g, "");
}
function value(token) {
  this.config.enter.data.call(this, token);
  this.config.exit.data.call(this, token);
}
function frontmatterToMarkdown(options) {
  const unsafe2 = [];
  const handlers = {};
  const matters = toMatters(options);
  let index3 = -1;
  while (++index3 < matters.length) {
    const matter2 = matters[index3];
    handlers[matter2.type] = handler(matter2);
    const open = fence2(matter2, "open");
    unsafe2.push({
      atBreak: true,
      character: open.charAt(0),
      after: escapeStringRegexp(open.charAt(1))
    });
  }
  return { unsafe: unsafe2, handlers };
}
function handler(matter2) {
  const open = fence2(matter2, "open");
  const close2 = fence2(matter2, "close");
  return handle2;
  function handle2(node2) {
    return open + (node2.value ? "\n" + node2.value : "") + "\n" + close2;
  }
}
function fence2(matter2, prop2) {
  return matter2.marker ? pick2(matter2.marker, prop2).repeat(3) : (
    // @ts-expect-error: They’re mutually exclusive.
    pick2(matter2.fence, prop2)
  );
}
function pick2(schema2, prop2) {
  return typeof schema2 === "string" ? schema2 : schema2[prop2];
}

// node_modules/@mdxeditor/editor/dist/plugins/frontmatter/FrontmatterNode.js
var import_react38 = __toESM(require_react(), 1);

// node_modules/@mdxeditor/editor/dist/plugins/frontmatter/FrontmatterEditor.js
var import_classnames6 = __toESM(require_classnames(), 1);

// node_modules/js-yaml/dist/js-yaml.mjs
function isNothing(subject) {
  return typeof subject === "undefined" || subject === null;
}
function isObject2(subject) {
  return typeof subject === "object" && subject !== null;
}
function toArray(sequence) {
  if (Array.isArray(sequence)) return sequence;
  else if (isNothing(sequence)) return [];
  return [sequence];
}
function extend(target, source) {
  var index3, length, key2, sourceKeys;
  if (source) {
    sourceKeys = Object.keys(source);
    for (index3 = 0, length = sourceKeys.length; index3 < length; index3 += 1) {
      key2 = sourceKeys[index3];
      target[key2] = source[key2];
    }
  }
  return target;
}
function repeat(string3, count3) {
  var result = "", cycle;
  for (cycle = 0; cycle < count3; cycle += 1) {
    result += string3;
  }
  return result;
}
function isNegativeZero(number) {
  return number === 0 && Number.NEGATIVE_INFINITY === 1 / number;
}
var isNothing_1 = isNothing;
var isObject_1 = isObject2;
var toArray_1 = toArray;
var repeat_1 = repeat;
var isNegativeZero_1 = isNegativeZero;
var extend_1 = extend;
var common = {
  isNothing: isNothing_1,
  isObject: isObject_1,
  toArray: toArray_1,
  repeat: repeat_1,
  isNegativeZero: isNegativeZero_1,
  extend: extend_1
};
function formatError(exception2, compact2) {
  var where = "", message = exception2.reason || "(unknown reason)";
  if (!exception2.mark) return message;
  if (exception2.mark.name) {
    where += 'in "' + exception2.mark.name + '" ';
  }
  where += "(" + (exception2.mark.line + 1) + ":" + (exception2.mark.column + 1) + ")";
  if (!compact2 && exception2.mark.snippet) {
    where += "\n\n" + exception2.mark.snippet;
  }
  return message + " " + where;
}
function YAMLException$1(reason, mark) {
  Error.call(this);
  this.name = "YAMLException";
  this.reason = reason;
  this.mark = mark;
  this.message = formatError(this, false);
  if (Error.captureStackTrace) {
    Error.captureStackTrace(this, this.constructor);
  } else {
    this.stack = new Error().stack || "";
  }
}
YAMLException$1.prototype = Object.create(Error.prototype);
YAMLException$1.prototype.constructor = YAMLException$1;
YAMLException$1.prototype.toString = function toString2(compact2) {
  return this.name + ": " + formatError(this, compact2);
};
var exception = YAMLException$1;
function getLine(buffer, lineStart, lineEnd, position2, maxLineLength) {
  var head = "";
  var tail = "";
  var maxHalfLength = Math.floor(maxLineLength / 2) - 1;
  if (position2 - lineStart > maxHalfLength) {
    head = " ... ";
    lineStart = position2 - maxHalfLength + head.length;
  }
  if (lineEnd - position2 > maxHalfLength) {
    tail = " ...";
    lineEnd = position2 + maxHalfLength - tail.length;
  }
  return {
    str: head + buffer.slice(lineStart, lineEnd).replace(/\t/g, "→") + tail,
    pos: position2 - lineStart + head.length
    // relative position
  };
}
function padStart(string3, max2) {
  return common.repeat(" ", max2 - string3.length) + string3;
}
function makeSnippet(mark, options) {
  options = Object.create(options || null);
  if (!mark.buffer) return null;
  if (!options.maxLength) options.maxLength = 79;
  if (typeof options.indent !== "number") options.indent = 1;
  if (typeof options.linesBefore !== "number") options.linesBefore = 3;
  if (typeof options.linesAfter !== "number") options.linesAfter = 2;
  var re = /\r?\n|\r|\0/g;
  var lineStarts = [0];
  var lineEnds = [];
  var match;
  var foundLineNo = -1;
  while (match = re.exec(mark.buffer)) {
    lineEnds.push(match.index);
    lineStarts.push(match.index + match[0].length);
    if (mark.position <= match.index && foundLineNo < 0) {
      foundLineNo = lineStarts.length - 2;
    }
  }
  if (foundLineNo < 0) foundLineNo = lineStarts.length - 1;
  var result = "", i3, line;
  var lineNoLength = Math.min(mark.line + options.linesAfter, lineEnds.length).toString().length;
  var maxLineLength = options.maxLength - (options.indent + lineNoLength + 3);
  for (i3 = 1; i3 <= options.linesBefore; i3++) {
    if (foundLineNo - i3 < 0) break;
    line = getLine(
      mark.buffer,
      lineStarts[foundLineNo - i3],
      lineEnds[foundLineNo - i3],
      mark.position - (lineStarts[foundLineNo] - lineStarts[foundLineNo - i3]),
      maxLineLength
    );
    result = common.repeat(" ", options.indent) + padStart((mark.line - i3 + 1).toString(), lineNoLength) + " | " + line.str + "\n" + result;
  }
  line = getLine(mark.buffer, lineStarts[foundLineNo], lineEnds[foundLineNo], mark.position, maxLineLength);
  result += common.repeat(" ", options.indent) + padStart((mark.line + 1).toString(), lineNoLength) + " | " + line.str + "\n";
  result += common.repeat("-", options.indent + lineNoLength + 3 + line.pos) + "^\n";
  for (i3 = 1; i3 <= options.linesAfter; i3++) {
    if (foundLineNo + i3 >= lineEnds.length) break;
    line = getLine(
      mark.buffer,
      lineStarts[foundLineNo + i3],
      lineEnds[foundLineNo + i3],
      mark.position - (lineStarts[foundLineNo] - lineStarts[foundLineNo + i3]),
      maxLineLength
    );
    result += common.repeat(" ", options.indent) + padStart((mark.line + i3 + 1).toString(), lineNoLength) + " | " + line.str + "\n";
  }
  return result.replace(/\n$/, "");
}
var snippet = makeSnippet;
var TYPE_CONSTRUCTOR_OPTIONS = [
  "kind",
  "multi",
  "resolve",
  "construct",
  "instanceOf",
  "predicate",
  "represent",
  "representName",
  "defaultStyle",
  "styleAliases"
];
var YAML_NODE_KINDS = [
  "scalar",
  "sequence",
  "mapping"
];
function compileStyleAliases(map5) {
  var result = {};
  if (map5 !== null) {
    Object.keys(map5).forEach(function(style) {
      map5[style].forEach(function(alias) {
        result[String(alias)] = style;
      });
    });
  }
  return result;
}
function Type$1(tag, options) {
  options = options || {};
  Object.keys(options).forEach(function(name2) {
    if (TYPE_CONSTRUCTOR_OPTIONS.indexOf(name2) === -1) {
      throw new exception('Unknown option "' + name2 + '" is met in definition of "' + tag + '" YAML type.');
    }
  });
  this.options = options;
  this.tag = tag;
  this.kind = options["kind"] || null;
  this.resolve = options["resolve"] || function() {
    return true;
  };
  this.construct = options["construct"] || function(data2) {
    return data2;
  };
  this.instanceOf = options["instanceOf"] || null;
  this.predicate = options["predicate"] || null;
  this.represent = options["represent"] || null;
  this.representName = options["representName"] || null;
  this.defaultStyle = options["defaultStyle"] || null;
  this.multi = options["multi"] || false;
  this.styleAliases = compileStyleAliases(options["styleAliases"] || null);
  if (YAML_NODE_KINDS.indexOf(this.kind) === -1) {
    throw new exception('Unknown kind "' + this.kind + '" is specified for "' + tag + '" YAML type.');
  }
}
var type = Type$1;
function compileList(schema2, name2) {
  var result = [];
  schema2[name2].forEach(function(currentType) {
    var newIndex = result.length;
    result.forEach(function(previousType, previousIndex) {
      if (previousType.tag === currentType.tag && previousType.kind === currentType.kind && previousType.multi === currentType.multi) {
        newIndex = previousIndex;
      }
    });
    result[newIndex] = currentType;
  });
  return result;
}
function compileMap() {
  var result = {
    scalar: {},
    sequence: {},
    mapping: {},
    fallback: {},
    multi: {
      scalar: [],
      sequence: [],
      mapping: [],
      fallback: []
    }
  }, index3, length;
  function collectType(type2) {
    if (type2.multi) {
      result.multi[type2.kind].push(type2);
      result.multi["fallback"].push(type2);
    } else {
      result[type2.kind][type2.tag] = result["fallback"][type2.tag] = type2;
    }
  }
  for (index3 = 0, length = arguments.length; index3 < length; index3 += 1) {
    arguments[index3].forEach(collectType);
  }
  return result;
}
function Schema$1(definition3) {
  return this.extend(definition3);
}
Schema$1.prototype.extend = function extend2(definition3) {
  var implicit = [];
  var explicit = [];
  if (definition3 instanceof type) {
    explicit.push(definition3);
  } else if (Array.isArray(definition3)) {
    explicit = explicit.concat(definition3);
  } else if (definition3 && (Array.isArray(definition3.implicit) || Array.isArray(definition3.explicit))) {
    if (definition3.implicit) implicit = implicit.concat(definition3.implicit);
    if (definition3.explicit) explicit = explicit.concat(definition3.explicit);
  } else {
    throw new exception("Schema.extend argument should be a Type, [ Type ], or a schema definition ({ implicit: [...], explicit: [...] })");
  }
  implicit.forEach(function(type$1) {
    if (!(type$1 instanceof type)) {
      throw new exception("Specified list of YAML types (or a single Type object) contains a non-Type object.");
    }
    if (type$1.loadKind && type$1.loadKind !== "scalar") {
      throw new exception("There is a non-scalar type in the implicit list of a schema. Implicit resolving of such types is not supported.");
    }
    if (type$1.multi) {
      throw new exception("There is a multi type in the implicit list of a schema. Multi tags can only be listed as explicit.");
    }
  });
  explicit.forEach(function(type$1) {
    if (!(type$1 instanceof type)) {
      throw new exception("Specified list of YAML types (or a single Type object) contains a non-Type object.");
    }
  });
  var result = Object.create(Schema$1.prototype);
  result.implicit = (this.implicit || []).concat(implicit);
  result.explicit = (this.explicit || []).concat(explicit);
  result.compiledImplicit = compileList(result, "implicit");
  result.compiledExplicit = compileList(result, "explicit");
  result.compiledTypeMap = compileMap(result.compiledImplicit, result.compiledExplicit);
  return result;
};
var schema = Schema$1;
var str = new type("tag:yaml.org,2002:str", {
  kind: "scalar",
  construct: function(data2) {
    return data2 !== null ? data2 : "";
  }
});
var seq = new type("tag:yaml.org,2002:seq", {
  kind: "sequence",
  construct: function(data2) {
    return data2 !== null ? data2 : [];
  }
});
var map4 = new type("tag:yaml.org,2002:map", {
  kind: "mapping",
  construct: function(data2) {
    return data2 !== null ? data2 : {};
  }
});
var failsafe = new schema({
  explicit: [
    str,
    seq,
    map4
  ]
});
function resolveYamlNull(data2) {
  if (data2 === null) return true;
  var max2 = data2.length;
  return max2 === 1 && data2 === "~" || max2 === 4 && (data2 === "null" || data2 === "Null" || data2 === "NULL");
}
function constructYamlNull() {
  return null;
}
function isNull(object) {
  return object === null;
}
var _null = new type("tag:yaml.org,2002:null", {
  kind: "scalar",
  resolve: resolveYamlNull,
  construct: constructYamlNull,
  predicate: isNull,
  represent: {
    canonical: function() {
      return "~";
    },
    lowercase: function() {
      return "null";
    },
    uppercase: function() {
      return "NULL";
    },
    camelcase: function() {
      return "Null";
    },
    empty: function() {
      return "";
    }
  },
  defaultStyle: "lowercase"
});
function resolveYamlBoolean(data2) {
  if (data2 === null) return false;
  var max2 = data2.length;
  return max2 === 4 && (data2 === "true" || data2 === "True" || data2 === "TRUE") || max2 === 5 && (data2 === "false" || data2 === "False" || data2 === "FALSE");
}
function constructYamlBoolean(data2) {
  return data2 === "true" || data2 === "True" || data2 === "TRUE";
}
function isBoolean2(object) {
  return Object.prototype.toString.call(object) === "[object Boolean]";
}
var bool = new type("tag:yaml.org,2002:bool", {
  kind: "scalar",
  resolve: resolveYamlBoolean,
  construct: constructYamlBoolean,
  predicate: isBoolean2,
  represent: {
    lowercase: function(object) {
      return object ? "true" : "false";
    },
    uppercase: function(object) {
      return object ? "TRUE" : "FALSE";
    },
    camelcase: function(object) {
      return object ? "True" : "False";
    }
  },
  defaultStyle: "lowercase"
});
function isHexCode(c2) {
  return 48 <= c2 && c2 <= 57 || 65 <= c2 && c2 <= 70 || 97 <= c2 && c2 <= 102;
}
function isOctCode(c2) {
  return 48 <= c2 && c2 <= 55;
}
function isDecCode(c2) {
  return 48 <= c2 && c2 <= 57;
}
function resolveYamlInteger(data2) {
  if (data2 === null) return false;
  var max2 = data2.length, index3 = 0, hasDigits = false, ch;
  if (!max2) return false;
  ch = data2[index3];
  if (ch === "-" || ch === "+") {
    ch = data2[++index3];
  }
  if (ch === "0") {
    if (index3 + 1 === max2) return true;
    ch = data2[++index3];
    if (ch === "b") {
      index3++;
      for (; index3 < max2; index3++) {
        ch = data2[index3];
        if (ch === "_") continue;
        if (ch !== "0" && ch !== "1") return false;
        hasDigits = true;
      }
      return hasDigits && ch !== "_";
    }
    if (ch === "x") {
      index3++;
      for (; index3 < max2; index3++) {
        ch = data2[index3];
        if (ch === "_") continue;
        if (!isHexCode(data2.charCodeAt(index3))) return false;
        hasDigits = true;
      }
      return hasDigits && ch !== "_";
    }
    if (ch === "o") {
      index3++;
      for (; index3 < max2; index3++) {
        ch = data2[index3];
        if (ch === "_") continue;
        if (!isOctCode(data2.charCodeAt(index3))) return false;
        hasDigits = true;
      }
      return hasDigits && ch !== "_";
    }
  }
  if (ch === "_") return false;
  for (; index3 < max2; index3++) {
    ch = data2[index3];
    if (ch === "_") continue;
    if (!isDecCode(data2.charCodeAt(index3))) {
      return false;
    }
    hasDigits = true;
  }
  if (!hasDigits || ch === "_") return false;
  return true;
}
function constructYamlInteger(data2) {
  var value2 = data2, sign = 1, ch;
  if (value2.indexOf("_") !== -1) {
    value2 = value2.replace(/_/g, "");
  }
  ch = value2[0];
  if (ch === "-" || ch === "+") {
    if (ch === "-") sign = -1;
    value2 = value2.slice(1);
    ch = value2[0];
  }
  if (value2 === "0") return 0;
  if (ch === "0") {
    if (value2[1] === "b") return sign * parseInt(value2.slice(2), 2);
    if (value2[1] === "x") return sign * parseInt(value2.slice(2), 16);
    if (value2[1] === "o") return sign * parseInt(value2.slice(2), 8);
  }
  return sign * parseInt(value2, 10);
}
function isInteger(object) {
  return Object.prototype.toString.call(object) === "[object Number]" && (object % 1 === 0 && !common.isNegativeZero(object));
}
var int = new type("tag:yaml.org,2002:int", {
  kind: "scalar",
  resolve: resolveYamlInteger,
  construct: constructYamlInteger,
  predicate: isInteger,
  represent: {
    binary: function(obj) {
      return obj >= 0 ? "0b" + obj.toString(2) : "-0b" + obj.toString(2).slice(1);
    },
    octal: function(obj) {
      return obj >= 0 ? "0o" + obj.toString(8) : "-0o" + obj.toString(8).slice(1);
    },
    decimal: function(obj) {
      return obj.toString(10);
    },
    /* eslint-disable max-len */
    hexadecimal: function(obj) {
      return obj >= 0 ? "0x" + obj.toString(16).toUpperCase() : "-0x" + obj.toString(16).toUpperCase().slice(1);
    }
  },
  defaultStyle: "decimal",
  styleAliases: {
    binary: [2, "bin"],
    octal: [8, "oct"],
    decimal: [10, "dec"],
    hexadecimal: [16, "hex"]
  }
});
var YAML_FLOAT_PATTERN = new RegExp(
  // 2.5e4, 2.5 and integers
  "^(?:[-+]?(?:[0-9][0-9_]*)(?:\\.[0-9_]*)?(?:[eE][-+]?[0-9]+)?|\\.[0-9_]+(?:[eE][-+]?[0-9]+)?|[-+]?\\.(?:inf|Inf|INF)|\\.(?:nan|NaN|NAN))$"
);
function resolveYamlFloat(data2) {
  if (data2 === null) return false;
  if (!YAML_FLOAT_PATTERN.test(data2) || // Quick hack to not allow integers end with `_`
  // Probably should update regexp & check speed
  data2[data2.length - 1] === "_") {
    return false;
  }
  return true;
}
function constructYamlFloat(data2) {
  var value2, sign;
  value2 = data2.replace(/_/g, "").toLowerCase();
  sign = value2[0] === "-" ? -1 : 1;
  if ("+-".indexOf(value2[0]) >= 0) {
    value2 = value2.slice(1);
  }
  if (value2 === ".inf") {
    return sign === 1 ? Number.POSITIVE_INFINITY : Number.NEGATIVE_INFINITY;
  } else if (value2 === ".nan") {
    return NaN;
  }
  return sign * parseFloat(value2, 10);
}
var SCIENTIFIC_WITHOUT_DOT = /^[-+]?[0-9]+e/;
function representYamlFloat(object, style) {
  var res;
  if (isNaN(object)) {
    switch (style) {
      case "lowercase":
        return ".nan";
      case "uppercase":
        return ".NAN";
      case "camelcase":
        return ".NaN";
    }
  } else if (Number.POSITIVE_INFINITY === object) {
    switch (style) {
      case "lowercase":
        return ".inf";
      case "uppercase":
        return ".INF";
      case "camelcase":
        return ".Inf";
    }
  } else if (Number.NEGATIVE_INFINITY === object) {
    switch (style) {
      case "lowercase":
        return "-.inf";
      case "uppercase":
        return "-.INF";
      case "camelcase":
        return "-.Inf";
    }
  } else if (common.isNegativeZero(object)) {
    return "-0.0";
  }
  res = object.toString(10);
  return SCIENTIFIC_WITHOUT_DOT.test(res) ? res.replace("e", ".e") : res;
}
function isFloat(object) {
  return Object.prototype.toString.call(object) === "[object Number]" && (object % 1 !== 0 || common.isNegativeZero(object));
}
var float = new type("tag:yaml.org,2002:float", {
  kind: "scalar",
  resolve: resolveYamlFloat,
  construct: constructYamlFloat,
  predicate: isFloat,
  represent: representYamlFloat,
  defaultStyle: "lowercase"
});
var json = failsafe.extend({
  implicit: [
    _null,
    bool,
    int,
    float
  ]
});
var core2 = json;
var YAML_DATE_REGEXP = new RegExp(
  "^([0-9][0-9][0-9][0-9])-([0-9][0-9])-([0-9][0-9])$"
);
var YAML_TIMESTAMP_REGEXP = new RegExp(
  "^([0-9][0-9][0-9][0-9])-([0-9][0-9]?)-([0-9][0-9]?)(?:[Tt]|[ \\t]+)([0-9][0-9]?):([0-9][0-9]):([0-9][0-9])(?:\\.([0-9]*))?(?:[ \\t]*(Z|([-+])([0-9][0-9]?)(?::([0-9][0-9]))?))?$"
);
function resolveYamlTimestamp(data2) {
  if (data2 === null) return false;
  if (YAML_DATE_REGEXP.exec(data2) !== null) return true;
  if (YAML_TIMESTAMP_REGEXP.exec(data2) !== null) return true;
  return false;
}
function constructYamlTimestamp(data2) {
  var match, year, month, day, hour, minute, second, fraction = 0, delta = null, tz_hour, tz_minute, date;
  match = YAML_DATE_REGEXP.exec(data2);
  if (match === null) match = YAML_TIMESTAMP_REGEXP.exec(data2);
  if (match === null) throw new Error("Date resolve error");
  year = +match[1];
  month = +match[2] - 1;
  day = +match[3];
  if (!match[4]) {
    return new Date(Date.UTC(year, month, day));
  }
  hour = +match[4];
  minute = +match[5];
  second = +match[6];
  if (match[7]) {
    fraction = match[7].slice(0, 3);
    while (fraction.length < 3) {
      fraction += "0";
    }
    fraction = +fraction;
  }
  if (match[9]) {
    tz_hour = +match[10];
    tz_minute = +(match[11] || 0);
    delta = (tz_hour * 60 + tz_minute) * 6e4;
    if (match[9] === "-") delta = -delta;
  }
  date = new Date(Date.UTC(year, month, day, hour, minute, second, fraction));
  if (delta) date.setTime(date.getTime() - delta);
  return date;
}
function representYamlTimestamp(object) {
  return object.toISOString();
}
var timestamp = new type("tag:yaml.org,2002:timestamp", {
  kind: "scalar",
  resolve: resolveYamlTimestamp,
  construct: constructYamlTimestamp,
  instanceOf: Date,
  represent: representYamlTimestamp
});
function resolveYamlMerge(data2) {
  return data2 === "<<" || data2 === null;
}
var merge = new type("tag:yaml.org,2002:merge", {
  kind: "scalar",
  resolve: resolveYamlMerge
});
var BASE64_MAP = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=\n\r";
function resolveYamlBinary(data2) {
  if (data2 === null) return false;
  var code3, idx, bitlen = 0, max2 = data2.length, map5 = BASE64_MAP;
  for (idx = 0; idx < max2; idx++) {
    code3 = map5.indexOf(data2.charAt(idx));
    if (code3 > 64) continue;
    if (code3 < 0) return false;
    bitlen += 6;
  }
  return bitlen % 8 === 0;
}
function constructYamlBinary(data2) {
  var idx, tailbits, input = data2.replace(/[\r\n=]/g, ""), max2 = input.length, map5 = BASE64_MAP, bits = 0, result = [];
  for (idx = 0; idx < max2; idx++) {
    if (idx % 4 === 0 && idx) {
      result.push(bits >> 16 & 255);
      result.push(bits >> 8 & 255);
      result.push(bits & 255);
    }
    bits = bits << 6 | map5.indexOf(input.charAt(idx));
  }
  tailbits = max2 % 4 * 6;
  if (tailbits === 0) {
    result.push(bits >> 16 & 255);
    result.push(bits >> 8 & 255);
    result.push(bits & 255);
  } else if (tailbits === 18) {
    result.push(bits >> 10 & 255);
    result.push(bits >> 2 & 255);
  } else if (tailbits === 12) {
    result.push(bits >> 4 & 255);
  }
  return new Uint8Array(result);
}
function representYamlBinary(object) {
  var result = "", bits = 0, idx, tail, max2 = object.length, map5 = BASE64_MAP;
  for (idx = 0; idx < max2; idx++) {
    if (idx % 3 === 0 && idx) {
      result += map5[bits >> 18 & 63];
      result += map5[bits >> 12 & 63];
      result += map5[bits >> 6 & 63];
      result += map5[bits & 63];
    }
    bits = (bits << 8) + object[idx];
  }
  tail = max2 % 3;
  if (tail === 0) {
    result += map5[bits >> 18 & 63];
    result += map5[bits >> 12 & 63];
    result += map5[bits >> 6 & 63];
    result += map5[bits & 63];
  } else if (tail === 2) {
    result += map5[bits >> 10 & 63];
    result += map5[bits >> 4 & 63];
    result += map5[bits << 2 & 63];
    result += map5[64];
  } else if (tail === 1) {
    result += map5[bits >> 2 & 63];
    result += map5[bits << 4 & 63];
    result += map5[64];
    result += map5[64];
  }
  return result;
}
function isBinary(obj) {
  return Object.prototype.toString.call(obj) === "[object Uint8Array]";
}
var binary = new type("tag:yaml.org,2002:binary", {
  kind: "scalar",
  resolve: resolveYamlBinary,
  construct: constructYamlBinary,
  predicate: isBinary,
  represent: representYamlBinary
});
var _hasOwnProperty$3 = Object.prototype.hasOwnProperty;
var _toString$2 = Object.prototype.toString;
function resolveYamlOmap(data2) {
  if (data2 === null) return true;
  var objectKeys = [], index3, length, pair, pairKey, pairHasKey, object = data2;
  for (index3 = 0, length = object.length; index3 < length; index3 += 1) {
    pair = object[index3];
    pairHasKey = false;
    if (_toString$2.call(pair) !== "[object Object]") return false;
    for (pairKey in pair) {
      if (_hasOwnProperty$3.call(pair, pairKey)) {
        if (!pairHasKey) pairHasKey = true;
        else return false;
      }
    }
    if (!pairHasKey) return false;
    if (objectKeys.indexOf(pairKey) === -1) objectKeys.push(pairKey);
    else return false;
  }
  return true;
}
function constructYamlOmap(data2) {
  return data2 !== null ? data2 : [];
}
var omap = new type("tag:yaml.org,2002:omap", {
  kind: "sequence",
  resolve: resolveYamlOmap,
  construct: constructYamlOmap
});
var _toString$1 = Object.prototype.toString;
function resolveYamlPairs(data2) {
  if (data2 === null) return true;
  var index3, length, pair, keys, result, object = data2;
  result = new Array(object.length);
  for (index3 = 0, length = object.length; index3 < length; index3 += 1) {
    pair = object[index3];
    if (_toString$1.call(pair) !== "[object Object]") return false;
    keys = Object.keys(pair);
    if (keys.length !== 1) return false;
    result[index3] = [keys[0], pair[keys[0]]];
  }
  return true;
}
function constructYamlPairs(data2) {
  if (data2 === null) return [];
  var index3, length, pair, keys, result, object = data2;
  result = new Array(object.length);
  for (index3 = 0, length = object.length; index3 < length; index3 += 1) {
    pair = object[index3];
    keys = Object.keys(pair);
    result[index3] = [keys[0], pair[keys[0]]];
  }
  return result;
}
var pairs = new type("tag:yaml.org,2002:pairs", {
  kind: "sequence",
  resolve: resolveYamlPairs,
  construct: constructYamlPairs
});
var _hasOwnProperty$2 = Object.prototype.hasOwnProperty;
function resolveYamlSet(data2) {
  if (data2 === null) return true;
  var key2, object = data2;
  for (key2 in object) {
    if (_hasOwnProperty$2.call(object, key2)) {
      if (object[key2] !== null) return false;
    }
  }
  return true;
}
function constructYamlSet(data2) {
  return data2 !== null ? data2 : {};
}
var set2 = new type("tag:yaml.org,2002:set", {
  kind: "mapping",
  resolve: resolveYamlSet,
  construct: constructYamlSet
});
var _default = core2.extend({
  implicit: [
    timestamp,
    merge
  ],
  explicit: [
    binary,
    omap,
    pairs,
    set2
  ]
});
var _hasOwnProperty$1 = Object.prototype.hasOwnProperty;
var CONTEXT_FLOW_IN = 1;
var CONTEXT_FLOW_OUT = 2;
var CONTEXT_BLOCK_IN = 3;
var CONTEXT_BLOCK_OUT = 4;
var CHOMPING_CLIP = 1;
var CHOMPING_STRIP = 2;
var CHOMPING_KEEP = 3;
var PATTERN_NON_PRINTABLE = /[\x00-\x08\x0B\x0C\x0E-\x1F\x7F-\x84\x86-\x9F\uFFFE\uFFFF]|[\uD800-\uDBFF](?![\uDC00-\uDFFF])|(?:[^\uD800-\uDBFF]|^)[\uDC00-\uDFFF]/;
var PATTERN_NON_ASCII_LINE_BREAKS = /[\x85\u2028\u2029]/;
var PATTERN_FLOW_INDICATORS = /[,\[\]\{\}]/;
var PATTERN_TAG_HANDLE = /^(?:!|!!|![a-z\-]+!)$/i;
var PATTERN_TAG_URI = /^(?:!|[^,\[\]\{\}])(?:%[0-9a-f]{2}|[0-9a-z\-#;\/\?:@&=\+\$,_\.!~\*'\(\)\[\]])*$/i;
function _class(obj) {
  return Object.prototype.toString.call(obj);
}
function is_EOL(c2) {
  return c2 === 10 || c2 === 13;
}
function is_WHITE_SPACE(c2) {
  return c2 === 9 || c2 === 32;
}
function is_WS_OR_EOL(c2) {
  return c2 === 9 || c2 === 32 || c2 === 10 || c2 === 13;
}
function is_FLOW_INDICATOR(c2) {
  return c2 === 44 || c2 === 91 || c2 === 93 || c2 === 123 || c2 === 125;
}
function fromHexCode(c2) {
  var lc;
  if (48 <= c2 && c2 <= 57) {
    return c2 - 48;
  }
  lc = c2 | 32;
  if (97 <= lc && lc <= 102) {
    return lc - 97 + 10;
  }
  return -1;
}
function escapedHexLen(c2) {
  if (c2 === 120) {
    return 2;
  }
  if (c2 === 117) {
    return 4;
  }
  if (c2 === 85) {
    return 8;
  }
  return 0;
}
function fromDecimalCode(c2) {
  if (48 <= c2 && c2 <= 57) {
    return c2 - 48;
  }
  return -1;
}
function simpleEscapeSequence(c2) {
  return c2 === 48 ? "\0" : c2 === 97 ? "\x07" : c2 === 98 ? "\b" : c2 === 116 ? "	" : c2 === 9 ? "	" : c2 === 110 ? "\n" : c2 === 118 ? "\v" : c2 === 102 ? "\f" : c2 === 114 ? "\r" : c2 === 101 ? "\x1B" : c2 === 32 ? " " : c2 === 34 ? '"' : c2 === 47 ? "/" : c2 === 92 ? "\\" : c2 === 78 ? "" : c2 === 95 ? " " : c2 === 76 ? "\u2028" : c2 === 80 ? "\u2029" : "";
}
function charFromCodepoint(c2) {
  if (c2 <= 65535) {
    return String.fromCharCode(c2);
  }
  return String.fromCharCode(
    (c2 - 65536 >> 10) + 55296,
    (c2 - 65536 & 1023) + 56320
  );
}
var simpleEscapeCheck = new Array(256);
var simpleEscapeMap = new Array(256);
for (i3 = 0; i3 < 256; i3++) {
  simpleEscapeCheck[i3] = simpleEscapeSequence(i3) ? 1 : 0;
  simpleEscapeMap[i3] = simpleEscapeSequence(i3);
}
var i3;
function State$1(input, options) {
  this.input = input;
  this.filename = options["filename"] || null;
  this.schema = options["schema"] || _default;
  this.onWarning = options["onWarning"] || null;
  this.legacy = options["legacy"] || false;
  this.json = options["json"] || false;
  this.listener = options["listener"] || null;
  this.implicitTypes = this.schema.compiledImplicit;
  this.typeMap = this.schema.compiledTypeMap;
  this.length = input.length;
  this.position = 0;
  this.line = 0;
  this.lineStart = 0;
  this.lineIndent = 0;
  this.firstTabInLine = -1;
  this.documents = [];
}
function generateError(state, message) {
  var mark = {
    name: state.filename,
    buffer: state.input.slice(0, -1),
    // omit trailing \0
    position: state.position,
    line: state.line,
    column: state.position - state.lineStart
  };
  mark.snippet = snippet(mark);
  return new exception(message, mark);
}
function throwError(state, message) {
  throw generateError(state, message);
}
function throwWarning(state, message) {
  if (state.onWarning) {
    state.onWarning.call(null, generateError(state, message));
  }
}
var directiveHandlers = {
  YAML: function handleYamlDirective(state, name2, args) {
    var match, major, minor;
    if (state.version !== null) {
      throwError(state, "duplication of %YAML directive");
    }
    if (args.length !== 1) {
      throwError(state, "YAML directive accepts exactly one argument");
    }
    match = /^([0-9]+)\.([0-9]+)$/.exec(args[0]);
    if (match === null) {
      throwError(state, "ill-formed argument of the YAML directive");
    }
    major = parseInt(match[1], 10);
    minor = parseInt(match[2], 10);
    if (major !== 1) {
      throwError(state, "unacceptable YAML version of the document");
    }
    state.version = args[0];
    state.checkLineBreaks = minor < 2;
    if (minor !== 1 && minor !== 2) {
      throwWarning(state, "unsupported YAML version of the document");
    }
  },
  TAG: function handleTagDirective(state, name2, args) {
    var handle2, prefix;
    if (args.length !== 2) {
      throwError(state, "TAG directive accepts exactly two arguments");
    }
    handle2 = args[0];
    prefix = args[1];
    if (!PATTERN_TAG_HANDLE.test(handle2)) {
      throwError(state, "ill-formed tag handle (first argument) of the TAG directive");
    }
    if (_hasOwnProperty$1.call(state.tagMap, handle2)) {
      throwError(state, 'there is a previously declared suffix for "' + handle2 + '" tag handle');
    }
    if (!PATTERN_TAG_URI.test(prefix)) {
      throwError(state, "ill-formed tag prefix (second argument) of the TAG directive");
    }
    try {
      prefix = decodeURIComponent(prefix);
    } catch (err) {
      throwError(state, "tag prefix is malformed: " + prefix);
    }
    state.tagMap[handle2] = prefix;
  }
};
function captureSegment(state, start2, end, checkJson) {
  var _position, _length, _character, _result;
  if (start2 < end) {
    _result = state.input.slice(start2, end);
    if (checkJson) {
      for (_position = 0, _length = _result.length; _position < _length; _position += 1) {
        _character = _result.charCodeAt(_position);
        if (!(_character === 9 || 32 <= _character && _character <= 1114111)) {
          throwError(state, "expected valid JSON character");
        }
      }
    } else if (PATTERN_NON_PRINTABLE.test(_result)) {
      throwError(state, "the stream contains non-printable characters");
    }
    state.result += _result;
  }
}
function mergeMappings(state, destination, source, overridableKeys) {
  var sourceKeys, key2, index3, quantity;
  if (!common.isObject(source)) {
    throwError(state, "cannot merge mappings; the provided source object is unacceptable");
  }
  sourceKeys = Object.keys(source);
  for (index3 = 0, quantity = sourceKeys.length; index3 < quantity; index3 += 1) {
    key2 = sourceKeys[index3];
    if (!_hasOwnProperty$1.call(destination, key2)) {
      destination[key2] = source[key2];
      overridableKeys[key2] = true;
    }
  }
}
function storeMappingPair(state, _result, overridableKeys, keyTag, keyNode, valueNode, startLine, startLineStart, startPos) {
  var index3, quantity;
  if (Array.isArray(keyNode)) {
    keyNode = Array.prototype.slice.call(keyNode);
    for (index3 = 0, quantity = keyNode.length; index3 < quantity; index3 += 1) {
      if (Array.isArray(keyNode[index3])) {
        throwError(state, "nested arrays are not supported inside keys");
      }
      if (typeof keyNode === "object" && _class(keyNode[index3]) === "[object Object]") {
        keyNode[index3] = "[object Object]";
      }
    }
  }
  if (typeof keyNode === "object" && _class(keyNode) === "[object Object]") {
    keyNode = "[object Object]";
  }
  keyNode = String(keyNode);
  if (_result === null) {
    _result = {};
  }
  if (keyTag === "tag:yaml.org,2002:merge") {
    if (Array.isArray(valueNode)) {
      for (index3 = 0, quantity = valueNode.length; index3 < quantity; index3 += 1) {
        mergeMappings(state, _result, valueNode[index3], overridableKeys);
      }
    } else {
      mergeMappings(state, _result, valueNode, overridableKeys);
    }
  } else {
    if (!state.json && !_hasOwnProperty$1.call(overridableKeys, keyNode) && _hasOwnProperty$1.call(_result, keyNode)) {
      state.line = startLine || state.line;
      state.lineStart = startLineStart || state.lineStart;
      state.position = startPos || state.position;
      throwError(state, "duplicated mapping key");
    }
    if (keyNode === "__proto__") {
      Object.defineProperty(_result, keyNode, {
        configurable: true,
        enumerable: true,
        writable: true,
        value: valueNode
      });
    } else {
      _result[keyNode] = valueNode;
    }
    delete overridableKeys[keyNode];
  }
  return _result;
}
function readLineBreak(state) {
  var ch;
  ch = state.input.charCodeAt(state.position);
  if (ch === 10) {
    state.position++;
  } else if (ch === 13) {
    state.position++;
    if (state.input.charCodeAt(state.position) === 10) {
      state.position++;
    }
  } else {
    throwError(state, "a line break is expected");
  }
  state.line += 1;
  state.lineStart = state.position;
  state.firstTabInLine = -1;
}
function skipSeparationSpace(state, allowComments, checkIndent) {
  var lineBreaks = 0, ch = state.input.charCodeAt(state.position);
  while (ch !== 0) {
    while (is_WHITE_SPACE(ch)) {
      if (ch === 9 && state.firstTabInLine === -1) {
        state.firstTabInLine = state.position;
      }
      ch = state.input.charCodeAt(++state.position);
    }
    if (allowComments && ch === 35) {
      do {
        ch = state.input.charCodeAt(++state.position);
      } while (ch !== 10 && ch !== 13 && ch !== 0);
    }
    if (is_EOL(ch)) {
      readLineBreak(state);
      ch = state.input.charCodeAt(state.position);
      lineBreaks++;
      state.lineIndent = 0;
      while (ch === 32) {
        state.lineIndent++;
        ch = state.input.charCodeAt(++state.position);
      }
    } else {
      break;
    }
  }
  if (checkIndent !== -1 && lineBreaks !== 0 && state.lineIndent < checkIndent) {
    throwWarning(state, "deficient indentation");
  }
  return lineBreaks;
}
function testDocumentSeparator(state) {
  var _position = state.position, ch;
  ch = state.input.charCodeAt(_position);
  if ((ch === 45 || ch === 46) && ch === state.input.charCodeAt(_position + 1) && ch === state.input.charCodeAt(_position + 2)) {
    _position += 3;
    ch = state.input.charCodeAt(_position);
    if (ch === 0 || is_WS_OR_EOL(ch)) {
      return true;
    }
  }
  return false;
}
function writeFoldedLines(state, count3) {
  if (count3 === 1) {
    state.result += " ";
  } else if (count3 > 1) {
    state.result += common.repeat("\n", count3 - 1);
  }
}
function readPlainScalar(state, nodeIndent, withinFlowCollection) {
  var preceding, following, captureStart, captureEnd, hasPendingContent, _line, _lineStart, _lineIndent, _kind = state.kind, _result = state.result, ch;
  ch = state.input.charCodeAt(state.position);
  if (is_WS_OR_EOL(ch) || is_FLOW_INDICATOR(ch) || ch === 35 || ch === 38 || ch === 42 || ch === 33 || ch === 124 || ch === 62 || ch === 39 || ch === 34 || ch === 37 || ch === 64 || ch === 96) {
    return false;
  }
  if (ch === 63 || ch === 45) {
    following = state.input.charCodeAt(state.position + 1);
    if (is_WS_OR_EOL(following) || withinFlowCollection && is_FLOW_INDICATOR(following)) {
      return false;
    }
  }
  state.kind = "scalar";
  state.result = "";
  captureStart = captureEnd = state.position;
  hasPendingContent = false;
  while (ch !== 0) {
    if (ch === 58) {
      following = state.input.charCodeAt(state.position + 1);
      if (is_WS_OR_EOL(following) || withinFlowCollection && is_FLOW_INDICATOR(following)) {
        break;
      }
    } else if (ch === 35) {
      preceding = state.input.charCodeAt(state.position - 1);
      if (is_WS_OR_EOL(preceding)) {
        break;
      }
    } else if (state.position === state.lineStart && testDocumentSeparator(state) || withinFlowCollection && is_FLOW_INDICATOR(ch)) {
      break;
    } else if (is_EOL(ch)) {
      _line = state.line;
      _lineStart = state.lineStart;
      _lineIndent = state.lineIndent;
      skipSeparationSpace(state, false, -1);
      if (state.lineIndent >= nodeIndent) {
        hasPendingContent = true;
        ch = state.input.charCodeAt(state.position);
        continue;
      } else {
        state.position = captureEnd;
        state.line = _line;
        state.lineStart = _lineStart;
        state.lineIndent = _lineIndent;
        break;
      }
    }
    if (hasPendingContent) {
      captureSegment(state, captureStart, captureEnd, false);
      writeFoldedLines(state, state.line - _line);
      captureStart = captureEnd = state.position;
      hasPendingContent = false;
    }
    if (!is_WHITE_SPACE(ch)) {
      captureEnd = state.position + 1;
    }
    ch = state.input.charCodeAt(++state.position);
  }
  captureSegment(state, captureStart, captureEnd, false);
  if (state.result) {
    return true;
  }
  state.kind = _kind;
  state.result = _result;
  return false;
}
function readSingleQuotedScalar(state, nodeIndent) {
  var ch, captureStart, captureEnd;
  ch = state.input.charCodeAt(state.position);
  if (ch !== 39) {
    return false;
  }
  state.kind = "scalar";
  state.result = "";
  state.position++;
  captureStart = captureEnd = state.position;
  while ((ch = state.input.charCodeAt(state.position)) !== 0) {
    if (ch === 39) {
      captureSegment(state, captureStart, state.position, true);
      ch = state.input.charCodeAt(++state.position);
      if (ch === 39) {
        captureStart = state.position;
        state.position++;
        captureEnd = state.position;
      } else {
        return true;
      }
    } else if (is_EOL(ch)) {
      captureSegment(state, captureStart, captureEnd, true);
      writeFoldedLines(state, skipSeparationSpace(state, false, nodeIndent));
      captureStart = captureEnd = state.position;
    } else if (state.position === state.lineStart && testDocumentSeparator(state)) {
      throwError(state, "unexpected end of the document within a single quoted scalar");
    } else {
      state.position++;
      captureEnd = state.position;
    }
  }
  throwError(state, "unexpected end of the stream within a single quoted scalar");
}
function readDoubleQuotedScalar(state, nodeIndent) {
  var captureStart, captureEnd, hexLength, hexResult, tmp, ch;
  ch = state.input.charCodeAt(state.position);
  if (ch !== 34) {
    return false;
  }
  state.kind = "scalar";
  state.result = "";
  state.position++;
  captureStart = captureEnd = state.position;
  while ((ch = state.input.charCodeAt(state.position)) !== 0) {
    if (ch === 34) {
      captureSegment(state, captureStart, state.position, true);
      state.position++;
      return true;
    } else if (ch === 92) {
      captureSegment(state, captureStart, state.position, true);
      ch = state.input.charCodeAt(++state.position);
      if (is_EOL(ch)) {
        skipSeparationSpace(state, false, nodeIndent);
      } else if (ch < 256 && simpleEscapeCheck[ch]) {
        state.result += simpleEscapeMap[ch];
        state.position++;
      } else if ((tmp = escapedHexLen(ch)) > 0) {
        hexLength = tmp;
        hexResult = 0;
        for (; hexLength > 0; hexLength--) {
          ch = state.input.charCodeAt(++state.position);
          if ((tmp = fromHexCode(ch)) >= 0) {
            hexResult = (hexResult << 4) + tmp;
          } else {
            throwError(state, "expected hexadecimal character");
          }
        }
        state.result += charFromCodepoint(hexResult);
        state.position++;
      } else {
        throwError(state, "unknown escape sequence");
      }
      captureStart = captureEnd = state.position;
    } else if (is_EOL(ch)) {
      captureSegment(state, captureStart, captureEnd, true);
      writeFoldedLines(state, skipSeparationSpace(state, false, nodeIndent));
      captureStart = captureEnd = state.position;
    } else if (state.position === state.lineStart && testDocumentSeparator(state)) {
      throwError(state, "unexpected end of the document within a double quoted scalar");
    } else {
      state.position++;
      captureEnd = state.position;
    }
  }
  throwError(state, "unexpected end of the stream within a double quoted scalar");
}
function readFlowCollection(state, nodeIndent) {
  var readNext = true, _line, _lineStart, _pos, _tag = state.tag, _result, _anchor = state.anchor, following, terminator, isPair, isExplicitPair, isMapping, overridableKeys = /* @__PURE__ */ Object.create(null), keyNode, keyTag, valueNode, ch;
  ch = state.input.charCodeAt(state.position);
  if (ch === 91) {
    terminator = 93;
    isMapping = false;
    _result = [];
  } else if (ch === 123) {
    terminator = 125;
    isMapping = true;
    _result = {};
  } else {
    return false;
  }
  if (state.anchor !== null) {
    state.anchorMap[state.anchor] = _result;
  }
  ch = state.input.charCodeAt(++state.position);
  while (ch !== 0) {
    skipSeparationSpace(state, true, nodeIndent);
    ch = state.input.charCodeAt(state.position);
    if (ch === terminator) {
      state.position++;
      state.tag = _tag;
      state.anchor = _anchor;
      state.kind = isMapping ? "mapping" : "sequence";
      state.result = _result;
      return true;
    } else if (!readNext) {
      throwError(state, "missed comma between flow collection entries");
    } else if (ch === 44) {
      throwError(state, "expected the node content, but found ','");
    }
    keyTag = keyNode = valueNode = null;
    isPair = isExplicitPair = false;
    if (ch === 63) {
      following = state.input.charCodeAt(state.position + 1);
      if (is_WS_OR_EOL(following)) {
        isPair = isExplicitPair = true;
        state.position++;
        skipSeparationSpace(state, true, nodeIndent);
      }
    }
    _line = state.line;
    _lineStart = state.lineStart;
    _pos = state.position;
    composeNode(state, nodeIndent, CONTEXT_FLOW_IN, false, true);
    keyTag = state.tag;
    keyNode = state.result;
    skipSeparationSpace(state, true, nodeIndent);
    ch = state.input.charCodeAt(state.position);
    if ((isExplicitPair || state.line === _line) && ch === 58) {
      isPair = true;
      ch = state.input.charCodeAt(++state.position);
      skipSeparationSpace(state, true, nodeIndent);
      composeNode(state, nodeIndent, CONTEXT_FLOW_IN, false, true);
      valueNode = state.result;
    }
    if (isMapping) {
      storeMappingPair(state, _result, overridableKeys, keyTag, keyNode, valueNode, _line, _lineStart, _pos);
    } else if (isPair) {
      _result.push(storeMappingPair(state, null, overridableKeys, keyTag, keyNode, valueNode, _line, _lineStart, _pos));
    } else {
      _result.push(keyNode);
    }
    skipSeparationSpace(state, true, nodeIndent);
    ch = state.input.charCodeAt(state.position);
    if (ch === 44) {
      readNext = true;
      ch = state.input.charCodeAt(++state.position);
    } else {
      readNext = false;
    }
  }
  throwError(state, "unexpected end of the stream within a flow collection");
}
function readBlockScalar(state, nodeIndent) {
  var captureStart, folding, chomping = CHOMPING_CLIP, didReadContent = false, detectedIndent = false, textIndent = nodeIndent, emptyLines = 0, atMoreIndented = false, tmp, ch;
  ch = state.input.charCodeAt(state.position);
  if (ch === 124) {
    folding = false;
  } else if (ch === 62) {
    folding = true;
  } else {
    return false;
  }
  state.kind = "scalar";
  state.result = "";
  while (ch !== 0) {
    ch = state.input.charCodeAt(++state.position);
    if (ch === 43 || ch === 45) {
      if (CHOMPING_CLIP === chomping) {
        chomping = ch === 43 ? CHOMPING_KEEP : CHOMPING_STRIP;
      } else {
        throwError(state, "repeat of a chomping mode identifier");
      }
    } else if ((tmp = fromDecimalCode(ch)) >= 0) {
      if (tmp === 0) {
        throwError(state, "bad explicit indentation width of a block scalar; it cannot be less than one");
      } else if (!detectedIndent) {
        textIndent = nodeIndent + tmp - 1;
        detectedIndent = true;
      } else {
        throwError(state, "repeat of an indentation width identifier");
      }
    } else {
      break;
    }
  }
  if (is_WHITE_SPACE(ch)) {
    do {
      ch = state.input.charCodeAt(++state.position);
    } while (is_WHITE_SPACE(ch));
    if (ch === 35) {
      do {
        ch = state.input.charCodeAt(++state.position);
      } while (!is_EOL(ch) && ch !== 0);
    }
  }
  while (ch !== 0) {
    readLineBreak(state);
    state.lineIndent = 0;
    ch = state.input.charCodeAt(state.position);
    while ((!detectedIndent || state.lineIndent < textIndent) && ch === 32) {
      state.lineIndent++;
      ch = state.input.charCodeAt(++state.position);
    }
    if (!detectedIndent && state.lineIndent > textIndent) {
      textIndent = state.lineIndent;
    }
    if (is_EOL(ch)) {
      emptyLines++;
      continue;
    }
    if (state.lineIndent < textIndent) {
      if (chomping === CHOMPING_KEEP) {
        state.result += common.repeat("\n", didReadContent ? 1 + emptyLines : emptyLines);
      } else if (chomping === CHOMPING_CLIP) {
        if (didReadContent) {
          state.result += "\n";
        }
      }
      break;
    }
    if (folding) {
      if (is_WHITE_SPACE(ch)) {
        atMoreIndented = true;
        state.result += common.repeat("\n", didReadContent ? 1 + emptyLines : emptyLines);
      } else if (atMoreIndented) {
        atMoreIndented = false;
        state.result += common.repeat("\n", emptyLines + 1);
      } else if (emptyLines === 0) {
        if (didReadContent) {
          state.result += " ";
        }
      } else {
        state.result += common.repeat("\n", emptyLines);
      }
    } else {
      state.result += common.repeat("\n", didReadContent ? 1 + emptyLines : emptyLines);
    }
    didReadContent = true;
    detectedIndent = true;
    emptyLines = 0;
    captureStart = state.position;
    while (!is_EOL(ch) && ch !== 0) {
      ch = state.input.charCodeAt(++state.position);
    }
    captureSegment(state, captureStart, state.position, false);
  }
  return true;
}
function readBlockSequence(state, nodeIndent) {
  var _line, _tag = state.tag, _anchor = state.anchor, _result = [], following, detected = false, ch;
  if (state.firstTabInLine !== -1) return false;
  if (state.anchor !== null) {
    state.anchorMap[state.anchor] = _result;
  }
  ch = state.input.charCodeAt(state.position);
  while (ch !== 0) {
    if (state.firstTabInLine !== -1) {
      state.position = state.firstTabInLine;
      throwError(state, "tab characters must not be used in indentation");
    }
    if (ch !== 45) {
      break;
    }
    following = state.input.charCodeAt(state.position + 1);
    if (!is_WS_OR_EOL(following)) {
      break;
    }
    detected = true;
    state.position++;
    if (skipSeparationSpace(state, true, -1)) {
      if (state.lineIndent <= nodeIndent) {
        _result.push(null);
        ch = state.input.charCodeAt(state.position);
        continue;
      }
    }
    _line = state.line;
    composeNode(state, nodeIndent, CONTEXT_BLOCK_IN, false, true);
    _result.push(state.result);
    skipSeparationSpace(state, true, -1);
    ch = state.input.charCodeAt(state.position);
    if ((state.line === _line || state.lineIndent > nodeIndent) && ch !== 0) {
      throwError(state, "bad indentation of a sequence entry");
    } else if (state.lineIndent < nodeIndent) {
      break;
    }
  }
  if (detected) {
    state.tag = _tag;
    state.anchor = _anchor;
    state.kind = "sequence";
    state.result = _result;
    return true;
  }
  return false;
}
function readBlockMapping(state, nodeIndent, flowIndent) {
  var following, allowCompact, _line, _keyLine, _keyLineStart, _keyPos, _tag = state.tag, _anchor = state.anchor, _result = {}, overridableKeys = /* @__PURE__ */ Object.create(null), keyTag = null, keyNode = null, valueNode = null, atExplicitKey = false, detected = false, ch;
  if (state.firstTabInLine !== -1) return false;
  if (state.anchor !== null) {
    state.anchorMap[state.anchor] = _result;
  }
  ch = state.input.charCodeAt(state.position);
  while (ch !== 0) {
    if (!atExplicitKey && state.firstTabInLine !== -1) {
      state.position = state.firstTabInLine;
      throwError(state, "tab characters must not be used in indentation");
    }
    following = state.input.charCodeAt(state.position + 1);
    _line = state.line;
    if ((ch === 63 || ch === 58) && is_WS_OR_EOL(following)) {
      if (ch === 63) {
        if (atExplicitKey) {
          storeMappingPair(state, _result, overridableKeys, keyTag, keyNode, null, _keyLine, _keyLineStart, _keyPos);
          keyTag = keyNode = valueNode = null;
        }
        detected = true;
        atExplicitKey = true;
        allowCompact = true;
      } else if (atExplicitKey) {
        atExplicitKey = false;
        allowCompact = true;
      } else {
        throwError(state, "incomplete explicit mapping pair; a key node is missed; or followed by a non-tabulated empty line");
      }
      state.position += 1;
      ch = following;
    } else {
      _keyLine = state.line;
      _keyLineStart = state.lineStart;
      _keyPos = state.position;
      if (!composeNode(state, flowIndent, CONTEXT_FLOW_OUT, false, true)) {
        break;
      }
      if (state.line === _line) {
        ch = state.input.charCodeAt(state.position);
        while (is_WHITE_SPACE(ch)) {
          ch = state.input.charCodeAt(++state.position);
        }
        if (ch === 58) {
          ch = state.input.charCodeAt(++state.position);
          if (!is_WS_OR_EOL(ch)) {
            throwError(state, "a whitespace character is expected after the key-value separator within a block mapping");
          }
          if (atExplicitKey) {
            storeMappingPair(state, _result, overridableKeys, keyTag, keyNode, null, _keyLine, _keyLineStart, _keyPos);
            keyTag = keyNode = valueNode = null;
          }
          detected = true;
          atExplicitKey = false;
          allowCompact = false;
          keyTag = state.tag;
          keyNode = state.result;
        } else if (detected) {
          throwError(state, "can not read an implicit mapping pair; a colon is missed");
        } else {
          state.tag = _tag;
          state.anchor = _anchor;
          return true;
        }
      } else if (detected) {
        throwError(state, "can not read a block mapping entry; a multiline key may not be an implicit key");
      } else {
        state.tag = _tag;
        state.anchor = _anchor;
        return true;
      }
    }
    if (state.line === _line || state.lineIndent > nodeIndent) {
      if (atExplicitKey) {
        _keyLine = state.line;
        _keyLineStart = state.lineStart;
        _keyPos = state.position;
      }
      if (composeNode(state, nodeIndent, CONTEXT_BLOCK_OUT, true, allowCompact)) {
        if (atExplicitKey) {
          keyNode = state.result;
        } else {
          valueNode = state.result;
        }
      }
      if (!atExplicitKey) {
        storeMappingPair(state, _result, overridableKeys, keyTag, keyNode, valueNode, _keyLine, _keyLineStart, _keyPos);
        keyTag = keyNode = valueNode = null;
      }
      skipSeparationSpace(state, true, -1);
      ch = state.input.charCodeAt(state.position);
    }
    if ((state.line === _line || state.lineIndent > nodeIndent) && ch !== 0) {
      throwError(state, "bad indentation of a mapping entry");
    } else if (state.lineIndent < nodeIndent) {
      break;
    }
  }
  if (atExplicitKey) {
    storeMappingPair(state, _result, overridableKeys, keyTag, keyNode, null, _keyLine, _keyLineStart, _keyPos);
  }
  if (detected) {
    state.tag = _tag;
    state.anchor = _anchor;
    state.kind = "mapping";
    state.result = _result;
  }
  return detected;
}
function readTagProperty(state) {
  var _position, isVerbatim = false, isNamed = false, tagHandle, tagName, ch;
  ch = state.input.charCodeAt(state.position);
  if (ch !== 33) return false;
  if (state.tag !== null) {
    throwError(state, "duplication of a tag property");
  }
  ch = state.input.charCodeAt(++state.position);
  if (ch === 60) {
    isVerbatim = true;
    ch = state.input.charCodeAt(++state.position);
  } else if (ch === 33) {
    isNamed = true;
    tagHandle = "!!";
    ch = state.input.charCodeAt(++state.position);
  } else {
    tagHandle = "!";
  }
  _position = state.position;
  if (isVerbatim) {
    do {
      ch = state.input.charCodeAt(++state.position);
    } while (ch !== 0 && ch !== 62);
    if (state.position < state.length) {
      tagName = state.input.slice(_position, state.position);
      ch = state.input.charCodeAt(++state.position);
    } else {
      throwError(state, "unexpected end of the stream within a verbatim tag");
    }
  } else {
    while (ch !== 0 && !is_WS_OR_EOL(ch)) {
      if (ch === 33) {
        if (!isNamed) {
          tagHandle = state.input.slice(_position - 1, state.position + 1);
          if (!PATTERN_TAG_HANDLE.test(tagHandle)) {
            throwError(state, "named tag handle cannot contain such characters");
          }
          isNamed = true;
          _position = state.position + 1;
        } else {
          throwError(state, "tag suffix cannot contain exclamation marks");
        }
      }
      ch = state.input.charCodeAt(++state.position);
    }
    tagName = state.input.slice(_position, state.position);
    if (PATTERN_FLOW_INDICATORS.test(tagName)) {
      throwError(state, "tag suffix cannot contain flow indicator characters");
    }
  }
  if (tagName && !PATTERN_TAG_URI.test(tagName)) {
    throwError(state, "tag name cannot contain such characters: " + tagName);
  }
  try {
    tagName = decodeURIComponent(tagName);
  } catch (err) {
    throwError(state, "tag name is malformed: " + tagName);
  }
  if (isVerbatim) {
    state.tag = tagName;
  } else if (_hasOwnProperty$1.call(state.tagMap, tagHandle)) {
    state.tag = state.tagMap[tagHandle] + tagName;
  } else if (tagHandle === "!") {
    state.tag = "!" + tagName;
  } else if (tagHandle === "!!") {
    state.tag = "tag:yaml.org,2002:" + tagName;
  } else {
    throwError(state, 'undeclared tag handle "' + tagHandle + '"');
  }
  return true;
}
function readAnchorProperty(state) {
  var _position, ch;
  ch = state.input.charCodeAt(state.position);
  if (ch !== 38) return false;
  if (state.anchor !== null) {
    throwError(state, "duplication of an anchor property");
  }
  ch = state.input.charCodeAt(++state.position);
  _position = state.position;
  while (ch !== 0 && !is_WS_OR_EOL(ch) && !is_FLOW_INDICATOR(ch)) {
    ch = state.input.charCodeAt(++state.position);
  }
  if (state.position === _position) {
    throwError(state, "name of an anchor node must contain at least one character");
  }
  state.anchor = state.input.slice(_position, state.position);
  return true;
}
function readAlias(state) {
  var _position, alias, ch;
  ch = state.input.charCodeAt(state.position);
  if (ch !== 42) return false;
  ch = state.input.charCodeAt(++state.position);
  _position = state.position;
  while (ch !== 0 && !is_WS_OR_EOL(ch) && !is_FLOW_INDICATOR(ch)) {
    ch = state.input.charCodeAt(++state.position);
  }
  if (state.position === _position) {
    throwError(state, "name of an alias node must contain at least one character");
  }
  alias = state.input.slice(_position, state.position);
  if (!_hasOwnProperty$1.call(state.anchorMap, alias)) {
    throwError(state, 'unidentified alias "' + alias + '"');
  }
  state.result = state.anchorMap[alias];
  skipSeparationSpace(state, true, -1);
  return true;
}
function composeNode(state, parentIndent, nodeContext, allowToSeek, allowCompact) {
  var allowBlockStyles, allowBlockScalars, allowBlockCollections, indentStatus = 1, atNewLine = false, hasContent = false, typeIndex, typeQuantity, typeList, type2, flowIndent, blockIndent;
  if (state.listener !== null) {
    state.listener("open", state);
  }
  state.tag = null;
  state.anchor = null;
  state.kind = null;
  state.result = null;
  allowBlockStyles = allowBlockScalars = allowBlockCollections = CONTEXT_BLOCK_OUT === nodeContext || CONTEXT_BLOCK_IN === nodeContext;
  if (allowToSeek) {
    if (skipSeparationSpace(state, true, -1)) {
      atNewLine = true;
      if (state.lineIndent > parentIndent) {
        indentStatus = 1;
      } else if (state.lineIndent === parentIndent) {
        indentStatus = 0;
      } else if (state.lineIndent < parentIndent) {
        indentStatus = -1;
      }
    }
  }
  if (indentStatus === 1) {
    while (readTagProperty(state) || readAnchorProperty(state)) {
      if (skipSeparationSpace(state, true, -1)) {
        atNewLine = true;
        allowBlockCollections = allowBlockStyles;
        if (state.lineIndent > parentIndent) {
          indentStatus = 1;
        } else if (state.lineIndent === parentIndent) {
          indentStatus = 0;
        } else if (state.lineIndent < parentIndent) {
          indentStatus = -1;
        }
      } else {
        allowBlockCollections = false;
      }
    }
  }
  if (allowBlockCollections) {
    allowBlockCollections = atNewLine || allowCompact;
  }
  if (indentStatus === 1 || CONTEXT_BLOCK_OUT === nodeContext) {
    if (CONTEXT_FLOW_IN === nodeContext || CONTEXT_FLOW_OUT === nodeContext) {
      flowIndent = parentIndent;
    } else {
      flowIndent = parentIndent + 1;
    }
    blockIndent = state.position - state.lineStart;
    if (indentStatus === 1) {
      if (allowBlockCollections && (readBlockSequence(state, blockIndent) || readBlockMapping(state, blockIndent, flowIndent)) || readFlowCollection(state, flowIndent)) {
        hasContent = true;
      } else {
        if (allowBlockScalars && readBlockScalar(state, flowIndent) || readSingleQuotedScalar(state, flowIndent) || readDoubleQuotedScalar(state, flowIndent)) {
          hasContent = true;
        } else if (readAlias(state)) {
          hasContent = true;
          if (state.tag !== null || state.anchor !== null) {
            throwError(state, "alias node should not have any properties");
          }
        } else if (readPlainScalar(state, flowIndent, CONTEXT_FLOW_IN === nodeContext)) {
          hasContent = true;
          if (state.tag === null) {
            state.tag = "?";
          }
        }
        if (state.anchor !== null) {
          state.anchorMap[state.anchor] = state.result;
        }
      }
    } else if (indentStatus === 0) {
      hasContent = allowBlockCollections && readBlockSequence(state, blockIndent);
    }
  }
  if (state.tag === null) {
    if (state.anchor !== null) {
      state.anchorMap[state.anchor] = state.result;
    }
  } else if (state.tag === "?") {
    if (state.result !== null && state.kind !== "scalar") {
      throwError(state, 'unacceptable node kind for !<?> tag; it should be "scalar", not "' + state.kind + '"');
    }
    for (typeIndex = 0, typeQuantity = state.implicitTypes.length; typeIndex < typeQuantity; typeIndex += 1) {
      type2 = state.implicitTypes[typeIndex];
      if (type2.resolve(state.result)) {
        state.result = type2.construct(state.result);
        state.tag = type2.tag;
        if (state.anchor !== null) {
          state.anchorMap[state.anchor] = state.result;
        }
        break;
      }
    }
  } else if (state.tag !== "!") {
    if (_hasOwnProperty$1.call(state.typeMap[state.kind || "fallback"], state.tag)) {
      type2 = state.typeMap[state.kind || "fallback"][state.tag];
    } else {
      type2 = null;
      typeList = state.typeMap.multi[state.kind || "fallback"];
      for (typeIndex = 0, typeQuantity = typeList.length; typeIndex < typeQuantity; typeIndex += 1) {
        if (state.tag.slice(0, typeList[typeIndex].tag.length) === typeList[typeIndex].tag) {
          type2 = typeList[typeIndex];
          break;
        }
      }
    }
    if (!type2) {
      throwError(state, "unknown tag !<" + state.tag + ">");
    }
    if (state.result !== null && type2.kind !== state.kind) {
      throwError(state, "unacceptable node kind for !<" + state.tag + '> tag; it should be "' + type2.kind + '", not "' + state.kind + '"');
    }
    if (!type2.resolve(state.result, state.tag)) {
      throwError(state, "cannot resolve a node with !<" + state.tag + "> explicit tag");
    } else {
      state.result = type2.construct(state.result, state.tag);
      if (state.anchor !== null) {
        state.anchorMap[state.anchor] = state.result;
      }
    }
  }
  if (state.listener !== null) {
    state.listener("close", state);
  }
  return state.tag !== null || state.anchor !== null || hasContent;
}
function readDocument(state) {
  var documentStart = state.position, _position, directiveName, directiveArgs, hasDirectives = false, ch;
  state.version = null;
  state.checkLineBreaks = state.legacy;
  state.tagMap = /* @__PURE__ */ Object.create(null);
  state.anchorMap = /* @__PURE__ */ Object.create(null);
  while ((ch = state.input.charCodeAt(state.position)) !== 0) {
    skipSeparationSpace(state, true, -1);
    ch = state.input.charCodeAt(state.position);
    if (state.lineIndent > 0 || ch !== 37) {
      break;
    }
    hasDirectives = true;
    ch = state.input.charCodeAt(++state.position);
    _position = state.position;
    while (ch !== 0 && !is_WS_OR_EOL(ch)) {
      ch = state.input.charCodeAt(++state.position);
    }
    directiveName = state.input.slice(_position, state.position);
    directiveArgs = [];
    if (directiveName.length < 1) {
      throwError(state, "directive name must not be less than one character in length");
    }
    while (ch !== 0) {
      while (is_WHITE_SPACE(ch)) {
        ch = state.input.charCodeAt(++state.position);
      }
      if (ch === 35) {
        do {
          ch = state.input.charCodeAt(++state.position);
        } while (ch !== 0 && !is_EOL(ch));
        break;
      }
      if (is_EOL(ch)) break;
      _position = state.position;
      while (ch !== 0 && !is_WS_OR_EOL(ch)) {
        ch = state.input.charCodeAt(++state.position);
      }
      directiveArgs.push(state.input.slice(_position, state.position));
    }
    if (ch !== 0) readLineBreak(state);
    if (_hasOwnProperty$1.call(directiveHandlers, directiveName)) {
      directiveHandlers[directiveName](state, directiveName, directiveArgs);
    } else {
      throwWarning(state, 'unknown document directive "' + directiveName + '"');
    }
  }
  skipSeparationSpace(state, true, -1);
  if (state.lineIndent === 0 && state.input.charCodeAt(state.position) === 45 && state.input.charCodeAt(state.position + 1) === 45 && state.input.charCodeAt(state.position + 2) === 45) {
    state.position += 3;
    skipSeparationSpace(state, true, -1);
  } else if (hasDirectives) {
    throwError(state, "directives end mark is expected");
  }
  composeNode(state, state.lineIndent - 1, CONTEXT_BLOCK_OUT, false, true);
  skipSeparationSpace(state, true, -1);
  if (state.checkLineBreaks && PATTERN_NON_ASCII_LINE_BREAKS.test(state.input.slice(documentStart, state.position))) {
    throwWarning(state, "non-ASCII line breaks are interpreted as content");
  }
  state.documents.push(state.result);
  if (state.position === state.lineStart && testDocumentSeparator(state)) {
    if (state.input.charCodeAt(state.position) === 46) {
      state.position += 3;
      skipSeparationSpace(state, true, -1);
    }
    return;
  }
  if (state.position < state.length - 1) {
    throwError(state, "end of the stream or a document separator is expected");
  } else {
    return;
  }
}
function loadDocuments(input, options) {
  input = String(input);
  options = options || {};
  if (input.length !== 0) {
    if (input.charCodeAt(input.length - 1) !== 10 && input.charCodeAt(input.length - 1) !== 13) {
      input += "\n";
    }
    if (input.charCodeAt(0) === 65279) {
      input = input.slice(1);
    }
  }
  var state = new State$1(input, options);
  var nullpos = input.indexOf("\0");
  if (nullpos !== -1) {
    state.position = nullpos;
    throwError(state, "null byte is not allowed in input");
  }
  state.input += "\0";
  while (state.input.charCodeAt(state.position) === 32) {
    state.lineIndent += 1;
    state.position += 1;
  }
  while (state.position < state.length - 1) {
    readDocument(state);
  }
  return state.documents;
}
function loadAll$1(input, iterator, options) {
  if (iterator !== null && typeof iterator === "object" && typeof options === "undefined") {
    options = iterator;
    iterator = null;
  }
  var documents = loadDocuments(input, options);
  if (typeof iterator !== "function") {
    return documents;
  }
  for (var index3 = 0, length = documents.length; index3 < length; index3 += 1) {
    iterator(documents[index3]);
  }
}
function load$1(input, options) {
  var documents = loadDocuments(input, options);
  if (documents.length === 0) {
    return void 0;
  } else if (documents.length === 1) {
    return documents[0];
  }
  throw new exception("expected a single document in the stream, but found more");
}
var loadAll_1 = loadAll$1;
var load_1 = load$1;
var loader = {
  loadAll: loadAll_1,
  load: load_1
};
var _toString = Object.prototype.toString;
var _hasOwnProperty = Object.prototype.hasOwnProperty;
var CHAR_BOM = 65279;
var CHAR_TAB = 9;
var CHAR_LINE_FEED = 10;
var CHAR_CARRIAGE_RETURN = 13;
var CHAR_SPACE = 32;
var CHAR_EXCLAMATION = 33;
var CHAR_DOUBLE_QUOTE = 34;
var CHAR_SHARP = 35;
var CHAR_PERCENT = 37;
var CHAR_AMPERSAND = 38;
var CHAR_SINGLE_QUOTE = 39;
var CHAR_ASTERISK = 42;
var CHAR_COMMA = 44;
var CHAR_MINUS = 45;
var CHAR_COLON = 58;
var CHAR_EQUALS = 61;
var CHAR_GREATER_THAN = 62;
var CHAR_QUESTION = 63;
var CHAR_COMMERCIAL_AT = 64;
var CHAR_LEFT_SQUARE_BRACKET = 91;
var CHAR_RIGHT_SQUARE_BRACKET = 93;
var CHAR_GRAVE_ACCENT = 96;
var CHAR_LEFT_CURLY_BRACKET = 123;
var CHAR_VERTICAL_LINE = 124;
var CHAR_RIGHT_CURLY_BRACKET = 125;
var ESCAPE_SEQUENCES = {};
ESCAPE_SEQUENCES[0] = "\\0";
ESCAPE_SEQUENCES[7] = "\\a";
ESCAPE_SEQUENCES[8] = "\\b";
ESCAPE_SEQUENCES[9] = "\\t";
ESCAPE_SEQUENCES[10] = "\\n";
ESCAPE_SEQUENCES[11] = "\\v";
ESCAPE_SEQUENCES[12] = "\\f";
ESCAPE_SEQUENCES[13] = "\\r";
ESCAPE_SEQUENCES[27] = "\\e";
ESCAPE_SEQUENCES[34] = '\\"';
ESCAPE_SEQUENCES[92] = "\\\\";
ESCAPE_SEQUENCES[133] = "\\N";
ESCAPE_SEQUENCES[160] = "\\_";
ESCAPE_SEQUENCES[8232] = "\\L";
ESCAPE_SEQUENCES[8233] = "\\P";
var DEPRECATED_BOOLEANS_SYNTAX = [
  "y",
  "Y",
  "yes",
  "Yes",
  "YES",
  "on",
  "On",
  "ON",
  "n",
  "N",
  "no",
  "No",
  "NO",
  "off",
  "Off",
  "OFF"
];
var DEPRECATED_BASE60_SYNTAX = /^[-+]?[0-9_]+(?::[0-9_]+)+(?:\.[0-9_]*)?$/;
function compileStyleMap(schema2, map5) {
  var result, keys, index3, length, tag, style, type2;
  if (map5 === null) return {};
  result = {};
  keys = Object.keys(map5);
  for (index3 = 0, length = keys.length; index3 < length; index3 += 1) {
    tag = keys[index3];
    style = String(map5[tag]);
    if (tag.slice(0, 2) === "!!") {
      tag = "tag:yaml.org,2002:" + tag.slice(2);
    }
    type2 = schema2.compiledTypeMap["fallback"][tag];
    if (type2 && _hasOwnProperty.call(type2.styleAliases, style)) {
      style = type2.styleAliases[style];
    }
    result[tag] = style;
  }
  return result;
}
function encodeHex(character) {
  var string3, handle2, length;
  string3 = character.toString(16).toUpperCase();
  if (character <= 255) {
    handle2 = "x";
    length = 2;
  } else if (character <= 65535) {
    handle2 = "u";
    length = 4;
  } else if (character <= 4294967295) {
    handle2 = "U";
    length = 8;
  } else {
    throw new exception("code point within a string may not be greater than 0xFFFFFFFF");
  }
  return "\\" + handle2 + common.repeat("0", length - string3.length) + string3;
}
var QUOTING_TYPE_SINGLE = 1;
var QUOTING_TYPE_DOUBLE = 2;
function State(options) {
  this.schema = options["schema"] || _default;
  this.indent = Math.max(1, options["indent"] || 2);
  this.noArrayIndent = options["noArrayIndent"] || false;
  this.skipInvalid = options["skipInvalid"] || false;
  this.flowLevel = common.isNothing(options["flowLevel"]) ? -1 : options["flowLevel"];
  this.styleMap = compileStyleMap(this.schema, options["styles"] || null);
  this.sortKeys = options["sortKeys"] || false;
  this.lineWidth = options["lineWidth"] || 80;
  this.noRefs = options["noRefs"] || false;
  this.noCompatMode = options["noCompatMode"] || false;
  this.condenseFlow = options["condenseFlow"] || false;
  this.quotingType = options["quotingType"] === '"' ? QUOTING_TYPE_DOUBLE : QUOTING_TYPE_SINGLE;
  this.forceQuotes = options["forceQuotes"] || false;
  this.replacer = typeof options["replacer"] === "function" ? options["replacer"] : null;
  this.implicitTypes = this.schema.compiledImplicit;
  this.explicitTypes = this.schema.compiledExplicit;
  this.tag = null;
  this.result = "";
  this.duplicates = [];
  this.usedDuplicates = null;
}
function indentString2(string3, spaces) {
  var ind = common.repeat(" ", spaces), position2 = 0, next = -1, result = "", line, length = string3.length;
  while (position2 < length) {
    next = string3.indexOf("\n", position2);
    if (next === -1) {
      line = string3.slice(position2);
      position2 = length;
    } else {
      line = string3.slice(position2, next + 1);
      position2 = next + 1;
    }
    if (line.length && line !== "\n") result += ind;
    result += line;
  }
  return result;
}
function generateNextLine(state, level) {
  return "\n" + common.repeat(" ", state.indent * level);
}
function testImplicitResolving(state, str2) {
  var index3, length, type2;
  for (index3 = 0, length = state.implicitTypes.length; index3 < length; index3 += 1) {
    type2 = state.implicitTypes[index3];
    if (type2.resolve(str2)) {
      return true;
    }
  }
  return false;
}
function isWhitespace(c2) {
  return c2 === CHAR_SPACE || c2 === CHAR_TAB;
}
function isPrintable(c2) {
  return 32 <= c2 && c2 <= 126 || 161 <= c2 && c2 <= 55295 && c2 !== 8232 && c2 !== 8233 || 57344 <= c2 && c2 <= 65533 && c2 !== CHAR_BOM || 65536 <= c2 && c2 <= 1114111;
}
function isNsCharOrWhitespace(c2) {
  return isPrintable(c2) && c2 !== CHAR_BOM && c2 !== CHAR_CARRIAGE_RETURN && c2 !== CHAR_LINE_FEED;
}
function isPlainSafe(c2, prev, inblock) {
  var cIsNsCharOrWhitespace = isNsCharOrWhitespace(c2);
  var cIsNsChar = cIsNsCharOrWhitespace && !isWhitespace(c2);
  return (
    // ns-plain-safe
    (inblock ? (
      // c = flow-in
      cIsNsCharOrWhitespace
    ) : cIsNsCharOrWhitespace && c2 !== CHAR_COMMA && c2 !== CHAR_LEFT_SQUARE_BRACKET && c2 !== CHAR_RIGHT_SQUARE_BRACKET && c2 !== CHAR_LEFT_CURLY_BRACKET && c2 !== CHAR_RIGHT_CURLY_BRACKET) && c2 !== CHAR_SHARP && !(prev === CHAR_COLON && !cIsNsChar) || isNsCharOrWhitespace(prev) && !isWhitespace(prev) && c2 === CHAR_SHARP || prev === CHAR_COLON && cIsNsChar
  );
}
function isPlainSafeFirst(c2) {
  return isPrintable(c2) && c2 !== CHAR_BOM && !isWhitespace(c2) && c2 !== CHAR_MINUS && c2 !== CHAR_QUESTION && c2 !== CHAR_COLON && c2 !== CHAR_COMMA && c2 !== CHAR_LEFT_SQUARE_BRACKET && c2 !== CHAR_RIGHT_SQUARE_BRACKET && c2 !== CHAR_LEFT_CURLY_BRACKET && c2 !== CHAR_RIGHT_CURLY_BRACKET && c2 !== CHAR_SHARP && c2 !== CHAR_AMPERSAND && c2 !== CHAR_ASTERISK && c2 !== CHAR_EXCLAMATION && c2 !== CHAR_VERTICAL_LINE && c2 !== CHAR_EQUALS && c2 !== CHAR_GREATER_THAN && c2 !== CHAR_SINGLE_QUOTE && c2 !== CHAR_DOUBLE_QUOTE && c2 !== CHAR_PERCENT && c2 !== CHAR_COMMERCIAL_AT && c2 !== CHAR_GRAVE_ACCENT;
}
function isPlainSafeLast(c2) {
  return !isWhitespace(c2) && c2 !== CHAR_COLON;
}
function codePointAt2(string3, pos) {
  var first = string3.charCodeAt(pos), second;
  if (first >= 55296 && first <= 56319 && pos + 1 < string3.length) {
    second = string3.charCodeAt(pos + 1);
    if (second >= 56320 && second <= 57343) {
      return (first - 55296) * 1024 + second - 56320 + 65536;
    }
  }
  return first;
}
function needIndentIndicator(string3) {
  var leadingSpaceRe = /^\n* /;
  return leadingSpaceRe.test(string3);
}
var STYLE_PLAIN = 1;
var STYLE_SINGLE = 2;
var STYLE_LITERAL = 3;
var STYLE_FOLDED = 4;
var STYLE_DOUBLE = 5;
function chooseScalarStyle(string3, singleLineOnly, indentPerLevel, lineWidth, testAmbiguousType, quotingType, forceQuotes, inblock) {
  var i3;
  var char = 0;
  var prevChar = null;
  var hasLineBreak = false;
  var hasFoldableLine = false;
  var shouldTrackWidth = lineWidth !== -1;
  var previousLineBreak = -1;
  var plain = isPlainSafeFirst(codePointAt2(string3, 0)) && isPlainSafeLast(codePointAt2(string3, string3.length - 1));
  if (singleLineOnly || forceQuotes) {
    for (i3 = 0; i3 < string3.length; char >= 65536 ? i3 += 2 : i3++) {
      char = codePointAt2(string3, i3);
      if (!isPrintable(char)) {
        return STYLE_DOUBLE;
      }
      plain = plain && isPlainSafe(char, prevChar, inblock);
      prevChar = char;
    }
  } else {
    for (i3 = 0; i3 < string3.length; char >= 65536 ? i3 += 2 : i3++) {
      char = codePointAt2(string3, i3);
      if (char === CHAR_LINE_FEED) {
        hasLineBreak = true;
        if (shouldTrackWidth) {
          hasFoldableLine = hasFoldableLine || // Foldable line = too long, and not more-indented.
          i3 - previousLineBreak - 1 > lineWidth && string3[previousLineBreak + 1] !== " ";
          previousLineBreak = i3;
        }
      } else if (!isPrintable(char)) {
        return STYLE_DOUBLE;
      }
      plain = plain && isPlainSafe(char, prevChar, inblock);
      prevChar = char;
    }
    hasFoldableLine = hasFoldableLine || shouldTrackWidth && (i3 - previousLineBreak - 1 > lineWidth && string3[previousLineBreak + 1] !== " ");
  }
  if (!hasLineBreak && !hasFoldableLine) {
    if (plain && !forceQuotes && !testAmbiguousType(string3)) {
      return STYLE_PLAIN;
    }
    return quotingType === QUOTING_TYPE_DOUBLE ? STYLE_DOUBLE : STYLE_SINGLE;
  }
  if (indentPerLevel > 9 && needIndentIndicator(string3)) {
    return STYLE_DOUBLE;
  }
  if (!forceQuotes) {
    return hasFoldableLine ? STYLE_FOLDED : STYLE_LITERAL;
  }
  return quotingType === QUOTING_TYPE_DOUBLE ? STYLE_DOUBLE : STYLE_SINGLE;
}
function writeScalar(state, string3, level, iskey, inblock) {
  state.dump = function() {
    if (string3.length === 0) {
      return state.quotingType === QUOTING_TYPE_DOUBLE ? '""' : "''";
    }
    if (!state.noCompatMode) {
      if (DEPRECATED_BOOLEANS_SYNTAX.indexOf(string3) !== -1 || DEPRECATED_BASE60_SYNTAX.test(string3)) {
        return state.quotingType === QUOTING_TYPE_DOUBLE ? '"' + string3 + '"' : "'" + string3 + "'";
      }
    }
    var indent2 = state.indent * Math.max(1, level);
    var lineWidth = state.lineWidth === -1 ? -1 : Math.max(Math.min(state.lineWidth, 40), state.lineWidth - indent2);
    var singleLineOnly = iskey || state.flowLevel > -1 && level >= state.flowLevel;
    function testAmbiguity(string4) {
      return testImplicitResolving(state, string4);
    }
    switch (chooseScalarStyle(
      string3,
      singleLineOnly,
      state.indent,
      lineWidth,
      testAmbiguity,
      state.quotingType,
      state.forceQuotes && !iskey,
      inblock
    )) {
      case STYLE_PLAIN:
        return string3;
      case STYLE_SINGLE:
        return "'" + string3.replace(/'/g, "''") + "'";
      case STYLE_LITERAL:
        return "|" + blockHeader(string3, state.indent) + dropEndingNewline(indentString2(string3, indent2));
      case STYLE_FOLDED:
        return ">" + blockHeader(string3, state.indent) + dropEndingNewline(indentString2(foldString(string3, lineWidth), indent2));
      case STYLE_DOUBLE:
        return '"' + escapeString(string3) + '"';
      default:
        throw new exception("impossible error: invalid scalar style");
    }
  }();
}
function blockHeader(string3, indentPerLevel) {
  var indentIndicator = needIndentIndicator(string3) ? String(indentPerLevel) : "";
  var clip = string3[string3.length - 1] === "\n";
  var keep = clip && (string3[string3.length - 2] === "\n" || string3 === "\n");
  var chomp = keep ? "+" : clip ? "" : "-";
  return indentIndicator + chomp + "\n";
}
function dropEndingNewline(string3) {
  return string3[string3.length - 1] === "\n" ? string3.slice(0, -1) : string3;
}
function foldString(string3, width) {
  var lineRe = /(\n+)([^\n]*)/g;
  var result = function() {
    var nextLF = string3.indexOf("\n");
    nextLF = nextLF !== -1 ? nextLF : string3.length;
    lineRe.lastIndex = nextLF;
    return foldLine(string3.slice(0, nextLF), width);
  }();
  var prevMoreIndented = string3[0] === "\n" || string3[0] === " ";
  var moreIndented;
  var match;
  while (match = lineRe.exec(string3)) {
    var prefix = match[1], line = match[2];
    moreIndented = line[0] === " ";
    result += prefix + (!prevMoreIndented && !moreIndented && line !== "" ? "\n" : "") + foldLine(line, width);
    prevMoreIndented = moreIndented;
  }
  return result;
}
function foldLine(line, width) {
  if (line === "" || line[0] === " ") return line;
  var breakRe = / [^ ]/g;
  var match;
  var start2 = 0, end, curr = 0, next = 0;
  var result = "";
  while (match = breakRe.exec(line)) {
    next = match.index;
    if (next - start2 > width) {
      end = curr > start2 ? curr : next;
      result += "\n" + line.slice(start2, end);
      start2 = end + 1;
    }
    curr = next;
  }
  result += "\n";
  if (line.length - start2 > width && curr > start2) {
    result += line.slice(start2, curr) + "\n" + line.slice(curr + 1);
  } else {
    result += line.slice(start2);
  }
  return result.slice(1);
}
function escapeString(string3) {
  var result = "";
  var char = 0;
  var escapeSeq;
  for (var i3 = 0; i3 < string3.length; char >= 65536 ? i3 += 2 : i3++) {
    char = codePointAt2(string3, i3);
    escapeSeq = ESCAPE_SEQUENCES[char];
    if (!escapeSeq && isPrintable(char)) {
      result += string3[i3];
      if (char >= 65536) result += string3[i3 + 1];
    } else {
      result += escapeSeq || encodeHex(char);
    }
  }
  return result;
}
function writeFlowSequence(state, level, object) {
  var _result = "", _tag = state.tag, index3, length, value2;
  for (index3 = 0, length = object.length; index3 < length; index3 += 1) {
    value2 = object[index3];
    if (state.replacer) {
      value2 = state.replacer.call(object, String(index3), value2);
    }
    if (writeNode(state, level, value2, false, false) || typeof value2 === "undefined" && writeNode(state, level, null, false, false)) {
      if (_result !== "") _result += "," + (!state.condenseFlow ? " " : "");
      _result += state.dump;
    }
  }
  state.tag = _tag;
  state.dump = "[" + _result + "]";
}
function writeBlockSequence(state, level, object, compact2) {
  var _result = "", _tag = state.tag, index3, length, value2;
  for (index3 = 0, length = object.length; index3 < length; index3 += 1) {
    value2 = object[index3];
    if (state.replacer) {
      value2 = state.replacer.call(object, String(index3), value2);
    }
    if (writeNode(state, level + 1, value2, true, true, false, true) || typeof value2 === "undefined" && writeNode(state, level + 1, null, true, true, false, true)) {
      if (!compact2 || _result !== "") {
        _result += generateNextLine(state, level);
      }
      if (state.dump && CHAR_LINE_FEED === state.dump.charCodeAt(0)) {
        _result += "-";
      } else {
        _result += "- ";
      }
      _result += state.dump;
    }
  }
  state.tag = _tag;
  state.dump = _result || "[]";
}
function writeFlowMapping(state, level, object) {
  var _result = "", _tag = state.tag, objectKeyList = Object.keys(object), index3, length, objectKey, objectValue, pairBuffer;
  for (index3 = 0, length = objectKeyList.length; index3 < length; index3 += 1) {
    pairBuffer = "";
    if (_result !== "") pairBuffer += ", ";
    if (state.condenseFlow) pairBuffer += '"';
    objectKey = objectKeyList[index3];
    objectValue = object[objectKey];
    if (state.replacer) {
      objectValue = state.replacer.call(object, objectKey, objectValue);
    }
    if (!writeNode(state, level, objectKey, false, false)) {
      continue;
    }
    if (state.dump.length > 1024) pairBuffer += "? ";
    pairBuffer += state.dump + (state.condenseFlow ? '"' : "") + ":" + (state.condenseFlow ? "" : " ");
    if (!writeNode(state, level, objectValue, false, false)) {
      continue;
    }
    pairBuffer += state.dump;
    _result += pairBuffer;
  }
  state.tag = _tag;
  state.dump = "{" + _result + "}";
}
function writeBlockMapping(state, level, object, compact2) {
  var _result = "", _tag = state.tag, objectKeyList = Object.keys(object), index3, length, objectKey, objectValue, explicitPair, pairBuffer;
  if (state.sortKeys === true) {
    objectKeyList.sort();
  } else if (typeof state.sortKeys === "function") {
    objectKeyList.sort(state.sortKeys);
  } else if (state.sortKeys) {
    throw new exception("sortKeys must be a boolean or a function");
  }
  for (index3 = 0, length = objectKeyList.length; index3 < length; index3 += 1) {
    pairBuffer = "";
    if (!compact2 || _result !== "") {
      pairBuffer += generateNextLine(state, level);
    }
    objectKey = objectKeyList[index3];
    objectValue = object[objectKey];
    if (state.replacer) {
      objectValue = state.replacer.call(object, objectKey, objectValue);
    }
    if (!writeNode(state, level + 1, objectKey, true, true, true)) {
      continue;
    }
    explicitPair = state.tag !== null && state.tag !== "?" || state.dump && state.dump.length > 1024;
    if (explicitPair) {
      if (state.dump && CHAR_LINE_FEED === state.dump.charCodeAt(0)) {
        pairBuffer += "?";
      } else {
        pairBuffer += "? ";
      }
    }
    pairBuffer += state.dump;
    if (explicitPair) {
      pairBuffer += generateNextLine(state, level);
    }
    if (!writeNode(state, level + 1, objectValue, true, explicitPair)) {
      continue;
    }
    if (state.dump && CHAR_LINE_FEED === state.dump.charCodeAt(0)) {
      pairBuffer += ":";
    } else {
      pairBuffer += ": ";
    }
    pairBuffer += state.dump;
    _result += pairBuffer;
  }
  state.tag = _tag;
  state.dump = _result || "{}";
}
function detectType(state, object, explicit) {
  var _result, typeList, index3, length, type2, style;
  typeList = explicit ? state.explicitTypes : state.implicitTypes;
  for (index3 = 0, length = typeList.length; index3 < length; index3 += 1) {
    type2 = typeList[index3];
    if ((type2.instanceOf || type2.predicate) && (!type2.instanceOf || typeof object === "object" && object instanceof type2.instanceOf) && (!type2.predicate || type2.predicate(object))) {
      if (explicit) {
        if (type2.multi && type2.representName) {
          state.tag = type2.representName(object);
        } else {
          state.tag = type2.tag;
        }
      } else {
        state.tag = "?";
      }
      if (type2.represent) {
        style = state.styleMap[type2.tag] || type2.defaultStyle;
        if (_toString.call(type2.represent) === "[object Function]") {
          _result = type2.represent(object, style);
        } else if (_hasOwnProperty.call(type2.represent, style)) {
          _result = type2.represent[style](object, style);
        } else {
          throw new exception("!<" + type2.tag + '> tag resolver accepts not "' + style + '" style');
        }
        state.dump = _result;
      }
      return true;
    }
  }
  return false;
}
function writeNode(state, level, object, block, compact2, iskey, isblockseq) {
  state.tag = null;
  state.dump = object;
  if (!detectType(state, object, false)) {
    detectType(state, object, true);
  }
  var type2 = _toString.call(state.dump);
  var inblock = block;
  var tagStr;
  if (block) {
    block = state.flowLevel < 0 || state.flowLevel > level;
  }
  var objectOrArray = type2 === "[object Object]" || type2 === "[object Array]", duplicateIndex, duplicate;
  if (objectOrArray) {
    duplicateIndex = state.duplicates.indexOf(object);
    duplicate = duplicateIndex !== -1;
  }
  if (state.tag !== null && state.tag !== "?" || duplicate || state.indent !== 2 && level > 0) {
    compact2 = false;
  }
  if (duplicate && state.usedDuplicates[duplicateIndex]) {
    state.dump = "*ref_" + duplicateIndex;
  } else {
    if (objectOrArray && duplicate && !state.usedDuplicates[duplicateIndex]) {
      state.usedDuplicates[duplicateIndex] = true;
    }
    if (type2 === "[object Object]") {
      if (block && Object.keys(state.dump).length !== 0) {
        writeBlockMapping(state, level, state.dump, compact2);
        if (duplicate) {
          state.dump = "&ref_" + duplicateIndex + state.dump;
        }
      } else {
        writeFlowMapping(state, level, state.dump);
        if (duplicate) {
          state.dump = "&ref_" + duplicateIndex + " " + state.dump;
        }
      }
    } else if (type2 === "[object Array]") {
      if (block && state.dump.length !== 0) {
        if (state.noArrayIndent && !isblockseq && level > 0) {
          writeBlockSequence(state, level - 1, state.dump, compact2);
        } else {
          writeBlockSequence(state, level, state.dump, compact2);
        }
        if (duplicate) {
          state.dump = "&ref_" + duplicateIndex + state.dump;
        }
      } else {
        writeFlowSequence(state, level, state.dump);
        if (duplicate) {
          state.dump = "&ref_" + duplicateIndex + " " + state.dump;
        }
      }
    } else if (type2 === "[object String]") {
      if (state.tag !== "?") {
        writeScalar(state, state.dump, level, iskey, inblock);
      }
    } else if (type2 === "[object Undefined]") {
      return false;
    } else {
      if (state.skipInvalid) return false;
      throw new exception("unacceptable kind of an object to dump " + type2);
    }
    if (state.tag !== null && state.tag !== "?") {
      tagStr = encodeURI(
        state.tag[0] === "!" ? state.tag.slice(1) : state.tag
      ).replace(/!/g, "%21");
      if (state.tag[0] === "!") {
        tagStr = "!" + tagStr;
      } else if (tagStr.slice(0, 18) === "tag:yaml.org,2002:") {
        tagStr = "!!" + tagStr.slice(18);
      } else {
        tagStr = "!<" + tagStr + ">";
      }
      state.dump = tagStr + " " + state.dump;
    }
  }
  return true;
}
function getDuplicateReferences(object, state) {
  var objects = [], duplicatesIndexes = [], index3, length;
  inspectNode(object, objects, duplicatesIndexes);
  for (index3 = 0, length = duplicatesIndexes.length; index3 < length; index3 += 1) {
    state.duplicates.push(objects[duplicatesIndexes[index3]]);
  }
  state.usedDuplicates = new Array(length);
}
function inspectNode(object, objects, duplicatesIndexes) {
  var objectKeyList, index3, length;
  if (object !== null && typeof object === "object") {
    index3 = objects.indexOf(object);
    if (index3 !== -1) {
      if (duplicatesIndexes.indexOf(index3) === -1) {
        duplicatesIndexes.push(index3);
      }
    } else {
      objects.push(object);
      if (Array.isArray(object)) {
        for (index3 = 0, length = object.length; index3 < length; index3 += 1) {
          inspectNode(object[index3], objects, duplicatesIndexes);
        }
      } else {
        objectKeyList = Object.keys(object);
        for (index3 = 0, length = objectKeyList.length; index3 < length; index3 += 1) {
          inspectNode(object[objectKeyList[index3]], objects, duplicatesIndexes);
        }
      }
    }
  }
}
function dump$1(input, options) {
  options = options || {};
  var state = new State(options);
  if (!state.noRefs) getDuplicateReferences(input, state);
  var value2 = input;
  if (state.replacer) {
    value2 = state.replacer.call({ "": value2 }, "", value2);
  }
  if (writeNode(state, 0, value2, true, true)) return state.dump + "\n";
  return "";
}
var dump_1 = dump$1;
var dumper = {
  dump: dump_1
};
function renamed(from, to) {
  return function() {
    throw new Error("Function yaml." + from + " is removed in js-yaml 4. Use yaml." + to + " instead, which is now safe by default.");
  };
}
var Type = type;
var Schema = schema;
var FAILSAFE_SCHEMA = failsafe;
var JSON_SCHEMA = json;
var CORE_SCHEMA = core2;
var DEFAULT_SCHEMA = _default;
var load = loader.load;
var loadAll = loader.loadAll;
var dump = dumper.dump;
var YAMLException = exception;
var types2 = {
  binary,
  float,
  map: map4,
  null: _null,
  pairs,
  set: set2,
  timestamp,
  bool,
  int,
  merge,
  omap,
  seq,
  str
};
var safeLoad = renamed("safeLoad", "load");
var safeLoadAll = renamed("safeLoadAll", "loadAll");
var safeDump = renamed("safeDump", "dump");
var jsYaml = {
  Type,
  Schema,
  FAILSAFE_SCHEMA,
  JSON_SCHEMA,
  CORE_SCHEMA,
  DEFAULT_SCHEMA,
  load,
  loadAll,
  dump,
  YAMLException,
  types: types2,
  safeLoad,
  safeLoadAll,
  safeDump
};
var js_yaml_default = jsYaml;

// node_modules/@mdxeditor/editor/dist/plugins/frontmatter/FrontmatterEditor.js
var import_react37 = __toESM(require_react(), 1);
var FrontmatterEditor = ({ yaml, onChange }) => {
  const [readOnly, editorRootElementRef, iconComponentFor, frontmatterDialogOpen] = X(
    readOnly$,
    editorRootElementRef$,
    iconComponentFor$,
    frontmatterDialogOpen$
  );
  const t3 = useTranslation();
  const setFrontmatterDialogOpen = A(frontmatterDialogOpen$);
  const removeFrontmatter = A(removeFrontmatter$);
  const yamlConfig = import_react37.default.useMemo(() => {
    if (!yaml) {
      return [];
    }
    return Object.entries(js_yaml_default.load(yaml)).map(([key2, value2]) => ({ key: key2, value: value2 }));
  }, [yaml]);
  const { register, control, handleSubmit } = useForm({
    defaultValues: {
      yamlConfig
    }
  });
  const { fields, append: append2, remove } = useFieldArray({
    control,
    name: "yamlConfig"
  });
  const onSubmit = import_react37.default.useCallback(
    ({ yamlConfig: yamlConfig2 }) => {
      if (yamlConfig2.length === 0) {
        removeFrontmatter();
        setFrontmatterDialogOpen(false);
        return;
      }
      const yaml2 = yamlConfig2.reduce((acc, { key: key2, value: value2 }) => {
        if (key2 && value2) {
          acc[key2] = value2;
        }
        return acc;
      }, {});
      onChange(js_yaml_default.dump(yaml2).trim());
      setFrontmatterDialogOpen(false);
    },
    [onChange, setFrontmatterDialogOpen, removeFrontmatter]
  );
  return import_react37.default.createElement(import_react37.default.Fragment, null, import_react37.default.createElement(
    Root5,
    {
      open: frontmatterDialogOpen,
      onOpenChange: (open) => {
        setFrontmatterDialogOpen(open);
      }
    },
    import_react37.default.createElement(Portal3, { container: editorRootElementRef == null ? void 0 : editorRootElementRef.current }, import_react37.default.createElement(Overlay, { className: styles.dialogOverlay }), import_react37.default.createElement(Content3, { className: styles.largeDialogContent, "data-editor-type": "frontmatter" }, import_react37.default.createElement(Title, { className: styles.dialogTitle }, t3("frontmatterEditor.title", "Edit document frontmatter")), import_react37.default.createElement(
      "form",
      {
        onSubmit: (e2) => {
          void handleSubmit(onSubmit)(e2);
          e2.stopPropagation();
        },
        onReset: (e2) => {
          e2.stopPropagation();
          setFrontmatterDialogOpen(false);
        }
      },
      import_react37.default.createElement("table", { className: styles.propertyEditorTable }, import_react37.default.createElement("colgroup", null, import_react37.default.createElement("col", null), import_react37.default.createElement("col", null), import_react37.default.createElement("col", null)), import_react37.default.createElement("thead", null, import_react37.default.createElement("tr", null, import_react37.default.createElement("th", null, t3("frontmatterEditor.key", "Key")), import_react37.default.createElement("th", null, t3("frontmatterEditor.value", "Value")), import_react37.default.createElement("th", null))), import_react37.default.createElement("tbody", null, fields.map((item, index3) => {
        return import_react37.default.createElement("tr", { key: item.id }, import_react37.default.createElement("td", null, import_react37.default.createElement(TableInput, { ...register(`yamlConfig.${index3}.key`, { required: true }), autofocusIfEmpty: true, readOnly })), import_react37.default.createElement("td", null, import_react37.default.createElement(TableInput, { ...register(`yamlConfig.${index3}.value`, { required: true }), readOnly })), import_react37.default.createElement("td", null, import_react37.default.createElement(
          "button",
          {
            type: "button",
            onClick: () => {
              remove(index3);
            },
            className: styles.iconButton,
            disabled: readOnly
          },
          iconComponentFor("delete_big")
        )));
      })), import_react37.default.createElement("tfoot", null, import_react37.default.createElement("tr", null, import_react37.default.createElement("td", null, import_react37.default.createElement(
        "button",
        {
          disabled: readOnly,
          className: (0, import_classnames6.default)(styles.primaryButton, styles.smallButton),
          type: "button",
          onClick: () => {
            append2({ key: "", value: "" });
          }
        },
        t3("frontmatterEditor.addEntry", "Add entry")
      ))))),
      import_react37.default.createElement("div", { style: { display: "flex", justifyContent: "flex-end", gap: "var(--spacing-2)" } }, import_react37.default.createElement("button", { type: "submit", className: styles.primaryButton }, t3("dialogControls.save", "Save")), import_react37.default.createElement("button", { type: "reset", className: styles.secondaryButton }, t3("dialogControls.cancel", "Cancel")))
    ), import_react37.default.createElement(Close, { asChild: true }, import_react37.default.createElement("button", { className: styles.dialogCloseButton, "aria-label": t3("dialogControls.cancel", "Cancel") }, iconComponentFor("close")))))
  ));
};
var TableInput = import_react37.default.forwardRef(({ className, autofocusIfEmpty: _2, ...props }, ref2) => {
  return import_react37.default.createElement("input", { className: (0, import_classnames6.default)(styles.propertyEditorInput, className), ...props, ref: ref2 });
});

// node_modules/@mdxeditor/editor/dist/plugins/frontmatter/FrontmatterNode.js
var __defProp4 = Object.defineProperty;
var __defNormalProp4 = (obj, key2, value2) => key2 in obj ? __defProp4(obj, key2, { enumerable: true, configurable: true, writable: true, value: value2 }) : obj[key2] = value2;
var __publicField5 = (obj, key2, value2) => {
  __defNormalProp4(obj, typeof key2 !== "symbol" ? key2 + "" : key2, value2);
  return value2;
};
var FrontmatterNode = class _FrontmatterNode extends DecoratorNode {
  constructor(code3, key2) {
    super(key2);
    __publicField5(this, "__yaml");
    this.__yaml = code3;
  }
  static getType() {
    return "frontmatter";
  }
  static clone(node2) {
    return new _FrontmatterNode(node2.__yaml, node2.__key);
  }
  static importJSON(serializedNode) {
    const { yaml } = serializedNode;
    const node2 = $createFrontmatterNode(yaml);
    return node2;
  }
  exportJSON() {
    return {
      yaml: this.getYaml(),
      type: "frontmatter",
      version: 1
    };
  }
  // View
  createDOM(_config) {
    return document.createElement("div");
  }
  updateDOM() {
    return false;
  }
  getYaml() {
    return this.getLatest().__yaml;
  }
  setYaml(yaml) {
    if (yaml !== this.__yaml) {
      this.getWritable().__yaml = yaml;
    }
  }
  decorate(editor) {
    return import_react38.default.createElement(
      FrontmatterEditor,
      {
        yaml: this.getYaml(),
        onChange: (yaml) => {
          editor.update(() => {
            this.setYaml(yaml);
          });
        }
      }
    );
  }
  isKeyboardSelectable() {
    return false;
  }
};
function $createFrontmatterNode(yaml) {
  return new FrontmatterNode(yaml);
}
function $isFrontmatterNode(node2) {
  return node2 instanceof FrontmatterNode;
}

// node_modules/@mdxeditor/editor/dist/plugins/frontmatter/LexicalFrontmatterVisitor.js
var LexicalFrontmatterVisitor = {
  testLexicalNode: $isFrontmatterNode,
  visitLexicalNode: ({ actions, lexicalNode }) => {
    actions.addAndStepInto("yaml", { value: lexicalNode.getYaml() });
  }
};

// node_modules/@mdxeditor/editor/dist/plugins/frontmatter/MdastFrontmatterVisitor.js
var MdastFrontmatterVisitor = {
  testNode: "yaml",
  visitNode({ mdastNode, actions }) {
    actions.addAndStepInto($createFrontmatterNode(mdastNode.value));
  }
};

// node_modules/@mdxeditor/editor/dist/plugins/frontmatter/index.js
var frontmatterDialogOpen$ = $(false);
var insertFrontmatter$ = q((r2) => {
  r2.sub(r2.pipe(insertFrontmatter$, tt(rootEditor$)), ([, rootEditor]) => {
    rootEditor == null ? void 0 : rootEditor.update(() => {
      const firstItem = $getRoot().getFirstChild();
      if (!$isFrontmatterNode(firstItem)) {
        const fmNode = $createFrontmatterNode('"": ""');
        if (firstItem) {
          firstItem.insertBefore(fmNode);
        } else {
          $getRoot().append(fmNode);
        }
      }
    });
    r2.pub(frontmatterDialogOpen$, true);
  });
});
var removeFrontmatter$ = q((r2) => {
  r2.sub(r2.pipe(removeFrontmatter$, tt(rootEditor$)), ([, rootEditor]) => {
    rootEditor == null ? void 0 : rootEditor.update(() => {
      const firstItem = $getRoot().getFirstChild();
      if ($isFrontmatterNode(firstItem)) {
        firstItem.remove();
      }
    });
    r2.pub(frontmatterDialogOpen$, false);
  });
});
var hasFrontmatter$ = $(false, (r2) => {
  r2.pub(createRootEditorSubscription$, (rootEditor) => {
    return rootEditor.registerUpdateListener(({ editorState }) => {
      editorState.read(() => {
        r2.pub(hasFrontmatter$, $isFrontmatterNode($getRoot().getFirstChild()));
      });
    });
  });
});
var frontmatterPlugin = realmPlugin({
  init: (realm) => {
    realm.pubIn({
      [addMdastExtension$]: frontmatterFromMarkdown("yaml"),
      [addSyntaxExtension$]: frontmatter(),
      [addLexicalNode$]: FrontmatterNode,
      [addImportVisitor$]: MdastFrontmatterVisitor,
      [addExportVisitor$]: LexicalFrontmatterVisitor,
      [addToMarkdownExtension$]: frontmatterToMarkdown("yaml"),
      [createRootEditorSubscription$]: (editor) => {
        return editor.registerCommand(
          KEY_DOWN_COMMAND,
          (event) => {
            let shouldPrevent = false;
            editor.read(() => {
              const selection2 = $getSelection();
              if ($isRangeSelection(selection2)) {
                if (selection2.isCollapsed() && selection2.anchor.offset === 0 && selection2.focus.offset === 0 && event.key === "Backspace") {
                  let node2 = selection2.getNodes()[0];
                  if ($isTextNode(node2)) {
                    node2 = node2.getParent();
                  }
                  const prevSibling = node2 == null ? void 0 : node2.getPreviousSibling();
                  if ($isFrontmatterNode(prevSibling)) {
                    shouldPrevent = true;
                    event.preventDefault();
                  }
                } else {
                  const firstNode = selection2.getNodes()[0];
                  if ($isFrontmatterNode(firstNode)) {
                    const yaml = firstNode.getYaml();
                    setTimeout(() => {
                      editor.update(
                        () => {
                          const firstItem = $getRoot().getFirstChild();
                          if (!$isFrontmatterNode(firstItem)) {
                            $getRoot().splice(0, 0, [$createFrontmatterNode(yaml)]);
                          }
                        },
                        { discrete: true }
                      );
                    });
                  }
                }
              }
            });
            if (shouldPrevent) {
              return true;
            }
            return false;
          },
          COMMAND_PRIORITY_CRITICAL
        );
      }
    });
  }
});

// node_modules/@mdxeditor/editor/dist/plugins/quote/MdastBlockQuoteVisitor.js
var MdastBlockQuoteVisitor = {
  testNode: "blockquote",
  visitNode({ actions }) {
    actions.addAndStepInto($createQuoteNode());
  }
};

// node_modules/@mdxeditor/editor/dist/plugins/quote/LexicalQuoteVisitor.js
var LexicalQuoteVisitor = {
  testLexicalNode: $isQuoteNode,
  visitLexicalNode: ({ lexicalNode, mdastParent, actions }) => {
    const paragraph2 = { type: "paragraph", children: [] };
    actions.appendToParent(mdastParent, { type: "blockquote", children: [paragraph2] });
    actions.visitChildren(lexicalNode, paragraph2);
  }
};

// node_modules/@mdxeditor/editor/dist/plugins/quote/index.js
var quotePlugin = realmPlugin({
  init(realm) {
    realm.pubIn({
      [addActivePlugin$]: "quote",
      [addImportVisitor$]: MdastBlockQuoteVisitor,
      [addLexicalNode$]: QuoteNode,
      [addExportVisitor$]: LexicalQuoteVisitor
    });
  }
});

// node_modules/@mdxeditor/editor/dist/plugins/maxlength/index.js
var maxLengthPlugin = realmPlugin({
  init: (realm, maxLength = Infinity) => {
    realm.pub(createRootEditorSubscription$, (editor) => {
      let lastRestoredEditorState = null;
      return editor.registerNodeTransform(RootNode, (rootNode) => {
        const selection2 = $getSelection();
        if (!$isRangeSelection(selection2) || !selection2.isCollapsed()) {
          return;
        }
        const prevEditorState = editor.getEditorState();
        const prevTextContentSize = prevEditorState.read(() => rootNode.getTextContentSize());
        const textContentSize = rootNode.getTextContentSize();
        if (prevTextContentSize !== textContentSize) {
          const delCount = textContentSize - maxLength;
          const anchor = selection2.anchor;
          if (delCount > 0) {
            if (prevTextContentSize === maxLength && lastRestoredEditorState !== prevEditorState) {
              lastRestoredEditorState = prevEditorState;
              $restoreEditorState(editor, prevEditorState);
            } else {
              trimTextContentFromAnchor(editor, anchor, delCount);
            }
          }
        }
      });
    });
  }
});

// node_modules/mdast-util-mdx-expression/lib/index.js
function mdxExpressionFromMarkdown() {
  return {
    enter: {
      mdxFlowExpression: enterMdxFlowExpression,
      mdxTextExpression: enterMdxTextExpression
    },
    exit: {
      mdxFlowExpression: exitMdxExpression,
      mdxFlowExpressionChunk: exitMdxExpressionData,
      mdxTextExpression: exitMdxExpression,
      mdxTextExpressionChunk: exitMdxExpressionData
    }
  };
}
function mdxExpressionToMarkdown() {
  return {
    handlers: {
      mdxFlowExpression: handleMdxExpression,
      mdxTextExpression: handleMdxExpression
    },
    unsafe: [
      { character: "{", inConstruct: ["phrasing"] },
      { atBreak: true, character: "{" }
    ]
  };
}
function enterMdxFlowExpression(token) {
  this.enter({ type: "mdxFlowExpression", value: "" }, token);
  this.buffer();
}
function enterMdxTextExpression(token) {
  this.enter({ type: "mdxTextExpression", value: "" }, token);
  this.buffer();
}
function exitMdxExpression(token) {
  const value2 = this.resume();
  const estree = token.estree;
  const node2 = this.stack[this.stack.length - 1];
  ok(node2.type === "mdxFlowExpression" || node2.type === "mdxTextExpression");
  this.exit(token);
  node2.value = value2;
  if (estree) {
    node2.data = { estree };
  }
}
function exitMdxExpressionData(token) {
  this.config.enter.data.call(this, token);
  this.config.exit.data.call(this, token);
}
function handleMdxExpression(node2, parent, state) {
  const value2 = node2.value || "";
  const result = state.indentLines(value2, function(line, index3, blank) {
    return (index3 === 0 || blank ? "" : "  ") + line;
  });
  return "{" + result + "}";
}

// node_modules/mdast-util-mdxjs-esm/lib/index.js
function mdxjsEsmFromMarkdown() {
  return {
    enter: { mdxjsEsm: enterMdxjsEsm },
    exit: { mdxjsEsm: exitMdxjsEsm, mdxjsEsmData: exitMdxjsEsmData }
  };
}
function mdxjsEsmToMarkdown() {
  return { handlers: { mdxjsEsm: handleMdxjsEsm } };
}
function enterMdxjsEsm(token) {
  this.enter({ type: "mdxjsEsm", value: "" }, token);
  this.buffer();
}
function exitMdxjsEsm(token) {
  const value2 = this.resume();
  const node2 = this.stack[this.stack.length - 1];
  ok(node2.type === "mdxjsEsm");
  this.exit(token);
  const estree = token.estree;
  node2.value = value2;
  if (estree) {
    node2.data = { estree };
  }
}
function exitMdxjsEsmData(token) {
  this.config.enter.data.call(this, token);
  this.config.exit.data.call(this, token);
}
function handleMdxjsEsm(node2) {
  return node2.value || "";
}

// node_modules/mdast-util-mdx/lib/index.js
function mdxFromMarkdown() {
  return [
    mdxExpressionFromMarkdown(),
    mdxJsxFromMarkdown(),
    mdxjsEsmFromMarkdown()
  ];
}
function mdxToMarkdown(options) {
  return {
    extensions: [
      mdxExpressionToMarkdown(),
      mdxJsxToMarkdown(options),
      mdxjsEsmToMarkdown()
    ]
  };
}

// node_modules/acorn/dist/acorn.mjs
var astralIdentifierCodes = [509, 0, 227, 0, 150, 4, 294, 9, 1368, 2, 2, 1, 6, 3, 41, 2, 5, 0, 166, 1, 574, 3, 9, 9, 7, 9, 32, 4, 318, 1, 80, 3, 71, 10, 50, 3, 123, 2, 54, 14, 32, 10, 3, 1, 11, 3, 46, 10, 8, 0, 46, 9, 7, 2, 37, 13, 2, 9, 6, 1, 45, 0, 13, 2, 49, 13, 9, 3, 2, 11, 83, 11, 7, 0, 3, 0, 158, 11, 6, 9, 7, 3, 56, 1, 2, 6, 3, 1, 3, 2, 10, 0, 11, 1, 3, 6, 4, 4, 68, 8, 2, 0, 3, 0, 2, 3, 2, 4, 2, 0, 15, 1, 83, 17, 10, 9, 5, 0, 82, 19, 13, 9, 214, 6, 3, 8, 28, 1, 83, 16, 16, 9, 82, 12, 9, 9, 7, 19, 58, 14, 5, 9, 243, 14, 166, 9, 71, 5, 2, 1, 3, 3, 2, 0, 2, 1, 13, 9, 120, 6, 3, 6, 4, 0, 29, 9, 41, 6, 2, 3, 9, 0, 10, 10, 47, 15, 343, 9, 54, 7, 2, 7, 17, 9, 57, 21, 2, 13, 123, 5, 4, 0, 2, 1, 2, 6, 2, 0, 9, 9, 49, 4, 2, 1, 2, 4, 9, 9, 330, 3, 10, 1, 2, 0, 49, 6, 4, 4, 14, 10, 5350, 0, 7, 14, 11465, 27, 2343, 9, 87, 9, 39, 4, 60, 6, 26, 9, 535, 9, 470, 0, 2, 54, 8, 3, 82, 0, 12, 1, 19628, 1, 4178, 9, 519, 45, 3, 22, 543, 4, 4, 5, 9, 7, 3, 6, 31, 3, 149, 2, 1418, 49, 513, 54, 5, 49, 9, 0, 15, 0, 23, 4, 2, 14, 1361, 6, 2, 16, 3, 6, 2, 1, 2, 4, 101, 0, 161, 6, 10, 9, 357, 0, 62, 13, 499, 13, 245, 1, 2, 9, 726, 6, 110, 6, 6, 9, 4759, 9, 787719, 239];
var astralIdentifierStartCodes = [0, 11, 2, 25, 2, 18, 2, 1, 2, 14, 3, 13, 35, 122, 70, 52, 268, 28, 4, 48, 48, 31, 14, 29, 6, 37, 11, 29, 3, 35, 5, 7, 2, 4, 43, 157, 19, 35, 5, 35, 5, 39, 9, 51, 13, 10, 2, 14, 2, 6, 2, 1, 2, 10, 2, 14, 2, 6, 2, 1, 4, 51, 13, 310, 10, 21, 11, 7, 25, 5, 2, 41, 2, 8, 70, 5, 3, 0, 2, 43, 2, 1, 4, 0, 3, 22, 11, 22, 10, 30, 66, 18, 2, 1, 11, 21, 11, 25, 71, 55, 7, 1, 65, 0, 16, 3, 2, 2, 2, 28, 43, 28, 4, 28, 36, 7, 2, 27, 28, 53, 11, 21, 11, 18, 14, 17, 111, 72, 56, 50, 14, 50, 14, 35, 39, 27, 10, 22, 251, 41, 7, 1, 17, 2, 60, 28, 11, 0, 9, 21, 43, 17, 47, 20, 28, 22, 13, 52, 58, 1, 3, 0, 14, 44, 33, 24, 27, 35, 30, 0, 3, 0, 9, 34, 4, 0, 13, 47, 15, 3, 22, 0, 2, 0, 36, 17, 2, 24, 20, 1, 64, 6, 2, 0, 2, 3, 2, 14, 2, 9, 8, 46, 39, 7, 3, 1, 3, 21, 2, 6, 2, 1, 2, 4, 4, 0, 19, 0, 13, 4, 31, 9, 2, 0, 3, 0, 2, 37, 2, 0, 26, 0, 2, 0, 45, 52, 19, 3, 21, 2, 31, 47, 21, 1, 2, 0, 185, 46, 42, 3, 37, 47, 21, 0, 60, 42, 14, 0, 72, 26, 38, 6, 186, 43, 117, 63, 32, 7, 3, 0, 3, 7, 2, 1, 2, 23, 16, 0, 2, 0, 95, 7, 3, 38, 17, 0, 2, 0, 29, 0, 11, 39, 8, 0, 22, 0, 12, 45, 20, 0, 19, 72, 200, 32, 32, 8, 2, 36, 18, 0, 50, 29, 113, 6, 2, 1, 2, 37, 22, 0, 26, 5, 2, 1, 2, 31, 15, 0, 328, 18, 16, 0, 2, 12, 2, 33, 125, 0, 80, 921, 103, 110, 18, 195, 2637, 96, 16, 1071, 18, 5, 26, 3994, 6, 582, 6842, 29, 1763, 568, 8, 30, 18, 78, 18, 29, 19, 47, 17, 3, 32, 20, 6, 18, 433, 44, 212, 63, 129, 74, 6, 0, 67, 12, 65, 1, 2, 0, 29, 6135, 9, 1237, 42, 9, 8936, 3, 2, 6, 2, 1, 2, 290, 16, 0, 30, 2, 3, 0, 15, 3, 9, 395, 2309, 106, 6, 12, 4, 8, 8, 9, 5991, 84, 2, 70, 2, 1, 3, 0, 3, 1, 3, 3, 2, 11, 2, 0, 2, 6, 2, 64, 2, 3, 3, 7, 2, 6, 2, 27, 2, 3, 2, 4, 2, 0, 4, 6, 2, 339, 3, 24, 2, 24, 2, 30, 2, 24, 2, 30, 2, 24, 2, 30, 2, 24, 2, 30, 2, 24, 2, 7, 1845, 30, 7, 5, 262, 61, 147, 44, 11, 6, 17, 0, 322, 29, 19, 43, 485, 27, 229, 29, 3, 0, 496, 6, 2, 3, 2, 1, 2, 14, 2, 196, 60, 67, 8, 0, 1205, 3, 2, 26, 2, 1, 2, 0, 3, 0, 2, 9, 2, 3, 2, 0, 2, 0, 7, 0, 5, 0, 2, 0, 2, 0, 2, 2, 2, 1, 2, 0, 3, 0, 2, 0, 2, 0, 2, 0, 2, 0, 2, 1, 2, 0, 3, 3, 2, 6, 2, 3, 2, 3, 2, 0, 2, 9, 2, 16, 6, 2, 2, 4, 2, 16, 4421, 42719, 33, 4153, 7, 221, 3, 5761, 15, 7472, 16, 621, 2467, 541, 1507, 4938, 6, 4191];
var nonASCIIidentifierChars = "‌‍·̀-ͯ·҃-֑҇-ׇֽֿׁׂׅׄؐ-ًؚ-٩ٰۖ-ۜ۟-۪ۤۧۨ-ۭ۰-۹ܑܰ-݊ަ-ް߀-߉߫-߽߳ࠖ-࠙ࠛ-ࠣࠥ-ࠧࠩ-࡙࠭-࡛ࢗ-࢟࣊-ࣣ࣡-ःऺ-़ा-ॏ॑-ॗॢॣ०-९ঁ-ঃ়া-ৄেৈো-্ৗৢৣ০-৯৾ਁ-ਃ਼ਾ-ੂੇੈੋ-੍ੑ੦-ੱੵઁ-ઃ઼ા-ૅે-ૉો-્ૢૣ૦-૯ૺ-૿ଁ-ଃ଼ା-ୄେୈୋ-୍୕-ୗୢୣ୦-୯ஂா-ூெ-ைொ-்ௗ௦-௯ఀ-ఄ఼ా-ౄె-ైొ-్ౕౖౢౣ౦-౯ಁ-ಃ಼ಾ-ೄೆ-ೈೊ-್ೕೖೢೣ೦-೯ೳഀ-ഃ഻഼ാ-ൄെ-ൈൊ-്ൗൢൣ൦-൯ඁ-ඃ්ා-ුූෘ-ෟ෦-෯ෲෳัิ-ฺ็-๎๐-๙ັິ-ຼ່-໎໐-໙༘༙༠-༩༹༵༷༾༿ཱ-྄྆྇ྍ-ྗྙ-ྼ࿆ါ-ှ၀-၉ၖ-ၙၞ-ၠၢ-ၤၧ-ၭၱ-ၴႂ-ႍႏ-ႝ፝-፟፩-፱ᜒ-᜕ᜲ-᜴ᝒᝓᝲᝳ឴-៓៝០-៩᠋-᠍᠏-᠙ᢩᤠ-ᤫᤰ-᤻᥆-᥏᧐-᧚ᨗ-ᨛᩕ-ᩞ᩠-᩿᩼-᪉᪐-᪙᪰-᪽ᪿ-ᫎᬀ-ᬄ᬴-᭄᭐-᭙᭫-᭳ᮀ-ᮂᮡ-ᮭ᮰-᮹᯦-᯳ᰤ-᰷᱀-᱉᱐-᱙᳐-᳔᳒-᳨᳭᳴᳷-᳹᷀-᷿‌‍‿⁀⁔⃐-⃥⃜⃡-⃰⳯-⵿⳱ⷠ-〪ⷿ-゙゚〯・꘠-꘩꙯ꙴ-꙽ꚞꚟ꛰꛱ꠂ꠆ꠋꠣ-ꠧ꠬ꢀꢁꢴ-ꣅ꣐-꣙꣠-꣱ꣿ-꤉ꤦ-꤭ꥇ-꥓ꦀ-ꦃ꦳-꧀꧐-꧙ꧥ꧰-꧹ꨩ-ꨶꩃꩌꩍ꩐-꩙ꩻ-ꩽꪰꪲ-ꪴꪷꪸꪾ꪿꫁ꫫ-ꫯꫵ꫶ꯣ-ꯪ꯬꯭꯰-꯹ﬞ︀-️︠-︯︳︴﹍-﹏０-９＿･";
var nonASCIIidentifierStartChars = "ªµºÀ-ÖØ-öø-ˁˆ-ˑˠ-ˤˬˮͰ-ʹͶͷͺ-ͽͿΆΈ-ΊΌΎ-ΡΣ-ϵϷ-ҁҊ-ԯԱ-Ֆՙՠ-ֈא-תׯ-ײؠ-يٮٯٱ-ۓەۥۦۮۯۺ-ۼۿܐܒ-ܯݍ-ޥޱߊ-ߪߴߵߺࠀ-ࠕࠚࠤࠨࡀ-ࡘࡠ-ࡪࡰ-ࢇࢉ-ࢎࢠ-ࣉऄ-हऽॐक़-ॡॱ-ঀঅ-ঌএঐও-নপ-রলশ-হঽৎড়ঢ়য়-ৡৰৱৼਅ-ਊਏਐਓ-ਨਪ-ਰਲਲ਼ਵਸ਼ਸਹਖ਼-ੜਫ਼ੲ-ੴઅ-ઍએ-ઑઓ-નપ-રલળવ-હઽૐૠૡૹଅ-ଌଏଐଓ-ନପ-ରଲଳଵ-ହଽଡ଼ଢ଼ୟ-ୡୱஃஅ-ஊஎ-ஐஒ-கஙசஜஞடணதந-பம-ஹௐఅ-ఌఎ-ఐఒ-నప-హఽౘ-ౚౝౠౡಀಅ-ಌಎ-ಐಒ-ನಪ-ಳವ-ಹಽೝೞೠೡೱೲഄ-ഌഎ-ഐഒ-ഺഽൎൔ-ൖൟ-ൡൺ-ൿඅ-ඖක-නඳ-රලව-ෆก-ะาำเ-ๆກຂຄຆ-ຊຌ-ຣລວ-ະາຳຽເ-ໄໆໜ-ໟༀཀ-ཇཉ-ཬྈ-ྌက-ဪဿၐ-ၕၚ-ၝၡၥၦၮ-ၰၵ-ႁႎႠ-ჅჇჍა-ჺჼ-ቈቊ-ቍቐ-ቖቘቚ-ቝበ-ኈኊ-ኍነ-ኰኲ-ኵኸ-ኾዀዂ-ዅወ-ዖዘ-ጐጒ-ጕጘ-ፚᎀ-ᎏᎠ-Ᏽᏸ-ᏽᐁ-ᙬᙯ-ᙿᚁ-ᚚᚠ-ᛪᛮ-ᛸᜀ-ᜑᜟ-ᜱᝀ-ᝑᝠ-ᝬᝮ-ᝰក-ឳៗៜᠠ-ᡸᢀ-ᢨᢪᢰ-ᣵᤀ-ᤞᥐ-ᥭᥰ-ᥴᦀ-ᦫᦰ-ᧉᨀ-ᨖᨠ-ᩔᪧᬅ-ᬳᭅ-ᭌᮃ-ᮠᮮᮯᮺ-ᯥᰀ-ᰣᱍ-ᱏᱚ-ᱽᲀ-ᲊᲐ-ᲺᲽ-Ჿᳩ-ᳬᳮ-ᳳᳵᳶᳺᴀ-ᶿḀ-ἕἘ-Ἕἠ-ὅὈ-Ὅὐ-ὗὙὛὝὟ-ώᾀ-ᾴᾶ-ᾼιῂ-ῄῆ-ῌῐ-ΐῖ-Ίῠ-Ῥῲ-ῴῶ-ῼⁱⁿₐ-ₜℂℇℊ-ℓℕ℘-ℝℤΩℨK-ℹℼ-ℿⅅ-ⅉⅎⅠ-ↈⰀ-ⳤⳫ-ⳮⳲⳳⴀ-ⴥⴧⴭⴰ-ⵧⵯⶀ-ⶖⶠ-ⶦⶨ-ⶮⶰ-ⶶⶸ-ⶾⷀ-ⷆⷈ-ⷎⷐ-ⷖⷘ-ⷞ々-〇〡-〩〱-〵〸-〼ぁ-ゖ゛-ゟァ-ヺー-ヿㄅ-ㄯㄱ-ㆎㆠ-ㆿㇰ-ㇿ㐀-䶿一-ꒌꓐ-ꓽꔀ-ꘌꘐ-ꘟꘪꘫꙀ-ꙮꙿ-ꚝꚠ-ꛯꜗ-ꜟꜢ-ꞈꞋ-ꟍꟐꟑꟓꟕ-Ƛꟲ-ꠁꠃ-ꠅꠇ-ꠊꠌ-ꠢꡀ-ꡳꢂ-ꢳꣲ-ꣷꣻꣽꣾꤊ-ꤥꤰ-ꥆꥠ-ꥼꦄ-ꦲꧏꧠ-ꧤꧦ-ꧯꧺ-ꧾꨀ-ꨨꩀ-ꩂꩄ-ꩋꩠ-ꩶꩺꩾ-ꪯꪱꪵꪶꪹ-ꪽꫀꫂꫛ-ꫝꫠ-ꫪꫲ-ꫴꬁ-ꬆꬉ-ꬎꬑ-ꬖꬠ-ꬦꬨ-ꬮꬰ-ꭚꭜ-ꭩꭰ-ꯢ가-힣ힰ-ퟆퟋ-ퟻ豈-舘並-龎ﬀ-ﬆﬓ-ﬗיִײַ-ﬨשׁ-זּטּ-לּמּנּסּףּפּצּ-ﮱﯓ-ﴽﵐ-ﶏﶒ-ﷇﷰ-ﷻﹰ-ﹴﹶ-ﻼＡ-Ｚａ-ｚｦ-ﾾￂ-ￇￊ-ￏￒ-ￗￚ-ￜ";
var reservedWords = {
  3: "abstract boolean byte char class double enum export extends final float goto implements import int interface long native package private protected public short static super synchronized throws transient volatile",
  5: "class enum extends super const export import",
  6: "enum",
  strict: "implements interface let package private protected public static yield",
  strictBind: "eval arguments"
};
var ecma5AndLessKeywords = "break case catch continue debugger default do else finally for function if return switch throw try var while with null true false instanceof typeof void delete new in this";
var keywords$1 = {
  5: ecma5AndLessKeywords,
  "5module": ecma5AndLessKeywords + " export import",
  6: ecma5AndLessKeywords + " const class extends export import super"
};
var keywordRelationalOperator = /^in(stanceof)?$/;
var nonASCIIidentifierStart = new RegExp("[" + nonASCIIidentifierStartChars + "]");
var nonASCIIidentifier = new RegExp("[" + nonASCIIidentifierStartChars + nonASCIIidentifierChars + "]");
function isInAstralSet(code3, set3) {
  var pos = 65536;
  for (var i3 = 0; i3 < set3.length; i3 += 2) {
    pos += set3[i3];
    if (pos > code3) {
      return false;
    }
    pos += set3[i3 + 1];
    if (pos >= code3) {
      return true;
    }
  }
  return false;
}
function isIdentifierStart(code3, astral) {
  if (code3 < 65) {
    return code3 === 36;
  }
  if (code3 < 91) {
    return true;
  }
  if (code3 < 97) {
    return code3 === 95;
  }
  if (code3 < 123) {
    return true;
  }
  if (code3 <= 65535) {
    return code3 >= 170 && nonASCIIidentifierStart.test(String.fromCharCode(code3));
  }
  if (astral === false) {
    return false;
  }
  return isInAstralSet(code3, astralIdentifierStartCodes);
}
function isIdentifierChar(code3, astral) {
  if (code3 < 48) {
    return code3 === 36;
  }
  if (code3 < 58) {
    return true;
  }
  if (code3 < 65) {
    return false;
  }
  if (code3 < 91) {
    return true;
  }
  if (code3 < 97) {
    return code3 === 95;
  }
  if (code3 < 123) {
    return true;
  }
  if (code3 <= 65535) {
    return code3 >= 170 && nonASCIIidentifier.test(String.fromCharCode(code3));
  }
  if (astral === false) {
    return false;
  }
  return isInAstralSet(code3, astralIdentifierStartCodes) || isInAstralSet(code3, astralIdentifierCodes);
}
var TokenType = function TokenType2(label4, conf) {
  if (conf === void 0) conf = {};
  this.label = label4;
  this.keyword = conf.keyword;
  this.beforeExpr = !!conf.beforeExpr;
  this.startsExpr = !!conf.startsExpr;
  this.isLoop = !!conf.isLoop;
  this.isAssign = !!conf.isAssign;
  this.prefix = !!conf.prefix;
  this.postfix = !!conf.postfix;
  this.binop = conf.binop || null;
  this.updateContext = null;
};
function binop(name2, prec) {
  return new TokenType(name2, { beforeExpr: true, binop: prec });
}
var beforeExpr = { beforeExpr: true };
var startsExpr = { startsExpr: true };
var keywords = {};
function kw(name2, options) {
  if (options === void 0) options = {};
  options.keyword = name2;
  return keywords[name2] = new TokenType(name2, options);
}
var types$1 = {
  num: new TokenType("num", startsExpr),
  regexp: new TokenType("regexp", startsExpr),
  string: new TokenType("string", startsExpr),
  name: new TokenType("name", startsExpr),
  privateId: new TokenType("privateId", startsExpr),
  eof: new TokenType("eof"),
  // Punctuation token types.
  bracketL: new TokenType("[", { beforeExpr: true, startsExpr: true }),
  bracketR: new TokenType("]"),
  braceL: new TokenType("{", { beforeExpr: true, startsExpr: true }),
  braceR: new TokenType("}"),
  parenL: new TokenType("(", { beforeExpr: true, startsExpr: true }),
  parenR: new TokenType(")"),
  comma: new TokenType(",", beforeExpr),
  semi: new TokenType(";", beforeExpr),
  colon: new TokenType(":", beforeExpr),
  dot: new TokenType("."),
  question: new TokenType("?", beforeExpr),
  questionDot: new TokenType("?."),
  arrow: new TokenType("=>", beforeExpr),
  template: new TokenType("template"),
  invalidTemplate: new TokenType("invalidTemplate"),
  ellipsis: new TokenType("...", beforeExpr),
  backQuote: new TokenType("`", startsExpr),
  dollarBraceL: new TokenType("${", { beforeExpr: true, startsExpr: true }),
  // Operators. These carry several kinds of properties to help the
  // parser use them properly (the presence of these properties is
  // what categorizes them as operators).
  //
  // `binop`, when present, specifies that this operator is a binary
  // operator, and will refer to its precedence.
  //
  // `prefix` and `postfix` mark the operator as a prefix or postfix
  // unary operator.
  //
  // `isAssign` marks all of `=`, `+=`, `-=` etcetera, which act as
  // binary operators with a very low precedence, that should result
  // in AssignmentExpression nodes.
  eq: new TokenType("=", { beforeExpr: true, isAssign: true }),
  assign: new TokenType("_=", { beforeExpr: true, isAssign: true }),
  incDec: new TokenType("++/--", { prefix: true, postfix: true, startsExpr: true }),
  prefix: new TokenType("!/~", { beforeExpr: true, prefix: true, startsExpr: true }),
  logicalOR: binop("||", 1),
  logicalAND: binop("&&", 2),
  bitwiseOR: binop("|", 3),
  bitwiseXOR: binop("^", 4),
  bitwiseAND: binop("&", 5),
  equality: binop("==/!=/===/!==", 6),
  relational: binop("</>/<=/>=", 7),
  bitShift: binop("<</>>/>>>", 8),
  plusMin: new TokenType("+/-", { beforeExpr: true, binop: 9, prefix: true, startsExpr: true }),
  modulo: binop("%", 10),
  star: binop("*", 10),
  slash: binop("/", 10),
  starstar: new TokenType("**", { beforeExpr: true }),
  coalesce: binop("??", 1),
  // Keyword token types.
  _break: kw("break"),
  _case: kw("case", beforeExpr),
  _catch: kw("catch"),
  _continue: kw("continue"),
  _debugger: kw("debugger"),
  _default: kw("default", beforeExpr),
  _do: kw("do", { isLoop: true, beforeExpr: true }),
  _else: kw("else", beforeExpr),
  _finally: kw("finally"),
  _for: kw("for", { isLoop: true }),
  _function: kw("function", startsExpr),
  _if: kw("if"),
  _return: kw("return", beforeExpr),
  _switch: kw("switch"),
  _throw: kw("throw", beforeExpr),
  _try: kw("try"),
  _var: kw("var"),
  _const: kw("const"),
  _while: kw("while", { isLoop: true }),
  _with: kw("with"),
  _new: kw("new", { beforeExpr: true, startsExpr: true }),
  _this: kw("this", startsExpr),
  _super: kw("super", startsExpr),
  _class: kw("class", startsExpr),
  _extends: kw("extends", beforeExpr),
  _export: kw("export"),
  _import: kw("import", startsExpr),
  _null: kw("null", startsExpr),
  _true: kw("true", startsExpr),
  _false: kw("false", startsExpr),
  _in: kw("in", { beforeExpr: true, binop: 7 }),
  _instanceof: kw("instanceof", { beforeExpr: true, binop: 7 }),
  _typeof: kw("typeof", { beforeExpr: true, prefix: true, startsExpr: true }),
  _void: kw("void", { beforeExpr: true, prefix: true, startsExpr: true }),
  _delete: kw("delete", { beforeExpr: true, prefix: true, startsExpr: true })
};
var lineBreak = /\r\n?|\n|\u2028|\u2029/;
var lineBreakG = new RegExp(lineBreak.source, "g");
function isNewLine(code3) {
  return code3 === 10 || code3 === 13 || code3 === 8232 || code3 === 8233;
}
function nextLineBreak(code3, from, end) {
  if (end === void 0) end = code3.length;
  for (var i3 = from; i3 < end; i3++) {
    var next = code3.charCodeAt(i3);
    if (isNewLine(next)) {
      return i3 < end - 1 && next === 13 && code3.charCodeAt(i3 + 1) === 10 ? i3 + 2 : i3 + 1;
    }
  }
  return -1;
}
var nonASCIIwhitespace = /[\u1680\u2000-\u200a\u202f\u205f\u3000\ufeff]/;
var skipWhiteSpace = /(?:\s|\/\/.*|\/\*[^]*?\*\/)*/g;
var ref = Object.prototype;
var hasOwnProperty3 = ref.hasOwnProperty;
var toString3 = ref.toString;
var hasOwn = Object.hasOwn || function(obj, propName) {
  return hasOwnProperty3.call(obj, propName);
};
var isArray = Array.isArray || function(obj) {
  return toString3.call(obj) === "[object Array]";
};
var regexpCache = /* @__PURE__ */ Object.create(null);
function wordsRegexp(words) {
  return regexpCache[words] || (regexpCache[words] = new RegExp("^(?:" + words.replace(/ /g, "|") + ")$"));
}
function codePointToString(code3) {
  if (code3 <= 65535) {
    return String.fromCharCode(code3);
  }
  code3 -= 65536;
  return String.fromCharCode((code3 >> 10) + 55296, (code3 & 1023) + 56320);
}
var loneSurrogate = /(?:[\uD800-\uDBFF](?![\uDC00-\uDFFF])|(?:[^\uD800-\uDBFF]|^)[\uDC00-\uDFFF])/;
var Position = function Position2(line, col) {
  this.line = line;
  this.column = col;
};
Position.prototype.offset = function offset4(n3) {
  return new Position(this.line, this.column + n3);
};
var SourceLocation = function SourceLocation2(p2, start2, end) {
  this.start = start2;
  this.end = end;
  if (p2.sourceFile !== null) {
    this.source = p2.sourceFile;
  }
};
function getLineInfo(input, offset5) {
  for (var line = 1, cur = 0; ; ) {
    var nextBreak = nextLineBreak(input, cur, offset5);
    if (nextBreak < 0) {
      return new Position(line, offset5 - cur);
    }
    ++line;
    cur = nextBreak;
  }
}
var defaultOptions2 = {
  // `ecmaVersion` indicates the ECMAScript version to parse. Must be
  // either 3, 5, 6 (or 2015), 7 (2016), 8 (2017), 9 (2018), 10
  // (2019), 11 (2020), 12 (2021), 13 (2022), 14 (2023), or `"latest"`
  // (the latest version the library supports). This influences
  // support for strict mode, the set of reserved words, and support
  // for new syntax features.
  ecmaVersion: null,
  // `sourceType` indicates the mode the code should be parsed in.
  // Can be either `"script"` or `"module"`. This influences global
  // strict mode and parsing of `import` and `export` declarations.
  sourceType: "script",
  // `onInsertedSemicolon` can be a callback that will be called when
  // a semicolon is automatically inserted. It will be passed the
  // position of the inserted semicolon as an offset, and if
  // `locations` is enabled, it is given the location as a `{line,
  // column}` object as second argument.
  onInsertedSemicolon: null,
  // `onTrailingComma` is similar to `onInsertedSemicolon`, but for
  // trailing commas.
  onTrailingComma: null,
  // By default, reserved words are only enforced if ecmaVersion >= 5.
  // Set `allowReserved` to a boolean value to explicitly turn this on
  // an off. When this option has the value "never", reserved words
  // and keywords can also not be used as property names.
  allowReserved: null,
  // When enabled, a return at the top level is not considered an
  // error.
  allowReturnOutsideFunction: false,
  // When enabled, import/export statements are not constrained to
  // appearing at the top of the program, and an import.meta expression
  // in a script isn't considered an error.
  allowImportExportEverywhere: false,
  // By default, await identifiers are allowed to appear at the top-level scope only if ecmaVersion >= 2022.
  // When enabled, await identifiers are allowed to appear at the top-level scope,
  // but they are still not allowed in non-async functions.
  allowAwaitOutsideFunction: null,
  // When enabled, super identifiers are not constrained to
  // appearing in methods and do not raise an error when they appear elsewhere.
  allowSuperOutsideMethod: null,
  // When enabled, hashbang directive in the beginning of file is
  // allowed and treated as a line comment. Enabled by default when
  // `ecmaVersion` >= 2023.
  allowHashBang: false,
  // By default, the parser will verify that private properties are
  // only used in places where they are valid and have been declared.
  // Set this to false to turn such checks off.
  checkPrivateFields: true,
  // When `locations` is on, `loc` properties holding objects with
  // `start` and `end` properties in `{line, column}` form (with
  // line being 1-based and column 0-based) will be attached to the
  // nodes.
  locations: false,
  // A function can be passed as `onToken` option, which will
  // cause Acorn to call that function with object in the same
  // format as tokens returned from `tokenizer().getToken()`. Note
  // that you are not allowed to call the parser from the
  // callback—that will corrupt its internal state.
  onToken: null,
  // A function can be passed as `onComment` option, which will
  // cause Acorn to call that function with `(block, text, start,
  // end)` parameters whenever a comment is skipped. `block` is a
  // boolean indicating whether this is a block (`/* */`) comment,
  // `text` is the content of the comment, and `start` and `end` are
  // character offsets that denote the start and end of the comment.
  // When the `locations` option is on, two more parameters are
  // passed, the full `{line, column}` locations of the start and
  // end of the comments. Note that you are not allowed to call the
  // parser from the callback—that will corrupt its internal state.
  // When this option has an array as value, objects representing the
  // comments are pushed to it.
  onComment: null,
  // Nodes have their start and end characters offsets recorded in
  // `start` and `end` properties (directly on the node, rather than
  // the `loc` object, which holds line/column data. To also add a
  // [semi-standardized][range] `range` property holding a `[start,
  // end]` array with the same numbers, set the `ranges` option to
  // `true`.
  //
  // [range]: https://bugzilla.mozilla.org/show_bug.cgi?id=745678
  ranges: false,
  // It is possible to parse multiple files into a single AST by
  // passing the tree produced by parsing the first file as
  // `program` option in subsequent parses. This will add the
  // toplevel forms of the parsed file to the `Program` (top) node
  // of an existing parse tree.
  program: null,
  // When `locations` is on, you can pass this to record the source
  // file in every node's `loc` object.
  sourceFile: null,
  // This value, if given, is stored in every node, whether
  // `locations` is on or off.
  directSourceFile: null,
  // When enabled, parenthesized expressions are represented by
  // (non-standard) ParenthesizedExpression nodes
  preserveParens: false
};
var warnedAboutEcmaVersion = false;
function getOptions(opts) {
  var options = {};
  for (var opt in defaultOptions2) {
    options[opt] = opts && hasOwn(opts, opt) ? opts[opt] : defaultOptions2[opt];
  }
  if (options.ecmaVersion === "latest") {
    options.ecmaVersion = 1e8;
  } else if (options.ecmaVersion == null) {
    if (!warnedAboutEcmaVersion && typeof console === "object" && console.warn) {
      warnedAboutEcmaVersion = true;
      console.warn("Since Acorn 8.0.0, options.ecmaVersion is required.\nDefaulting to 2020, but this will stop working in the future.");
    }
    options.ecmaVersion = 11;
  } else if (options.ecmaVersion >= 2015) {
    options.ecmaVersion -= 2009;
  }
  if (options.allowReserved == null) {
    options.allowReserved = options.ecmaVersion < 5;
  }
  if (!opts || opts.allowHashBang == null) {
    options.allowHashBang = options.ecmaVersion >= 14;
  }
  if (isArray(options.onToken)) {
    var tokens = options.onToken;
    options.onToken = function(token) {
      return tokens.push(token);
    };
  }
  if (isArray(options.onComment)) {
    options.onComment = pushComment(options, options.onComment);
  }
  return options;
}
function pushComment(options, array) {
  return function(block, text4, start2, end, startLoc, endLoc) {
    var comment2 = {
      type: block ? "Block" : "Line",
      value: text4,
      start: start2,
      end
    };
    if (options.locations) {
      comment2.loc = new SourceLocation(this, startLoc, endLoc);
    }
    if (options.ranges) {
      comment2.range = [start2, end];
    }
    array.push(comment2);
  };
}
var SCOPE_TOP = 1;
var SCOPE_FUNCTION = 2;
var SCOPE_ASYNC = 4;
var SCOPE_GENERATOR = 8;
var SCOPE_ARROW = 16;
var SCOPE_SIMPLE_CATCH = 32;
var SCOPE_SUPER = 64;
var SCOPE_DIRECT_SUPER = 128;
var SCOPE_CLASS_STATIC_BLOCK = 256;
var SCOPE_VAR = SCOPE_TOP | SCOPE_FUNCTION | SCOPE_CLASS_STATIC_BLOCK;
function functionFlags(async, generator) {
  return SCOPE_FUNCTION | (async ? SCOPE_ASYNC : 0) | (generator ? SCOPE_GENERATOR : 0);
}
var BIND_NONE = 0;
var BIND_VAR = 1;
var BIND_LEXICAL = 2;
var BIND_FUNCTION = 3;
var BIND_SIMPLE_CATCH = 4;
var BIND_OUTSIDE = 5;
var Parser = function Parser2(options, input, startPos) {
  this.options = options = getOptions(options);
  this.sourceFile = options.sourceFile;
  this.keywords = wordsRegexp(keywords$1[options.ecmaVersion >= 6 ? 6 : options.sourceType === "module" ? "5module" : 5]);
  var reserved = "";
  if (options.allowReserved !== true) {
    reserved = reservedWords[options.ecmaVersion >= 6 ? 6 : options.ecmaVersion === 5 ? 5 : 3];
    if (options.sourceType === "module") {
      reserved += " await";
    }
  }
  this.reservedWords = wordsRegexp(reserved);
  var reservedStrict = (reserved ? reserved + " " : "") + reservedWords.strict;
  this.reservedWordsStrict = wordsRegexp(reservedStrict);
  this.reservedWordsStrictBind = wordsRegexp(reservedStrict + " " + reservedWords.strictBind);
  this.input = String(input);
  this.containsEsc = false;
  if (startPos) {
    this.pos = startPos;
    this.lineStart = this.input.lastIndexOf("\n", startPos - 1) + 1;
    this.curLine = this.input.slice(0, this.lineStart).split(lineBreak).length;
  } else {
    this.pos = this.lineStart = 0;
    this.curLine = 1;
  }
  this.type = types$1.eof;
  this.value = null;
  this.start = this.end = this.pos;
  this.startLoc = this.endLoc = this.curPosition();
  this.lastTokEndLoc = this.lastTokStartLoc = null;
  this.lastTokStart = this.lastTokEnd = this.pos;
  this.context = this.initialContext();
  this.exprAllowed = true;
  this.inModule = options.sourceType === "module";
  this.strict = this.inModule || this.strictDirective(this.pos);
  this.potentialArrowAt = -1;
  this.potentialArrowInForAwait = false;
  this.yieldPos = this.awaitPos = this.awaitIdentPos = 0;
  this.labels = [];
  this.undefinedExports = /* @__PURE__ */ Object.create(null);
  if (this.pos === 0 && options.allowHashBang && this.input.slice(0, 2) === "#!") {
    this.skipLineComment(2);
  }
  this.scopeStack = [];
  this.enterScope(SCOPE_TOP);
  this.regexpState = null;
  this.privateNameStack = [];
};
var prototypeAccessors = { inFunction: { configurable: true }, inGenerator: { configurable: true }, inAsync: { configurable: true }, canAwait: { configurable: true }, allowSuper: { configurable: true }, allowDirectSuper: { configurable: true }, treatFunctionsAsVar: { configurable: true }, allowNewDotTarget: { configurable: true }, inClassStaticBlock: { configurable: true } };
Parser.prototype.parse = function parse3() {
  var node2 = this.options.program || this.startNode();
  this.nextToken();
  return this.parseTopLevel(node2);
};
prototypeAccessors.inFunction.get = function() {
  return (this.currentVarScope().flags & SCOPE_FUNCTION) > 0;
};
prototypeAccessors.inGenerator.get = function() {
  return (this.currentVarScope().flags & SCOPE_GENERATOR) > 0 && !this.currentVarScope().inClassFieldInit;
};
prototypeAccessors.inAsync.get = function() {
  return (this.currentVarScope().flags & SCOPE_ASYNC) > 0 && !this.currentVarScope().inClassFieldInit;
};
prototypeAccessors.canAwait.get = function() {
  for (var i3 = this.scopeStack.length - 1; i3 >= 0; i3--) {
    var scope = this.scopeStack[i3];
    if (scope.inClassFieldInit || scope.flags & SCOPE_CLASS_STATIC_BLOCK) {
      return false;
    }
    if (scope.flags & SCOPE_FUNCTION) {
      return (scope.flags & SCOPE_ASYNC) > 0;
    }
  }
  return this.inModule && this.options.ecmaVersion >= 13 || this.options.allowAwaitOutsideFunction;
};
prototypeAccessors.allowSuper.get = function() {
  var ref2 = this.currentThisScope();
  var flags = ref2.flags;
  var inClassFieldInit = ref2.inClassFieldInit;
  return (flags & SCOPE_SUPER) > 0 || inClassFieldInit || this.options.allowSuperOutsideMethod;
};
prototypeAccessors.allowDirectSuper.get = function() {
  return (this.currentThisScope().flags & SCOPE_DIRECT_SUPER) > 0;
};
prototypeAccessors.treatFunctionsAsVar.get = function() {
  return this.treatFunctionsAsVarInScope(this.currentScope());
};
prototypeAccessors.allowNewDotTarget.get = function() {
  var ref2 = this.currentThisScope();
  var flags = ref2.flags;
  var inClassFieldInit = ref2.inClassFieldInit;
  return (flags & (SCOPE_FUNCTION | SCOPE_CLASS_STATIC_BLOCK)) > 0 || inClassFieldInit;
};
prototypeAccessors.inClassStaticBlock.get = function() {
  return (this.currentVarScope().flags & SCOPE_CLASS_STATIC_BLOCK) > 0;
};
Parser.extend = function extend3() {
  var plugins = [], len = arguments.length;
  while (len--) plugins[len] = arguments[len];
  var cls = this;
  for (var i3 = 0; i3 < plugins.length; i3++) {
    cls = plugins[i3](cls);
  }
  return cls;
};
Parser.parse = function parse4(input, options) {
  return new this(options, input).parse();
};
Parser.parseExpressionAt = function parseExpressionAt(input, pos, options) {
  var parser = new this(options, input, pos);
  parser.nextToken();
  return parser.parseExpression();
};
Parser.tokenizer = function tokenizer(input, options) {
  return new this(options, input);
};
Object.defineProperties(Parser.prototype, prototypeAccessors);
var pp$9 = Parser.prototype;
var literal = /^(?:'((?:\\[^]|[^'\\])*?)'|"((?:\\[^]|[^"\\])*?)")/;
pp$9.strictDirective = function(start2) {
  if (this.options.ecmaVersion < 5) {
    return false;
  }
  for (; ; ) {
    skipWhiteSpace.lastIndex = start2;
    start2 += skipWhiteSpace.exec(this.input)[0].length;
    var match = literal.exec(this.input.slice(start2));
    if (!match) {
      return false;
    }
    if ((match[1] || match[2]) === "use strict") {
      skipWhiteSpace.lastIndex = start2 + match[0].length;
      var spaceAfter = skipWhiteSpace.exec(this.input), end = spaceAfter.index + spaceAfter[0].length;
      var next = this.input.charAt(end);
      return next === ";" || next === "}" || lineBreak.test(spaceAfter[0]) && !(/[(`.[+\-/*%<>=,?^&]/.test(next) || next === "!" && this.input.charAt(end + 1) === "=");
    }
    start2 += match[0].length;
    skipWhiteSpace.lastIndex = start2;
    start2 += skipWhiteSpace.exec(this.input)[0].length;
    if (this.input[start2] === ";") {
      start2++;
    }
  }
};
pp$9.eat = function(type2) {
  if (this.type === type2) {
    this.next();
    return true;
  } else {
    return false;
  }
};
pp$9.isContextual = function(name2) {
  return this.type === types$1.name && this.value === name2 && !this.containsEsc;
};
pp$9.eatContextual = function(name2) {
  if (!this.isContextual(name2)) {
    return false;
  }
  this.next();
  return true;
};
pp$9.expectContextual = function(name2) {
  if (!this.eatContextual(name2)) {
    this.unexpected();
  }
};
pp$9.canInsertSemicolon = function() {
  return this.type === types$1.eof || this.type === types$1.braceR || lineBreak.test(this.input.slice(this.lastTokEnd, this.start));
};
pp$9.insertSemicolon = function() {
  if (this.canInsertSemicolon()) {
    if (this.options.onInsertedSemicolon) {
      this.options.onInsertedSemicolon(this.lastTokEnd, this.lastTokEndLoc);
    }
    return true;
  }
};
pp$9.semicolon = function() {
  if (!this.eat(types$1.semi) && !this.insertSemicolon()) {
    this.unexpected();
  }
};
pp$9.afterTrailingComma = function(tokType, notNext) {
  if (this.type === tokType) {
    if (this.options.onTrailingComma) {
      this.options.onTrailingComma(this.lastTokStart, this.lastTokStartLoc);
    }
    if (!notNext) {
      this.next();
    }
    return true;
  }
};
pp$9.expect = function(type2) {
  this.eat(type2) || this.unexpected();
};
pp$9.unexpected = function(pos) {
  this.raise(pos != null ? pos : this.start, "Unexpected token");
};
var DestructuringErrors = function DestructuringErrors2() {
  this.shorthandAssign = this.trailingComma = this.parenthesizedAssign = this.parenthesizedBind = this.doubleProto = -1;
};
pp$9.checkPatternErrors = function(refDestructuringErrors, isAssign) {
  if (!refDestructuringErrors) {
    return;
  }
  if (refDestructuringErrors.trailingComma > -1) {
    this.raiseRecoverable(refDestructuringErrors.trailingComma, "Comma is not permitted after the rest element");
  }
  var parens = isAssign ? refDestructuringErrors.parenthesizedAssign : refDestructuringErrors.parenthesizedBind;
  if (parens > -1) {
    this.raiseRecoverable(parens, isAssign ? "Assigning to rvalue" : "Parenthesized pattern");
  }
};
pp$9.checkExpressionErrors = function(refDestructuringErrors, andThrow) {
  if (!refDestructuringErrors) {
    return false;
  }
  var shorthandAssign = refDestructuringErrors.shorthandAssign;
  var doubleProto = refDestructuringErrors.doubleProto;
  if (!andThrow) {
    return shorthandAssign >= 0 || doubleProto >= 0;
  }
  if (shorthandAssign >= 0) {
    this.raise(shorthandAssign, "Shorthand property assignments are valid only in destructuring patterns");
  }
  if (doubleProto >= 0) {
    this.raiseRecoverable(doubleProto, "Redefinition of __proto__ property");
  }
};
pp$9.checkYieldAwaitInDefaultParams = function() {
  if (this.yieldPos && (!this.awaitPos || this.yieldPos < this.awaitPos)) {
    this.raise(this.yieldPos, "Yield expression cannot be a default value");
  }
  if (this.awaitPos) {
    this.raise(this.awaitPos, "Await expression cannot be a default value");
  }
};
pp$9.isSimpleAssignTarget = function(expr) {
  if (expr.type === "ParenthesizedExpression") {
    return this.isSimpleAssignTarget(expr.expression);
  }
  return expr.type === "Identifier" || expr.type === "MemberExpression";
};
var pp$8 = Parser.prototype;
pp$8.parseTopLevel = function(node2) {
  var exports = /* @__PURE__ */ Object.create(null);
  if (!node2.body) {
    node2.body = [];
  }
  while (this.type !== types$1.eof) {
    var stmt = this.parseStatement(null, true, exports);
    node2.body.push(stmt);
  }
  if (this.inModule) {
    for (var i3 = 0, list4 = Object.keys(this.undefinedExports); i3 < list4.length; i3 += 1) {
      var name2 = list4[i3];
      this.raiseRecoverable(this.undefinedExports[name2].start, "Export '" + name2 + "' is not defined");
    }
  }
  this.adaptDirectivePrologue(node2.body);
  this.next();
  node2.sourceType = this.options.sourceType;
  return this.finishNode(node2, "Program");
};
var loopLabel = { kind: "loop" };
var switchLabel = { kind: "switch" };
pp$8.isLet = function(context) {
  if (this.options.ecmaVersion < 6 || !this.isContextual("let")) {
    return false;
  }
  skipWhiteSpace.lastIndex = this.pos;
  var skip = skipWhiteSpace.exec(this.input);
  var next = this.pos + skip[0].length, nextCh = this.input.charCodeAt(next);
  if (nextCh === 91 || nextCh === 92) {
    return true;
  }
  if (context) {
    return false;
  }
  if (nextCh === 123 || nextCh > 55295 && nextCh < 56320) {
    return true;
  }
  if (isIdentifierStart(nextCh, true)) {
    var pos = next + 1;
    while (isIdentifierChar(nextCh = this.input.charCodeAt(pos), true)) {
      ++pos;
    }
    if (nextCh === 92 || nextCh > 55295 && nextCh < 56320) {
      return true;
    }
    var ident = this.input.slice(next, pos);
    if (!keywordRelationalOperator.test(ident)) {
      return true;
    }
  }
  return false;
};
pp$8.isAsyncFunction = function() {
  if (this.options.ecmaVersion < 8 || !this.isContextual("async")) {
    return false;
  }
  skipWhiteSpace.lastIndex = this.pos;
  var skip = skipWhiteSpace.exec(this.input);
  var next = this.pos + skip[0].length, after;
  return !lineBreak.test(this.input.slice(this.pos, next)) && this.input.slice(next, next + 8) === "function" && (next + 8 === this.input.length || !(isIdentifierChar(after = this.input.charCodeAt(next + 8)) || after > 55295 && after < 56320));
};
pp$8.parseStatement = function(context, topLevel, exports) {
  var starttype = this.type, node2 = this.startNode(), kind;
  if (this.isLet(context)) {
    starttype = types$1._var;
    kind = "let";
  }
  switch (starttype) {
    case types$1._break:
    case types$1._continue:
      return this.parseBreakContinueStatement(node2, starttype.keyword);
    case types$1._debugger:
      return this.parseDebuggerStatement(node2);
    case types$1._do:
      return this.parseDoStatement(node2);
    case types$1._for:
      return this.parseForStatement(node2);
    case types$1._function:
      if (context && (this.strict || context !== "if" && context !== "label") && this.options.ecmaVersion >= 6) {
        this.unexpected();
      }
      return this.parseFunctionStatement(node2, false, !context);
    case types$1._class:
      if (context) {
        this.unexpected();
      }
      return this.parseClass(node2, true);
    case types$1._if:
      return this.parseIfStatement(node2);
    case types$1._return:
      return this.parseReturnStatement(node2);
    case types$1._switch:
      return this.parseSwitchStatement(node2);
    case types$1._throw:
      return this.parseThrowStatement(node2);
    case types$1._try:
      return this.parseTryStatement(node2);
    case types$1._const:
    case types$1._var:
      kind = kind || this.value;
      if (context && kind !== "var") {
        this.unexpected();
      }
      return this.parseVarStatement(node2, kind);
    case types$1._while:
      return this.parseWhileStatement(node2);
    case types$1._with:
      return this.parseWithStatement(node2);
    case types$1.braceL:
      return this.parseBlock(true, node2);
    case types$1.semi:
      return this.parseEmptyStatement(node2);
    case types$1._export:
    case types$1._import:
      if (this.options.ecmaVersion > 10 && starttype === types$1._import) {
        skipWhiteSpace.lastIndex = this.pos;
        var skip = skipWhiteSpace.exec(this.input);
        var next = this.pos + skip[0].length, nextCh = this.input.charCodeAt(next);
        if (nextCh === 40 || nextCh === 46) {
          return this.parseExpressionStatement(node2, this.parseExpression());
        }
      }
      if (!this.options.allowImportExportEverywhere) {
        if (!topLevel) {
          this.raise(this.start, "'import' and 'export' may only appear at the top level");
        }
        if (!this.inModule) {
          this.raise(this.start, "'import' and 'export' may appear only with 'sourceType: module'");
        }
      }
      return starttype === types$1._import ? this.parseImport(node2) : this.parseExport(node2, exports);
    default:
      if (this.isAsyncFunction()) {
        if (context) {
          this.unexpected();
        }
        this.next();
        return this.parseFunctionStatement(node2, true, !context);
      }
      var maybeName = this.value, expr = this.parseExpression();
      if (starttype === types$1.name && expr.type === "Identifier" && this.eat(types$1.colon)) {
        return this.parseLabeledStatement(node2, maybeName, expr, context);
      } else {
        return this.parseExpressionStatement(node2, expr);
      }
  }
};
pp$8.parseBreakContinueStatement = function(node2, keyword) {
  var isBreak = keyword === "break";
  this.next();
  if (this.eat(types$1.semi) || this.insertSemicolon()) {
    node2.label = null;
  } else if (this.type !== types$1.name) {
    this.unexpected();
  } else {
    node2.label = this.parseIdent();
    this.semicolon();
  }
  var i3 = 0;
  for (; i3 < this.labels.length; ++i3) {
    var lab = this.labels[i3];
    if (node2.label == null || lab.name === node2.label.name) {
      if (lab.kind != null && (isBreak || lab.kind === "loop")) {
        break;
      }
      if (node2.label && isBreak) {
        break;
      }
    }
  }
  if (i3 === this.labels.length) {
    this.raise(node2.start, "Unsyntactic " + keyword);
  }
  return this.finishNode(node2, isBreak ? "BreakStatement" : "ContinueStatement");
};
pp$8.parseDebuggerStatement = function(node2) {
  this.next();
  this.semicolon();
  return this.finishNode(node2, "DebuggerStatement");
};
pp$8.parseDoStatement = function(node2) {
  this.next();
  this.labels.push(loopLabel);
  node2.body = this.parseStatement("do");
  this.labels.pop();
  this.expect(types$1._while);
  node2.test = this.parseParenExpression();
  if (this.options.ecmaVersion >= 6) {
    this.eat(types$1.semi);
  } else {
    this.semicolon();
  }
  return this.finishNode(node2, "DoWhileStatement");
};
pp$8.parseForStatement = function(node2) {
  this.next();
  var awaitAt = this.options.ecmaVersion >= 9 && this.canAwait && this.eatContextual("await") ? this.lastTokStart : -1;
  this.labels.push(loopLabel);
  this.enterScope(0);
  this.expect(types$1.parenL);
  if (this.type === types$1.semi) {
    if (awaitAt > -1) {
      this.unexpected(awaitAt);
    }
    return this.parseFor(node2, null);
  }
  var isLet = this.isLet();
  if (this.type === types$1._var || this.type === types$1._const || isLet) {
    var init$1 = this.startNode(), kind = isLet ? "let" : this.value;
    this.next();
    this.parseVar(init$1, true, kind);
    this.finishNode(init$1, "VariableDeclaration");
    if ((this.type === types$1._in || this.options.ecmaVersion >= 6 && this.isContextual("of")) && init$1.declarations.length === 1) {
      if (this.options.ecmaVersion >= 9) {
        if (this.type === types$1._in) {
          if (awaitAt > -1) {
            this.unexpected(awaitAt);
          }
        } else {
          node2.await = awaitAt > -1;
        }
      }
      return this.parseForIn(node2, init$1);
    }
    if (awaitAt > -1) {
      this.unexpected(awaitAt);
    }
    return this.parseFor(node2, init$1);
  }
  var startsWithLet = this.isContextual("let"), isForOf = false;
  var containsEsc = this.containsEsc;
  var refDestructuringErrors = new DestructuringErrors();
  var initPos = this.start;
  var init = awaitAt > -1 ? this.parseExprSubscripts(refDestructuringErrors, "await") : this.parseExpression(true, refDestructuringErrors);
  if (this.type === types$1._in || (isForOf = this.options.ecmaVersion >= 6 && this.isContextual("of"))) {
    if (awaitAt > -1) {
      if (this.type === types$1._in) {
        this.unexpected(awaitAt);
      }
      node2.await = true;
    } else if (isForOf && this.options.ecmaVersion >= 8) {
      if (init.start === initPos && !containsEsc && init.type === "Identifier" && init.name === "async") {
        this.unexpected();
      } else if (this.options.ecmaVersion >= 9) {
        node2.await = false;
      }
    }
    if (startsWithLet && isForOf) {
      this.raise(init.start, "The left-hand side of a for-of loop may not start with 'let'.");
    }
    this.toAssignable(init, false, refDestructuringErrors);
    this.checkLValPattern(init);
    return this.parseForIn(node2, init);
  } else {
    this.checkExpressionErrors(refDestructuringErrors, true);
  }
  if (awaitAt > -1) {
    this.unexpected(awaitAt);
  }
  return this.parseFor(node2, init);
};
pp$8.parseFunctionStatement = function(node2, isAsync, declarationPosition) {
  this.next();
  return this.parseFunction(node2, FUNC_STATEMENT | (declarationPosition ? 0 : FUNC_HANGING_STATEMENT), false, isAsync);
};
pp$8.parseIfStatement = function(node2) {
  this.next();
  node2.test = this.parseParenExpression();
  node2.consequent = this.parseStatement("if");
  node2.alternate = this.eat(types$1._else) ? this.parseStatement("if") : null;
  return this.finishNode(node2, "IfStatement");
};
pp$8.parseReturnStatement = function(node2) {
  if (!this.inFunction && !this.options.allowReturnOutsideFunction) {
    this.raise(this.start, "'return' outside of function");
  }
  this.next();
  if (this.eat(types$1.semi) || this.insertSemicolon()) {
    node2.argument = null;
  } else {
    node2.argument = this.parseExpression();
    this.semicolon();
  }
  return this.finishNode(node2, "ReturnStatement");
};
pp$8.parseSwitchStatement = function(node2) {
  this.next();
  node2.discriminant = this.parseParenExpression();
  node2.cases = [];
  this.expect(types$1.braceL);
  this.labels.push(switchLabel);
  this.enterScope(0);
  var cur;
  for (var sawDefault = false; this.type !== types$1.braceR; ) {
    if (this.type === types$1._case || this.type === types$1._default) {
      var isCase = this.type === types$1._case;
      if (cur) {
        this.finishNode(cur, "SwitchCase");
      }
      node2.cases.push(cur = this.startNode());
      cur.consequent = [];
      this.next();
      if (isCase) {
        cur.test = this.parseExpression();
      } else {
        if (sawDefault) {
          this.raiseRecoverable(this.lastTokStart, "Multiple default clauses");
        }
        sawDefault = true;
        cur.test = null;
      }
      this.expect(types$1.colon);
    } else {
      if (!cur) {
        this.unexpected();
      }
      cur.consequent.push(this.parseStatement(null));
    }
  }
  this.exitScope();
  if (cur) {
    this.finishNode(cur, "SwitchCase");
  }
  this.next();
  this.labels.pop();
  return this.finishNode(node2, "SwitchStatement");
};
pp$8.parseThrowStatement = function(node2) {
  this.next();
  if (lineBreak.test(this.input.slice(this.lastTokEnd, this.start))) {
    this.raise(this.lastTokEnd, "Illegal newline after throw");
  }
  node2.argument = this.parseExpression();
  this.semicolon();
  return this.finishNode(node2, "ThrowStatement");
};
var empty$1 = [];
pp$8.parseCatchClauseParam = function() {
  var param = this.parseBindingAtom();
  var simple = param.type === "Identifier";
  this.enterScope(simple ? SCOPE_SIMPLE_CATCH : 0);
  this.checkLValPattern(param, simple ? BIND_SIMPLE_CATCH : BIND_LEXICAL);
  this.expect(types$1.parenR);
  return param;
};
pp$8.parseTryStatement = function(node2) {
  this.next();
  node2.block = this.parseBlock();
  node2.handler = null;
  if (this.type === types$1._catch) {
    var clause = this.startNode();
    this.next();
    if (this.eat(types$1.parenL)) {
      clause.param = this.parseCatchClauseParam();
    } else {
      if (this.options.ecmaVersion < 10) {
        this.unexpected();
      }
      clause.param = null;
      this.enterScope(0);
    }
    clause.body = this.parseBlock(false);
    this.exitScope();
    node2.handler = this.finishNode(clause, "CatchClause");
  }
  node2.finalizer = this.eat(types$1._finally) ? this.parseBlock() : null;
  if (!node2.handler && !node2.finalizer) {
    this.raise(node2.start, "Missing catch or finally clause");
  }
  return this.finishNode(node2, "TryStatement");
};
pp$8.parseVarStatement = function(node2, kind, allowMissingInitializer) {
  this.next();
  this.parseVar(node2, false, kind, allowMissingInitializer);
  this.semicolon();
  return this.finishNode(node2, "VariableDeclaration");
};
pp$8.parseWhileStatement = function(node2) {
  this.next();
  node2.test = this.parseParenExpression();
  this.labels.push(loopLabel);
  node2.body = this.parseStatement("while");
  this.labels.pop();
  return this.finishNode(node2, "WhileStatement");
};
pp$8.parseWithStatement = function(node2) {
  if (this.strict) {
    this.raise(this.start, "'with' in strict mode");
  }
  this.next();
  node2.object = this.parseParenExpression();
  node2.body = this.parseStatement("with");
  return this.finishNode(node2, "WithStatement");
};
pp$8.parseEmptyStatement = function(node2) {
  this.next();
  return this.finishNode(node2, "EmptyStatement");
};
pp$8.parseLabeledStatement = function(node2, maybeName, expr, context) {
  for (var i$1 = 0, list4 = this.labels; i$1 < list4.length; i$1 += 1) {
    var label4 = list4[i$1];
    if (label4.name === maybeName) {
      this.raise(expr.start, "Label '" + maybeName + "' is already declared");
    }
  }
  var kind = this.type.isLoop ? "loop" : this.type === types$1._switch ? "switch" : null;
  for (var i3 = this.labels.length - 1; i3 >= 0; i3--) {
    var label$1 = this.labels[i3];
    if (label$1.statementStart === node2.start) {
      label$1.statementStart = this.start;
      label$1.kind = kind;
    } else {
      break;
    }
  }
  this.labels.push({ name: maybeName, kind, statementStart: this.start });
  node2.body = this.parseStatement(context ? context.indexOf("label") === -1 ? context + "label" : context : "label");
  this.labels.pop();
  node2.label = expr;
  return this.finishNode(node2, "LabeledStatement");
};
pp$8.parseExpressionStatement = function(node2, expr) {
  node2.expression = expr;
  this.semicolon();
  return this.finishNode(node2, "ExpressionStatement");
};
pp$8.parseBlock = function(createNewLexicalScope, node2, exitStrict) {
  if (createNewLexicalScope === void 0) createNewLexicalScope = true;
  if (node2 === void 0) node2 = this.startNode();
  node2.body = [];
  this.expect(types$1.braceL);
  if (createNewLexicalScope) {
    this.enterScope(0);
  }
  while (this.type !== types$1.braceR) {
    var stmt = this.parseStatement(null);
    node2.body.push(stmt);
  }
  if (exitStrict) {
    this.strict = false;
  }
  this.next();
  if (createNewLexicalScope) {
    this.exitScope();
  }
  return this.finishNode(node2, "BlockStatement");
};
pp$8.parseFor = function(node2, init) {
  node2.init = init;
  this.expect(types$1.semi);
  node2.test = this.type === types$1.semi ? null : this.parseExpression();
  this.expect(types$1.semi);
  node2.update = this.type === types$1.parenR ? null : this.parseExpression();
  this.expect(types$1.parenR);
  node2.body = this.parseStatement("for");
  this.exitScope();
  this.labels.pop();
  return this.finishNode(node2, "ForStatement");
};
pp$8.parseForIn = function(node2, init) {
  var isForIn = this.type === types$1._in;
  this.next();
  if (init.type === "VariableDeclaration" && init.declarations[0].init != null && (!isForIn || this.options.ecmaVersion < 8 || this.strict || init.kind !== "var" || init.declarations[0].id.type !== "Identifier")) {
    this.raise(
      init.start,
      (isForIn ? "for-in" : "for-of") + " loop variable declaration may not have an initializer"
    );
  }
  node2.left = init;
  node2.right = isForIn ? this.parseExpression() : this.parseMaybeAssign();
  this.expect(types$1.parenR);
  node2.body = this.parseStatement("for");
  this.exitScope();
  this.labels.pop();
  return this.finishNode(node2, isForIn ? "ForInStatement" : "ForOfStatement");
};
pp$8.parseVar = function(node2, isFor, kind, allowMissingInitializer) {
  node2.declarations = [];
  node2.kind = kind;
  for (; ; ) {
    var decl = this.startNode();
    this.parseVarId(decl, kind);
    if (this.eat(types$1.eq)) {
      decl.init = this.parseMaybeAssign(isFor);
    } else if (!allowMissingInitializer && kind === "const" && !(this.type === types$1._in || this.options.ecmaVersion >= 6 && this.isContextual("of"))) {
      this.unexpected();
    } else if (!allowMissingInitializer && decl.id.type !== "Identifier" && !(isFor && (this.type === types$1._in || this.isContextual("of")))) {
      this.raise(this.lastTokEnd, "Complex binding patterns require an initialization value");
    } else {
      decl.init = null;
    }
    node2.declarations.push(this.finishNode(decl, "VariableDeclarator"));
    if (!this.eat(types$1.comma)) {
      break;
    }
  }
  return node2;
};
pp$8.parseVarId = function(decl, kind) {
  decl.id = this.parseBindingAtom();
  this.checkLValPattern(decl.id, kind === "var" ? BIND_VAR : BIND_LEXICAL, false);
};
var FUNC_STATEMENT = 1;
var FUNC_HANGING_STATEMENT = 2;
var FUNC_NULLABLE_ID = 4;
pp$8.parseFunction = function(node2, statement, allowExpressionBody, isAsync, forInit) {
  this.initFunction(node2);
  if (this.options.ecmaVersion >= 9 || this.options.ecmaVersion >= 6 && !isAsync) {
    if (this.type === types$1.star && statement & FUNC_HANGING_STATEMENT) {
      this.unexpected();
    }
    node2.generator = this.eat(types$1.star);
  }
  if (this.options.ecmaVersion >= 8) {
    node2.async = !!isAsync;
  }
  if (statement & FUNC_STATEMENT) {
    node2.id = statement & FUNC_NULLABLE_ID && this.type !== types$1.name ? null : this.parseIdent();
    if (node2.id && !(statement & FUNC_HANGING_STATEMENT)) {
      this.checkLValSimple(node2.id, this.strict || node2.generator || node2.async ? this.treatFunctionsAsVar ? BIND_VAR : BIND_LEXICAL : BIND_FUNCTION);
    }
  }
  var oldYieldPos = this.yieldPos, oldAwaitPos = this.awaitPos, oldAwaitIdentPos = this.awaitIdentPos;
  this.yieldPos = 0;
  this.awaitPos = 0;
  this.awaitIdentPos = 0;
  this.enterScope(functionFlags(node2.async, node2.generator));
  if (!(statement & FUNC_STATEMENT)) {
    node2.id = this.type === types$1.name ? this.parseIdent() : null;
  }
  this.parseFunctionParams(node2);
  this.parseFunctionBody(node2, allowExpressionBody, false, forInit);
  this.yieldPos = oldYieldPos;
  this.awaitPos = oldAwaitPos;
  this.awaitIdentPos = oldAwaitIdentPos;
  return this.finishNode(node2, statement & FUNC_STATEMENT ? "FunctionDeclaration" : "FunctionExpression");
};
pp$8.parseFunctionParams = function(node2) {
  this.expect(types$1.parenL);
  node2.params = this.parseBindingList(types$1.parenR, false, this.options.ecmaVersion >= 8);
  this.checkYieldAwaitInDefaultParams();
};
pp$8.parseClass = function(node2, isStatement) {
  this.next();
  var oldStrict = this.strict;
  this.strict = true;
  this.parseClassId(node2, isStatement);
  this.parseClassSuper(node2);
  var privateNameMap = this.enterClassBody();
  var classBody = this.startNode();
  var hadConstructor = false;
  classBody.body = [];
  this.expect(types$1.braceL);
  while (this.type !== types$1.braceR) {
    var element2 = this.parseClassElement(node2.superClass !== null);
    if (element2) {
      classBody.body.push(element2);
      if (element2.type === "MethodDefinition" && element2.kind === "constructor") {
        if (hadConstructor) {
          this.raiseRecoverable(element2.start, "Duplicate constructor in the same class");
        }
        hadConstructor = true;
      } else if (element2.key && element2.key.type === "PrivateIdentifier" && isPrivateNameConflicted(privateNameMap, element2)) {
        this.raiseRecoverable(element2.key.start, "Identifier '#" + element2.key.name + "' has already been declared");
      }
    }
  }
  this.strict = oldStrict;
  this.next();
  node2.body = this.finishNode(classBody, "ClassBody");
  this.exitClassBody();
  return this.finishNode(node2, isStatement ? "ClassDeclaration" : "ClassExpression");
};
pp$8.parseClassElement = function(constructorAllowsSuper) {
  if (this.eat(types$1.semi)) {
    return null;
  }
  var ecmaVersion = this.options.ecmaVersion;
  var node2 = this.startNode();
  var keyName = "";
  var isGenerator = false;
  var isAsync = false;
  var kind = "method";
  var isStatic = false;
  if (this.eatContextual("static")) {
    if (ecmaVersion >= 13 && this.eat(types$1.braceL)) {
      this.parseClassStaticBlock(node2);
      return node2;
    }
    if (this.isClassElementNameStart() || this.type === types$1.star) {
      isStatic = true;
    } else {
      keyName = "static";
    }
  }
  node2.static = isStatic;
  if (!keyName && ecmaVersion >= 8 && this.eatContextual("async")) {
    if ((this.isClassElementNameStart() || this.type === types$1.star) && !this.canInsertSemicolon()) {
      isAsync = true;
    } else {
      keyName = "async";
    }
  }
  if (!keyName && (ecmaVersion >= 9 || !isAsync) && this.eat(types$1.star)) {
    isGenerator = true;
  }
  if (!keyName && !isAsync && !isGenerator) {
    var lastValue = this.value;
    if (this.eatContextual("get") || this.eatContextual("set")) {
      if (this.isClassElementNameStart()) {
        kind = lastValue;
      } else {
        keyName = lastValue;
      }
    }
  }
  if (keyName) {
    node2.computed = false;
    node2.key = this.startNodeAt(this.lastTokStart, this.lastTokStartLoc);
    node2.key.name = keyName;
    this.finishNode(node2.key, "Identifier");
  } else {
    this.parseClassElementName(node2);
  }
  if (ecmaVersion < 13 || this.type === types$1.parenL || kind !== "method" || isGenerator || isAsync) {
    var isConstructor = !node2.static && checkKeyName(node2, "constructor");
    var allowsDirectSuper = isConstructor && constructorAllowsSuper;
    if (isConstructor && kind !== "method") {
      this.raise(node2.key.start, "Constructor can't have get/set modifier");
    }
    node2.kind = isConstructor ? "constructor" : kind;
    this.parseClassMethod(node2, isGenerator, isAsync, allowsDirectSuper);
  } else {
    this.parseClassField(node2);
  }
  return node2;
};
pp$8.isClassElementNameStart = function() {
  return this.type === types$1.name || this.type === types$1.privateId || this.type === types$1.num || this.type === types$1.string || this.type === types$1.bracketL || this.type.keyword;
};
pp$8.parseClassElementName = function(element2) {
  if (this.type === types$1.privateId) {
    if (this.value === "constructor") {
      this.raise(this.start, "Classes can't have an element named '#constructor'");
    }
    element2.computed = false;
    element2.key = this.parsePrivateIdent();
  } else {
    this.parsePropertyName(element2);
  }
};
pp$8.parseClassMethod = function(method, isGenerator, isAsync, allowsDirectSuper) {
  var key2 = method.key;
  if (method.kind === "constructor") {
    if (isGenerator) {
      this.raise(key2.start, "Constructor can't be a generator");
    }
    if (isAsync) {
      this.raise(key2.start, "Constructor can't be an async method");
    }
  } else if (method.static && checkKeyName(method, "prototype")) {
    this.raise(key2.start, "Classes may not have a static property named prototype");
  }
  var value2 = method.value = this.parseMethod(isGenerator, isAsync, allowsDirectSuper);
  if (method.kind === "get" && value2.params.length !== 0) {
    this.raiseRecoverable(value2.start, "getter should have no params");
  }
  if (method.kind === "set" && value2.params.length !== 1) {
    this.raiseRecoverable(value2.start, "setter should have exactly one param");
  }
  if (method.kind === "set" && value2.params[0].type === "RestElement") {
    this.raiseRecoverable(value2.params[0].start, "Setter cannot use rest params");
  }
  return this.finishNode(method, "MethodDefinition");
};
pp$8.parseClassField = function(field) {
  if (checkKeyName(field, "constructor")) {
    this.raise(field.key.start, "Classes can't have a field named 'constructor'");
  } else if (field.static && checkKeyName(field, "prototype")) {
    this.raise(field.key.start, "Classes can't have a static field named 'prototype'");
  }
  if (this.eat(types$1.eq)) {
    var scope = this.currentThisScope();
    var inClassFieldInit = scope.inClassFieldInit;
    scope.inClassFieldInit = true;
    field.value = this.parseMaybeAssign();
    scope.inClassFieldInit = inClassFieldInit;
  } else {
    field.value = null;
  }
  this.semicolon();
  return this.finishNode(field, "PropertyDefinition");
};
pp$8.parseClassStaticBlock = function(node2) {
  node2.body = [];
  var oldLabels = this.labels;
  this.labels = [];
  this.enterScope(SCOPE_CLASS_STATIC_BLOCK | SCOPE_SUPER);
  while (this.type !== types$1.braceR) {
    var stmt = this.parseStatement(null);
    node2.body.push(stmt);
  }
  this.next();
  this.exitScope();
  this.labels = oldLabels;
  return this.finishNode(node2, "StaticBlock");
};
pp$8.parseClassId = function(node2, isStatement) {
  if (this.type === types$1.name) {
    node2.id = this.parseIdent();
    if (isStatement) {
      this.checkLValSimple(node2.id, BIND_LEXICAL, false);
    }
  } else {
    if (isStatement === true) {
      this.unexpected();
    }
    node2.id = null;
  }
};
pp$8.parseClassSuper = function(node2) {
  node2.superClass = this.eat(types$1._extends) ? this.parseExprSubscripts(null, false) : null;
};
pp$8.enterClassBody = function() {
  var element2 = { declared: /* @__PURE__ */ Object.create(null), used: [] };
  this.privateNameStack.push(element2);
  return element2.declared;
};
pp$8.exitClassBody = function() {
  var ref2 = this.privateNameStack.pop();
  var declared = ref2.declared;
  var used = ref2.used;
  if (!this.options.checkPrivateFields) {
    return;
  }
  var len = this.privateNameStack.length;
  var parent = len === 0 ? null : this.privateNameStack[len - 1];
  for (var i3 = 0; i3 < used.length; ++i3) {
    var id = used[i3];
    if (!hasOwn(declared, id.name)) {
      if (parent) {
        parent.used.push(id);
      } else {
        this.raiseRecoverable(id.start, "Private field '#" + id.name + "' must be declared in an enclosing class");
      }
    }
  }
};
function isPrivateNameConflicted(privateNameMap, element2) {
  var name2 = element2.key.name;
  var curr = privateNameMap[name2];
  var next = "true";
  if (element2.type === "MethodDefinition" && (element2.kind === "get" || element2.kind === "set")) {
    next = (element2.static ? "s" : "i") + element2.kind;
  }
  if (curr === "iget" && next === "iset" || curr === "iset" && next === "iget" || curr === "sget" && next === "sset" || curr === "sset" && next === "sget") {
    privateNameMap[name2] = "true";
    return false;
  } else if (!curr) {
    privateNameMap[name2] = next;
    return false;
  } else {
    return true;
  }
}
function checkKeyName(node2, name2) {
  var computed = node2.computed;
  var key2 = node2.key;
  return !computed && (key2.type === "Identifier" && key2.name === name2 || key2.type === "Literal" && key2.value === name2);
}
pp$8.parseExportAllDeclaration = function(node2, exports) {
  if (this.options.ecmaVersion >= 11) {
    if (this.eatContextual("as")) {
      node2.exported = this.parseModuleExportName();
      this.checkExport(exports, node2.exported, this.lastTokStart);
    } else {
      node2.exported = null;
    }
  }
  this.expectContextual("from");
  if (this.type !== types$1.string) {
    this.unexpected();
  }
  node2.source = this.parseExprAtom();
  if (this.options.ecmaVersion >= 16) {
    node2.attributes = this.parseWithClause();
  }
  this.semicolon();
  return this.finishNode(node2, "ExportAllDeclaration");
};
pp$8.parseExport = function(node2, exports) {
  this.next();
  if (this.eat(types$1.star)) {
    return this.parseExportAllDeclaration(node2, exports);
  }
  if (this.eat(types$1._default)) {
    this.checkExport(exports, "default", this.lastTokStart);
    node2.declaration = this.parseExportDefaultDeclaration();
    return this.finishNode(node2, "ExportDefaultDeclaration");
  }
  if (this.shouldParseExportStatement()) {
    node2.declaration = this.parseExportDeclaration(node2);
    if (node2.declaration.type === "VariableDeclaration") {
      this.checkVariableExport(exports, node2.declaration.declarations);
    } else {
      this.checkExport(exports, node2.declaration.id, node2.declaration.id.start);
    }
    node2.specifiers = [];
    node2.source = null;
  } else {
    node2.declaration = null;
    node2.specifiers = this.parseExportSpecifiers(exports);
    if (this.eatContextual("from")) {
      if (this.type !== types$1.string) {
        this.unexpected();
      }
      node2.source = this.parseExprAtom();
      if (this.options.ecmaVersion >= 16) {
        node2.attributes = this.parseWithClause();
      }
    } else {
      for (var i3 = 0, list4 = node2.specifiers; i3 < list4.length; i3 += 1) {
        var spec = list4[i3];
        this.checkUnreserved(spec.local);
        this.checkLocalExport(spec.local);
        if (spec.local.type === "Literal") {
          this.raise(spec.local.start, "A string literal cannot be used as an exported binding without `from`.");
        }
      }
      node2.source = null;
    }
    this.semicolon();
  }
  return this.finishNode(node2, "ExportNamedDeclaration");
};
pp$8.parseExportDeclaration = function(node2) {
  return this.parseStatement(null);
};
pp$8.parseExportDefaultDeclaration = function() {
  var isAsync;
  if (this.type === types$1._function || (isAsync = this.isAsyncFunction())) {
    var fNode = this.startNode();
    this.next();
    if (isAsync) {
      this.next();
    }
    return this.parseFunction(fNode, FUNC_STATEMENT | FUNC_NULLABLE_ID, false, isAsync);
  } else if (this.type === types$1._class) {
    var cNode = this.startNode();
    return this.parseClass(cNode, "nullableID");
  } else {
    var declaration = this.parseMaybeAssign();
    this.semicolon();
    return declaration;
  }
};
pp$8.checkExport = function(exports, name2, pos) {
  if (!exports) {
    return;
  }
  if (typeof name2 !== "string") {
    name2 = name2.type === "Identifier" ? name2.name : name2.value;
  }
  if (hasOwn(exports, name2)) {
    this.raiseRecoverable(pos, "Duplicate export '" + name2 + "'");
  }
  exports[name2] = true;
};
pp$8.checkPatternExport = function(exports, pat) {
  var type2 = pat.type;
  if (type2 === "Identifier") {
    this.checkExport(exports, pat, pat.start);
  } else if (type2 === "ObjectPattern") {
    for (var i3 = 0, list4 = pat.properties; i3 < list4.length; i3 += 1) {
      var prop2 = list4[i3];
      this.checkPatternExport(exports, prop2);
    }
  } else if (type2 === "ArrayPattern") {
    for (var i$1 = 0, list$1 = pat.elements; i$1 < list$1.length; i$1 += 1) {
      var elt = list$1[i$1];
      if (elt) {
        this.checkPatternExport(exports, elt);
      }
    }
  } else if (type2 === "Property") {
    this.checkPatternExport(exports, pat.value);
  } else if (type2 === "AssignmentPattern") {
    this.checkPatternExport(exports, pat.left);
  } else if (type2 === "RestElement") {
    this.checkPatternExport(exports, pat.argument);
  }
};
pp$8.checkVariableExport = function(exports, decls) {
  if (!exports) {
    return;
  }
  for (var i3 = 0, list4 = decls; i3 < list4.length; i3 += 1) {
    var decl = list4[i3];
    this.checkPatternExport(exports, decl.id);
  }
};
pp$8.shouldParseExportStatement = function() {
  return this.type.keyword === "var" || this.type.keyword === "const" || this.type.keyword === "class" || this.type.keyword === "function" || this.isLet() || this.isAsyncFunction();
};
pp$8.parseExportSpecifier = function(exports) {
  var node2 = this.startNode();
  node2.local = this.parseModuleExportName();
  node2.exported = this.eatContextual("as") ? this.parseModuleExportName() : node2.local;
  this.checkExport(
    exports,
    node2.exported,
    node2.exported.start
  );
  return this.finishNode(node2, "ExportSpecifier");
};
pp$8.parseExportSpecifiers = function(exports) {
  var nodes = [], first = true;
  this.expect(types$1.braceL);
  while (!this.eat(types$1.braceR)) {
    if (!first) {
      this.expect(types$1.comma);
      if (this.afterTrailingComma(types$1.braceR)) {
        break;
      }
    } else {
      first = false;
    }
    nodes.push(this.parseExportSpecifier(exports));
  }
  return nodes;
};
pp$8.parseImport = function(node2) {
  this.next();
  if (this.type === types$1.string) {
    node2.specifiers = empty$1;
    node2.source = this.parseExprAtom();
  } else {
    node2.specifiers = this.parseImportSpecifiers();
    this.expectContextual("from");
    node2.source = this.type === types$1.string ? this.parseExprAtom() : this.unexpected();
  }
  if (this.options.ecmaVersion >= 16) {
    node2.attributes = this.parseWithClause();
  }
  this.semicolon();
  return this.finishNode(node2, "ImportDeclaration");
};
pp$8.parseImportSpecifier = function() {
  var node2 = this.startNode();
  node2.imported = this.parseModuleExportName();
  if (this.eatContextual("as")) {
    node2.local = this.parseIdent();
  } else {
    this.checkUnreserved(node2.imported);
    node2.local = node2.imported;
  }
  this.checkLValSimple(node2.local, BIND_LEXICAL);
  return this.finishNode(node2, "ImportSpecifier");
};
pp$8.parseImportDefaultSpecifier = function() {
  var node2 = this.startNode();
  node2.local = this.parseIdent();
  this.checkLValSimple(node2.local, BIND_LEXICAL);
  return this.finishNode(node2, "ImportDefaultSpecifier");
};
pp$8.parseImportNamespaceSpecifier = function() {
  var node2 = this.startNode();
  this.next();
  this.expectContextual("as");
  node2.local = this.parseIdent();
  this.checkLValSimple(node2.local, BIND_LEXICAL);
  return this.finishNode(node2, "ImportNamespaceSpecifier");
};
pp$8.parseImportSpecifiers = function() {
  var nodes = [], first = true;
  if (this.type === types$1.name) {
    nodes.push(this.parseImportDefaultSpecifier());
    if (!this.eat(types$1.comma)) {
      return nodes;
    }
  }
  if (this.type === types$1.star) {
    nodes.push(this.parseImportNamespaceSpecifier());
    return nodes;
  }
  this.expect(types$1.braceL);
  while (!this.eat(types$1.braceR)) {
    if (!first) {
      this.expect(types$1.comma);
      if (this.afterTrailingComma(types$1.braceR)) {
        break;
      }
    } else {
      first = false;
    }
    nodes.push(this.parseImportSpecifier());
  }
  return nodes;
};
pp$8.parseWithClause = function() {
  var nodes = [];
  if (!this.eat(types$1._with)) {
    return nodes;
  }
  this.expect(types$1.braceL);
  var attributeKeys = {};
  var first = true;
  while (!this.eat(types$1.braceR)) {
    if (!first) {
      this.expect(types$1.comma);
      if (this.afterTrailingComma(types$1.braceR)) {
        break;
      }
    } else {
      first = false;
    }
    var attr = this.parseImportAttribute();
    var keyName = attr.key.type === "Identifier" ? attr.key.name : attr.key.value;
    if (hasOwn(attributeKeys, keyName)) {
      this.raiseRecoverable(attr.key.start, "Duplicate attribute key '" + keyName + "'");
    }
    attributeKeys[keyName] = true;
    nodes.push(attr);
  }
  return nodes;
};
pp$8.parseImportAttribute = function() {
  var node2 = this.startNode();
  node2.key = this.type === types$1.string ? this.parseExprAtom() : this.parseIdent(this.options.allowReserved !== "never");
  this.expect(types$1.colon);
  if (this.type !== types$1.string) {
    this.unexpected();
  }
  node2.value = this.parseExprAtom();
  return this.finishNode(node2, "ImportAttribute");
};
pp$8.parseModuleExportName = function() {
  if (this.options.ecmaVersion >= 13 && this.type === types$1.string) {
    var stringLiteral = this.parseLiteral(this.value);
    if (loneSurrogate.test(stringLiteral.value)) {
      this.raise(stringLiteral.start, "An export name cannot include a lone surrogate.");
    }
    return stringLiteral;
  }
  return this.parseIdent(true);
};
pp$8.adaptDirectivePrologue = function(statements) {
  for (var i3 = 0; i3 < statements.length && this.isDirectiveCandidate(statements[i3]); ++i3) {
    statements[i3].directive = statements[i3].expression.raw.slice(1, -1);
  }
};
pp$8.isDirectiveCandidate = function(statement) {
  return this.options.ecmaVersion >= 5 && statement.type === "ExpressionStatement" && statement.expression.type === "Literal" && typeof statement.expression.value === "string" && // Reject parenthesized strings.
  (this.input[statement.start] === '"' || this.input[statement.start] === "'");
};
var pp$7 = Parser.prototype;
pp$7.toAssignable = function(node2, isBinding, refDestructuringErrors) {
  if (this.options.ecmaVersion >= 6 && node2) {
    switch (node2.type) {
      case "Identifier":
        if (this.inAsync && node2.name === "await") {
          this.raise(node2.start, "Cannot use 'await' as identifier inside an async function");
        }
        break;
      case "ObjectPattern":
      case "ArrayPattern":
      case "AssignmentPattern":
      case "RestElement":
        break;
      case "ObjectExpression":
        node2.type = "ObjectPattern";
        if (refDestructuringErrors) {
          this.checkPatternErrors(refDestructuringErrors, true);
        }
        for (var i3 = 0, list4 = node2.properties; i3 < list4.length; i3 += 1) {
          var prop2 = list4[i3];
          this.toAssignable(prop2, isBinding);
          if (prop2.type === "RestElement" && (prop2.argument.type === "ArrayPattern" || prop2.argument.type === "ObjectPattern")) {
            this.raise(prop2.argument.start, "Unexpected token");
          }
        }
        break;
      case "Property":
        if (node2.kind !== "init") {
          this.raise(node2.key.start, "Object pattern can't contain getter or setter");
        }
        this.toAssignable(node2.value, isBinding);
        break;
      case "ArrayExpression":
        node2.type = "ArrayPattern";
        if (refDestructuringErrors) {
          this.checkPatternErrors(refDestructuringErrors, true);
        }
        this.toAssignableList(node2.elements, isBinding);
        break;
      case "SpreadElement":
        node2.type = "RestElement";
        this.toAssignable(node2.argument, isBinding);
        if (node2.argument.type === "AssignmentPattern") {
          this.raise(node2.argument.start, "Rest elements cannot have a default value");
        }
        break;
      case "AssignmentExpression":
        if (node2.operator !== "=") {
          this.raise(node2.left.end, "Only '=' operator can be used for specifying default value.");
        }
        node2.type = "AssignmentPattern";
        delete node2.operator;
        this.toAssignable(node2.left, isBinding);
        break;
      case "ParenthesizedExpression":
        this.toAssignable(node2.expression, isBinding, refDestructuringErrors);
        break;
      case "ChainExpression":
        this.raiseRecoverable(node2.start, "Optional chaining cannot appear in left-hand side");
        break;
      case "MemberExpression":
        if (!isBinding) {
          break;
        }
      default:
        this.raise(node2.start, "Assigning to rvalue");
    }
  } else if (refDestructuringErrors) {
    this.checkPatternErrors(refDestructuringErrors, true);
  }
  return node2;
};
pp$7.toAssignableList = function(exprList, isBinding) {
  var end = exprList.length;
  for (var i3 = 0; i3 < end; i3++) {
    var elt = exprList[i3];
    if (elt) {
      this.toAssignable(elt, isBinding);
    }
  }
  if (end) {
    var last = exprList[end - 1];
    if (this.options.ecmaVersion === 6 && isBinding && last && last.type === "RestElement" && last.argument.type !== "Identifier") {
      this.unexpected(last.argument.start);
    }
  }
  return exprList;
};
pp$7.parseSpread = function(refDestructuringErrors) {
  var node2 = this.startNode();
  this.next();
  node2.argument = this.parseMaybeAssign(false, refDestructuringErrors);
  return this.finishNode(node2, "SpreadElement");
};
pp$7.parseRestBinding = function() {
  var node2 = this.startNode();
  this.next();
  if (this.options.ecmaVersion === 6 && this.type !== types$1.name) {
    this.unexpected();
  }
  node2.argument = this.parseBindingAtom();
  return this.finishNode(node2, "RestElement");
};
pp$7.parseBindingAtom = function() {
  if (this.options.ecmaVersion >= 6) {
    switch (this.type) {
      case types$1.bracketL:
        var node2 = this.startNode();
        this.next();
        node2.elements = this.parseBindingList(types$1.bracketR, true, true);
        return this.finishNode(node2, "ArrayPattern");
      case types$1.braceL:
        return this.parseObj(true);
    }
  }
  return this.parseIdent();
};
pp$7.parseBindingList = function(close2, allowEmpty, allowTrailingComma, allowModifiers) {
  var elts = [], first = true;
  while (!this.eat(close2)) {
    if (first) {
      first = false;
    } else {
      this.expect(types$1.comma);
    }
    if (allowEmpty && this.type === types$1.comma) {
      elts.push(null);
    } else if (allowTrailingComma && this.afterTrailingComma(close2)) {
      break;
    } else if (this.type === types$1.ellipsis) {
      var rest = this.parseRestBinding();
      this.parseBindingListItem(rest);
      elts.push(rest);
      if (this.type === types$1.comma) {
        this.raiseRecoverable(this.start, "Comma is not permitted after the rest element");
      }
      this.expect(close2);
      break;
    } else {
      elts.push(this.parseAssignableListItem(allowModifiers));
    }
  }
  return elts;
};
pp$7.parseAssignableListItem = function(allowModifiers) {
  var elem = this.parseMaybeDefault(this.start, this.startLoc);
  this.parseBindingListItem(elem);
  return elem;
};
pp$7.parseBindingListItem = function(param) {
  return param;
};
pp$7.parseMaybeDefault = function(startPos, startLoc, left) {
  left = left || this.parseBindingAtom();
  if (this.options.ecmaVersion < 6 || !this.eat(types$1.eq)) {
    return left;
  }
  var node2 = this.startNodeAt(startPos, startLoc);
  node2.left = left;
  node2.right = this.parseMaybeAssign();
  return this.finishNode(node2, "AssignmentPattern");
};
pp$7.checkLValSimple = function(expr, bindingType, checkClashes) {
  if (bindingType === void 0) bindingType = BIND_NONE;
  var isBind = bindingType !== BIND_NONE;
  switch (expr.type) {
    case "Identifier":
      if (this.strict && this.reservedWordsStrictBind.test(expr.name)) {
        this.raiseRecoverable(expr.start, (isBind ? "Binding " : "Assigning to ") + expr.name + " in strict mode");
      }
      if (isBind) {
        if (bindingType === BIND_LEXICAL && expr.name === "let") {
          this.raiseRecoverable(expr.start, "let is disallowed as a lexically bound name");
        }
        if (checkClashes) {
          if (hasOwn(checkClashes, expr.name)) {
            this.raiseRecoverable(expr.start, "Argument name clash");
          }
          checkClashes[expr.name] = true;
        }
        if (bindingType !== BIND_OUTSIDE) {
          this.declareName(expr.name, bindingType, expr.start);
        }
      }
      break;
    case "ChainExpression":
      this.raiseRecoverable(expr.start, "Optional chaining cannot appear in left-hand side");
      break;
    case "MemberExpression":
      if (isBind) {
        this.raiseRecoverable(expr.start, "Binding member expression");
      }
      break;
    case "ParenthesizedExpression":
      if (isBind) {
        this.raiseRecoverable(expr.start, "Binding parenthesized expression");
      }
      return this.checkLValSimple(expr.expression, bindingType, checkClashes);
    default:
      this.raise(expr.start, (isBind ? "Binding" : "Assigning to") + " rvalue");
  }
};
pp$7.checkLValPattern = function(expr, bindingType, checkClashes) {
  if (bindingType === void 0) bindingType = BIND_NONE;
  switch (expr.type) {
    case "ObjectPattern":
      for (var i3 = 0, list4 = expr.properties; i3 < list4.length; i3 += 1) {
        var prop2 = list4[i3];
        this.checkLValInnerPattern(prop2, bindingType, checkClashes);
      }
      break;
    case "ArrayPattern":
      for (var i$1 = 0, list$1 = expr.elements; i$1 < list$1.length; i$1 += 1) {
        var elem = list$1[i$1];
        if (elem) {
          this.checkLValInnerPattern(elem, bindingType, checkClashes);
        }
      }
      break;
    default:
      this.checkLValSimple(expr, bindingType, checkClashes);
  }
};
pp$7.checkLValInnerPattern = function(expr, bindingType, checkClashes) {
  if (bindingType === void 0) bindingType = BIND_NONE;
  switch (expr.type) {
    case "Property":
      this.checkLValInnerPattern(expr.value, bindingType, checkClashes);
      break;
    case "AssignmentPattern":
      this.checkLValPattern(expr.left, bindingType, checkClashes);
      break;
    case "RestElement":
      this.checkLValPattern(expr.argument, bindingType, checkClashes);
      break;
    default:
      this.checkLValPattern(expr, bindingType, checkClashes);
  }
};
var TokContext = function TokContext2(token, isExpr, preserveSpace, override, generator) {
  this.token = token;
  this.isExpr = !!isExpr;
  this.preserveSpace = !!preserveSpace;
  this.override = override;
  this.generator = !!generator;
};
var types3 = {
  b_stat: new TokContext("{", false),
  b_expr: new TokContext("{", true),
  b_tmpl: new TokContext("${", false),
  p_stat: new TokContext("(", false),
  p_expr: new TokContext("(", true),
  q_tmpl: new TokContext("`", true, true, function(p2) {
    return p2.tryReadTemplateToken();
  }),
  f_stat: new TokContext("function", false),
  f_expr: new TokContext("function", true),
  f_expr_gen: new TokContext("function", true, false, null, true),
  f_gen: new TokContext("function", false, false, null, true)
};
var pp$6 = Parser.prototype;
pp$6.initialContext = function() {
  return [types3.b_stat];
};
pp$6.curContext = function() {
  return this.context[this.context.length - 1];
};
pp$6.braceIsBlock = function(prevType) {
  var parent = this.curContext();
  if (parent === types3.f_expr || parent === types3.f_stat) {
    return true;
  }
  if (prevType === types$1.colon && (parent === types3.b_stat || parent === types3.b_expr)) {
    return !parent.isExpr;
  }
  if (prevType === types$1._return || prevType === types$1.name && this.exprAllowed) {
    return lineBreak.test(this.input.slice(this.lastTokEnd, this.start));
  }
  if (prevType === types$1._else || prevType === types$1.semi || prevType === types$1.eof || prevType === types$1.parenR || prevType === types$1.arrow) {
    return true;
  }
  if (prevType === types$1.braceL) {
    return parent === types3.b_stat;
  }
  if (prevType === types$1._var || prevType === types$1._const || prevType === types$1.name) {
    return false;
  }
  return !this.exprAllowed;
};
pp$6.inGeneratorContext = function() {
  for (var i3 = this.context.length - 1; i3 >= 1; i3--) {
    var context = this.context[i3];
    if (context.token === "function") {
      return context.generator;
    }
  }
  return false;
};
pp$6.updateContext = function(prevType) {
  var update, type2 = this.type;
  if (type2.keyword && prevType === types$1.dot) {
    this.exprAllowed = false;
  } else if (update = type2.updateContext) {
    update.call(this, prevType);
  } else {
    this.exprAllowed = type2.beforeExpr;
  }
};
pp$6.overrideContext = function(tokenCtx) {
  if (this.curContext() !== tokenCtx) {
    this.context[this.context.length - 1] = tokenCtx;
  }
};
types$1.parenR.updateContext = types$1.braceR.updateContext = function() {
  if (this.context.length === 1) {
    this.exprAllowed = true;
    return;
  }
  var out = this.context.pop();
  if (out === types3.b_stat && this.curContext().token === "function") {
    out = this.context.pop();
  }
  this.exprAllowed = !out.isExpr;
};
types$1.braceL.updateContext = function(prevType) {
  this.context.push(this.braceIsBlock(prevType) ? types3.b_stat : types3.b_expr);
  this.exprAllowed = true;
};
types$1.dollarBraceL.updateContext = function() {
  this.context.push(types3.b_tmpl);
  this.exprAllowed = true;
};
types$1.parenL.updateContext = function(prevType) {
  var statementParens = prevType === types$1._if || prevType === types$1._for || prevType === types$1._with || prevType === types$1._while;
  this.context.push(statementParens ? types3.p_stat : types3.p_expr);
  this.exprAllowed = true;
};
types$1.incDec.updateContext = function() {
};
types$1._function.updateContext = types$1._class.updateContext = function(prevType) {
  if (prevType.beforeExpr && prevType !== types$1._else && !(prevType === types$1.semi && this.curContext() !== types3.p_stat) && !(prevType === types$1._return && lineBreak.test(this.input.slice(this.lastTokEnd, this.start))) && !((prevType === types$1.colon || prevType === types$1.braceL) && this.curContext() === types3.b_stat)) {
    this.context.push(types3.f_expr);
  } else {
    this.context.push(types3.f_stat);
  }
  this.exprAllowed = false;
};
types$1.colon.updateContext = function() {
  if (this.curContext().token === "function") {
    this.context.pop();
  }
  this.exprAllowed = true;
};
types$1.backQuote.updateContext = function() {
  if (this.curContext() === types3.q_tmpl) {
    this.context.pop();
  } else {
    this.context.push(types3.q_tmpl);
  }
  this.exprAllowed = false;
};
types$1.star.updateContext = function(prevType) {
  if (prevType === types$1._function) {
    var index3 = this.context.length - 1;
    if (this.context[index3] === types3.f_expr) {
      this.context[index3] = types3.f_expr_gen;
    } else {
      this.context[index3] = types3.f_gen;
    }
  }
  this.exprAllowed = true;
};
types$1.name.updateContext = function(prevType) {
  var allowed = false;
  if (this.options.ecmaVersion >= 6 && prevType !== types$1.dot) {
    if (this.value === "of" && !this.exprAllowed || this.value === "yield" && this.inGeneratorContext()) {
      allowed = true;
    }
  }
  this.exprAllowed = allowed;
};
var pp$5 = Parser.prototype;
pp$5.checkPropClash = function(prop2, propHash, refDestructuringErrors) {
  if (this.options.ecmaVersion >= 9 && prop2.type === "SpreadElement") {
    return;
  }
  if (this.options.ecmaVersion >= 6 && (prop2.computed || prop2.method || prop2.shorthand)) {
    return;
  }
  var key2 = prop2.key;
  var name2;
  switch (key2.type) {
    case "Identifier":
      name2 = key2.name;
      break;
    case "Literal":
      name2 = String(key2.value);
      break;
    default:
      return;
  }
  var kind = prop2.kind;
  if (this.options.ecmaVersion >= 6) {
    if (name2 === "__proto__" && kind === "init") {
      if (propHash.proto) {
        if (refDestructuringErrors) {
          if (refDestructuringErrors.doubleProto < 0) {
            refDestructuringErrors.doubleProto = key2.start;
          }
        } else {
          this.raiseRecoverable(key2.start, "Redefinition of __proto__ property");
        }
      }
      propHash.proto = true;
    }
    return;
  }
  name2 = "$" + name2;
  var other = propHash[name2];
  if (other) {
    var redefinition;
    if (kind === "init") {
      redefinition = this.strict && other.init || other.get || other.set;
    } else {
      redefinition = other.init || other[kind];
    }
    if (redefinition) {
      this.raiseRecoverable(key2.start, "Redefinition of property");
    }
  } else {
    other = propHash[name2] = {
      init: false,
      get: false,
      set: false
    };
  }
  other[kind] = true;
};
pp$5.parseExpression = function(forInit, refDestructuringErrors) {
  var startPos = this.start, startLoc = this.startLoc;
  var expr = this.parseMaybeAssign(forInit, refDestructuringErrors);
  if (this.type === types$1.comma) {
    var node2 = this.startNodeAt(startPos, startLoc);
    node2.expressions = [expr];
    while (this.eat(types$1.comma)) {
      node2.expressions.push(this.parseMaybeAssign(forInit, refDestructuringErrors));
    }
    return this.finishNode(node2, "SequenceExpression");
  }
  return expr;
};
pp$5.parseMaybeAssign = function(forInit, refDestructuringErrors, afterLeftParse) {
  if (this.isContextual("yield")) {
    if (this.inGenerator) {
      return this.parseYield(forInit);
    } else {
      this.exprAllowed = false;
    }
  }
  var ownDestructuringErrors = false, oldParenAssign = -1, oldTrailingComma = -1, oldDoubleProto = -1;
  if (refDestructuringErrors) {
    oldParenAssign = refDestructuringErrors.parenthesizedAssign;
    oldTrailingComma = refDestructuringErrors.trailingComma;
    oldDoubleProto = refDestructuringErrors.doubleProto;
    refDestructuringErrors.parenthesizedAssign = refDestructuringErrors.trailingComma = -1;
  } else {
    refDestructuringErrors = new DestructuringErrors();
    ownDestructuringErrors = true;
  }
  var startPos = this.start, startLoc = this.startLoc;
  if (this.type === types$1.parenL || this.type === types$1.name) {
    this.potentialArrowAt = this.start;
    this.potentialArrowInForAwait = forInit === "await";
  }
  var left = this.parseMaybeConditional(forInit, refDestructuringErrors);
  if (afterLeftParse) {
    left = afterLeftParse.call(this, left, startPos, startLoc);
  }
  if (this.type.isAssign) {
    var node2 = this.startNodeAt(startPos, startLoc);
    node2.operator = this.value;
    if (this.type === types$1.eq) {
      left = this.toAssignable(left, false, refDestructuringErrors);
    }
    if (!ownDestructuringErrors) {
      refDestructuringErrors.parenthesizedAssign = refDestructuringErrors.trailingComma = refDestructuringErrors.doubleProto = -1;
    }
    if (refDestructuringErrors.shorthandAssign >= left.start) {
      refDestructuringErrors.shorthandAssign = -1;
    }
    if (this.type === types$1.eq) {
      this.checkLValPattern(left);
    } else {
      this.checkLValSimple(left);
    }
    node2.left = left;
    this.next();
    node2.right = this.parseMaybeAssign(forInit);
    if (oldDoubleProto > -1) {
      refDestructuringErrors.doubleProto = oldDoubleProto;
    }
    return this.finishNode(node2, "AssignmentExpression");
  } else {
    if (ownDestructuringErrors) {
      this.checkExpressionErrors(refDestructuringErrors, true);
    }
  }
  if (oldParenAssign > -1) {
    refDestructuringErrors.parenthesizedAssign = oldParenAssign;
  }
  if (oldTrailingComma > -1) {
    refDestructuringErrors.trailingComma = oldTrailingComma;
  }
  return left;
};
pp$5.parseMaybeConditional = function(forInit, refDestructuringErrors) {
  var startPos = this.start, startLoc = this.startLoc;
  var expr = this.parseExprOps(forInit, refDestructuringErrors);
  if (this.checkExpressionErrors(refDestructuringErrors)) {
    return expr;
  }
  if (this.eat(types$1.question)) {
    var node2 = this.startNodeAt(startPos, startLoc);
    node2.test = expr;
    node2.consequent = this.parseMaybeAssign();
    this.expect(types$1.colon);
    node2.alternate = this.parseMaybeAssign(forInit);
    return this.finishNode(node2, "ConditionalExpression");
  }
  return expr;
};
pp$5.parseExprOps = function(forInit, refDestructuringErrors) {
  var startPos = this.start, startLoc = this.startLoc;
  var expr = this.parseMaybeUnary(refDestructuringErrors, false, false, forInit);
  if (this.checkExpressionErrors(refDestructuringErrors)) {
    return expr;
  }
  return expr.start === startPos && expr.type === "ArrowFunctionExpression" ? expr : this.parseExprOp(expr, startPos, startLoc, -1, forInit);
};
pp$5.parseExprOp = function(left, leftStartPos, leftStartLoc, minPrec, forInit) {
  var prec = this.type.binop;
  if (prec != null && (!forInit || this.type !== types$1._in)) {
    if (prec > minPrec) {
      var logical = this.type === types$1.logicalOR || this.type === types$1.logicalAND;
      var coalesce = this.type === types$1.coalesce;
      if (coalesce) {
        prec = types$1.logicalAND.binop;
      }
      var op = this.value;
      this.next();
      var startPos = this.start, startLoc = this.startLoc;
      var right = this.parseExprOp(this.parseMaybeUnary(null, false, false, forInit), startPos, startLoc, prec, forInit);
      var node2 = this.buildBinary(leftStartPos, leftStartLoc, left, right, op, logical || coalesce);
      if (logical && this.type === types$1.coalesce || coalesce && (this.type === types$1.logicalOR || this.type === types$1.logicalAND)) {
        this.raiseRecoverable(this.start, "Logical expressions and coalesce expressions cannot be mixed. Wrap either by parentheses");
      }
      return this.parseExprOp(node2, leftStartPos, leftStartLoc, minPrec, forInit);
    }
  }
  return left;
};
pp$5.buildBinary = function(startPos, startLoc, left, right, op, logical) {
  if (right.type === "PrivateIdentifier") {
    this.raise(right.start, "Private identifier can only be left side of binary expression");
  }
  var node2 = this.startNodeAt(startPos, startLoc);
  node2.left = left;
  node2.operator = op;
  node2.right = right;
  return this.finishNode(node2, logical ? "LogicalExpression" : "BinaryExpression");
};
pp$5.parseMaybeUnary = function(refDestructuringErrors, sawUnary, incDec, forInit) {
  var startPos = this.start, startLoc = this.startLoc, expr;
  if (this.isContextual("await") && this.canAwait) {
    expr = this.parseAwait(forInit);
    sawUnary = true;
  } else if (this.type.prefix) {
    var node2 = this.startNode(), update = this.type === types$1.incDec;
    node2.operator = this.value;
    node2.prefix = true;
    this.next();
    node2.argument = this.parseMaybeUnary(null, true, update, forInit);
    this.checkExpressionErrors(refDestructuringErrors, true);
    if (update) {
      this.checkLValSimple(node2.argument);
    } else if (this.strict && node2.operator === "delete" && isLocalVariableAccess(node2.argument)) {
      this.raiseRecoverable(node2.start, "Deleting local variable in strict mode");
    } else if (node2.operator === "delete" && isPrivateFieldAccess(node2.argument)) {
      this.raiseRecoverable(node2.start, "Private fields can not be deleted");
    } else {
      sawUnary = true;
    }
    expr = this.finishNode(node2, update ? "UpdateExpression" : "UnaryExpression");
  } else if (!sawUnary && this.type === types$1.privateId) {
    if ((forInit || this.privateNameStack.length === 0) && this.options.checkPrivateFields) {
      this.unexpected();
    }
    expr = this.parsePrivateIdent();
    if (this.type !== types$1._in) {
      this.unexpected();
    }
  } else {
    expr = this.parseExprSubscripts(refDestructuringErrors, forInit);
    if (this.checkExpressionErrors(refDestructuringErrors)) {
      return expr;
    }
    while (this.type.postfix && !this.canInsertSemicolon()) {
      var node$1 = this.startNodeAt(startPos, startLoc);
      node$1.operator = this.value;
      node$1.prefix = false;
      node$1.argument = expr;
      this.checkLValSimple(expr);
      this.next();
      expr = this.finishNode(node$1, "UpdateExpression");
    }
  }
  if (!incDec && this.eat(types$1.starstar)) {
    if (sawUnary) {
      this.unexpected(this.lastTokStart);
    } else {
      return this.buildBinary(startPos, startLoc, expr, this.parseMaybeUnary(null, false, false, forInit), "**", false);
    }
  } else {
    return expr;
  }
};
function isLocalVariableAccess(node2) {
  return node2.type === "Identifier" || node2.type === "ParenthesizedExpression" && isLocalVariableAccess(node2.expression);
}
function isPrivateFieldAccess(node2) {
  return node2.type === "MemberExpression" && node2.property.type === "PrivateIdentifier" || node2.type === "ChainExpression" && isPrivateFieldAccess(node2.expression) || node2.type === "ParenthesizedExpression" && isPrivateFieldAccess(node2.expression);
}
pp$5.parseExprSubscripts = function(refDestructuringErrors, forInit) {
  var startPos = this.start, startLoc = this.startLoc;
  var expr = this.parseExprAtom(refDestructuringErrors, forInit);
  if (expr.type === "ArrowFunctionExpression" && this.input.slice(this.lastTokStart, this.lastTokEnd) !== ")") {
    return expr;
  }
  var result = this.parseSubscripts(expr, startPos, startLoc, false, forInit);
  if (refDestructuringErrors && result.type === "MemberExpression") {
    if (refDestructuringErrors.parenthesizedAssign >= result.start) {
      refDestructuringErrors.parenthesizedAssign = -1;
    }
    if (refDestructuringErrors.parenthesizedBind >= result.start) {
      refDestructuringErrors.parenthesizedBind = -1;
    }
    if (refDestructuringErrors.trailingComma >= result.start) {
      refDestructuringErrors.trailingComma = -1;
    }
  }
  return result;
};
pp$5.parseSubscripts = function(base, startPos, startLoc, noCalls, forInit) {
  var maybeAsyncArrow = this.options.ecmaVersion >= 8 && base.type === "Identifier" && base.name === "async" && this.lastTokEnd === base.end && !this.canInsertSemicolon() && base.end - base.start === 5 && this.potentialArrowAt === base.start;
  var optionalChained = false;
  while (true) {
    var element2 = this.parseSubscript(base, startPos, startLoc, noCalls, maybeAsyncArrow, optionalChained, forInit);
    if (element2.optional) {
      optionalChained = true;
    }
    if (element2 === base || element2.type === "ArrowFunctionExpression") {
      if (optionalChained) {
        var chainNode = this.startNodeAt(startPos, startLoc);
        chainNode.expression = element2;
        element2 = this.finishNode(chainNode, "ChainExpression");
      }
      return element2;
    }
    base = element2;
  }
};
pp$5.shouldParseAsyncArrow = function() {
  return !this.canInsertSemicolon() && this.eat(types$1.arrow);
};
pp$5.parseSubscriptAsyncArrow = function(startPos, startLoc, exprList, forInit) {
  return this.parseArrowExpression(this.startNodeAt(startPos, startLoc), exprList, true, forInit);
};
pp$5.parseSubscript = function(base, startPos, startLoc, noCalls, maybeAsyncArrow, optionalChained, forInit) {
  var optionalSupported = this.options.ecmaVersion >= 11;
  var optional = optionalSupported && this.eat(types$1.questionDot);
  if (noCalls && optional) {
    this.raise(this.lastTokStart, "Optional chaining cannot appear in the callee of new expressions");
  }
  var computed = this.eat(types$1.bracketL);
  if (computed || optional && this.type !== types$1.parenL && this.type !== types$1.backQuote || this.eat(types$1.dot)) {
    var node2 = this.startNodeAt(startPos, startLoc);
    node2.object = base;
    if (computed) {
      node2.property = this.parseExpression();
      this.expect(types$1.bracketR);
    } else if (this.type === types$1.privateId && base.type !== "Super") {
      node2.property = this.parsePrivateIdent();
    } else {
      node2.property = this.parseIdent(this.options.allowReserved !== "never");
    }
    node2.computed = !!computed;
    if (optionalSupported) {
      node2.optional = optional;
    }
    base = this.finishNode(node2, "MemberExpression");
  } else if (!noCalls && this.eat(types$1.parenL)) {
    var refDestructuringErrors = new DestructuringErrors(), oldYieldPos = this.yieldPos, oldAwaitPos = this.awaitPos, oldAwaitIdentPos = this.awaitIdentPos;
    this.yieldPos = 0;
    this.awaitPos = 0;
    this.awaitIdentPos = 0;
    var exprList = this.parseExprList(types$1.parenR, this.options.ecmaVersion >= 8, false, refDestructuringErrors);
    if (maybeAsyncArrow && !optional && this.shouldParseAsyncArrow()) {
      this.checkPatternErrors(refDestructuringErrors, false);
      this.checkYieldAwaitInDefaultParams();
      if (this.awaitIdentPos > 0) {
        this.raise(this.awaitIdentPos, "Cannot use 'await' as identifier inside an async function");
      }
      this.yieldPos = oldYieldPos;
      this.awaitPos = oldAwaitPos;
      this.awaitIdentPos = oldAwaitIdentPos;
      return this.parseSubscriptAsyncArrow(startPos, startLoc, exprList, forInit);
    }
    this.checkExpressionErrors(refDestructuringErrors, true);
    this.yieldPos = oldYieldPos || this.yieldPos;
    this.awaitPos = oldAwaitPos || this.awaitPos;
    this.awaitIdentPos = oldAwaitIdentPos || this.awaitIdentPos;
    var node$1 = this.startNodeAt(startPos, startLoc);
    node$1.callee = base;
    node$1.arguments = exprList;
    if (optionalSupported) {
      node$1.optional = optional;
    }
    base = this.finishNode(node$1, "CallExpression");
  } else if (this.type === types$1.backQuote) {
    if (optional || optionalChained) {
      this.raise(this.start, "Optional chaining cannot appear in the tag of tagged template expressions");
    }
    var node$2 = this.startNodeAt(startPos, startLoc);
    node$2.tag = base;
    node$2.quasi = this.parseTemplate({ isTagged: true });
    base = this.finishNode(node$2, "TaggedTemplateExpression");
  }
  return base;
};
pp$5.parseExprAtom = function(refDestructuringErrors, forInit, forNew) {
  if (this.type === types$1.slash) {
    this.readRegexp();
  }
  var node2, canBeArrow = this.potentialArrowAt === this.start;
  switch (this.type) {
    case types$1._super:
      if (!this.allowSuper) {
        this.raise(this.start, "'super' keyword outside a method");
      }
      node2 = this.startNode();
      this.next();
      if (this.type === types$1.parenL && !this.allowDirectSuper) {
        this.raise(node2.start, "super() call outside constructor of a subclass");
      }
      if (this.type !== types$1.dot && this.type !== types$1.bracketL && this.type !== types$1.parenL) {
        this.unexpected();
      }
      return this.finishNode(node2, "Super");
    case types$1._this:
      node2 = this.startNode();
      this.next();
      return this.finishNode(node2, "ThisExpression");
    case types$1.name:
      var startPos = this.start, startLoc = this.startLoc, containsEsc = this.containsEsc;
      var id = this.parseIdent(false);
      if (this.options.ecmaVersion >= 8 && !containsEsc && id.name === "async" && !this.canInsertSemicolon() && this.eat(types$1._function)) {
        this.overrideContext(types3.f_expr);
        return this.parseFunction(this.startNodeAt(startPos, startLoc), 0, false, true, forInit);
      }
      if (canBeArrow && !this.canInsertSemicolon()) {
        if (this.eat(types$1.arrow)) {
          return this.parseArrowExpression(this.startNodeAt(startPos, startLoc), [id], false, forInit);
        }
        if (this.options.ecmaVersion >= 8 && id.name === "async" && this.type === types$1.name && !containsEsc && (!this.potentialArrowInForAwait || this.value !== "of" || this.containsEsc)) {
          id = this.parseIdent(false);
          if (this.canInsertSemicolon() || !this.eat(types$1.arrow)) {
            this.unexpected();
          }
          return this.parseArrowExpression(this.startNodeAt(startPos, startLoc), [id], true, forInit);
        }
      }
      return id;
    case types$1.regexp:
      var value2 = this.value;
      node2 = this.parseLiteral(value2.value);
      node2.regex = { pattern: value2.pattern, flags: value2.flags };
      return node2;
    case types$1.num:
    case types$1.string:
      return this.parseLiteral(this.value);
    case types$1._null:
    case types$1._true:
    case types$1._false:
      node2 = this.startNode();
      node2.value = this.type === types$1._null ? null : this.type === types$1._true;
      node2.raw = this.type.keyword;
      this.next();
      return this.finishNode(node2, "Literal");
    case types$1.parenL:
      var start2 = this.start, expr = this.parseParenAndDistinguishExpression(canBeArrow, forInit);
      if (refDestructuringErrors) {
        if (refDestructuringErrors.parenthesizedAssign < 0 && !this.isSimpleAssignTarget(expr)) {
          refDestructuringErrors.parenthesizedAssign = start2;
        }
        if (refDestructuringErrors.parenthesizedBind < 0) {
          refDestructuringErrors.parenthesizedBind = start2;
        }
      }
      return expr;
    case types$1.bracketL:
      node2 = this.startNode();
      this.next();
      node2.elements = this.parseExprList(types$1.bracketR, true, true, refDestructuringErrors);
      return this.finishNode(node2, "ArrayExpression");
    case types$1.braceL:
      this.overrideContext(types3.b_expr);
      return this.parseObj(false, refDestructuringErrors);
    case types$1._function:
      node2 = this.startNode();
      this.next();
      return this.parseFunction(node2, 0);
    case types$1._class:
      return this.parseClass(this.startNode(), false);
    case types$1._new:
      return this.parseNew();
    case types$1.backQuote:
      return this.parseTemplate();
    case types$1._import:
      if (this.options.ecmaVersion >= 11) {
        return this.parseExprImport(forNew);
      } else {
        return this.unexpected();
      }
    default:
      return this.parseExprAtomDefault();
  }
};
pp$5.parseExprAtomDefault = function() {
  this.unexpected();
};
pp$5.parseExprImport = function(forNew) {
  var node2 = this.startNode();
  if (this.containsEsc) {
    this.raiseRecoverable(this.start, "Escape sequence in keyword import");
  }
  this.next();
  if (this.type === types$1.parenL && !forNew) {
    return this.parseDynamicImport(node2);
  } else if (this.type === types$1.dot) {
    var meta = this.startNodeAt(node2.start, node2.loc && node2.loc.start);
    meta.name = "import";
    node2.meta = this.finishNode(meta, "Identifier");
    return this.parseImportMeta(node2);
  } else {
    this.unexpected();
  }
};
pp$5.parseDynamicImport = function(node2) {
  this.next();
  node2.source = this.parseMaybeAssign();
  if (this.options.ecmaVersion >= 16) {
    if (!this.eat(types$1.parenR)) {
      this.expect(types$1.comma);
      if (!this.afterTrailingComma(types$1.parenR)) {
        node2.options = this.parseMaybeAssign();
        if (!this.eat(types$1.parenR)) {
          this.expect(types$1.comma);
          if (!this.afterTrailingComma(types$1.parenR)) {
            this.unexpected();
          }
        }
      } else {
        node2.options = null;
      }
    } else {
      node2.options = null;
    }
  } else {
    if (!this.eat(types$1.parenR)) {
      var errorPos = this.start;
      if (this.eat(types$1.comma) && this.eat(types$1.parenR)) {
        this.raiseRecoverable(errorPos, "Trailing comma is not allowed in import()");
      } else {
        this.unexpected(errorPos);
      }
    }
  }
  return this.finishNode(node2, "ImportExpression");
};
pp$5.parseImportMeta = function(node2) {
  this.next();
  var containsEsc = this.containsEsc;
  node2.property = this.parseIdent(true);
  if (node2.property.name !== "meta") {
    this.raiseRecoverable(node2.property.start, "The only valid meta property for import is 'import.meta'");
  }
  if (containsEsc) {
    this.raiseRecoverable(node2.start, "'import.meta' must not contain escaped characters");
  }
  if (this.options.sourceType !== "module" && !this.options.allowImportExportEverywhere) {
    this.raiseRecoverable(node2.start, "Cannot use 'import.meta' outside a module");
  }
  return this.finishNode(node2, "MetaProperty");
};
pp$5.parseLiteral = function(value2) {
  var node2 = this.startNode();
  node2.value = value2;
  node2.raw = this.input.slice(this.start, this.end);
  if (node2.raw.charCodeAt(node2.raw.length - 1) === 110) {
    node2.bigint = node2.raw.slice(0, -1).replace(/_/g, "");
  }
  this.next();
  return this.finishNode(node2, "Literal");
};
pp$5.parseParenExpression = function() {
  this.expect(types$1.parenL);
  var val = this.parseExpression();
  this.expect(types$1.parenR);
  return val;
};
pp$5.shouldParseArrow = function(exprList) {
  return !this.canInsertSemicolon();
};
pp$5.parseParenAndDistinguishExpression = function(canBeArrow, forInit) {
  var startPos = this.start, startLoc = this.startLoc, val, allowTrailingComma = this.options.ecmaVersion >= 8;
  if (this.options.ecmaVersion >= 6) {
    this.next();
    var innerStartPos = this.start, innerStartLoc = this.startLoc;
    var exprList = [], first = true, lastIsComma = false;
    var refDestructuringErrors = new DestructuringErrors(), oldYieldPos = this.yieldPos, oldAwaitPos = this.awaitPos, spreadStart;
    this.yieldPos = 0;
    this.awaitPos = 0;
    while (this.type !== types$1.parenR) {
      first ? first = false : this.expect(types$1.comma);
      if (allowTrailingComma && this.afterTrailingComma(types$1.parenR, true)) {
        lastIsComma = true;
        break;
      } else if (this.type === types$1.ellipsis) {
        spreadStart = this.start;
        exprList.push(this.parseParenItem(this.parseRestBinding()));
        if (this.type === types$1.comma) {
          this.raiseRecoverable(
            this.start,
            "Comma is not permitted after the rest element"
          );
        }
        break;
      } else {
        exprList.push(this.parseMaybeAssign(false, refDestructuringErrors, this.parseParenItem));
      }
    }
    var innerEndPos = this.lastTokEnd, innerEndLoc = this.lastTokEndLoc;
    this.expect(types$1.parenR);
    if (canBeArrow && this.shouldParseArrow(exprList) && this.eat(types$1.arrow)) {
      this.checkPatternErrors(refDestructuringErrors, false);
      this.checkYieldAwaitInDefaultParams();
      this.yieldPos = oldYieldPos;
      this.awaitPos = oldAwaitPos;
      return this.parseParenArrowList(startPos, startLoc, exprList, forInit);
    }
    if (!exprList.length || lastIsComma) {
      this.unexpected(this.lastTokStart);
    }
    if (spreadStart) {
      this.unexpected(spreadStart);
    }
    this.checkExpressionErrors(refDestructuringErrors, true);
    this.yieldPos = oldYieldPos || this.yieldPos;
    this.awaitPos = oldAwaitPos || this.awaitPos;
    if (exprList.length > 1) {
      val = this.startNodeAt(innerStartPos, innerStartLoc);
      val.expressions = exprList;
      this.finishNodeAt(val, "SequenceExpression", innerEndPos, innerEndLoc);
    } else {
      val = exprList[0];
    }
  } else {
    val = this.parseParenExpression();
  }
  if (this.options.preserveParens) {
    var par = this.startNodeAt(startPos, startLoc);
    par.expression = val;
    return this.finishNode(par, "ParenthesizedExpression");
  } else {
    return val;
  }
};
pp$5.parseParenItem = function(item) {
  return item;
};
pp$5.parseParenArrowList = function(startPos, startLoc, exprList, forInit) {
  return this.parseArrowExpression(this.startNodeAt(startPos, startLoc), exprList, false, forInit);
};
var empty3 = [];
pp$5.parseNew = function() {
  if (this.containsEsc) {
    this.raiseRecoverable(this.start, "Escape sequence in keyword new");
  }
  var node2 = this.startNode();
  this.next();
  if (this.options.ecmaVersion >= 6 && this.type === types$1.dot) {
    var meta = this.startNodeAt(node2.start, node2.loc && node2.loc.start);
    meta.name = "new";
    node2.meta = this.finishNode(meta, "Identifier");
    this.next();
    var containsEsc = this.containsEsc;
    node2.property = this.parseIdent(true);
    if (node2.property.name !== "target") {
      this.raiseRecoverable(node2.property.start, "The only valid meta property for new is 'new.target'");
    }
    if (containsEsc) {
      this.raiseRecoverable(node2.start, "'new.target' must not contain escaped characters");
    }
    if (!this.allowNewDotTarget) {
      this.raiseRecoverable(node2.start, "'new.target' can only be used in functions and class static block");
    }
    return this.finishNode(node2, "MetaProperty");
  }
  var startPos = this.start, startLoc = this.startLoc;
  node2.callee = this.parseSubscripts(this.parseExprAtom(null, false, true), startPos, startLoc, true, false);
  if (this.eat(types$1.parenL)) {
    node2.arguments = this.parseExprList(types$1.parenR, this.options.ecmaVersion >= 8, false);
  } else {
    node2.arguments = empty3;
  }
  return this.finishNode(node2, "NewExpression");
};
pp$5.parseTemplateElement = function(ref2) {
  var isTagged = ref2.isTagged;
  var elem = this.startNode();
  if (this.type === types$1.invalidTemplate) {
    if (!isTagged) {
      this.raiseRecoverable(this.start, "Bad escape sequence in untagged template literal");
    }
    elem.value = {
      raw: this.value.replace(/\r\n?/g, "\n"),
      cooked: null
    };
  } else {
    elem.value = {
      raw: this.input.slice(this.start, this.end).replace(/\r\n?/g, "\n"),
      cooked: this.value
    };
  }
  this.next();
  elem.tail = this.type === types$1.backQuote;
  return this.finishNode(elem, "TemplateElement");
};
pp$5.parseTemplate = function(ref2) {
  if (ref2 === void 0) ref2 = {};
  var isTagged = ref2.isTagged;
  if (isTagged === void 0) isTagged = false;
  var node2 = this.startNode();
  this.next();
  node2.expressions = [];
  var curElt = this.parseTemplateElement({ isTagged });
  node2.quasis = [curElt];
  while (!curElt.tail) {
    if (this.type === types$1.eof) {
      this.raise(this.pos, "Unterminated template literal");
    }
    this.expect(types$1.dollarBraceL);
    node2.expressions.push(this.parseExpression());
    this.expect(types$1.braceR);
    node2.quasis.push(curElt = this.parseTemplateElement({ isTagged }));
  }
  this.next();
  return this.finishNode(node2, "TemplateLiteral");
};
pp$5.isAsyncProp = function(prop2) {
  return !prop2.computed && prop2.key.type === "Identifier" && prop2.key.name === "async" && (this.type === types$1.name || this.type === types$1.num || this.type === types$1.string || this.type === types$1.bracketL || this.type.keyword || this.options.ecmaVersion >= 9 && this.type === types$1.star) && !lineBreak.test(this.input.slice(this.lastTokEnd, this.start));
};
pp$5.parseObj = function(isPattern, refDestructuringErrors) {
  var node2 = this.startNode(), first = true, propHash = {};
  node2.properties = [];
  this.next();
  while (!this.eat(types$1.braceR)) {
    if (!first) {
      this.expect(types$1.comma);
      if (this.options.ecmaVersion >= 5 && this.afterTrailingComma(types$1.braceR)) {
        break;
      }
    } else {
      first = false;
    }
    var prop2 = this.parseProperty(isPattern, refDestructuringErrors);
    if (!isPattern) {
      this.checkPropClash(prop2, propHash, refDestructuringErrors);
    }
    node2.properties.push(prop2);
  }
  return this.finishNode(node2, isPattern ? "ObjectPattern" : "ObjectExpression");
};
pp$5.parseProperty = function(isPattern, refDestructuringErrors) {
  var prop2 = this.startNode(), isGenerator, isAsync, startPos, startLoc;
  if (this.options.ecmaVersion >= 9 && this.eat(types$1.ellipsis)) {
    if (isPattern) {
      prop2.argument = this.parseIdent(false);
      if (this.type === types$1.comma) {
        this.raiseRecoverable(this.start, "Comma is not permitted after the rest element");
      }
      return this.finishNode(prop2, "RestElement");
    }
    prop2.argument = this.parseMaybeAssign(false, refDestructuringErrors);
    if (this.type === types$1.comma && refDestructuringErrors && refDestructuringErrors.trailingComma < 0) {
      refDestructuringErrors.trailingComma = this.start;
    }
    return this.finishNode(prop2, "SpreadElement");
  }
  if (this.options.ecmaVersion >= 6) {
    prop2.method = false;
    prop2.shorthand = false;
    if (isPattern || refDestructuringErrors) {
      startPos = this.start;
      startLoc = this.startLoc;
    }
    if (!isPattern) {
      isGenerator = this.eat(types$1.star);
    }
  }
  var containsEsc = this.containsEsc;
  this.parsePropertyName(prop2);
  if (!isPattern && !containsEsc && this.options.ecmaVersion >= 8 && !isGenerator && this.isAsyncProp(prop2)) {
    isAsync = true;
    isGenerator = this.options.ecmaVersion >= 9 && this.eat(types$1.star);
    this.parsePropertyName(prop2);
  } else {
    isAsync = false;
  }
  this.parsePropertyValue(prop2, isPattern, isGenerator, isAsync, startPos, startLoc, refDestructuringErrors, containsEsc);
  return this.finishNode(prop2, "Property");
};
pp$5.parseGetterSetter = function(prop2) {
  prop2.kind = prop2.key.name;
  this.parsePropertyName(prop2);
  prop2.value = this.parseMethod(false);
  var paramCount = prop2.kind === "get" ? 0 : 1;
  if (prop2.value.params.length !== paramCount) {
    var start2 = prop2.value.start;
    if (prop2.kind === "get") {
      this.raiseRecoverable(start2, "getter should have no params");
    } else {
      this.raiseRecoverable(start2, "setter should have exactly one param");
    }
  } else {
    if (prop2.kind === "set" && prop2.value.params[0].type === "RestElement") {
      this.raiseRecoverable(prop2.value.params[0].start, "Setter cannot use rest params");
    }
  }
};
pp$5.parsePropertyValue = function(prop2, isPattern, isGenerator, isAsync, startPos, startLoc, refDestructuringErrors, containsEsc) {
  if ((isGenerator || isAsync) && this.type === types$1.colon) {
    this.unexpected();
  }
  if (this.eat(types$1.colon)) {
    prop2.value = isPattern ? this.parseMaybeDefault(this.start, this.startLoc) : this.parseMaybeAssign(false, refDestructuringErrors);
    prop2.kind = "init";
  } else if (this.options.ecmaVersion >= 6 && this.type === types$1.parenL) {
    if (isPattern) {
      this.unexpected();
    }
    prop2.kind = "init";
    prop2.method = true;
    prop2.value = this.parseMethod(isGenerator, isAsync);
  } else if (!isPattern && !containsEsc && this.options.ecmaVersion >= 5 && !prop2.computed && prop2.key.type === "Identifier" && (prop2.key.name === "get" || prop2.key.name === "set") && (this.type !== types$1.comma && this.type !== types$1.braceR && this.type !== types$1.eq)) {
    if (isGenerator || isAsync) {
      this.unexpected();
    }
    this.parseGetterSetter(prop2);
  } else if (this.options.ecmaVersion >= 6 && !prop2.computed && prop2.key.type === "Identifier") {
    if (isGenerator || isAsync) {
      this.unexpected();
    }
    this.checkUnreserved(prop2.key);
    if (prop2.key.name === "await" && !this.awaitIdentPos) {
      this.awaitIdentPos = startPos;
    }
    prop2.kind = "init";
    if (isPattern) {
      prop2.value = this.parseMaybeDefault(startPos, startLoc, this.copyNode(prop2.key));
    } else if (this.type === types$1.eq && refDestructuringErrors) {
      if (refDestructuringErrors.shorthandAssign < 0) {
        refDestructuringErrors.shorthandAssign = this.start;
      }
      prop2.value = this.parseMaybeDefault(startPos, startLoc, this.copyNode(prop2.key));
    } else {
      prop2.value = this.copyNode(prop2.key);
    }
    prop2.shorthand = true;
  } else {
    this.unexpected();
  }
};
pp$5.parsePropertyName = function(prop2) {
  if (this.options.ecmaVersion >= 6) {
    if (this.eat(types$1.bracketL)) {
      prop2.computed = true;
      prop2.key = this.parseMaybeAssign();
      this.expect(types$1.bracketR);
      return prop2.key;
    } else {
      prop2.computed = false;
    }
  }
  return prop2.key = this.type === types$1.num || this.type === types$1.string ? this.parseExprAtom() : this.parseIdent(this.options.allowReserved !== "never");
};
pp$5.initFunction = function(node2) {
  node2.id = null;
  if (this.options.ecmaVersion >= 6) {
    node2.generator = node2.expression = false;
  }
  if (this.options.ecmaVersion >= 8) {
    node2.async = false;
  }
};
pp$5.parseMethod = function(isGenerator, isAsync, allowDirectSuper) {
  var node2 = this.startNode(), oldYieldPos = this.yieldPos, oldAwaitPos = this.awaitPos, oldAwaitIdentPos = this.awaitIdentPos;
  this.initFunction(node2);
  if (this.options.ecmaVersion >= 6) {
    node2.generator = isGenerator;
  }
  if (this.options.ecmaVersion >= 8) {
    node2.async = !!isAsync;
  }
  this.yieldPos = 0;
  this.awaitPos = 0;
  this.awaitIdentPos = 0;
  this.enterScope(functionFlags(isAsync, node2.generator) | SCOPE_SUPER | (allowDirectSuper ? SCOPE_DIRECT_SUPER : 0));
  this.expect(types$1.parenL);
  node2.params = this.parseBindingList(types$1.parenR, false, this.options.ecmaVersion >= 8);
  this.checkYieldAwaitInDefaultParams();
  this.parseFunctionBody(node2, false, true, false);
  this.yieldPos = oldYieldPos;
  this.awaitPos = oldAwaitPos;
  this.awaitIdentPos = oldAwaitIdentPos;
  return this.finishNode(node2, "FunctionExpression");
};
pp$5.parseArrowExpression = function(node2, params, isAsync, forInit) {
  var oldYieldPos = this.yieldPos, oldAwaitPos = this.awaitPos, oldAwaitIdentPos = this.awaitIdentPos;
  this.enterScope(functionFlags(isAsync, false) | SCOPE_ARROW);
  this.initFunction(node2);
  if (this.options.ecmaVersion >= 8) {
    node2.async = !!isAsync;
  }
  this.yieldPos = 0;
  this.awaitPos = 0;
  this.awaitIdentPos = 0;
  node2.params = this.toAssignableList(params, true);
  this.parseFunctionBody(node2, true, false, forInit);
  this.yieldPos = oldYieldPos;
  this.awaitPos = oldAwaitPos;
  this.awaitIdentPos = oldAwaitIdentPos;
  return this.finishNode(node2, "ArrowFunctionExpression");
};
pp$5.parseFunctionBody = function(node2, isArrowFunction, isMethod, forInit) {
  var isExpression = isArrowFunction && this.type !== types$1.braceL;
  var oldStrict = this.strict, useStrict = false;
  if (isExpression) {
    node2.body = this.parseMaybeAssign(forInit);
    node2.expression = true;
    this.checkParams(node2, false);
  } else {
    var nonSimple = this.options.ecmaVersion >= 7 && !this.isSimpleParamList(node2.params);
    if (!oldStrict || nonSimple) {
      useStrict = this.strictDirective(this.end);
      if (useStrict && nonSimple) {
        this.raiseRecoverable(node2.start, "Illegal 'use strict' directive in function with non-simple parameter list");
      }
    }
    var oldLabels = this.labels;
    this.labels = [];
    if (useStrict) {
      this.strict = true;
    }
    this.checkParams(node2, !oldStrict && !useStrict && !isArrowFunction && !isMethod && this.isSimpleParamList(node2.params));
    if (this.strict && node2.id) {
      this.checkLValSimple(node2.id, BIND_OUTSIDE);
    }
    node2.body = this.parseBlock(false, void 0, useStrict && !oldStrict);
    node2.expression = false;
    this.adaptDirectivePrologue(node2.body.body);
    this.labels = oldLabels;
  }
  this.exitScope();
};
pp$5.isSimpleParamList = function(params) {
  for (var i3 = 0, list4 = params; i3 < list4.length; i3 += 1) {
    var param = list4[i3];
    if (param.type !== "Identifier") {
      return false;
    }
  }
  return true;
};
pp$5.checkParams = function(node2, allowDuplicates) {
  var nameHash = /* @__PURE__ */ Object.create(null);
  for (var i3 = 0, list4 = node2.params; i3 < list4.length; i3 += 1) {
    var param = list4[i3];
    this.checkLValInnerPattern(param, BIND_VAR, allowDuplicates ? null : nameHash);
  }
};
pp$5.parseExprList = function(close2, allowTrailingComma, allowEmpty, refDestructuringErrors) {
  var elts = [], first = true;
  while (!this.eat(close2)) {
    if (!first) {
      this.expect(types$1.comma);
      if (allowTrailingComma && this.afterTrailingComma(close2)) {
        break;
      }
    } else {
      first = false;
    }
    var elt = void 0;
    if (allowEmpty && this.type === types$1.comma) {
      elt = null;
    } else if (this.type === types$1.ellipsis) {
      elt = this.parseSpread(refDestructuringErrors);
      if (refDestructuringErrors && this.type === types$1.comma && refDestructuringErrors.trailingComma < 0) {
        refDestructuringErrors.trailingComma = this.start;
      }
    } else {
      elt = this.parseMaybeAssign(false, refDestructuringErrors);
    }
    elts.push(elt);
  }
  return elts;
};
pp$5.checkUnreserved = function(ref2) {
  var start2 = ref2.start;
  var end = ref2.end;
  var name2 = ref2.name;
  if (this.inGenerator && name2 === "yield") {
    this.raiseRecoverable(start2, "Cannot use 'yield' as identifier inside a generator");
  }
  if (this.inAsync && name2 === "await") {
    this.raiseRecoverable(start2, "Cannot use 'await' as identifier inside an async function");
  }
  if (this.currentThisScope().inClassFieldInit && name2 === "arguments") {
    this.raiseRecoverable(start2, "Cannot use 'arguments' in class field initializer");
  }
  if (this.inClassStaticBlock && (name2 === "arguments" || name2 === "await")) {
    this.raise(start2, "Cannot use " + name2 + " in class static initialization block");
  }
  if (this.keywords.test(name2)) {
    this.raise(start2, "Unexpected keyword '" + name2 + "'");
  }
  if (this.options.ecmaVersion < 6 && this.input.slice(start2, end).indexOf("\\") !== -1) {
    return;
  }
  var re = this.strict ? this.reservedWordsStrict : this.reservedWords;
  if (re.test(name2)) {
    if (!this.inAsync && name2 === "await") {
      this.raiseRecoverable(start2, "Cannot use keyword 'await' outside an async function");
    }
    this.raiseRecoverable(start2, "The keyword '" + name2 + "' is reserved");
  }
};
pp$5.parseIdent = function(liberal) {
  var node2 = this.parseIdentNode();
  this.next(!!liberal);
  this.finishNode(node2, "Identifier");
  if (!liberal) {
    this.checkUnreserved(node2);
    if (node2.name === "await" && !this.awaitIdentPos) {
      this.awaitIdentPos = node2.start;
    }
  }
  return node2;
};
pp$5.parseIdentNode = function() {
  var node2 = this.startNode();
  if (this.type === types$1.name) {
    node2.name = this.value;
  } else if (this.type.keyword) {
    node2.name = this.type.keyword;
    if ((node2.name === "class" || node2.name === "function") && (this.lastTokEnd !== this.lastTokStart + 1 || this.input.charCodeAt(this.lastTokStart) !== 46)) {
      this.context.pop();
    }
    this.type = types$1.name;
  } else {
    this.unexpected();
  }
  return node2;
};
pp$5.parsePrivateIdent = function() {
  var node2 = this.startNode();
  if (this.type === types$1.privateId) {
    node2.name = this.value;
  } else {
    this.unexpected();
  }
  this.next();
  this.finishNode(node2, "PrivateIdentifier");
  if (this.options.checkPrivateFields) {
    if (this.privateNameStack.length === 0) {
      this.raise(node2.start, "Private field '#" + node2.name + "' must be declared in an enclosing class");
    } else {
      this.privateNameStack[this.privateNameStack.length - 1].used.push(node2);
    }
  }
  return node2;
};
pp$5.parseYield = function(forInit) {
  if (!this.yieldPos) {
    this.yieldPos = this.start;
  }
  var node2 = this.startNode();
  this.next();
  if (this.type === types$1.semi || this.canInsertSemicolon() || this.type !== types$1.star && !this.type.startsExpr) {
    node2.delegate = false;
    node2.argument = null;
  } else {
    node2.delegate = this.eat(types$1.star);
    node2.argument = this.parseMaybeAssign(forInit);
  }
  return this.finishNode(node2, "YieldExpression");
};
pp$5.parseAwait = function(forInit) {
  if (!this.awaitPos) {
    this.awaitPos = this.start;
  }
  var node2 = this.startNode();
  this.next();
  node2.argument = this.parseMaybeUnary(null, true, false, forInit);
  return this.finishNode(node2, "AwaitExpression");
};
var pp$4 = Parser.prototype;
pp$4.raise = function(pos, message) {
  var loc = getLineInfo(this.input, pos);
  message += " (" + loc.line + ":" + loc.column + ")";
  var err = new SyntaxError(message);
  err.pos = pos;
  err.loc = loc;
  err.raisedAt = this.pos;
  throw err;
};
pp$4.raiseRecoverable = pp$4.raise;
pp$4.curPosition = function() {
  if (this.options.locations) {
    return new Position(this.curLine, this.pos - this.lineStart);
  }
};
var pp$3 = Parser.prototype;
var Scope = function Scope2(flags) {
  this.flags = flags;
  this.var = [];
  this.lexical = [];
  this.functions = [];
  this.inClassFieldInit = false;
};
pp$3.enterScope = function(flags) {
  this.scopeStack.push(new Scope(flags));
};
pp$3.exitScope = function() {
  this.scopeStack.pop();
};
pp$3.treatFunctionsAsVarInScope = function(scope) {
  return scope.flags & SCOPE_FUNCTION || !this.inModule && scope.flags & SCOPE_TOP;
};
pp$3.declareName = function(name2, bindingType, pos) {
  var redeclared = false;
  if (bindingType === BIND_LEXICAL) {
    var scope = this.currentScope();
    redeclared = scope.lexical.indexOf(name2) > -1 || scope.functions.indexOf(name2) > -1 || scope.var.indexOf(name2) > -1;
    scope.lexical.push(name2);
    if (this.inModule && scope.flags & SCOPE_TOP) {
      delete this.undefinedExports[name2];
    }
  } else if (bindingType === BIND_SIMPLE_CATCH) {
    var scope$1 = this.currentScope();
    scope$1.lexical.push(name2);
  } else if (bindingType === BIND_FUNCTION) {
    var scope$2 = this.currentScope();
    if (this.treatFunctionsAsVar) {
      redeclared = scope$2.lexical.indexOf(name2) > -1;
    } else {
      redeclared = scope$2.lexical.indexOf(name2) > -1 || scope$2.var.indexOf(name2) > -1;
    }
    scope$2.functions.push(name2);
  } else {
    for (var i3 = this.scopeStack.length - 1; i3 >= 0; --i3) {
      var scope$3 = this.scopeStack[i3];
      if (scope$3.lexical.indexOf(name2) > -1 && !(scope$3.flags & SCOPE_SIMPLE_CATCH && scope$3.lexical[0] === name2) || !this.treatFunctionsAsVarInScope(scope$3) && scope$3.functions.indexOf(name2) > -1) {
        redeclared = true;
        break;
      }
      scope$3.var.push(name2);
      if (this.inModule && scope$3.flags & SCOPE_TOP) {
        delete this.undefinedExports[name2];
      }
      if (scope$3.flags & SCOPE_VAR) {
        break;
      }
    }
  }
  if (redeclared) {
    this.raiseRecoverable(pos, "Identifier '" + name2 + "' has already been declared");
  }
};
pp$3.checkLocalExport = function(id) {
  if (this.scopeStack[0].lexical.indexOf(id.name) === -1 && this.scopeStack[0].var.indexOf(id.name) === -1) {
    this.undefinedExports[id.name] = id;
  }
};
pp$3.currentScope = function() {
  return this.scopeStack[this.scopeStack.length - 1];
};
pp$3.currentVarScope = function() {
  for (var i3 = this.scopeStack.length - 1; ; i3--) {
    var scope = this.scopeStack[i3];
    if (scope.flags & SCOPE_VAR) {
      return scope;
    }
  }
};
pp$3.currentThisScope = function() {
  for (var i3 = this.scopeStack.length - 1; ; i3--) {
    var scope = this.scopeStack[i3];
    if (scope.flags & SCOPE_VAR && !(scope.flags & SCOPE_ARROW)) {
      return scope;
    }
  }
};
var Node2 = function Node3(parser, pos, loc) {
  this.type = "";
  this.start = pos;
  this.end = 0;
  if (parser.options.locations) {
    this.loc = new SourceLocation(parser, loc);
  }
  if (parser.options.directSourceFile) {
    this.sourceFile = parser.options.directSourceFile;
  }
  if (parser.options.ranges) {
    this.range = [pos, 0];
  }
};
var pp$2 = Parser.prototype;
pp$2.startNode = function() {
  return new Node2(this, this.start, this.startLoc);
};
pp$2.startNodeAt = function(pos, loc) {
  return new Node2(this, pos, loc);
};
function finishNodeAt(node2, type2, pos, loc) {
  node2.type = type2;
  node2.end = pos;
  if (this.options.locations) {
    node2.loc.end = loc;
  }
  if (this.options.ranges) {
    node2.range[1] = pos;
  }
  return node2;
}
pp$2.finishNode = function(node2, type2) {
  return finishNodeAt.call(this, node2, type2, this.lastTokEnd, this.lastTokEndLoc);
};
pp$2.finishNodeAt = function(node2, type2, pos, loc) {
  return finishNodeAt.call(this, node2, type2, pos, loc);
};
pp$2.copyNode = function(node2) {
  var newNode = new Node2(this, node2.start, this.startLoc);
  for (var prop2 in node2) {
    newNode[prop2] = node2[prop2];
  }
  return newNode;
};
var scriptValuesAddedInUnicode = "Gara Garay Gukh Gurung_Khema Hrkt Katakana_Or_Hiragana Kawi Kirat_Rai Krai Nag_Mundari Nagm Ol_Onal Onao Sunu Sunuwar Todhri Todr Tulu_Tigalari Tutg Unknown Zzzz";
var ecma9BinaryProperties = "ASCII ASCII_Hex_Digit AHex Alphabetic Alpha Any Assigned Bidi_Control Bidi_C Bidi_Mirrored Bidi_M Case_Ignorable CI Cased Changes_When_Casefolded CWCF Changes_When_Casemapped CWCM Changes_When_Lowercased CWL Changes_When_NFKC_Casefolded CWKCF Changes_When_Titlecased CWT Changes_When_Uppercased CWU Dash Default_Ignorable_Code_Point DI Deprecated Dep Diacritic Dia Emoji Emoji_Component Emoji_Modifier Emoji_Modifier_Base Emoji_Presentation Extender Ext Grapheme_Base Gr_Base Grapheme_Extend Gr_Ext Hex_Digit Hex IDS_Binary_Operator IDSB IDS_Trinary_Operator IDST ID_Continue IDC ID_Start IDS Ideographic Ideo Join_Control Join_C Logical_Order_Exception LOE Lowercase Lower Math Noncharacter_Code_Point NChar Pattern_Syntax Pat_Syn Pattern_White_Space Pat_WS Quotation_Mark QMark Radical Regional_Indicator RI Sentence_Terminal STerm Soft_Dotted SD Terminal_Punctuation Term Unified_Ideograph UIdeo Uppercase Upper Variation_Selector VS White_Space space XID_Continue XIDC XID_Start XIDS";
var ecma10BinaryProperties = ecma9BinaryProperties + " Extended_Pictographic";
var ecma11BinaryProperties = ecma10BinaryProperties;
var ecma12BinaryProperties = ecma11BinaryProperties + " EBase EComp EMod EPres ExtPict";
var ecma13BinaryProperties = ecma12BinaryProperties;
var ecma14BinaryProperties = ecma13BinaryProperties;
var unicodeBinaryProperties = {
  9: ecma9BinaryProperties,
  10: ecma10BinaryProperties,
  11: ecma11BinaryProperties,
  12: ecma12BinaryProperties,
  13: ecma13BinaryProperties,
  14: ecma14BinaryProperties
};
var ecma14BinaryPropertiesOfStrings = "Basic_Emoji Emoji_Keycap_Sequence RGI_Emoji_Modifier_Sequence RGI_Emoji_Flag_Sequence RGI_Emoji_Tag_Sequence RGI_Emoji_ZWJ_Sequence RGI_Emoji";
var unicodeBinaryPropertiesOfStrings = {
  9: "",
  10: "",
  11: "",
  12: "",
  13: "",
  14: ecma14BinaryPropertiesOfStrings
};
var unicodeGeneralCategoryValues = "Cased_Letter LC Close_Punctuation Pe Connector_Punctuation Pc Control Cc cntrl Currency_Symbol Sc Dash_Punctuation Pd Decimal_Number Nd digit Enclosing_Mark Me Final_Punctuation Pf Format Cf Initial_Punctuation Pi Letter L Letter_Number Nl Line_Separator Zl Lowercase_Letter Ll Mark M Combining_Mark Math_Symbol Sm Modifier_Letter Lm Modifier_Symbol Sk Nonspacing_Mark Mn Number N Open_Punctuation Ps Other C Other_Letter Lo Other_Number No Other_Punctuation Po Other_Symbol So Paragraph_Separator Zp Private_Use Co Punctuation P punct Separator Z Space_Separator Zs Spacing_Mark Mc Surrogate Cs Symbol S Titlecase_Letter Lt Unassigned Cn Uppercase_Letter Lu";
var ecma9ScriptValues = "Adlam Adlm Ahom Anatolian_Hieroglyphs Hluw Arabic Arab Armenian Armn Avestan Avst Balinese Bali Bamum Bamu Bassa_Vah Bass Batak Batk Bengali Beng Bhaiksuki Bhks Bopomofo Bopo Brahmi Brah Braille Brai Buginese Bugi Buhid Buhd Canadian_Aboriginal Cans Carian Cari Caucasian_Albanian Aghb Chakma Cakm Cham Cham Cherokee Cher Common Zyyy Coptic Copt Qaac Cuneiform Xsux Cypriot Cprt Cyrillic Cyrl Deseret Dsrt Devanagari Deva Duployan Dupl Egyptian_Hieroglyphs Egyp Elbasan Elba Ethiopic Ethi Georgian Geor Glagolitic Glag Gothic Goth Grantha Gran Greek Grek Gujarati Gujr Gurmukhi Guru Han Hani Hangul Hang Hanunoo Hano Hatran Hatr Hebrew Hebr Hiragana Hira Imperial_Aramaic Armi Inherited Zinh Qaai Inscriptional_Pahlavi Phli Inscriptional_Parthian Prti Javanese Java Kaithi Kthi Kannada Knda Katakana Kana Kayah_Li Kali Kharoshthi Khar Khmer Khmr Khojki Khoj Khudawadi Sind Lao Laoo Latin Latn Lepcha Lepc Limbu Limb Linear_A Lina Linear_B Linb Lisu Lisu Lycian Lyci Lydian Lydi Mahajani Mahj Malayalam Mlym Mandaic Mand Manichaean Mani Marchen Marc Masaram_Gondi Gonm Meetei_Mayek Mtei Mende_Kikakui Mend Meroitic_Cursive Merc Meroitic_Hieroglyphs Mero Miao Plrd Modi Mongolian Mong Mro Mroo Multani Mult Myanmar Mymr Nabataean Nbat New_Tai_Lue Talu Newa Newa Nko Nkoo Nushu Nshu Ogham Ogam Ol_Chiki Olck Old_Hungarian Hung Old_Italic Ital Old_North_Arabian Narb Old_Permic Perm Old_Persian Xpeo Old_South_Arabian Sarb Old_Turkic Orkh Oriya Orya Osage Osge Osmanya Osma Pahawh_Hmong Hmng Palmyrene Palm Pau_Cin_Hau Pauc Phags_Pa Phag Phoenician Phnx Psalter_Pahlavi Phlp Rejang Rjng Runic Runr Samaritan Samr Saurashtra Saur Sharada Shrd Shavian Shaw Siddham Sidd SignWriting Sgnw Sinhala Sinh Sora_Sompeng Sora Soyombo Soyo Sundanese Sund Syloti_Nagri Sylo Syriac Syrc Tagalog Tglg Tagbanwa Tagb Tai_Le Tale Tai_Tham Lana Tai_Viet Tavt Takri Takr Tamil Taml Tangut Tang Telugu Telu Thaana Thaa Thai Thai Tibetan Tibt Tifinagh Tfng Tirhuta Tirh Ugaritic Ugar Vai Vaii Warang_Citi Wara Yi Yiii Zanabazar_Square Zanb";
var ecma10ScriptValues = ecma9ScriptValues + " Dogra Dogr Gunjala_Gondi Gong Hanifi_Rohingya Rohg Makasar Maka Medefaidrin Medf Old_Sogdian Sogo Sogdian Sogd";
var ecma11ScriptValues = ecma10ScriptValues + " Elymaic Elym Nandinagari Nand Nyiakeng_Puachue_Hmong Hmnp Wancho Wcho";
var ecma12ScriptValues = ecma11ScriptValues + " Chorasmian Chrs Diak Dives_Akuru Khitan_Small_Script Kits Yezi Yezidi";
var ecma13ScriptValues = ecma12ScriptValues + " Cypro_Minoan Cpmn Old_Uyghur Ougr Tangsa Tnsa Toto Vithkuqi Vith";
var ecma14ScriptValues = ecma13ScriptValues + " " + scriptValuesAddedInUnicode;
var unicodeScriptValues = {
  9: ecma9ScriptValues,
  10: ecma10ScriptValues,
  11: ecma11ScriptValues,
  12: ecma12ScriptValues,
  13: ecma13ScriptValues,
  14: ecma14ScriptValues
};
var data = {};
function buildUnicodeData(ecmaVersion) {
  var d3 = data[ecmaVersion] = {
    binary: wordsRegexp(unicodeBinaryProperties[ecmaVersion] + " " + unicodeGeneralCategoryValues),
    binaryOfStrings: wordsRegexp(unicodeBinaryPropertiesOfStrings[ecmaVersion]),
    nonBinary: {
      General_Category: wordsRegexp(unicodeGeneralCategoryValues),
      Script: wordsRegexp(unicodeScriptValues[ecmaVersion])
    }
  };
  d3.nonBinary.Script_Extensions = d3.nonBinary.Script;
  d3.nonBinary.gc = d3.nonBinary.General_Category;
  d3.nonBinary.sc = d3.nonBinary.Script;
  d3.nonBinary.scx = d3.nonBinary.Script_Extensions;
}
for (i3 = 0, list4 = [9, 10, 11, 12, 13, 14]; i3 < list4.length; i3 += 1) {
  ecmaVersion = list4[i3];
  buildUnicodeData(ecmaVersion);
}
var ecmaVersion;
var i3;
var list4;
var pp$1 = Parser.prototype;
var BranchID = function BranchID2(parent, base) {
  this.parent = parent;
  this.base = base || this;
};
BranchID.prototype.separatedFrom = function separatedFrom(alt) {
  for (var self2 = this; self2; self2 = self2.parent) {
    for (var other = alt; other; other = other.parent) {
      if (self2.base === other.base && self2 !== other) {
        return true;
      }
    }
  }
  return false;
};
BranchID.prototype.sibling = function sibling() {
  return new BranchID(this.parent, this.base);
};
var RegExpValidationState = function RegExpValidationState2(parser) {
  this.parser = parser;
  this.validFlags = "gim" + (parser.options.ecmaVersion >= 6 ? "uy" : "") + (parser.options.ecmaVersion >= 9 ? "s" : "") + (parser.options.ecmaVersion >= 13 ? "d" : "") + (parser.options.ecmaVersion >= 15 ? "v" : "");
  this.unicodeProperties = data[parser.options.ecmaVersion >= 14 ? 14 : parser.options.ecmaVersion];
  this.source = "";
  this.flags = "";
  this.start = 0;
  this.switchU = false;
  this.switchV = false;
  this.switchN = false;
  this.pos = 0;
  this.lastIntValue = 0;
  this.lastStringValue = "";
  this.lastAssertionIsQuantifiable = false;
  this.numCapturingParens = 0;
  this.maxBackReference = 0;
  this.groupNames = /* @__PURE__ */ Object.create(null);
  this.backReferenceNames = [];
  this.branchID = null;
};
RegExpValidationState.prototype.reset = function reset(start2, pattern, flags) {
  var unicodeSets = flags.indexOf("v") !== -1;
  var unicode = flags.indexOf("u") !== -1;
  this.start = start2 | 0;
  this.source = pattern + "";
  this.flags = flags;
  if (unicodeSets && this.parser.options.ecmaVersion >= 15) {
    this.switchU = true;
    this.switchV = true;
    this.switchN = true;
  } else {
    this.switchU = unicode && this.parser.options.ecmaVersion >= 6;
    this.switchV = false;
    this.switchN = unicode && this.parser.options.ecmaVersion >= 9;
  }
};
RegExpValidationState.prototype.raise = function raise(message) {
  this.parser.raiseRecoverable(this.start, "Invalid regular expression: /" + this.source + "/: " + message);
};
RegExpValidationState.prototype.at = function at2(i3, forceU) {
  if (forceU === void 0) forceU = false;
  var s2 = this.source;
  var l3 = s2.length;
  if (i3 >= l3) {
    return -1;
  }
  var c2 = s2.charCodeAt(i3);
  if (!(forceU || this.switchU) || c2 <= 55295 || c2 >= 57344 || i3 + 1 >= l3) {
    return c2;
  }
  var next = s2.charCodeAt(i3 + 1);
  return next >= 56320 && next <= 57343 ? (c2 << 10) + next - 56613888 : c2;
};
RegExpValidationState.prototype.nextIndex = function nextIndex(i3, forceU) {
  if (forceU === void 0) forceU = false;
  var s2 = this.source;
  var l3 = s2.length;
  if (i3 >= l3) {
    return l3;
  }
  var c2 = s2.charCodeAt(i3), next;
  if (!(forceU || this.switchU) || c2 <= 55295 || c2 >= 57344 || i3 + 1 >= l3 || (next = s2.charCodeAt(i3 + 1)) < 56320 || next > 57343) {
    return i3 + 1;
  }
  return i3 + 2;
};
RegExpValidationState.prototype.current = function current(forceU) {
  if (forceU === void 0) forceU = false;
  return this.at(this.pos, forceU);
};
RegExpValidationState.prototype.lookahead = function lookahead(forceU) {
  if (forceU === void 0) forceU = false;
  return this.at(this.nextIndex(this.pos, forceU), forceU);
};
RegExpValidationState.prototype.advance = function advance(forceU) {
  if (forceU === void 0) forceU = false;
  this.pos = this.nextIndex(this.pos, forceU);
};
RegExpValidationState.prototype.eat = function eat(ch, forceU) {
  if (forceU === void 0) forceU = false;
  if (this.current(forceU) === ch) {
    this.advance(forceU);
    return true;
  }
  return false;
};
RegExpValidationState.prototype.eatChars = function eatChars(chs, forceU) {
  if (forceU === void 0) forceU = false;
  var pos = this.pos;
  for (var i3 = 0, list4 = chs; i3 < list4.length; i3 += 1) {
    var ch = list4[i3];
    var current2 = this.at(pos, forceU);
    if (current2 === -1 || current2 !== ch) {
      return false;
    }
    pos = this.nextIndex(pos, forceU);
  }
  this.pos = pos;
  return true;
};
pp$1.validateRegExpFlags = function(state) {
  var validFlags = state.validFlags;
  var flags = state.flags;
  var u2 = false;
  var v3 = false;
  for (var i3 = 0; i3 < flags.length; i3++) {
    var flag = flags.charAt(i3);
    if (validFlags.indexOf(flag) === -1) {
      this.raise(state.start, "Invalid regular expression flag");
    }
    if (flags.indexOf(flag, i3 + 1) > -1) {
      this.raise(state.start, "Duplicate regular expression flag");
    }
    if (flag === "u") {
      u2 = true;
    }
    if (flag === "v") {
      v3 = true;
    }
  }
  if (this.options.ecmaVersion >= 15 && u2 && v3) {
    this.raise(state.start, "Invalid regular expression flag");
  }
};
function hasProp(obj) {
  for (var _2 in obj) {
    return true;
  }
  return false;
}
pp$1.validateRegExpPattern = function(state) {
  this.regexp_pattern(state);
  if (!state.switchN && this.options.ecmaVersion >= 9 && hasProp(state.groupNames)) {
    state.switchN = true;
    this.regexp_pattern(state);
  }
};
pp$1.regexp_pattern = function(state) {
  state.pos = 0;
  state.lastIntValue = 0;
  state.lastStringValue = "";
  state.lastAssertionIsQuantifiable = false;
  state.numCapturingParens = 0;
  state.maxBackReference = 0;
  state.groupNames = /* @__PURE__ */ Object.create(null);
  state.backReferenceNames.length = 0;
  state.branchID = null;
  this.regexp_disjunction(state);
  if (state.pos !== state.source.length) {
    if (state.eat(
      41
      /* ) */
    )) {
      state.raise("Unmatched ')'");
    }
    if (state.eat(
      93
      /* ] */
    ) || state.eat(
      125
      /* } */
    )) {
      state.raise("Lone quantifier brackets");
    }
  }
  if (state.maxBackReference > state.numCapturingParens) {
    state.raise("Invalid escape");
  }
  for (var i3 = 0, list4 = state.backReferenceNames; i3 < list4.length; i3 += 1) {
    var name2 = list4[i3];
    if (!state.groupNames[name2]) {
      state.raise("Invalid named capture referenced");
    }
  }
};
pp$1.regexp_disjunction = function(state) {
  var trackDisjunction = this.options.ecmaVersion >= 16;
  if (trackDisjunction) {
    state.branchID = new BranchID(state.branchID, null);
  }
  this.regexp_alternative(state);
  while (state.eat(
    124
    /* | */
  )) {
    if (trackDisjunction) {
      state.branchID = state.branchID.sibling();
    }
    this.regexp_alternative(state);
  }
  if (trackDisjunction) {
    state.branchID = state.branchID.parent;
  }
  if (this.regexp_eatQuantifier(state, true)) {
    state.raise("Nothing to repeat");
  }
  if (state.eat(
    123
    /* { */
  )) {
    state.raise("Lone quantifier brackets");
  }
};
pp$1.regexp_alternative = function(state) {
  while (state.pos < state.source.length && this.regexp_eatTerm(state)) {
  }
};
pp$1.regexp_eatTerm = function(state) {
  if (this.regexp_eatAssertion(state)) {
    if (state.lastAssertionIsQuantifiable && this.regexp_eatQuantifier(state)) {
      if (state.switchU) {
        state.raise("Invalid quantifier");
      }
    }
    return true;
  }
  if (state.switchU ? this.regexp_eatAtom(state) : this.regexp_eatExtendedAtom(state)) {
    this.regexp_eatQuantifier(state);
    return true;
  }
  return false;
};
pp$1.regexp_eatAssertion = function(state) {
  var start2 = state.pos;
  state.lastAssertionIsQuantifiable = false;
  if (state.eat(
    94
    /* ^ */
  ) || state.eat(
    36
    /* $ */
  )) {
    return true;
  }
  if (state.eat(
    92
    /* \ */
  )) {
    if (state.eat(
      66
      /* B */
    ) || state.eat(
      98
      /* b */
    )) {
      return true;
    }
    state.pos = start2;
  }
  if (state.eat(
    40
    /* ( */
  ) && state.eat(
    63
    /* ? */
  )) {
    var lookbehind = false;
    if (this.options.ecmaVersion >= 9) {
      lookbehind = state.eat(
        60
        /* < */
      );
    }
    if (state.eat(
      61
      /* = */
    ) || state.eat(
      33
      /* ! */
    )) {
      this.regexp_disjunction(state);
      if (!state.eat(
        41
        /* ) */
      )) {
        state.raise("Unterminated group");
      }
      state.lastAssertionIsQuantifiable = !lookbehind;
      return true;
    }
  }
  state.pos = start2;
  return false;
};
pp$1.regexp_eatQuantifier = function(state, noError) {
  if (noError === void 0) noError = false;
  if (this.regexp_eatQuantifierPrefix(state, noError)) {
    state.eat(
      63
      /* ? */
    );
    return true;
  }
  return false;
};
pp$1.regexp_eatQuantifierPrefix = function(state, noError) {
  return state.eat(
    42
    /* * */
  ) || state.eat(
    43
    /* + */
  ) || state.eat(
    63
    /* ? */
  ) || this.regexp_eatBracedQuantifier(state, noError);
};
pp$1.regexp_eatBracedQuantifier = function(state, noError) {
  var start2 = state.pos;
  if (state.eat(
    123
    /* { */
  )) {
    var min2 = 0, max2 = -1;
    if (this.regexp_eatDecimalDigits(state)) {
      min2 = state.lastIntValue;
      if (state.eat(
        44
        /* , */
      ) && this.regexp_eatDecimalDigits(state)) {
        max2 = state.lastIntValue;
      }
      if (state.eat(
        125
        /* } */
      )) {
        if (max2 !== -1 && max2 < min2 && !noError) {
          state.raise("numbers out of order in {} quantifier");
        }
        return true;
      }
    }
    if (state.switchU && !noError) {
      state.raise("Incomplete quantifier");
    }
    state.pos = start2;
  }
  return false;
};
pp$1.regexp_eatAtom = function(state) {
  return this.regexp_eatPatternCharacters(state) || state.eat(
    46
    /* . */
  ) || this.regexp_eatReverseSolidusAtomEscape(state) || this.regexp_eatCharacterClass(state) || this.regexp_eatUncapturingGroup(state) || this.regexp_eatCapturingGroup(state);
};
pp$1.regexp_eatReverseSolidusAtomEscape = function(state) {
  var start2 = state.pos;
  if (state.eat(
    92
    /* \ */
  )) {
    if (this.regexp_eatAtomEscape(state)) {
      return true;
    }
    state.pos = start2;
  }
  return false;
};
pp$1.regexp_eatUncapturingGroup = function(state) {
  var start2 = state.pos;
  if (state.eat(
    40
    /* ( */
  )) {
    if (state.eat(
      63
      /* ? */
    )) {
      if (this.options.ecmaVersion >= 16) {
        var addModifiers = this.regexp_eatModifiers(state);
        var hasHyphen = state.eat(
          45
          /* - */
        );
        if (addModifiers || hasHyphen) {
          for (var i3 = 0; i3 < addModifiers.length; i3++) {
            var modifier = addModifiers.charAt(i3);
            if (addModifiers.indexOf(modifier, i3 + 1) > -1) {
              state.raise("Duplicate regular expression modifiers");
            }
          }
          if (hasHyphen) {
            var removeModifiers = this.regexp_eatModifiers(state);
            if (!addModifiers && !removeModifiers && state.current() === 58) {
              state.raise("Invalid regular expression modifiers");
            }
            for (var i$1 = 0; i$1 < removeModifiers.length; i$1++) {
              var modifier$1 = removeModifiers.charAt(i$1);
              if (removeModifiers.indexOf(modifier$1, i$1 + 1) > -1 || addModifiers.indexOf(modifier$1) > -1) {
                state.raise("Duplicate regular expression modifiers");
              }
            }
          }
        }
      }
      if (state.eat(
        58
        /* : */
      )) {
        this.regexp_disjunction(state);
        if (state.eat(
          41
          /* ) */
        )) {
          return true;
        }
        state.raise("Unterminated group");
      }
    }
    state.pos = start2;
  }
  return false;
};
pp$1.regexp_eatCapturingGroup = function(state) {
  if (state.eat(
    40
    /* ( */
  )) {
    if (this.options.ecmaVersion >= 9) {
      this.regexp_groupSpecifier(state);
    } else if (state.current() === 63) {
      state.raise("Invalid group");
    }
    this.regexp_disjunction(state);
    if (state.eat(
      41
      /* ) */
    )) {
      state.numCapturingParens += 1;
      return true;
    }
    state.raise("Unterminated group");
  }
  return false;
};
pp$1.regexp_eatModifiers = function(state) {
  var modifiers = "";
  var ch = 0;
  while ((ch = state.current()) !== -1 && isRegularExpressionModifier(ch)) {
    modifiers += codePointToString(ch);
    state.advance();
  }
  return modifiers;
};
function isRegularExpressionModifier(ch) {
  return ch === 105 || ch === 109 || ch === 115;
}
pp$1.regexp_eatExtendedAtom = function(state) {
  return state.eat(
    46
    /* . */
  ) || this.regexp_eatReverseSolidusAtomEscape(state) || this.regexp_eatCharacterClass(state) || this.regexp_eatUncapturingGroup(state) || this.regexp_eatCapturingGroup(state) || this.regexp_eatInvalidBracedQuantifier(state) || this.regexp_eatExtendedPatternCharacter(state);
};
pp$1.regexp_eatInvalidBracedQuantifier = function(state) {
  if (this.regexp_eatBracedQuantifier(state, true)) {
    state.raise("Nothing to repeat");
  }
  return false;
};
pp$1.regexp_eatSyntaxCharacter = function(state) {
  var ch = state.current();
  if (isSyntaxCharacter(ch)) {
    state.lastIntValue = ch;
    state.advance();
    return true;
  }
  return false;
};
function isSyntaxCharacter(ch) {
  return ch === 36 || ch >= 40 && ch <= 43 || ch === 46 || ch === 63 || ch >= 91 && ch <= 94 || ch >= 123 && ch <= 125;
}
pp$1.regexp_eatPatternCharacters = function(state) {
  var start2 = state.pos;
  var ch = 0;
  while ((ch = state.current()) !== -1 && !isSyntaxCharacter(ch)) {
    state.advance();
  }
  return state.pos !== start2;
};
pp$1.regexp_eatExtendedPatternCharacter = function(state) {
  var ch = state.current();
  if (ch !== -1 && ch !== 36 && !(ch >= 40 && ch <= 43) && ch !== 46 && ch !== 63 && ch !== 91 && ch !== 94 && ch !== 124) {
    state.advance();
    return true;
  }
  return false;
};
pp$1.regexp_groupSpecifier = function(state) {
  if (state.eat(
    63
    /* ? */
  )) {
    if (!this.regexp_eatGroupName(state)) {
      state.raise("Invalid group");
    }
    var trackDisjunction = this.options.ecmaVersion >= 16;
    var known = state.groupNames[state.lastStringValue];
    if (known) {
      if (trackDisjunction) {
        for (var i3 = 0, list4 = known; i3 < list4.length; i3 += 1) {
          var altID = list4[i3];
          if (!altID.separatedFrom(state.branchID)) {
            state.raise("Duplicate capture group name");
          }
        }
      } else {
        state.raise("Duplicate capture group name");
      }
    }
    if (trackDisjunction) {
      (known || (state.groupNames[state.lastStringValue] = [])).push(state.branchID);
    } else {
      state.groupNames[state.lastStringValue] = true;
    }
  }
};
pp$1.regexp_eatGroupName = function(state) {
  state.lastStringValue = "";
  if (state.eat(
    60
    /* < */
  )) {
    if (this.regexp_eatRegExpIdentifierName(state) && state.eat(
      62
      /* > */
    )) {
      return true;
    }
    state.raise("Invalid capture group name");
  }
  return false;
};
pp$1.regexp_eatRegExpIdentifierName = function(state) {
  state.lastStringValue = "";
  if (this.regexp_eatRegExpIdentifierStart(state)) {
    state.lastStringValue += codePointToString(state.lastIntValue);
    while (this.regexp_eatRegExpIdentifierPart(state)) {
      state.lastStringValue += codePointToString(state.lastIntValue);
    }
    return true;
  }
  return false;
};
pp$1.regexp_eatRegExpIdentifierStart = function(state) {
  var start2 = state.pos;
  var forceU = this.options.ecmaVersion >= 11;
  var ch = state.current(forceU);
  state.advance(forceU);
  if (ch === 92 && this.regexp_eatRegExpUnicodeEscapeSequence(state, forceU)) {
    ch = state.lastIntValue;
  }
  if (isRegExpIdentifierStart(ch)) {
    state.lastIntValue = ch;
    return true;
  }
  state.pos = start2;
  return false;
};
function isRegExpIdentifierStart(ch) {
  return isIdentifierStart(ch, true) || ch === 36 || ch === 95;
}
pp$1.regexp_eatRegExpIdentifierPart = function(state) {
  var start2 = state.pos;
  var forceU = this.options.ecmaVersion >= 11;
  var ch = state.current(forceU);
  state.advance(forceU);
  if (ch === 92 && this.regexp_eatRegExpUnicodeEscapeSequence(state, forceU)) {
    ch = state.lastIntValue;
  }
  if (isRegExpIdentifierPart(ch)) {
    state.lastIntValue = ch;
    return true;
  }
  state.pos = start2;
  return false;
};
function isRegExpIdentifierPart(ch) {
  return isIdentifierChar(ch, true) || ch === 36 || ch === 95 || ch === 8204 || ch === 8205;
}
pp$1.regexp_eatAtomEscape = function(state) {
  if (this.regexp_eatBackReference(state) || this.regexp_eatCharacterClassEscape(state) || this.regexp_eatCharacterEscape(state) || state.switchN && this.regexp_eatKGroupName(state)) {
    return true;
  }
  if (state.switchU) {
    if (state.current() === 99) {
      state.raise("Invalid unicode escape");
    }
    state.raise("Invalid escape");
  }
  return false;
};
pp$1.regexp_eatBackReference = function(state) {
  var start2 = state.pos;
  if (this.regexp_eatDecimalEscape(state)) {
    var n3 = state.lastIntValue;
    if (state.switchU) {
      if (n3 > state.maxBackReference) {
        state.maxBackReference = n3;
      }
      return true;
    }
    if (n3 <= state.numCapturingParens) {
      return true;
    }
    state.pos = start2;
  }
  return false;
};
pp$1.regexp_eatKGroupName = function(state) {
  if (state.eat(
    107
    /* k */
  )) {
    if (this.regexp_eatGroupName(state)) {
      state.backReferenceNames.push(state.lastStringValue);
      return true;
    }
    state.raise("Invalid named reference");
  }
  return false;
};
pp$1.regexp_eatCharacterEscape = function(state) {
  return this.regexp_eatControlEscape(state) || this.regexp_eatCControlLetter(state) || this.regexp_eatZero(state) || this.regexp_eatHexEscapeSequence(state) || this.regexp_eatRegExpUnicodeEscapeSequence(state, false) || !state.switchU && this.regexp_eatLegacyOctalEscapeSequence(state) || this.regexp_eatIdentityEscape(state);
};
pp$1.regexp_eatCControlLetter = function(state) {
  var start2 = state.pos;
  if (state.eat(
    99
    /* c */
  )) {
    if (this.regexp_eatControlLetter(state)) {
      return true;
    }
    state.pos = start2;
  }
  return false;
};
pp$1.regexp_eatZero = function(state) {
  if (state.current() === 48 && !isDecimalDigit(state.lookahead())) {
    state.lastIntValue = 0;
    state.advance();
    return true;
  }
  return false;
};
pp$1.regexp_eatControlEscape = function(state) {
  var ch = state.current();
  if (ch === 116) {
    state.lastIntValue = 9;
    state.advance();
    return true;
  }
  if (ch === 110) {
    state.lastIntValue = 10;
    state.advance();
    return true;
  }
  if (ch === 118) {
    state.lastIntValue = 11;
    state.advance();
    return true;
  }
  if (ch === 102) {
    state.lastIntValue = 12;
    state.advance();
    return true;
  }
  if (ch === 114) {
    state.lastIntValue = 13;
    state.advance();
    return true;
  }
  return false;
};
pp$1.regexp_eatControlLetter = function(state) {
  var ch = state.current();
  if (isControlLetter(ch)) {
    state.lastIntValue = ch % 32;
    state.advance();
    return true;
  }
  return false;
};
function isControlLetter(ch) {
  return ch >= 65 && ch <= 90 || ch >= 97 && ch <= 122;
}
pp$1.regexp_eatRegExpUnicodeEscapeSequence = function(state, forceU) {
  if (forceU === void 0) forceU = false;
  var start2 = state.pos;
  var switchU = forceU || state.switchU;
  if (state.eat(
    117
    /* u */
  )) {
    if (this.regexp_eatFixedHexDigits(state, 4)) {
      var lead = state.lastIntValue;
      if (switchU && lead >= 55296 && lead <= 56319) {
        var leadSurrogateEnd = state.pos;
        if (state.eat(
          92
          /* \ */
        ) && state.eat(
          117
          /* u */
        ) && this.regexp_eatFixedHexDigits(state, 4)) {
          var trail = state.lastIntValue;
          if (trail >= 56320 && trail <= 57343) {
            state.lastIntValue = (lead - 55296) * 1024 + (trail - 56320) + 65536;
            return true;
          }
        }
        state.pos = leadSurrogateEnd;
        state.lastIntValue = lead;
      }
      return true;
    }
    if (switchU && state.eat(
      123
      /* { */
    ) && this.regexp_eatHexDigits(state) && state.eat(
      125
      /* } */
    ) && isValidUnicode(state.lastIntValue)) {
      return true;
    }
    if (switchU) {
      state.raise("Invalid unicode escape");
    }
    state.pos = start2;
  }
  return false;
};
function isValidUnicode(ch) {
  return ch >= 0 && ch <= 1114111;
}
pp$1.regexp_eatIdentityEscape = function(state) {
  if (state.switchU) {
    if (this.regexp_eatSyntaxCharacter(state)) {
      return true;
    }
    if (state.eat(
      47
      /* / */
    )) {
      state.lastIntValue = 47;
      return true;
    }
    return false;
  }
  var ch = state.current();
  if (ch !== 99 && (!state.switchN || ch !== 107)) {
    state.lastIntValue = ch;
    state.advance();
    return true;
  }
  return false;
};
pp$1.regexp_eatDecimalEscape = function(state) {
  state.lastIntValue = 0;
  var ch = state.current();
  if (ch >= 49 && ch <= 57) {
    do {
      state.lastIntValue = 10 * state.lastIntValue + (ch - 48);
      state.advance();
    } while ((ch = state.current()) >= 48 && ch <= 57);
    return true;
  }
  return false;
};
var CharSetNone = 0;
var CharSetOk = 1;
var CharSetString = 2;
pp$1.regexp_eatCharacterClassEscape = function(state) {
  var ch = state.current();
  if (isCharacterClassEscape(ch)) {
    state.lastIntValue = -1;
    state.advance();
    return CharSetOk;
  }
  var negate = false;
  if (state.switchU && this.options.ecmaVersion >= 9 && ((negate = ch === 80) || ch === 112)) {
    state.lastIntValue = -1;
    state.advance();
    var result;
    if (state.eat(
      123
      /* { */
    ) && (result = this.regexp_eatUnicodePropertyValueExpression(state)) && state.eat(
      125
      /* } */
    )) {
      if (negate && result === CharSetString) {
        state.raise("Invalid property name");
      }
      return result;
    }
    state.raise("Invalid property name");
  }
  return CharSetNone;
};
function isCharacterClassEscape(ch) {
  return ch === 100 || ch === 68 || ch === 115 || ch === 83 || ch === 119 || ch === 87;
}
pp$1.regexp_eatUnicodePropertyValueExpression = function(state) {
  var start2 = state.pos;
  if (this.regexp_eatUnicodePropertyName(state) && state.eat(
    61
    /* = */
  )) {
    var name2 = state.lastStringValue;
    if (this.regexp_eatUnicodePropertyValue(state)) {
      var value2 = state.lastStringValue;
      this.regexp_validateUnicodePropertyNameAndValue(state, name2, value2);
      return CharSetOk;
    }
  }
  state.pos = start2;
  if (this.regexp_eatLoneUnicodePropertyNameOrValue(state)) {
    var nameOrValue = state.lastStringValue;
    return this.regexp_validateUnicodePropertyNameOrValue(state, nameOrValue);
  }
  return CharSetNone;
};
pp$1.regexp_validateUnicodePropertyNameAndValue = function(state, name2, value2) {
  if (!hasOwn(state.unicodeProperties.nonBinary, name2)) {
    state.raise("Invalid property name");
  }
  if (!state.unicodeProperties.nonBinary[name2].test(value2)) {
    state.raise("Invalid property value");
  }
};
pp$1.regexp_validateUnicodePropertyNameOrValue = function(state, nameOrValue) {
  if (state.unicodeProperties.binary.test(nameOrValue)) {
    return CharSetOk;
  }
  if (state.switchV && state.unicodeProperties.binaryOfStrings.test(nameOrValue)) {
    return CharSetString;
  }
  state.raise("Invalid property name");
};
pp$1.regexp_eatUnicodePropertyName = function(state) {
  var ch = 0;
  state.lastStringValue = "";
  while (isUnicodePropertyNameCharacter(ch = state.current())) {
    state.lastStringValue += codePointToString(ch);
    state.advance();
  }
  return state.lastStringValue !== "";
};
function isUnicodePropertyNameCharacter(ch) {
  return isControlLetter(ch) || ch === 95;
}
pp$1.regexp_eatUnicodePropertyValue = function(state) {
  var ch = 0;
  state.lastStringValue = "";
  while (isUnicodePropertyValueCharacter(ch = state.current())) {
    state.lastStringValue += codePointToString(ch);
    state.advance();
  }
  return state.lastStringValue !== "";
};
function isUnicodePropertyValueCharacter(ch) {
  return isUnicodePropertyNameCharacter(ch) || isDecimalDigit(ch);
}
pp$1.regexp_eatLoneUnicodePropertyNameOrValue = function(state) {
  return this.regexp_eatUnicodePropertyValue(state);
};
pp$1.regexp_eatCharacterClass = function(state) {
  if (state.eat(
    91
    /* [ */
  )) {
    var negate = state.eat(
      94
      /* ^ */
    );
    var result = this.regexp_classContents(state);
    if (!state.eat(
      93
      /* ] */
    )) {
      state.raise("Unterminated character class");
    }
    if (negate && result === CharSetString) {
      state.raise("Negated character class may contain strings");
    }
    return true;
  }
  return false;
};
pp$1.regexp_classContents = function(state) {
  if (state.current() === 93) {
    return CharSetOk;
  }
  if (state.switchV) {
    return this.regexp_classSetExpression(state);
  }
  this.regexp_nonEmptyClassRanges(state);
  return CharSetOk;
};
pp$1.regexp_nonEmptyClassRanges = function(state) {
  while (this.regexp_eatClassAtom(state)) {
    var left = state.lastIntValue;
    if (state.eat(
      45
      /* - */
    ) && this.regexp_eatClassAtom(state)) {
      var right = state.lastIntValue;
      if (state.switchU && (left === -1 || right === -1)) {
        state.raise("Invalid character class");
      }
      if (left !== -1 && right !== -1 && left > right) {
        state.raise("Range out of order in character class");
      }
    }
  }
};
pp$1.regexp_eatClassAtom = function(state) {
  var start2 = state.pos;
  if (state.eat(
    92
    /* \ */
  )) {
    if (this.regexp_eatClassEscape(state)) {
      return true;
    }
    if (state.switchU) {
      var ch$1 = state.current();
      if (ch$1 === 99 || isOctalDigit(ch$1)) {
        state.raise("Invalid class escape");
      }
      state.raise("Invalid escape");
    }
    state.pos = start2;
  }
  var ch = state.current();
  if (ch !== 93) {
    state.lastIntValue = ch;
    state.advance();
    return true;
  }
  return false;
};
pp$1.regexp_eatClassEscape = function(state) {
  var start2 = state.pos;
  if (state.eat(
    98
    /* b */
  )) {
    state.lastIntValue = 8;
    return true;
  }
  if (state.switchU && state.eat(
    45
    /* - */
  )) {
    state.lastIntValue = 45;
    return true;
  }
  if (!state.switchU && state.eat(
    99
    /* c */
  )) {
    if (this.regexp_eatClassControlLetter(state)) {
      return true;
    }
    state.pos = start2;
  }
  return this.regexp_eatCharacterClassEscape(state) || this.regexp_eatCharacterEscape(state);
};
pp$1.regexp_classSetExpression = function(state) {
  var result = CharSetOk, subResult;
  if (this.regexp_eatClassSetRange(state)) ;
  else if (subResult = this.regexp_eatClassSetOperand(state)) {
    if (subResult === CharSetString) {
      result = CharSetString;
    }
    var start2 = state.pos;
    while (state.eatChars(
      [38, 38]
      /* && */
    )) {
      if (state.current() !== 38 && (subResult = this.regexp_eatClassSetOperand(state))) {
        if (subResult !== CharSetString) {
          result = CharSetOk;
        }
        continue;
      }
      state.raise("Invalid character in character class");
    }
    if (start2 !== state.pos) {
      return result;
    }
    while (state.eatChars(
      [45, 45]
      /* -- */
    )) {
      if (this.regexp_eatClassSetOperand(state)) {
        continue;
      }
      state.raise("Invalid character in character class");
    }
    if (start2 !== state.pos) {
      return result;
    }
  } else {
    state.raise("Invalid character in character class");
  }
  for (; ; ) {
    if (this.regexp_eatClassSetRange(state)) {
      continue;
    }
    subResult = this.regexp_eatClassSetOperand(state);
    if (!subResult) {
      return result;
    }
    if (subResult === CharSetString) {
      result = CharSetString;
    }
  }
};
pp$1.regexp_eatClassSetRange = function(state) {
  var start2 = state.pos;
  if (this.regexp_eatClassSetCharacter(state)) {
    var left = state.lastIntValue;
    if (state.eat(
      45
      /* - */
    ) && this.regexp_eatClassSetCharacter(state)) {
      var right = state.lastIntValue;
      if (left !== -1 && right !== -1 && left > right) {
        state.raise("Range out of order in character class");
      }
      return true;
    }
    state.pos = start2;
  }
  return false;
};
pp$1.regexp_eatClassSetOperand = function(state) {
  if (this.regexp_eatClassSetCharacter(state)) {
    return CharSetOk;
  }
  return this.regexp_eatClassStringDisjunction(state) || this.regexp_eatNestedClass(state);
};
pp$1.regexp_eatNestedClass = function(state) {
  var start2 = state.pos;
  if (state.eat(
    91
    /* [ */
  )) {
    var negate = state.eat(
      94
      /* ^ */
    );
    var result = this.regexp_classContents(state);
    if (state.eat(
      93
      /* ] */
    )) {
      if (negate && result === CharSetString) {
        state.raise("Negated character class may contain strings");
      }
      return result;
    }
    state.pos = start2;
  }
  if (state.eat(
    92
    /* \ */
  )) {
    var result$1 = this.regexp_eatCharacterClassEscape(state);
    if (result$1) {
      return result$1;
    }
    state.pos = start2;
  }
  return null;
};
pp$1.regexp_eatClassStringDisjunction = function(state) {
  var start2 = state.pos;
  if (state.eatChars(
    [92, 113]
    /* \q */
  )) {
    if (state.eat(
      123
      /* { */
    )) {
      var result = this.regexp_classStringDisjunctionContents(state);
      if (state.eat(
        125
        /* } */
      )) {
        return result;
      }
    } else {
      state.raise("Invalid escape");
    }
    state.pos = start2;
  }
  return null;
};
pp$1.regexp_classStringDisjunctionContents = function(state) {
  var result = this.regexp_classString(state);
  while (state.eat(
    124
    /* | */
  )) {
    if (this.regexp_classString(state) === CharSetString) {
      result = CharSetString;
    }
  }
  return result;
};
pp$1.regexp_classString = function(state) {
  var count3 = 0;
  while (this.regexp_eatClassSetCharacter(state)) {
    count3++;
  }
  return count3 === 1 ? CharSetOk : CharSetString;
};
pp$1.regexp_eatClassSetCharacter = function(state) {
  var start2 = state.pos;
  if (state.eat(
    92
    /* \ */
  )) {
    if (this.regexp_eatCharacterEscape(state) || this.regexp_eatClassSetReservedPunctuator(state)) {
      return true;
    }
    if (state.eat(
      98
      /* b */
    )) {
      state.lastIntValue = 8;
      return true;
    }
    state.pos = start2;
    return false;
  }
  var ch = state.current();
  if (ch < 0 || ch === state.lookahead() && isClassSetReservedDoublePunctuatorCharacter(ch)) {
    return false;
  }
  if (isClassSetSyntaxCharacter(ch)) {
    return false;
  }
  state.advance();
  state.lastIntValue = ch;
  return true;
};
function isClassSetReservedDoublePunctuatorCharacter(ch) {
  return ch === 33 || ch >= 35 && ch <= 38 || ch >= 42 && ch <= 44 || ch === 46 || ch >= 58 && ch <= 64 || ch === 94 || ch === 96 || ch === 126;
}
function isClassSetSyntaxCharacter(ch) {
  return ch === 40 || ch === 41 || ch === 45 || ch === 47 || ch >= 91 && ch <= 93 || ch >= 123 && ch <= 125;
}
pp$1.regexp_eatClassSetReservedPunctuator = function(state) {
  var ch = state.current();
  if (isClassSetReservedPunctuator(ch)) {
    state.lastIntValue = ch;
    state.advance();
    return true;
  }
  return false;
};
function isClassSetReservedPunctuator(ch) {
  return ch === 33 || ch === 35 || ch === 37 || ch === 38 || ch === 44 || ch === 45 || ch >= 58 && ch <= 62 || ch === 64 || ch === 96 || ch === 126;
}
pp$1.regexp_eatClassControlLetter = function(state) {
  var ch = state.current();
  if (isDecimalDigit(ch) || ch === 95) {
    state.lastIntValue = ch % 32;
    state.advance();
    return true;
  }
  return false;
};
pp$1.regexp_eatHexEscapeSequence = function(state) {
  var start2 = state.pos;
  if (state.eat(
    120
    /* x */
  )) {
    if (this.regexp_eatFixedHexDigits(state, 2)) {
      return true;
    }
    if (state.switchU) {
      state.raise("Invalid escape");
    }
    state.pos = start2;
  }
  return false;
};
pp$1.regexp_eatDecimalDigits = function(state) {
  var start2 = state.pos;
  var ch = 0;
  state.lastIntValue = 0;
  while (isDecimalDigit(ch = state.current())) {
    state.lastIntValue = 10 * state.lastIntValue + (ch - 48);
    state.advance();
  }
  return state.pos !== start2;
};
function isDecimalDigit(ch) {
  return ch >= 48 && ch <= 57;
}
pp$1.regexp_eatHexDigits = function(state) {
  var start2 = state.pos;
  var ch = 0;
  state.lastIntValue = 0;
  while (isHexDigit(ch = state.current())) {
    state.lastIntValue = 16 * state.lastIntValue + hexToInt(ch);
    state.advance();
  }
  return state.pos !== start2;
};
function isHexDigit(ch) {
  return ch >= 48 && ch <= 57 || ch >= 65 && ch <= 70 || ch >= 97 && ch <= 102;
}
function hexToInt(ch) {
  if (ch >= 65 && ch <= 70) {
    return 10 + (ch - 65);
  }
  if (ch >= 97 && ch <= 102) {
    return 10 + (ch - 97);
  }
  return ch - 48;
}
pp$1.regexp_eatLegacyOctalEscapeSequence = function(state) {
  if (this.regexp_eatOctalDigit(state)) {
    var n1 = state.lastIntValue;
    if (this.regexp_eatOctalDigit(state)) {
      var n22 = state.lastIntValue;
      if (n1 <= 3 && this.regexp_eatOctalDigit(state)) {
        state.lastIntValue = n1 * 64 + n22 * 8 + state.lastIntValue;
      } else {
        state.lastIntValue = n1 * 8 + n22;
      }
    } else {
      state.lastIntValue = n1;
    }
    return true;
  }
  return false;
};
pp$1.regexp_eatOctalDigit = function(state) {
  var ch = state.current();
  if (isOctalDigit(ch)) {
    state.lastIntValue = ch - 48;
    state.advance();
    return true;
  }
  state.lastIntValue = 0;
  return false;
};
function isOctalDigit(ch) {
  return ch >= 48 && ch <= 55;
}
pp$1.regexp_eatFixedHexDigits = function(state, length) {
  var start2 = state.pos;
  state.lastIntValue = 0;
  for (var i3 = 0; i3 < length; ++i3) {
    var ch = state.current();
    if (!isHexDigit(ch)) {
      state.pos = start2;
      return false;
    }
    state.lastIntValue = 16 * state.lastIntValue + hexToInt(ch);
    state.advance();
  }
  return true;
};
var Token = function Token2(p2) {
  this.type = p2.type;
  this.value = p2.value;
  this.start = p2.start;
  this.end = p2.end;
  if (p2.options.locations) {
    this.loc = new SourceLocation(p2, p2.startLoc, p2.endLoc);
  }
  if (p2.options.ranges) {
    this.range = [p2.start, p2.end];
  }
};
var pp = Parser.prototype;
pp.next = function(ignoreEscapeSequenceInKeyword) {
  if (!ignoreEscapeSequenceInKeyword && this.type.keyword && this.containsEsc) {
    this.raiseRecoverable(this.start, "Escape sequence in keyword " + this.type.keyword);
  }
  if (this.options.onToken) {
    this.options.onToken(new Token(this));
  }
  this.lastTokEnd = this.end;
  this.lastTokStart = this.start;
  this.lastTokEndLoc = this.endLoc;
  this.lastTokStartLoc = this.startLoc;
  this.nextToken();
};
pp.getToken = function() {
  this.next();
  return new Token(this);
};
if (typeof Symbol !== "undefined") {
  pp[Symbol.iterator] = function() {
    var this$1$1 = this;
    return {
      next: function() {
        var token = this$1$1.getToken();
        return {
          done: token.type === types$1.eof,
          value: token
        };
      }
    };
  };
}
pp.nextToken = function() {
  var curContext = this.curContext();
  if (!curContext || !curContext.preserveSpace) {
    this.skipSpace();
  }
  this.start = this.pos;
  if (this.options.locations) {
    this.startLoc = this.curPosition();
  }
  if (this.pos >= this.input.length) {
    return this.finishToken(types$1.eof);
  }
  if (curContext.override) {
    return curContext.override(this);
  } else {
    this.readToken(this.fullCharCodeAtPos());
  }
};
pp.readToken = function(code3) {
  if (isIdentifierStart(code3, this.options.ecmaVersion >= 6) || code3 === 92) {
    return this.readWord();
  }
  return this.getTokenFromCode(code3);
};
pp.fullCharCodeAtPos = function() {
  var code3 = this.input.charCodeAt(this.pos);
  if (code3 <= 55295 || code3 >= 56320) {
    return code3;
  }
  var next = this.input.charCodeAt(this.pos + 1);
  return next <= 56319 || next >= 57344 ? code3 : (code3 << 10) + next - 56613888;
};
pp.skipBlockComment = function() {
  var startLoc = this.options.onComment && this.curPosition();
  var start2 = this.pos, end = this.input.indexOf("*/", this.pos += 2);
  if (end === -1) {
    this.raise(this.pos - 2, "Unterminated comment");
  }
  this.pos = end + 2;
  if (this.options.locations) {
    for (var nextBreak = void 0, pos = start2; (nextBreak = nextLineBreak(this.input, pos, this.pos)) > -1; ) {
      ++this.curLine;
      pos = this.lineStart = nextBreak;
    }
  }
  if (this.options.onComment) {
    this.options.onComment(
      true,
      this.input.slice(start2 + 2, end),
      start2,
      this.pos,
      startLoc,
      this.curPosition()
    );
  }
};
pp.skipLineComment = function(startSkip) {
  var start2 = this.pos;
  var startLoc = this.options.onComment && this.curPosition();
  var ch = this.input.charCodeAt(this.pos += startSkip);
  while (this.pos < this.input.length && !isNewLine(ch)) {
    ch = this.input.charCodeAt(++this.pos);
  }
  if (this.options.onComment) {
    this.options.onComment(
      false,
      this.input.slice(start2 + startSkip, this.pos),
      start2,
      this.pos,
      startLoc,
      this.curPosition()
    );
  }
};
pp.skipSpace = function() {
  loop: while (this.pos < this.input.length) {
    var ch = this.input.charCodeAt(this.pos);
    switch (ch) {
      case 32:
      case 160:
        ++this.pos;
        break;
      case 13:
        if (this.input.charCodeAt(this.pos + 1) === 10) {
          ++this.pos;
        }
      case 10:
      case 8232:
      case 8233:
        ++this.pos;
        if (this.options.locations) {
          ++this.curLine;
          this.lineStart = this.pos;
        }
        break;
      case 47:
        switch (this.input.charCodeAt(this.pos + 1)) {
          case 42:
            this.skipBlockComment();
            break;
          case 47:
            this.skipLineComment(2);
            break;
          default:
            break loop;
        }
        break;
      default:
        if (ch > 8 && ch < 14 || ch >= 5760 && nonASCIIwhitespace.test(String.fromCharCode(ch))) {
          ++this.pos;
        } else {
          break loop;
        }
    }
  }
};
pp.finishToken = function(type2, val) {
  this.end = this.pos;
  if (this.options.locations) {
    this.endLoc = this.curPosition();
  }
  var prevType = this.type;
  this.type = type2;
  this.value = val;
  this.updateContext(prevType);
};
pp.readToken_dot = function() {
  var next = this.input.charCodeAt(this.pos + 1);
  if (next >= 48 && next <= 57) {
    return this.readNumber(true);
  }
  var next2 = this.input.charCodeAt(this.pos + 2);
  if (this.options.ecmaVersion >= 6 && next === 46 && next2 === 46) {
    this.pos += 3;
    return this.finishToken(types$1.ellipsis);
  } else {
    ++this.pos;
    return this.finishToken(types$1.dot);
  }
};
pp.readToken_slash = function() {
  var next = this.input.charCodeAt(this.pos + 1);
  if (this.exprAllowed) {
    ++this.pos;
    return this.readRegexp();
  }
  if (next === 61) {
    return this.finishOp(types$1.assign, 2);
  }
  return this.finishOp(types$1.slash, 1);
};
pp.readToken_mult_modulo_exp = function(code3) {
  var next = this.input.charCodeAt(this.pos + 1);
  var size4 = 1;
  var tokentype = code3 === 42 ? types$1.star : types$1.modulo;
  if (this.options.ecmaVersion >= 7 && code3 === 42 && next === 42) {
    ++size4;
    tokentype = types$1.starstar;
    next = this.input.charCodeAt(this.pos + 2);
  }
  if (next === 61) {
    return this.finishOp(types$1.assign, size4 + 1);
  }
  return this.finishOp(tokentype, size4);
};
pp.readToken_pipe_amp = function(code3) {
  var next = this.input.charCodeAt(this.pos + 1);
  if (next === code3) {
    if (this.options.ecmaVersion >= 12) {
      var next2 = this.input.charCodeAt(this.pos + 2);
      if (next2 === 61) {
        return this.finishOp(types$1.assign, 3);
      }
    }
    return this.finishOp(code3 === 124 ? types$1.logicalOR : types$1.logicalAND, 2);
  }
  if (next === 61) {
    return this.finishOp(types$1.assign, 2);
  }
  return this.finishOp(code3 === 124 ? types$1.bitwiseOR : types$1.bitwiseAND, 1);
};
pp.readToken_caret = function() {
  var next = this.input.charCodeAt(this.pos + 1);
  if (next === 61) {
    return this.finishOp(types$1.assign, 2);
  }
  return this.finishOp(types$1.bitwiseXOR, 1);
};
pp.readToken_plus_min = function(code3) {
  var next = this.input.charCodeAt(this.pos + 1);
  if (next === code3) {
    if (next === 45 && !this.inModule && this.input.charCodeAt(this.pos + 2) === 62 && (this.lastTokEnd === 0 || lineBreak.test(this.input.slice(this.lastTokEnd, this.pos)))) {
      this.skipLineComment(3);
      this.skipSpace();
      return this.nextToken();
    }
    return this.finishOp(types$1.incDec, 2);
  }
  if (next === 61) {
    return this.finishOp(types$1.assign, 2);
  }
  return this.finishOp(types$1.plusMin, 1);
};
pp.readToken_lt_gt = function(code3) {
  var next = this.input.charCodeAt(this.pos + 1);
  var size4 = 1;
  if (next === code3) {
    size4 = code3 === 62 && this.input.charCodeAt(this.pos + 2) === 62 ? 3 : 2;
    if (this.input.charCodeAt(this.pos + size4) === 61) {
      return this.finishOp(types$1.assign, size4 + 1);
    }
    return this.finishOp(types$1.bitShift, size4);
  }
  if (next === 33 && code3 === 60 && !this.inModule && this.input.charCodeAt(this.pos + 2) === 45 && this.input.charCodeAt(this.pos + 3) === 45) {
    this.skipLineComment(4);
    this.skipSpace();
    return this.nextToken();
  }
  if (next === 61) {
    size4 = 2;
  }
  return this.finishOp(types$1.relational, size4);
};
pp.readToken_eq_excl = function(code3) {
  var next = this.input.charCodeAt(this.pos + 1);
  if (next === 61) {
    return this.finishOp(types$1.equality, this.input.charCodeAt(this.pos + 2) === 61 ? 3 : 2);
  }
  if (code3 === 61 && next === 62 && this.options.ecmaVersion >= 6) {
    this.pos += 2;
    return this.finishToken(types$1.arrow);
  }
  return this.finishOp(code3 === 61 ? types$1.eq : types$1.prefix, 1);
};
pp.readToken_question = function() {
  var ecmaVersion = this.options.ecmaVersion;
  if (ecmaVersion >= 11) {
    var next = this.input.charCodeAt(this.pos + 1);
    if (next === 46) {
      var next2 = this.input.charCodeAt(this.pos + 2);
      if (next2 < 48 || next2 > 57) {
        return this.finishOp(types$1.questionDot, 2);
      }
    }
    if (next === 63) {
      if (ecmaVersion >= 12) {
        var next2$1 = this.input.charCodeAt(this.pos + 2);
        if (next2$1 === 61) {
          return this.finishOp(types$1.assign, 3);
        }
      }
      return this.finishOp(types$1.coalesce, 2);
    }
  }
  return this.finishOp(types$1.question, 1);
};
pp.readToken_numberSign = function() {
  var ecmaVersion = this.options.ecmaVersion;
  var code3 = 35;
  if (ecmaVersion >= 13) {
    ++this.pos;
    code3 = this.fullCharCodeAtPos();
    if (isIdentifierStart(code3, true) || code3 === 92) {
      return this.finishToken(types$1.privateId, this.readWord1());
    }
  }
  this.raise(this.pos, "Unexpected character '" + codePointToString(code3) + "'");
};
pp.getTokenFromCode = function(code3) {
  switch (code3) {
    case 46:
      return this.readToken_dot();
    case 40:
      ++this.pos;
      return this.finishToken(types$1.parenL);
    case 41:
      ++this.pos;
      return this.finishToken(types$1.parenR);
    case 59:
      ++this.pos;
      return this.finishToken(types$1.semi);
    case 44:
      ++this.pos;
      return this.finishToken(types$1.comma);
    case 91:
      ++this.pos;
      return this.finishToken(types$1.bracketL);
    case 93:
      ++this.pos;
      return this.finishToken(types$1.bracketR);
    case 123:
      ++this.pos;
      return this.finishToken(types$1.braceL);
    case 125:
      ++this.pos;
      return this.finishToken(types$1.braceR);
    case 58:
      ++this.pos;
      return this.finishToken(types$1.colon);
    case 96:
      if (this.options.ecmaVersion < 6) {
        break;
      }
      ++this.pos;
      return this.finishToken(types$1.backQuote);
    case 48:
      var next = this.input.charCodeAt(this.pos + 1);
      if (next === 120 || next === 88) {
        return this.readRadixNumber(16);
      }
      if (this.options.ecmaVersion >= 6) {
        if (next === 111 || next === 79) {
          return this.readRadixNumber(8);
        }
        if (next === 98 || next === 66) {
          return this.readRadixNumber(2);
        }
      }
    case 49:
    case 50:
    case 51:
    case 52:
    case 53:
    case 54:
    case 55:
    case 56:
    case 57:
      return this.readNumber(false);
    case 34:
    case 39:
      return this.readString(code3);
    case 47:
      return this.readToken_slash();
    case 37:
    case 42:
      return this.readToken_mult_modulo_exp(code3);
    case 124:
    case 38:
      return this.readToken_pipe_amp(code3);
    case 94:
      return this.readToken_caret();
    case 43:
    case 45:
      return this.readToken_plus_min(code3);
    case 60:
    case 62:
      return this.readToken_lt_gt(code3);
    case 61:
    case 33:
      return this.readToken_eq_excl(code3);
    case 63:
      return this.readToken_question();
    case 126:
      return this.finishOp(types$1.prefix, 1);
    case 35:
      return this.readToken_numberSign();
  }
  this.raise(this.pos, "Unexpected character '" + codePointToString(code3) + "'");
};
pp.finishOp = function(type2, size4) {
  var str2 = this.input.slice(this.pos, this.pos + size4);
  this.pos += size4;
  return this.finishToken(type2, str2);
};
pp.readRegexp = function() {
  var escaped, inClass, start2 = this.pos;
  for (; ; ) {
    if (this.pos >= this.input.length) {
      this.raise(start2, "Unterminated regular expression");
    }
    var ch = this.input.charAt(this.pos);
    if (lineBreak.test(ch)) {
      this.raise(start2, "Unterminated regular expression");
    }
    if (!escaped) {
      if (ch === "[") {
        inClass = true;
      } else if (ch === "]" && inClass) {
        inClass = false;
      } else if (ch === "/" && !inClass) {
        break;
      }
      escaped = ch === "\\";
    } else {
      escaped = false;
    }
    ++this.pos;
  }
  var pattern = this.input.slice(start2, this.pos);
  ++this.pos;
  var flagsStart = this.pos;
  var flags = this.readWord1();
  if (this.containsEsc) {
    this.unexpected(flagsStart);
  }
  var state = this.regexpState || (this.regexpState = new RegExpValidationState(this));
  state.reset(start2, pattern, flags);
  this.validateRegExpFlags(state);
  this.validateRegExpPattern(state);
  var value2 = null;
  try {
    value2 = new RegExp(pattern, flags);
  } catch (e2) {
  }
  return this.finishToken(types$1.regexp, { pattern, flags, value: value2 });
};
pp.readInt = function(radix, len, maybeLegacyOctalNumericLiteral) {
  var allowSeparators = this.options.ecmaVersion >= 12 && len === void 0;
  var isLegacyOctalNumericLiteral = maybeLegacyOctalNumericLiteral && this.input.charCodeAt(this.pos) === 48;
  var start2 = this.pos, total = 0, lastCode = 0;
  for (var i3 = 0, e2 = len == null ? Infinity : len; i3 < e2; ++i3, ++this.pos) {
    var code3 = this.input.charCodeAt(this.pos), val = void 0;
    if (allowSeparators && code3 === 95) {
      if (isLegacyOctalNumericLiteral) {
        this.raiseRecoverable(this.pos, "Numeric separator is not allowed in legacy octal numeric literals");
      }
      if (lastCode === 95) {
        this.raiseRecoverable(this.pos, "Numeric separator must be exactly one underscore");
      }
      if (i3 === 0) {
        this.raiseRecoverable(this.pos, "Numeric separator is not allowed at the first of digits");
      }
      lastCode = code3;
      continue;
    }
    if (code3 >= 97) {
      val = code3 - 97 + 10;
    } else if (code3 >= 65) {
      val = code3 - 65 + 10;
    } else if (code3 >= 48 && code3 <= 57) {
      val = code3 - 48;
    } else {
      val = Infinity;
    }
    if (val >= radix) {
      break;
    }
    lastCode = code3;
    total = total * radix + val;
  }
  if (allowSeparators && lastCode === 95) {
    this.raiseRecoverable(this.pos - 1, "Numeric separator is not allowed at the last of digits");
  }
  if (this.pos === start2 || len != null && this.pos - start2 !== len) {
    return null;
  }
  return total;
};
function stringToNumber(str2, isLegacyOctalNumericLiteral) {
  if (isLegacyOctalNumericLiteral) {
    return parseInt(str2, 8);
  }
  return parseFloat(str2.replace(/_/g, ""));
}
function stringToBigInt(str2) {
  if (typeof BigInt !== "function") {
    return null;
  }
  return BigInt(str2.replace(/_/g, ""));
}
pp.readRadixNumber = function(radix) {
  var start2 = this.pos;
  this.pos += 2;
  var val = this.readInt(radix);
  if (val == null) {
    this.raise(this.start + 2, "Expected number in radix " + radix);
  }
  if (this.options.ecmaVersion >= 11 && this.input.charCodeAt(this.pos) === 110) {
    val = stringToBigInt(this.input.slice(start2, this.pos));
    ++this.pos;
  } else if (isIdentifierStart(this.fullCharCodeAtPos())) {
    this.raise(this.pos, "Identifier directly after number");
  }
  return this.finishToken(types$1.num, val);
};
pp.readNumber = function(startsWithDot) {
  var start2 = this.pos;
  if (!startsWithDot && this.readInt(10, void 0, true) === null) {
    this.raise(start2, "Invalid number");
  }
  var octal = this.pos - start2 >= 2 && this.input.charCodeAt(start2) === 48;
  if (octal && this.strict) {
    this.raise(start2, "Invalid number");
  }
  var next = this.input.charCodeAt(this.pos);
  if (!octal && !startsWithDot && this.options.ecmaVersion >= 11 && next === 110) {
    var val$1 = stringToBigInt(this.input.slice(start2, this.pos));
    ++this.pos;
    if (isIdentifierStart(this.fullCharCodeAtPos())) {
      this.raise(this.pos, "Identifier directly after number");
    }
    return this.finishToken(types$1.num, val$1);
  }
  if (octal && /[89]/.test(this.input.slice(start2, this.pos))) {
    octal = false;
  }
  if (next === 46 && !octal) {
    ++this.pos;
    this.readInt(10);
    next = this.input.charCodeAt(this.pos);
  }
  if ((next === 69 || next === 101) && !octal) {
    next = this.input.charCodeAt(++this.pos);
    if (next === 43 || next === 45) {
      ++this.pos;
    }
    if (this.readInt(10) === null) {
      this.raise(start2, "Invalid number");
    }
  }
  if (isIdentifierStart(this.fullCharCodeAtPos())) {
    this.raise(this.pos, "Identifier directly after number");
  }
  var val = stringToNumber(this.input.slice(start2, this.pos), octal);
  return this.finishToken(types$1.num, val);
};
pp.readCodePoint = function() {
  var ch = this.input.charCodeAt(this.pos), code3;
  if (ch === 123) {
    if (this.options.ecmaVersion < 6) {
      this.unexpected();
    }
    var codePos = ++this.pos;
    code3 = this.readHexChar(this.input.indexOf("}", this.pos) - this.pos);
    ++this.pos;
    if (code3 > 1114111) {
      this.invalidStringToken(codePos, "Code point out of bounds");
    }
  } else {
    code3 = this.readHexChar(4);
  }
  return code3;
};
pp.readString = function(quote) {
  var out = "", chunkStart = ++this.pos;
  for (; ; ) {
    if (this.pos >= this.input.length) {
      this.raise(this.start, "Unterminated string constant");
    }
    var ch = this.input.charCodeAt(this.pos);
    if (ch === quote) {
      break;
    }
    if (ch === 92) {
      out += this.input.slice(chunkStart, this.pos);
      out += this.readEscapedChar(false);
      chunkStart = this.pos;
    } else if (ch === 8232 || ch === 8233) {
      if (this.options.ecmaVersion < 10) {
        this.raise(this.start, "Unterminated string constant");
      }
      ++this.pos;
      if (this.options.locations) {
        this.curLine++;
        this.lineStart = this.pos;
      }
    } else {
      if (isNewLine(ch)) {
        this.raise(this.start, "Unterminated string constant");
      }
      ++this.pos;
    }
  }
  out += this.input.slice(chunkStart, this.pos++);
  return this.finishToken(types$1.string, out);
};
var INVALID_TEMPLATE_ESCAPE_ERROR = {};
pp.tryReadTemplateToken = function() {
  this.inTemplateElement = true;
  try {
    this.readTmplToken();
  } catch (err) {
    if (err === INVALID_TEMPLATE_ESCAPE_ERROR) {
      this.readInvalidTemplateToken();
    } else {
      throw err;
    }
  }
  this.inTemplateElement = false;
};
pp.invalidStringToken = function(position2, message) {
  if (this.inTemplateElement && this.options.ecmaVersion >= 9) {
    throw INVALID_TEMPLATE_ESCAPE_ERROR;
  } else {
    this.raise(position2, message);
  }
};
pp.readTmplToken = function() {
  var out = "", chunkStart = this.pos;
  for (; ; ) {
    if (this.pos >= this.input.length) {
      this.raise(this.start, "Unterminated template");
    }
    var ch = this.input.charCodeAt(this.pos);
    if (ch === 96 || ch === 36 && this.input.charCodeAt(this.pos + 1) === 123) {
      if (this.pos === this.start && (this.type === types$1.template || this.type === types$1.invalidTemplate)) {
        if (ch === 36) {
          this.pos += 2;
          return this.finishToken(types$1.dollarBraceL);
        } else {
          ++this.pos;
          return this.finishToken(types$1.backQuote);
        }
      }
      out += this.input.slice(chunkStart, this.pos);
      return this.finishToken(types$1.template, out);
    }
    if (ch === 92) {
      out += this.input.slice(chunkStart, this.pos);
      out += this.readEscapedChar(true);
      chunkStart = this.pos;
    } else if (isNewLine(ch)) {
      out += this.input.slice(chunkStart, this.pos);
      ++this.pos;
      switch (ch) {
        case 13:
          if (this.input.charCodeAt(this.pos) === 10) {
            ++this.pos;
          }
        case 10:
          out += "\n";
          break;
        default:
          out += String.fromCharCode(ch);
          break;
      }
      if (this.options.locations) {
        ++this.curLine;
        this.lineStart = this.pos;
      }
      chunkStart = this.pos;
    } else {
      ++this.pos;
    }
  }
};
pp.readInvalidTemplateToken = function() {
  for (; this.pos < this.input.length; this.pos++) {
    switch (this.input[this.pos]) {
      case "\\":
        ++this.pos;
        break;
      case "$":
        if (this.input[this.pos + 1] !== "{") {
          break;
        }
      case "`":
        return this.finishToken(types$1.invalidTemplate, this.input.slice(this.start, this.pos));
      case "\r":
        if (this.input[this.pos + 1] === "\n") {
          ++this.pos;
        }
      case "\n":
      case "\u2028":
      case "\u2029":
        ++this.curLine;
        this.lineStart = this.pos + 1;
        break;
    }
  }
  this.raise(this.start, "Unterminated template");
};
pp.readEscapedChar = function(inTemplate) {
  var ch = this.input.charCodeAt(++this.pos);
  ++this.pos;
  switch (ch) {
    case 110:
      return "\n";
    case 114:
      return "\r";
    case 120:
      return String.fromCharCode(this.readHexChar(2));
    case 117:
      return codePointToString(this.readCodePoint());
    case 116:
      return "	";
    case 98:
      return "\b";
    case 118:
      return "\v";
    case 102:
      return "\f";
    case 13:
      if (this.input.charCodeAt(this.pos) === 10) {
        ++this.pos;
      }
    case 10:
      if (this.options.locations) {
        this.lineStart = this.pos;
        ++this.curLine;
      }
      return "";
    case 56:
    case 57:
      if (this.strict) {
        this.invalidStringToken(
          this.pos - 1,
          "Invalid escape sequence"
        );
      }
      if (inTemplate) {
        var codePos = this.pos - 1;
        this.invalidStringToken(
          codePos,
          "Invalid escape sequence in template string"
        );
      }
    default:
      if (ch >= 48 && ch <= 55) {
        var octalStr = this.input.substr(this.pos - 1, 3).match(/^[0-7]+/)[0];
        var octal = parseInt(octalStr, 8);
        if (octal > 255) {
          octalStr = octalStr.slice(0, -1);
          octal = parseInt(octalStr, 8);
        }
        this.pos += octalStr.length - 1;
        ch = this.input.charCodeAt(this.pos);
        if ((octalStr !== "0" || ch === 56 || ch === 57) && (this.strict || inTemplate)) {
          this.invalidStringToken(
            this.pos - 1 - octalStr.length,
            inTemplate ? "Octal literal in template string" : "Octal literal in strict mode"
          );
        }
        return String.fromCharCode(octal);
      }
      if (isNewLine(ch)) {
        if (this.options.locations) {
          this.lineStart = this.pos;
          ++this.curLine;
        }
        return "";
      }
      return String.fromCharCode(ch);
  }
};
pp.readHexChar = function(len) {
  var codePos = this.pos;
  var n3 = this.readInt(16, len);
  if (n3 === null) {
    this.invalidStringToken(codePos, "Bad character escape sequence");
  }
  return n3;
};
pp.readWord1 = function() {
  this.containsEsc = false;
  var word = "", first = true, chunkStart = this.pos;
  var astral = this.options.ecmaVersion >= 6;
  while (this.pos < this.input.length) {
    var ch = this.fullCharCodeAtPos();
    if (isIdentifierChar(ch, astral)) {
      this.pos += ch <= 65535 ? 1 : 2;
    } else if (ch === 92) {
      this.containsEsc = true;
      word += this.input.slice(chunkStart, this.pos);
      var escStart = this.pos;
      if (this.input.charCodeAt(++this.pos) !== 117) {
        this.invalidStringToken(this.pos, "Expecting Unicode escape sequence \\uXXXX");
      }
      ++this.pos;
      var esc = this.readCodePoint();
      if (!(first ? isIdentifierStart : isIdentifierChar)(esc, astral)) {
        this.invalidStringToken(escStart, "Invalid Unicode escape");
      }
      word += codePointToString(esc);
      chunkStart = this.pos;
    } else {
      break;
    }
    first = false;
  }
  return word + this.input.slice(chunkStart, this.pos);
};
pp.readWord = function() {
  var word = this.readWord1();
  var type2 = types$1.name;
  if (this.keywords.test(word)) {
    type2 = keywords[word];
  }
  return this.finishToken(type2, word);
};
var version = "8.14.0";
Parser.acorn = {
  Parser,
  version,
  defaultOptions: defaultOptions2,
  Position,
  SourceLocation,
  getLineInfo,
  Node: Node2,
  TokenType,
  tokTypes: types$1,
  keywordTypes: keywords,
  TokContext,
  tokContexts: types3,
  isIdentifierChar,
  isIdentifierStart,
  Token,
  isNewLine,
  lineBreak,
  lineBreakG,
  nonASCIIwhitespace
};

// node_modules/micromark-extension-mdxjs/index.js
var import_acorn_jsx = __toESM(require_acorn_jsx());

// node_modules/micromark-extension-mdx-expression/dev/lib/syntax.js
function mdxExpression2(options) {
  const options_ = options || {};
  const addResult = options_.addResult;
  const acorn = options_.acorn;
  const spread = options_.spread;
  let allowEmpty = options_.allowEmpty;
  let acornOptions;
  if (allowEmpty === null || allowEmpty === void 0) {
    allowEmpty = true;
  }
  if (acorn) {
    if (!acorn.parseExpressionAt) {
      throw new Error(
        "Expected a proper `acorn` instance passed in as `options.acorn`"
      );
    }
    acornOptions = Object.assign(
      { ecmaVersion: 2024, sourceType: "module" },
      options_.acornOptions
    );
  } else if (options_.acornOptions || options_.addResult) {
    throw new Error("Expected an `acorn` instance passed in as `options.acorn`");
  }
  return {
    flow: {
      [codes.leftCurlyBrace]: {
        name: "mdxFlowExpression",
        tokenize: tokenizeFlowExpression,
        concrete: true
      }
    },
    text: {
      [codes.leftCurlyBrace]: {
        name: "mdxTextExpression",
        tokenize: tokenizeTextExpression
      }
    }
  };
  function tokenizeFlowExpression(effects, ok3, nok) {
    const self2 = this;
    return start2;
    function start2(code3) {
      ok(code3 === codes.leftCurlyBrace, "expected `{`");
      return before(code3);
    }
    function before(code3) {
      return factoryMdxExpression.call(
        self2,
        effects,
        after,
        "mdxFlowExpression",
        "mdxFlowExpressionMarker",
        "mdxFlowExpressionChunk",
        acorn,
        acornOptions,
        addResult,
        spread,
        allowEmpty
      )(code3);
    }
    function after(code3) {
      return markdownSpace(code3) ? factorySpace(effects, end, types.whitespace)(code3) : end(code3);
    }
    function end(code3) {
      const lessThanValue = self2.parser.constructs.flow[codes.lessThan];
      const constructs2 = Array.isArray(lessThanValue) ? lessThanValue : (
        /* c8 ignore next 3 -- always a list when normalized. */
        lessThanValue ? [lessThanValue] : []
      );
      const jsxTag = constructs2.find(function(d3) {
        return d3.name === "mdxJsxFlowTag";
      });
      if (code3 === codes.lessThan && jsxTag) {
        return effects.attempt(jsxTag, end, nok)(code3);
      }
      return code3 === codes.eof || markdownLineEnding(code3) ? ok3(code3) : nok(code3);
    }
  }
  function tokenizeTextExpression(effects, ok3) {
    const self2 = this;
    return start2;
    function start2(code3) {
      ok(code3 === codes.leftCurlyBrace, "expected `{`");
      return factoryMdxExpression.call(
        self2,
        effects,
        ok3,
        "mdxTextExpression",
        "mdxTextExpressionMarker",
        "mdxTextExpressionChunk",
        acorn,
        acornOptions,
        addResult,
        spread,
        allowEmpty,
        true
      )(code3);
    }
  }
}

// node_modules/micromark-extension-mdxjs-esm/dev/lib/syntax.js
var blankLineBefore2 = { tokenize: tokenizeNextBlank, partial: true };
var trouble3 = "https://github.com/micromark/micromark-extension-mdxjs-esm";
var allowedAcornTypes = /* @__PURE__ */ new Set([
  "ExportAllDeclaration",
  "ExportDefaultDeclaration",
  "ExportNamedDeclaration",
  "ImportDeclaration"
]);
function mdxjsEsm(options) {
  const exportImportConstruct = { tokenize: tokenizeExportImport, concrete: true };
  if (!options || !options.acorn || !options.acorn.parse) {
    throw new Error("Expected an `acorn` instance passed in as `options.acorn`");
  }
  const acorn = options.acorn;
  const acornOptions = Object.assign(
    { ecmaVersion: 2024, sourceType: "module" },
    options.acornOptions,
    { locations: true }
  );
  return {
    flow: {
      [codes.lowercaseE]: exportImportConstruct,
      [codes.lowercaseI]: exportImportConstruct
    }
  };
  function tokenizeExportImport(effects, ok3, nok) {
    const self2 = this;
    const definedModuleSpecifiers = self2.parser.definedModuleSpecifiers || (self2.parser.definedModuleSpecifiers = []);
    const eventStart = this.events.length + 1;
    let buffer = "";
    return self2.interrupt ? nok : start2;
    function start2(code3) {
      ok(
        code3 === codes.lowercaseE || code3 === codes.lowercaseI,
        "expected `e` or `i`"
      );
      if (self2.now().column > 1) return nok(code3);
      effects.enter("mdxjsEsm");
      effects.enter("mdxjsEsmData");
      effects.consume(code3);
      buffer += String.fromCharCode(code3);
      return word;
    }
    function word(code3) {
      if (asciiAlpha(code3)) {
        effects.consume(code3);
        buffer += String.fromCharCode(code3);
        return word;
      }
      if ((buffer === "import" || buffer === "export") && code3 === codes.space) {
        effects.consume(code3);
        return inside;
      }
      return nok(code3);
    }
    function inside(code3) {
      if (code3 === codes.eof || markdownLineEnding(code3)) {
        effects.exit("mdxjsEsmData");
        return lineStart(code3);
      }
      effects.consume(code3);
      return inside;
    }
    function lineStart(code3) {
      if (code3 === codes.eof) {
        return atEnd(code3);
      }
      if (markdownLineEnding(code3)) {
        return effects.check(blankLineBefore2, atEnd, continuationStart)(code3);
      }
      effects.enter("mdxjsEsmData");
      return inside(code3);
    }
    function continuationStart(code3) {
      ok(markdownLineEnding(code3));
      effects.enter(types.lineEnding);
      effects.consume(code3);
      effects.exit(types.lineEnding);
      return lineStart;
    }
    function atEnd(code3) {
      const result = eventsToAcorn(self2.events.slice(eventStart), {
        acorn,
        acornOptions,
        tokenTypes: ["mdxjsEsmData"],
        prefix: definedModuleSpecifiers.length > 0 ? "var " + definedModuleSpecifiers.join(",") + "\n" : ""
      });
      if (result.error) {
        if (code3 !== codes.eof && result.swallow) {
          return continuationStart(code3);
        }
        const error = new VFileMessage(
          "Could not parse import/exports with acorn",
          {
            cause: result.error,
            place: {
              line: result.error.loc.line,
              column: result.error.loc.column + 1,
              offset: result.error.pos
            },
            ruleId: "acorn",
            source: "micromark-extension-mdxjs-esm"
          }
        );
        error.url = trouble3 + "#could-not-parse-importexports-with-acorn";
        throw error;
      }
      ok(result.estree, "expected `estree` to be defined");
      if (definedModuleSpecifiers.length > 0) {
        const declaration = result.estree.body.shift();
        ok(declaration);
        ok(declaration.type === "VariableDeclaration");
      }
      let index3 = -1;
      while (++index3 < result.estree.body.length) {
        const node2 = result.estree.body[index3];
        if (!allowedAcornTypes.has(node2.type)) {
          const error = new VFileMessage(
            "Unexpected `" + node2.type + "` in code: only import/exports are supported",
            {
              place: positionFromEstree(node2),
              ruleId: "non-esm",
              source: "micromark-extension-mdxjs-esm"
            }
          );
          error.url = trouble3 + "#unexpected-type-in-code-only-importexports-are-supported";
          throw error;
        }
        if (node2.type === "ImportDeclaration" && !self2.interrupt) {
          let index4 = -1;
          while (++index4 < node2.specifiers.length) {
            const specifier = node2.specifiers[index4];
            definedModuleSpecifiers.push(specifier.local.name);
          }
        }
      }
      Object.assign(
        effects.exit("mdxjsEsm"),
        options.addResult ? { estree: result.estree } : void 0
      );
      return ok3(code3);
    }
  }
}
function tokenizeNextBlank(effects, ok3, nok) {
  return start2;
  function start2(code3) {
    ok(markdownLineEnding(code3));
    effects.enter(types.lineEndingBlank);
    effects.consume(code3);
    effects.exit(types.lineEndingBlank);
    return effects.attempt(blankLine, ok3, nok);
  }
}

// node_modules/micromark-extension-mdxjs/index.js
function mdxjs(options) {
  const settings = Object.assign(
    {
      acorn: Parser.extend((0, import_acorn_jsx.default)()),
      acornOptions: { ecmaVersion: 2024, sourceType: "module" },
      addResult: true
    },
    options
  );
  return combineExtensions([
    mdxjsEsm(settings),
    mdxExpression2(settings),
    mdxJsx(settings),
    mdxMd()
  ]);
}

// node_modules/@mdxeditor/editor/dist/plugins/jsx/LexicalJsxNode.js
var import_react40 = __toESM(require_react(), 1);

// node_modules/@mdxeditor/editor/dist/plugins/core/NestedLexicalEditor.js
var import_react39 = __toESM(require_react(), 1);
var import_classnames7 = __toESM(require_classnames(), 1);
var NestedEditorsContext = import_react39.default.createContext(void 0);
function useNestedEditorContext() {
  const context = import_react39.default.useContext(NestedEditorsContext);
  if (!context) {
    throw new Error("useNestedEditor must be used within a NestedEditorsProvider");
  }
  return context;
}
function useMdastNodeUpdater() {
  const { parentEditor, mdastNode, lexicalNode } = useNestedEditorContext();
  return function updateMdastNode(node2) {
    parentEditor.update(
      () => {
        $addUpdateTag("history-push");
        const currentNode = $getNodeByKey(lexicalNode.getKey());
        if (currentNode) {
          currentNode.setMdastNode({ ...mdastNode, ...node2 });
        }
      },
      { discrete: true }
    );
    parentEditor.dispatchCommand(NESTED_EDITOR_UPDATED_COMMAND, void 0);
  };
}
function useLexicalNodeRemove() {
  const { parentEditor, lexicalNode } = useNestedEditorContext();
  return () => {
    parentEditor.update(() => {
      const node2 = $getNodeByKey(lexicalNode.getKey());
      node2.selectNext();
      node2.remove();
    });
  };
}
var NestedLexicalEditor = function(props) {
  const { getContent, getUpdatedMdastNode, contentEditableProps, block = false } = props;
  const { mdastNode, lexicalNode, focusEmitter } = useNestedEditorContext();
  const updateMdastNode = useMdastNodeUpdater();
  const removeNode = useLexicalNodeRemove();
  const content3 = getContent(mdastNode);
  const realm = R();
  const [
    rootEditor,
    importVisitors,
    exportVisitors,
    usedLexicalNodes,
    jsxComponentDescriptors,
    directiveDescriptors,
    codeBlockEditorDescriptors,
    jsxIsAvailable,
    nestedEditorChildren,
    lexicalTheme2
  ] = X(
    rootEditor$,
    importVisitors$,
    exportVisitors$,
    usedLexicalNodes$,
    jsxComponentDescriptors$,
    directiveDescriptors$,
    codeBlockEditorDescriptors$,
    jsxIsAvailable$,
    nestedEditorChildren$,
    lexicalTheme$
  );
  const setEditorInFocus = A(editorInFocus$);
  const [editor] = import_react39.default.useState(() => {
    const editor2 = createEditor({
      nodes: usedLexicalNodes,
      theme: realm.getValue(lexicalTheme$)
    });
    return editor2;
  });
  import_react39.default.useEffect(() => {
    focusEmitter.subscribe(() => {
      editor.focus();
    });
  }, [editor, focusEmitter]);
  import_react39.default.useEffect(() => {
    editor.update(() => {
      $getRoot().clear();
      let theContent = content3;
      if (block) {
        if (theContent.length === 0) {
          theContent = [{ type: "paragraph", children: [] }];
        }
      } else {
        theContent = [{ type: "paragraph", children: content3 }];
      }
      importMdastTreeToLexical({
        root: $getRoot(),
        mdastRoot: {
          type: "root",
          children: theContent
        },
        visitors: importVisitors,
        directiveDescriptors,
        codeBlockEditorDescriptors,
        jsxComponentDescriptors
      });
    });
  }, [editor, block, importVisitors]);
  import_react39.default.useEffect(() => {
    function updateParentNode() {
      editor.getEditorState().read(() => {
        const mdast = exportLexicalTreeToMdast({
          root: $getRoot(),
          visitors: exportVisitors,
          jsxComponentDescriptors,
          jsxIsAvailable,
          addImportStatements: false
        });
        const content22 = block ? mdast.children : mdast.children[0].children;
        updateMdastNode(getUpdatedMdastNode(structuredClone(mdastNode), content22));
      });
    }
    return mergeRegister(
      editor.registerCommand(
        FOCUS_COMMAND,
        () => {
          setEditorInFocus({ editorType: "lexical", rootNode: lexicalNode });
          return false;
        },
        COMMAND_PRIORITY_LOW
      ),
      editor.registerCommand(
        BLUR_COMMAND,
        (payload) => {
          const relatedTarget = payload.relatedTarget;
          if (isPartOftheEditorUI(relatedTarget, rootEditor.getRootElement())) {
            return false;
          }
          updateParentNode();
          setEditorInFocus(null);
          return true;
        },
        COMMAND_PRIORITY_EDITOR
      ),
      // triggered by codemirror
      editor.registerCommand(
        NESTED_EDITOR_UPDATED_COMMAND,
        () => {
          updateParentNode();
          return true;
        },
        COMMAND_PRIORITY_EDITOR
      ),
      editor.registerCommand(
        SELECTION_CHANGE_COMMAND,
        () => {
          setEditorInFocus({ editorType: "lexical", rootNode: lexicalNode });
          return false;
        },
        COMMAND_PRIORITY_HIGH
      ),
      editor.registerCommand(
        KEY_BACKSPACE_COMMAND,
        (_2, editor2) => {
          const editorElement = editor2.getRootElement();
          if ((editorElement == null ? void 0 : editorElement.innerText) === "\n") {
            removeNode();
            return true;
          }
          return false;
        },
        COMMAND_PRIORITY_CRITICAL
      )
    );
  }, [
    block,
    editor,
    exportVisitors,
    getUpdatedMdastNode,
    jsxComponentDescriptors,
    jsxIsAvailable,
    lexicalNode,
    mdastNode,
    removeNode,
    setEditorInFocus,
    updateMdastNode,
    rootEditor
  ]);
  return import_react39.default.createElement(LexicalNestedComposer, { initialEditor: editor, initialTheme: lexicalTheme2 }, import_react39.default.createElement(
    RichTextPlugin,
    {
      contentEditable: import_react39.default.createElement(ContentEditable, { ...contentEditableProps, className: (0, import_classnames7.default)(styles.nestedEditor, contentEditableProps == null ? void 0 : contentEditableProps.className) }),
      placeholder: null,
      ErrorBoundary: LexicalErrorBoundary
    }
  ), import_react39.default.createElement(SharedHistoryPlugin, null), nestedEditorChildren.map((Child, index3) => import_react39.default.createElement(Child, { key: index3 })));
};

// node_modules/@mdxeditor/editor/dist/utils/voidEmitter.js
function voidEmitter() {
  let subscription2 = noop;
  return {
    publish: () => {
      subscription2();
    },
    subscribe: (cb) => {
      subscription2 = cb;
    }
  };
}

// node_modules/@mdxeditor/editor/dist/plugins/jsx/LexicalJsxNode.js
var __defProp5 = Object.defineProperty;
var __defNormalProp5 = (obj, key2, value2) => key2 in obj ? __defProp5(obj, key2, { enumerable: true, configurable: true, writable: true, value: value2 }) : obj[key2] = value2;
var __publicField6 = (obj, key2, value2) => {
  __defNormalProp5(obj, typeof key2 !== "symbol" ? key2 + "" : key2, value2);
  return value2;
};
var LexicalJsxNode = class _LexicalJsxNode extends DecoratorNode {
  constructor(mdastNode, key2) {
    super(key2);
    __publicField6(this, "__mdastNode");
    __publicField6(this, "__focusEmitter", voidEmitter());
    __publicField6(this, "select", () => {
      this.__focusEmitter.publish();
    });
    this.__mdastNode = mdastNode;
  }
  static getType() {
    return "jsx";
  }
  static clone(node2) {
    return new _LexicalJsxNode(structuredClone(node2.__mdastNode), node2.__key);
  }
  static importJSON(serializedNode) {
    return $createLexicalJsxNode(serializedNode.mdastNode);
  }
  getMdastNode() {
    return this.__mdastNode;
  }
  exportJSON() {
    return {
      mdastNode: this.getMdastNode(),
      type: "jsx",
      version: 1
    };
  }
  createDOM() {
    return document.createElement(this.__mdastNode.type === "mdxJsxTextElement" ? "span" : "div");
  }
  updateDOM() {
    return false;
  }
  setMdastNode(mdastNode) {
    this.getWritable().__mdastNode = mdastNode;
  }
  decorate(parentEditor, config) {
    return import_react40.default.createElement(
      JsxEditorContainer,
      {
        lexicalJsxNode: this,
        config,
        mdastNode: this.getMdastNode(),
        parentEditor,
        focusEmitter: this.__focusEmitter
      }
    );
  }
  isInline() {
    return this.__mdastNode.type === "mdxJsxTextElement";
  }
  isKeyboardSelectable() {
    return true;
  }
};
function JsxEditorContainer(props) {
  const { mdastNode } = props;
  const jsxComponentDescriptors = E(jsxComponentDescriptors$);
  const descriptor = jsxComponentDescriptors.find((descriptor2) => descriptor2.name === mdastNode.name) ?? jsxComponentDescriptors.find((descriptor2) => descriptor2.name === "*");
  if (!descriptor) {
    throw new Error(`No JSX descriptor found for ${mdastNode.name}`);
  }
  const Editor = descriptor.Editor;
  return import_react40.default.createElement(
    NestedEditorsContext.Provider,
    {
      value: {
        config: props.config,
        focusEmitter: props.focusEmitter,
        mdastNode,
        parentEditor: props.parentEditor,
        lexicalNode: props.lexicalJsxNode
      }
    },
    import_react40.default.createElement(Editor, { descriptor, mdastNode })
  );
}
function $createLexicalJsxNode(mdastNode) {
  return new LexicalJsxNode(mdastNode);
}
function $isLexicalJsxNode(node2) {
  return node2 instanceof LexicalJsxNode;
}

// node_modules/@mdxeditor/editor/dist/plugins/jsx/LexicalJsxVisitor.js
var LexicalJsxVisitor = {
  testLexicalNode: $isLexicalJsxNode,
  visitLexicalNode({ actions, mdastParent, lexicalNode }) {
    function traverseNestedJsxNodes(node2) {
      if ("children" in node2 && node2.children instanceof Array) {
        node2.children.forEach((child) => {
          if (isMdastJsxNode(child) && !htmlTags.includes(child.name.toLowerCase())) {
            actions.registerReferredComponent(child.name);
          }
          traverseNestedJsxNodes(child);
        });
      }
    }
    const mdastNode = lexicalNode.getMdastNode();
    actions.registerReferredComponent(mdastNode.name);
    traverseNestedJsxNodes(mdastNode);
    actions.appendToParent(mdastParent, mdastNode);
  },
  priority: -200
};

// node_modules/@mdxeditor/editor/dist/plugins/jsx/MdastMdxJsEsmVisitor.js
var MdastMdxJsEsmVisitor = {
  testNode: "mdxjsEsm",
  visitNode() {
  }
};

// node_modules/@mdxeditor/editor/dist/plugins/jsx/MdastMdxJsxElementVisitor.js
var MdastMdxJsxElementVisitor = {
  testNode: (node2, { jsxComponentDescriptors }) => {
    if (node2.type === "mdxJsxTextElement" || node2.type === "mdxJsxFlowElement") {
      const descriptor = jsxComponentDescriptors.find((descriptor2) => descriptor2.name === node2.name) ?? jsxComponentDescriptors.find((descriptor2) => descriptor2.name === "*");
      return descriptor !== void 0;
    }
    return false;
  },
  visitNode({ lexicalParent, mdastNode, descriptors: { jsxComponentDescriptors } }) {
    const descriptor = jsxComponentDescriptors.find((descriptor2) => descriptor2.name === mdastNode.name) ?? jsxComponentDescriptors.find((descriptor2) => descriptor2.name === "*");
    if ((descriptor == null ? void 0 : descriptor.kind) === "text" && mdastNode.type === "mdxJsxFlowElement") {
      const patchedNode = { ...mdastNode, type: "mdxJsxTextElement" };
      const paragraph2 = $createParagraphNode();
      paragraph2.append($createLexicalJsxNode(patchedNode));
      lexicalParent.append(paragraph2);
    } else {
      lexicalParent.append($createLexicalJsxNode(mdastNode));
    }
  },
  priority: -200
};

// node_modules/@mdxeditor/editor/dist/plugins/jsx/LexicalMdxExpressionNode.js
var import_react41 = __toESM(require_react(), 1);
var __defProp6 = Object.defineProperty;
var __defNormalProp6 = (obj, key2, value2) => key2 in obj ? __defProp6(obj, key2, { enumerable: true, configurable: true, writable: true, value: value2 }) : obj[key2] = value2;
var __publicField7 = (obj, key2, value2) => {
  __defNormalProp6(obj, typeof key2 !== "symbol" ? key2 + "" : key2, value2);
  return value2;
};
var LexicalMdxExpressionNode = class _LexicalMdxExpressionNode extends DecoratorNode {
  /**
   * Constructs a new {@link GenericHTMLNode} with the specified MDAST HTML node as the object to edit.
   */
  constructor(value2, mdastType, key2) {
    super(key2);
    __publicField7(this, "__value");
    __publicField7(this, "__mdastType");
    this.__value = value2;
    this.__mdastType = mdastType;
  }
  /** @internal */
  static getType() {
    return "mdx-expression";
  }
  /** @internal */
  static clone(node2) {
    return new _LexicalMdxExpressionNode(node2.__value, node2.__mdastType, node2.__key);
  }
  getValue() {
    return this.__value;
  }
  getMdastType() {
    return this.__mdastType;
  }
  // View
  createDOM() {
    const element2 = document.createElement("span");
    element2.classList.add(lexicalThemeStyles.mdxExpression);
    return element2;
  }
  updateDOM() {
    return false;
  }
  static importDOM() {
    return {};
  }
  exportDOM(editor) {
    const { element: element2 } = super.exportDOM(editor);
    return {
      element: element2
    };
  }
  static importJSON(serializedNode) {
    return $createLexicalMdxExpressionNode(serializedNode.value, serializedNode.mdastType);
  }
  exportJSON() {
    return {
      ...super.exportJSON(),
      value: this.getValue(),
      mdastType: this.getMdastType(),
      type: "mdx-expression",
      version: 1
    };
  }
  /*
    // Mutation
    insertNewAfter(selection?: RangeSelection, restoreSelection = true): ParagraphNode | GenericHTMLNode {
      const anchorOffet = selection ? selection.anchor.offset : 0
      const newElement =
        anchorOffet > 0 && anchorOffet < this.getTextContentSize() ? $createHeadingNode(this.getTag()) : $createParagraphNode()
      const direction = this.getDirection()
      newElement.setDirection(direction)
      this.insertAfter(newElement, restoreSelection)
      return newElement
    }
  
    collapseAtStart(): true {
      const newElement = !this.isEmpty() ? $createHeadingNode(this.getTag()) : $createParagraphNode()
      const children = this.getChildren()
      children.forEach((child) => newElement.append(child))
      this.replace(newElement)
      return true
    }*/
  extractWithChild() {
    return true;
  }
  isInline() {
    return this.__mdastType === "mdxTextExpression";
  }
  decorate(editor) {
    return import_react41.default.createElement(import_react41.default.Fragment, null, "{", import_react41.default.createElement("span", { className: styles.inputSizer, "data-value": this.getValue() }, import_react41.default.createElement(
      "input",
      {
        size: 1,
        onKeyDown: (e2) => {
          const value2 = e2.target.value;
          if (value2 === "" && e2.key === "Backspace" || e2.key === "Delete") {
            e2.stopPropagation();
            e2.nativeEvent.stopImmediatePropagation();
            e2.preventDefault();
            editor.update(() => {
              this.selectPrevious();
              this.remove();
            });
          }
        },
        onChange: (e2) => {
          e2.target.parentElement.dataset.value = e2.target.value;
          editor.update(() => {
            this.getWritable().__value = e2.target.value;
          });
        },
        type: "text",
        value: this.getValue()
      }
    )), "}");
  }
};
function $createLexicalMdxExpressionNode(value2, type2) {
  return $applyNodeReplacement(new LexicalMdxExpressionNode(value2, type2));
}
function $isLexicalMdxExpressionNode(node2) {
  return node2 instanceof LexicalMdxExpressionNode;
}

// node_modules/@mdxeditor/editor/dist/plugins/jsx/MdastMdxExpressionVisitor.js
var MdastMdxExpressionVisitor = {
  testNode: (node2) => node2.type === "mdxTextExpression" || node2.type === "mdxFlowExpression",
  visitNode({ lexicalParent, mdastNode }) {
    lexicalParent.append($createLexicalMdxExpressionNode(mdastNode.value, mdastNode.type));
  },
  priority: -200
};

// node_modules/@mdxeditor/editor/dist/plugins/jsx/LexicalMdxExpressionVisitor.js
var LexicalMdxExpressionVisitor = {
  testLexicalNode: $isLexicalMdxExpressionNode,
  visitLexicalNode({ actions, mdastParent, lexicalNode }) {
    const mdastNode = {
      type: lexicalNode.getMdastType(),
      value: lexicalNode.getValue()
    };
    actions.appendToParent(mdastParent, mdastNode);
  }
};

// node_modules/@mdxeditor/editor/dist/jsx-editors/GenericJsxEditor.js
var import_react44 = __toESM(require_react(), 1);

// node_modules/@mdxeditor/editor/dist/plugins/core/PropertyPopover.js
var import_react43 = __toESM(require_react(), 1);

// node_modules/@mdxeditor/editor/dist/plugins/core/ui/PopoverUtils.js
var import_react42 = __toESM(require_react(), 1);
var PopoverPortal2 = (props) => {
  const editorRootElementRef = E(editorRootElementRef$);
  return import_react42.default.createElement(Portal2, { ...props, container: editorRootElementRef == null ? void 0 : editorRootElementRef.current });
};
var PopoverContent2 = import_react42.default.forwardRef(
  (props, ref2) => {
    return import_react42.default.createElement(Content2, { ...props, className: styles.popoverContent, sideOffset: 5, side: "top", ref: ref2 }, import_react42.default.createElement("span", { className: styles.popoverArrow }, import_react42.default.createElement(Arrow22, null)), props.children);
  }
);

// node_modules/@mdxeditor/editor/dist/plugins/core/PropertyPopover.js
var PropertyPopover = ({ title, properties, onChange }) => {
  const [open, setOpen] = import_react43.default.useState(false);
  const iconComponentFor = E(iconComponentFor$);
  const { register, handleSubmit, reset: reset2 } = useForm({ defaultValues: properties });
  return import_react43.default.createElement(
    Root22,
    {
      open,
      onOpenChange: (v3) => {
        setOpen(v3);
      }
    },
    import_react43.default.createElement(Trigger, { className: styles.iconButton }, import_react43.default.createElement("div", null, iconComponentFor("settings"))),
    import_react43.default.createElement(PopoverPortal2, null, import_react43.default.createElement(PopoverContent2, null, import_react43.default.createElement(
      "form",
      {
        onSubmit: (e2) => {
          void handleSubmit(onChange)(e2);
          setOpen(false);
          e2.preventDefault();
          e2.stopPropagation();
        }
      },
      import_react43.default.createElement("h3", { className: styles.propertyPanelTitle }, title, " Attributes"),
      import_react43.default.createElement("table", { className: styles.propertyEditorTable }, import_react43.default.createElement("thead", null, import_react43.default.createElement("tr", null, import_react43.default.createElement("th", { className: styles.readOnlyColumnCell }, "Attribute"), import_react43.default.createElement("th", null, "Value"))), import_react43.default.createElement("tbody", null, Object.keys(properties).map((propName) => import_react43.default.createElement("tr", { key: propName }, import_react43.default.createElement("th", { className: styles.readOnlyColumnCell }, " ", propName, " "), import_react43.default.createElement("td", null, import_react43.default.createElement("input", { ...register(propName), className: styles.propertyEditorInput }))))), import_react43.default.createElement("tfoot", null, import_react43.default.createElement("tr", null, import_react43.default.createElement("td", { colSpan: 2 }, import_react43.default.createElement("div", { className: styles.buttonsFooter }, import_react43.default.createElement("button", { type: "submit", className: styles.primaryButton }, "Save"), import_react43.default.createElement(
        "button",
        {
          type: "reset",
          className: styles.secondaryButton,
          onClick: (e2) => {
            e2.preventDefault();
            reset2(properties);
            setOpen(false);
          }
        },
        "Cancel"
      ))))))
    )))
  );
};

// node_modules/@mdxeditor/editor/dist/jsx-editors/GenericJsxEditor.js
var isExpressionValue = (value2) => {
  if (value2 !== null && typeof value2 === "object" && "type" in value2 && "value" in value2 && typeof value2.value === "string") {
    return true;
  }
  return false;
};
var isStringValue = (value2) => typeof value2 === "string";
var isMdxJsxAttribute = (value2) => {
  if (value2.type === "mdxJsxAttribute" && typeof value2.name === "string") {
    return true;
  }
  return false;
};
var GenericJsxEditor = ({ mdastNode, descriptor }) => {
  const updateMdastNode = useMdastNodeUpdater();
  const properties = import_react44.default.useMemo(
    () => descriptor.props.reduce((acc, { name: name2 }) => {
      const attribute = mdastNode.attributes.find((attr) => isMdxJsxAttribute(attr) ? attr.name === name2 : false);
      if (attribute) {
        if (isExpressionValue(attribute.value)) {
          acc[name2] = attribute.value.value;
          return acc;
        }
        if (isStringValue(attribute.value)) {
          acc[name2] = attribute.value;
          return acc;
        }
      }
      acc[name2] = "";
      return acc;
    }, {}),
    [mdastNode, descriptor]
  );
  const onChange = import_react44.default.useCallback(
    (values2) => {
      const updatedAttributes = Object.entries(values2).reduce((acc, [name2, value2]) => {
        if (value2 === "") {
          return acc;
        }
        const property = descriptor.props.find((prop2) => prop2.name === name2);
        if ((property == null ? void 0 : property.type) === "expression") {
          acc.push({
            type: "mdxJsxAttribute",
            name: name2,
            value: { type: "mdxJsxAttributeValueExpression", value: value2 }
          });
          return acc;
        }
        acc.push({
          type: "mdxJsxAttribute",
          name: name2,
          value: value2
        });
        return acc;
      }, []);
      updateMdastNode({ attributes: updatedAttributes });
    },
    [mdastNode, updateMdastNode, descriptor]
  );
  const shouldRenderComponentName = descriptor.props.length == 0 && descriptor.hasChildren && descriptor.kind === "flow";
  return import_react44.default.createElement("div", { className: descriptor.kind === "text" ? styles.inlineEditor : styles.blockEditor }, shouldRenderComponentName ? import_react44.default.createElement("span", { className: styles.genericComponentName }, mdastNode.name ?? "Fragment") : null, descriptor.props.length > 0 ? import_react44.default.createElement(PropertyPopover, { properties, title: mdastNode.name ?? "", onChange }) : null, descriptor.hasChildren ? import_react44.default.createElement(
    NestedLexicalEditor,
    {
      block: descriptor.kind === "flow",
      getContent: (node2) => node2.children,
      getUpdatedMdastNode: (mdastNode2, children) => {
        return { ...mdastNode2, children };
      }
    }
  ) : import_react44.default.createElement("span", { className: styles.genericComponentName }, mdastNode.name));
};

// node_modules/@mdxeditor/editor/dist/plugins/jsx/index.js
function isMdastJsxNode(node2) {
  return node2.type === "mdxJsxFlowElement" || node2.type === "mdxJsxTextElement";
}
var isExpressionValue2 = (value2) => {
  if (value2 !== null && typeof value2 === "object" && "type" in value2 && "value" in value2 && typeof value2.value === "string") {
    return true;
  }
  return false;
};
var toMdastJsxAttributes = (attributes4) => Object.entries(attributes4).map(
  ([name2, value2]) => ({
    type: "mdxJsxAttribute",
    name: name2,
    value: isExpressionValue2(value2) ? { type: "mdxJsxAttributeValueExpression", value: value2.value } : value2
  })
);
var insertJsx$ = K((r2) => {
  r2.link(
    r2.pipe(
      insertJsx$,
      _(({ kind, name: name2, children, props }) => {
        return () => {
          const attributes4 = toMdastJsxAttributes(props);
          if (kind === "flow") {
            return $createLexicalJsxNode({
              type: "mdxJsxFlowElement",
              name: name2,
              children: children ?? [],
              attributes: attributes4
            });
          } else {
            return $createLexicalJsxNode({
              type: "mdxJsxTextElement",
              name: name2,
              children: children ?? [],
              attributes: attributes4
            });
          }
        };
      })
    ),
    insertDecoratorNode$
  );
});
var fragmentDescriptor = {
  name: null,
  kind: "flow",
  props: [],
  hasChildren: true,
  Editor: GenericJsxEditor
};
var getDescriptors = (params) => {
  if (params) {
    if (params.allowFragment ?? true) {
      return [fragmentDescriptor, ...params.jsxComponentDescriptors];
    }
    return params.jsxComponentDescriptors;
  }
  return [fragmentDescriptor];
};
var jsxPlugin = realmPlugin({
  init: (realm, params) => {
    realm.pubIn({
      // import
      [jsxIsAvailable$]: true,
      [addMdastExtension$]: mdxFromMarkdown(),
      [addSyntaxExtension$]: mdxjs(),
      [addImportVisitor$]: [MdastMdxJsxElementVisitor, MdastMdxJsEsmVisitor, MdastMdxExpressionVisitor],
      // export
      [addLexicalNode$]: [LexicalJsxNode, LexicalMdxExpressionNode],
      [addExportVisitor$]: [LexicalJsxVisitor, LexicalMdxExpressionVisitor],
      [addToMarkdownExtension$]: mdxToMarkdown(),
      [jsxComponentDescriptors$]: getDescriptors(params)
    });
  },
  update(realm, params) {
    realm.pub(jsxComponentDescriptors$, getDescriptors(params));
  }
});

// node_modules/@mdxeditor/editor/dist/plugins/sandpack/index.js
var import_react50 = __toESM(require_react(), 1);

// node_modules/@mdxeditor/editor/dist/plugins/codeblock/CodeBlockNode.js
var import_react45 = __toESM(require_react(), 1);
var __defProp7 = Object.defineProperty;
var __defNormalProp7 = (obj, key2, value2) => key2 in obj ? __defProp7(obj, key2, { enumerable: true, configurable: true, writable: true, value: value2 }) : obj[key2] = value2;
var __publicField8 = (obj, key2, value2) => {
  __defNormalProp7(obj, typeof key2 !== "symbol" ? key2 + "" : key2, value2);
  return value2;
};
var CodeBlockNode = class _CodeBlockNode extends DecoratorNode {
  constructor(code3, language2, meta, key2) {
    super(key2);
    __publicField8(this, "__code");
    __publicField8(this, "__meta");
    __publicField8(this, "__language");
    __publicField8(this, "__focusEmitter", voidEmitter());
    __publicField8(this, "setCode", (code4) => {
      if (code4 !== this.__code) {
        this.getWritable().__code = code4;
      }
    });
    __publicField8(this, "setMeta", (meta2) => {
      if (meta2 !== this.__meta) {
        this.getWritable().__meta = meta2;
      }
    });
    __publicField8(this, "setLanguage", (language3) => {
      if (language3 !== this.__language) {
        this.getWritable().__language = language3;
      }
    });
    __publicField8(this, "select", () => {
      this.__focusEmitter.publish();
    });
    this.__code = code3;
    this.__meta = meta;
    this.__language = language2;
  }
  static getType() {
    return "codeblock";
  }
  static clone(node2) {
    return new _CodeBlockNode(node2.__code, node2.__language, node2.__meta, node2.__key);
  }
  static importJSON(serializedNode) {
    const { code: code3, meta, language: language2 } = serializedNode;
    return $createCodeBlockNode({
      code: code3,
      language: language2,
      meta
    });
  }
  exportJSON() {
    return {
      code: this.getCode(),
      language: this.getLanguage(),
      meta: this.getMeta(),
      type: "codeblock",
      version: 1
    };
  }
  // View
  createDOM(_config) {
    return document.createElement("div");
  }
  updateDOM() {
    return false;
  }
  getCode() {
    return this.__code;
  }
  getMeta() {
    return this.__meta;
  }
  getLanguage() {
    return this.__language;
  }
  decorate(editor) {
    return import_react45.default.createElement(
      CodeBlockEditorContainer,
      {
        parentEditor: editor,
        code: this.getCode(),
        meta: this.getMeta(),
        language: this.getLanguage(),
        codeBlockNode: this,
        nodeKey: this.getKey(),
        focusEmitter: this.__focusEmitter
      }
    );
  }
  isInline() {
    return false;
  }
};
var CodeBlockEditorContext = import_react45.default.createContext(null);
var CodeBlockEditorContextProvider = ({ parentEditor, lexicalNode, children }) => {
  const contextValue = import_react45.default.useMemo(() => {
    return {
      lexicalNode,
      parentEditor,
      setCode: (code3) => {
        parentEditor.update(() => {
          lexicalNode.setCode(code3);
          setTimeout(() => {
            parentEditor.dispatchCommand(NESTED_EDITOR_UPDATED_COMMAND, void 0);
          }, 0);
        });
      },
      setLanguage: (language2) => {
        parentEditor.update(() => {
          lexicalNode.setLanguage(language2);
        });
      },
      setMeta: (meta) => {
        parentEditor.update(() => {
          lexicalNode.setMeta(meta);
        });
      }
    };
  }, [lexicalNode, parentEditor]);
  return import_react45.default.createElement(CodeBlockEditorContext.Provider, { value: contextValue }, children);
};
function useCodeBlockEditorContext() {
  const context = import_react45.default.useContext(CodeBlockEditorContext);
  if (!context) {
    throw new Error("useCodeBlockEditor must be used within a CodeBlockEditor");
  }
  return context;
}
var CodeBlockEditorContainer = (props) => {
  const codeBlockEditorDescriptors = E(codeBlockEditorDescriptors$);
  const defaultCodeBlockLanguage = E(defaultCodeBlockLanguage$);
  let descriptor = codeBlockEditorDescriptors.sort((a2, b3) => b3.priority - a2.priority).find((descriptor2) => descriptor2.match(props.language || "", props.meta || ""));
  if (!descriptor) {
    descriptor = codeBlockEditorDescriptors.find((descriptor2) => descriptor2.match(defaultCodeBlockLanguage || "", props.meta || ""));
  }
  if (!descriptor) {
    throw new Error(`No CodeBlockEditor registered for language=${props.language} meta=${props.meta}`);
  }
  const Editor = descriptor.Editor;
  const { codeBlockNode: _2, parentEditor: __, ...restProps } = props;
  return import_react45.default.createElement(CodeBlockEditorContextProvider, { parentEditor: props.parentEditor, lexicalNode: props.codeBlockNode }, import_react45.default.createElement(Editor, { ...restProps }));
};
function $createCodeBlockNode(options) {
  const { code: code3 = "", language: language2 = "", meta = "" } = options;
  return new CodeBlockNode(code3, language2, meta);
}
function $isCodeBlockNode(node2) {
  return node2 instanceof CodeBlockNode;
}

// node_modules/@mdxeditor/editor/dist/plugins/codeblock/CodeBlockVisitor.js
var CodeBlockVisitor = {
  testLexicalNode: $isCodeBlockNode,
  visitLexicalNode: ({ lexicalNode, actions }) => {
    actions.addAndStepInto("code", {
      value: lexicalNode.getCode(),
      lang: lexicalNode.getLanguage(),
      meta: lexicalNode.getMeta()
    });
  }
};

// node_modules/@mdxeditor/editor/dist/plugins/codeblock/MdastCodeVisitor.js
var MdastCodeVisitor = {
  testNode: (node2, { codeBlockEditorDescriptors }) => {
    if (node2.type === "code") {
      const descriptor = codeBlockEditorDescriptors.find((descriptor2) => descriptor2.match(node2.lang, node2.meta));
      return descriptor !== void 0;
    }
    return false;
  },
  visitNode({ mdastNode, actions }) {
    actions.addAndStepInto(
      $createCodeBlockNode({
        code: mdastNode.value,
        language: mdastNode.lang,
        meta: mdastNode.meta
      })
    );
  }
};

// node_modules/@mdxeditor/editor/dist/plugins/codeblock/index.js
var defaultCodeBlockLanguage$ = $("");
var insertCodeBlock$ = K((r2) => {
  r2.link(
    r2.pipe(
      insertCodeBlock$,
      tt(defaultCodeBlockLanguage$),
      _(
        ([payload, defaultCodeBlockLanguage]) => () => $createCodeBlockNode({ language: defaultCodeBlockLanguage, ...payload })
      )
    ),
    insertDecoratorNode$
  );
});
var appendCodeBlockEditorDescriptor$ = Appender(codeBlockEditorDescriptors$);
var codeBlockPlugin = realmPlugin({
  update(realm, params) {
    realm.pub(defaultCodeBlockLanguage$, (params == null ? void 0 : params.defaultCodeBlockLanguage) ?? "");
  },
  init(realm, params) {
    realm.pubIn({
      [addActivePlugin$]: "codeblock",
      [codeBlockEditorDescriptors$]: (params == null ? void 0 : params.codeBlockEditorDescriptors) ?? [],
      [addImportVisitor$]: MdastCodeVisitor,
      [addLexicalNode$]: CodeBlockNode,
      [addExportVisitor$]: CodeBlockVisitor
    });
  }
});

// node_modules/@codesandbox/sandpack-react/dist/index.mjs
var import_jsx_runtime24 = __toESM(require_jsx_runtime(), 1);
var React43 = __toESM(require_react(), 1);
var import_react47 = __toESM(require_react(), 1);

// node_modules/@stitches/core/dist/index.mjs
var t2 = "colors";
var n2 = "sizes";
var r = "space";
var i2 = { gap: r, gridGap: r, columnGap: r, gridColumnGap: r, rowGap: r, gridRowGap: r, inset: r, insetBlock: r, insetBlockEnd: r, insetBlockStart: r, insetInline: r, insetInlineEnd: r, insetInlineStart: r, margin: r, marginTop: r, marginRight: r, marginBottom: r, marginLeft: r, marginBlock: r, marginBlockEnd: r, marginBlockStart: r, marginInline: r, marginInlineEnd: r, marginInlineStart: r, padding: r, paddingTop: r, paddingRight: r, paddingBottom: r, paddingLeft: r, paddingBlock: r, paddingBlockEnd: r, paddingBlockStart: r, paddingInline: r, paddingInlineEnd: r, paddingInlineStart: r, top: r, right: r, bottom: r, left: r, scrollMargin: r, scrollMarginTop: r, scrollMarginRight: r, scrollMarginBottom: r, scrollMarginLeft: r, scrollMarginX: r, scrollMarginY: r, scrollMarginBlock: r, scrollMarginBlockEnd: r, scrollMarginBlockStart: r, scrollMarginInline: r, scrollMarginInlineEnd: r, scrollMarginInlineStart: r, scrollPadding: r, scrollPaddingTop: r, scrollPaddingRight: r, scrollPaddingBottom: r, scrollPaddingLeft: r, scrollPaddingX: r, scrollPaddingY: r, scrollPaddingBlock: r, scrollPaddingBlockEnd: r, scrollPaddingBlockStart: r, scrollPaddingInline: r, scrollPaddingInlineEnd: r, scrollPaddingInlineStart: r, fontSize: "fontSizes", background: t2, backgroundColor: t2, backgroundImage: t2, borderImage: t2, border: t2, borderBlock: t2, borderBlockEnd: t2, borderBlockStart: t2, borderBottom: t2, borderBottomColor: t2, borderColor: t2, borderInline: t2, borderInlineEnd: t2, borderInlineStart: t2, borderLeft: t2, borderLeftColor: t2, borderRight: t2, borderRightColor: t2, borderTop: t2, borderTopColor: t2, caretColor: t2, color: t2, columnRuleColor: t2, fill: t2, outline: t2, outlineColor: t2, stroke: t2, textDecorationColor: t2, fontFamily: "fonts", fontWeight: "fontWeights", lineHeight: "lineHeights", letterSpacing: "letterSpacings", blockSize: n2, minBlockSize: n2, maxBlockSize: n2, inlineSize: n2, minInlineSize: n2, maxInlineSize: n2, width: n2, minWidth: n2, maxWidth: n2, height: n2, minHeight: n2, maxHeight: n2, flexBasis: n2, gridTemplateColumns: n2, gridTemplateRows: n2, borderWidth: "borderWidths", borderTopWidth: "borderWidths", borderRightWidth: "borderWidths", borderBottomWidth: "borderWidths", borderLeftWidth: "borderWidths", borderStyle: "borderStyles", borderTopStyle: "borderStyles", borderRightStyle: "borderStyles", borderBottomStyle: "borderStyles", borderLeftStyle: "borderStyles", borderRadius: "radii", borderTopLeftRadius: "radii", borderTopRightRadius: "radii", borderBottomRightRadius: "radii", borderBottomLeftRadius: "radii", boxShadow: "shadows", textShadow: "shadows", transition: "transitions", zIndex: "zIndices" };
var o2 = (e2, t3) => "function" == typeof t3 ? { "()": Function.prototype.toString.call(t3) } : t3;
var l2 = () => {
  const e2 = /* @__PURE__ */ Object.create(null);
  return (t3, n3, ...r2) => {
    const i3 = ((e3) => JSON.stringify(e3, o2))(t3);
    return i3 in e2 ? e2[i3] : e2[i3] = n3(t3, ...r2);
  };
};
var s = Symbol.for("sxs.internal");
var a = (e2, t3) => Object.defineProperties(e2, Object.getOwnPropertyDescriptors(t3));
var c = (e2) => {
  for (const t3 in e2) return true;
  return false;
};
var { hasOwnProperty: d2 } = Object.prototype;
var g2 = (e2) => e2.includes("-") ? e2 : e2.replace(/[A-Z]/g, (e3) => "-" + e3.toLowerCase());
var p = /\s+(?![^()]*\))/;
var u = (e2) => (t3) => e2(..."string" == typeof t3 ? String(t3).split(p) : [t3]);
var h = { appearance: (e2) => ({ WebkitAppearance: e2, appearance: e2 }), backfaceVisibility: (e2) => ({ WebkitBackfaceVisibility: e2, backfaceVisibility: e2 }), backdropFilter: (e2) => ({ WebkitBackdropFilter: e2, backdropFilter: e2 }), backgroundClip: (e2) => ({ WebkitBackgroundClip: e2, backgroundClip: e2 }), boxDecorationBreak: (e2) => ({ WebkitBoxDecorationBreak: e2, boxDecorationBreak: e2 }), clipPath: (e2) => ({ WebkitClipPath: e2, clipPath: e2 }), content: (e2) => ({ content: e2.includes('"') || e2.includes("'") || /^([A-Za-z]+\([^]*|[^]*-quote|inherit|initial|none|normal|revert|unset)$/.test(e2) ? e2 : `"${e2}"` }), hyphens: (e2) => ({ WebkitHyphens: e2, hyphens: e2 }), maskImage: (e2) => ({ WebkitMaskImage: e2, maskImage: e2 }), maskSize: (e2) => ({ WebkitMaskSize: e2, maskSize: e2 }), tabSize: (e2) => ({ MozTabSize: e2, tabSize: e2 }), textSizeAdjust: (e2) => ({ WebkitTextSizeAdjust: e2, textSizeAdjust: e2 }), userSelect: (e2) => ({ WebkitUserSelect: e2, userSelect: e2 }), marginBlock: u((e2, t3) => ({ marginBlockStart: e2, marginBlockEnd: t3 || e2 })), marginInline: u((e2, t3) => ({ marginInlineStart: e2, marginInlineEnd: t3 || e2 })), maxSize: u((e2, t3) => ({ maxBlockSize: e2, maxInlineSize: t3 || e2 })), minSize: u((e2, t3) => ({ minBlockSize: e2, minInlineSize: t3 || e2 })), paddingBlock: u((e2, t3) => ({ paddingBlockStart: e2, paddingBlockEnd: t3 || e2 })), paddingInline: u((e2, t3) => ({ paddingInlineStart: e2, paddingInlineEnd: t3 || e2 })) };
var f2 = /([\d.]+)([^]*)/;
var m = (e2, t3) => e2.length ? e2.reduce((e3, n3) => (e3.push(...t3.map((e4) => e4.includes("&") ? e4.replace(/&/g, /[ +>|~]/.test(n3) && /&.*&/.test(e4) ? `:is(${n3})` : n3) : n3 + " " + e4)), e3), []) : t3;
var b2 = (e2, t3) => e2 in S && "string" == typeof t3 ? t3.replace(/^((?:[^]*[^\w-])?)(fit-content|stretch)((?:[^\w-][^]*)?)$/, (t4, n3, r2, i3) => n3 + ("stretch" === r2 ? `-moz-available${i3};${g2(e2)}:${n3}-webkit-fill-available` : `-moz-fit-content${i3};${g2(e2)}:${n3}fit-content`) + i3) : String(t3);
var S = { blockSize: 1, height: 1, inlineSize: 1, maxBlockSize: 1, maxHeight: 1, maxInlineSize: 1, maxWidth: 1, minBlockSize: 1, minHeight: 1, minInlineSize: 1, minWidth: 1, width: 1 };
var k2 = (e2) => e2 ? e2 + "-" : "";
var y = (e2, t3, n3) => e2.replace(/([+-])?((?:\d+(?:\.\d*)?|\.\d+)(?:[Ee][+-]?\d+)?)?(\$|--)([$\w-]+)/g, (e3, r2, i3, o3, l3) => "$" == o3 == !!i3 ? e3 : (r2 || "--" == o3 ? "calc(" : "") + "var(--" + ("$" === o3 ? k2(t3) + (l3.includes("$") ? "" : k2(n3)) + l3.replace(/\$/g, "-") : l3) + ")" + (r2 || "--" == o3 ? "*" + (r2 || "") + (i3 || "1") + ")" : ""));
var B2 = /\s*,\s*(?![^()]*\))/;
var $2 = Object.prototype.toString;
var x2 = (e2, t3, n3, r2, i3) => {
  let o3, l3, s2;
  const a2 = (e3, t4, n4) => {
    let c2, d3;
    const p2 = (e4) => {
      for (c2 in e4) {
        const x3 = 64 === c2.charCodeAt(0), z3 = x3 && Array.isArray(e4[c2]) ? e4[c2] : [e4[c2]];
        for (d3 of z3) {
          const e5 = /[A-Z]/.test(S2 = c2) ? S2 : S2.replace(/-[^]/g, (e6) => e6[1].toUpperCase()), z4 = "object" == typeof d3 && d3 && d3.toString === $2 && (!r2.utils[e5] || !t4.length);
          if (e5 in r2.utils && !z4) {
            const t5 = r2.utils[e5];
            if (t5 !== l3) {
              l3 = t5, p2(t5(d3)), l3 = null;
              continue;
            }
          } else if (e5 in h) {
            const t5 = h[e5];
            if (t5 !== s2) {
              s2 = t5, p2(t5(d3)), s2 = null;
              continue;
            }
          }
          if (x3 && (u2 = c2.slice(1) in r2.media ? "@media " + r2.media[c2.slice(1)] : c2, c2 = u2.replace(/\(\s*([\w-]+)\s*(=|<|<=|>|>=)\s*([\w-]+)\s*(?:(<|<=|>|>=)\s*([\w-]+)\s*)?\)/g, (e6, t5, n5, r3, i4, o4) => {
            const l4 = f2.test(t5), s3 = 0.0625 * (l4 ? -1 : 1), [a3, c3] = l4 ? [r3, t5] : [t5, r3];
            return "(" + ("=" === n5[0] ? "" : ">" === n5[0] === l4 ? "max-" : "min-") + a3 + ":" + ("=" !== n5[0] && 1 === n5.length ? c3.replace(f2, (e7, t6, r4) => Number(t6) + s3 * (">" === n5 ? 1 : -1) + r4) : c3) + (i4 ? ") and (" + (">" === i4[0] ? "min-" : "max-") + a3 + ":" + (1 === i4.length ? o4.replace(f2, (e7, t6, n6) => Number(t6) + s3 * (">" === i4 ? -1 : 1) + n6) : o4) : "") + ")";
          })), z4) {
            const e6 = x3 ? n4.concat(c2) : [...n4], r3 = x3 ? [...t4] : m(t4, c2.split(B2));
            void 0 !== o3 && i3(I2(...o3)), o3 = void 0, a2(d3, r3, e6);
          } else void 0 === o3 && (o3 = [[], t4, n4]), c2 = x3 || 36 !== c2.charCodeAt(0) ? c2 : `--${k2(r2.prefix)}${c2.slice(1).replace(/\$/g, "-")}`, d3 = z4 ? d3 : "number" == typeof d3 ? d3 && e5 in R2 ? String(d3) + "px" : String(d3) : y(b2(e5, null == d3 ? "" : d3), r2.prefix, r2.themeMap[e5]), o3[0].push(`${x3 ? `${c2} ` : `${g2(c2)}:`}${d3}`);
        }
      }
      var u2, S2;
    };
    p2(e3), void 0 !== o3 && i3(I2(...o3)), o3 = void 0;
  };
  a2(e2, t3, n3);
};
var I2 = (e2, t3, n3) => `${n3.map((e3) => `${e3}{`).join("")}${t3.length ? `${t3.join(",")}{` : ""}${e2.join(";")}${t3.length ? "}" : ""}${Array(n3.length ? n3.length + 1 : 0).join("}")}`;
var R2 = { animationDelay: 1, animationDuration: 1, backgroundSize: 1, blockSize: 1, border: 1, borderBlock: 1, borderBlockEnd: 1, borderBlockEndWidth: 1, borderBlockStart: 1, borderBlockStartWidth: 1, borderBlockWidth: 1, borderBottom: 1, borderBottomLeftRadius: 1, borderBottomRightRadius: 1, borderBottomWidth: 1, borderEndEndRadius: 1, borderEndStartRadius: 1, borderInlineEnd: 1, borderInlineEndWidth: 1, borderInlineStart: 1, borderInlineStartWidth: 1, borderInlineWidth: 1, borderLeft: 1, borderLeftWidth: 1, borderRadius: 1, borderRight: 1, borderRightWidth: 1, borderSpacing: 1, borderStartEndRadius: 1, borderStartStartRadius: 1, borderTop: 1, borderTopLeftRadius: 1, borderTopRightRadius: 1, borderTopWidth: 1, borderWidth: 1, bottom: 1, columnGap: 1, columnRule: 1, columnRuleWidth: 1, columnWidth: 1, containIntrinsicSize: 1, flexBasis: 1, fontSize: 1, gap: 1, gridAutoColumns: 1, gridAutoRows: 1, gridTemplateColumns: 1, gridTemplateRows: 1, height: 1, inlineSize: 1, inset: 1, insetBlock: 1, insetBlockEnd: 1, insetBlockStart: 1, insetInline: 1, insetInlineEnd: 1, insetInlineStart: 1, left: 1, letterSpacing: 1, margin: 1, marginBlock: 1, marginBlockEnd: 1, marginBlockStart: 1, marginBottom: 1, marginInline: 1, marginInlineEnd: 1, marginInlineStart: 1, marginLeft: 1, marginRight: 1, marginTop: 1, maxBlockSize: 1, maxHeight: 1, maxInlineSize: 1, maxWidth: 1, minBlockSize: 1, minHeight: 1, minInlineSize: 1, minWidth: 1, offsetDistance: 1, offsetRotate: 1, outline: 1, outlineOffset: 1, outlineWidth: 1, overflowClipMargin: 1, padding: 1, paddingBlock: 1, paddingBlockEnd: 1, paddingBlockStart: 1, paddingBottom: 1, paddingInline: 1, paddingInlineEnd: 1, paddingInlineStart: 1, paddingLeft: 1, paddingRight: 1, paddingTop: 1, perspective: 1, right: 1, rowGap: 1, scrollMargin: 1, scrollMarginBlock: 1, scrollMarginBlockEnd: 1, scrollMarginBlockStart: 1, scrollMarginBottom: 1, scrollMarginInline: 1, scrollMarginInlineEnd: 1, scrollMarginInlineStart: 1, scrollMarginLeft: 1, scrollMarginRight: 1, scrollMarginTop: 1, scrollPadding: 1, scrollPaddingBlock: 1, scrollPaddingBlockEnd: 1, scrollPaddingBlockStart: 1, scrollPaddingBottom: 1, scrollPaddingInline: 1, scrollPaddingInlineEnd: 1, scrollPaddingInlineStart: 1, scrollPaddingLeft: 1, scrollPaddingRight: 1, scrollPaddingTop: 1, shapeMargin: 1, textDecoration: 1, textDecorationThickness: 1, textIndent: 1, textUnderlineOffset: 1, top: 1, transitionDelay: 1, transitionDuration: 1, verticalAlign: 1, width: 1, wordSpacing: 1 };
var z2 = (e2) => String.fromCharCode(e2 + (e2 > 25 ? 39 : 97));
var W = (e2) => ((e3) => {
  let t3, n3 = "";
  for (t3 = Math.abs(e3); t3 > 52; t3 = t3 / 52 | 0) n3 = z2(t3 % 52) + n3;
  return z2(t3 % 52) + n3;
})(((e3, t3) => {
  let n3 = t3.length;
  for (; n3; ) e3 = 33 * e3 ^ t3.charCodeAt(--n3);
  return e3;
})(5381, JSON.stringify(e2)) >>> 0);
var j2 = ["themed", "global", "styled", "onevar", "resonevar", "allvar", "inline"];
var E2 = (e2) => {
  if (e2.href && !e2.href.startsWith(location.origin)) return false;
  try {
    return !!e2.cssRules;
  } catch (e3) {
    return false;
  }
};
var T2 = (e2) => {
  let t3;
  const n3 = () => {
    const { cssRules: e3 } = t3.sheet;
    return [].map.call(e3, (n4, r3) => {
      const { cssText: i3 } = n4;
      let o3 = "";
      if (i3.startsWith("--sxs")) return "";
      if (e3[r3 - 1] && (o3 = e3[r3 - 1].cssText).startsWith("--sxs")) {
        if (!n4.cssRules.length) return "";
        for (const e4 in t3.rules) if (t3.rules[e4].group === n4) return `--sxs{--sxs:${[...t3.rules[e4].cache].join(" ")}}${i3}`;
        return n4.cssRules.length ? `${o3}${i3}` : "";
      }
      return i3;
    }).join("");
  }, r2 = () => {
    if (t3) {
      const { rules: e3, sheet: n4 } = t3;
      if (!n4.deleteRule) {
        for (; 3 === Object(Object(n4.cssRules)[0]).type; ) n4.cssRules.splice(0, 1);
        n4.cssRules = [];
      }
      for (const t4 in e3) delete e3[t4];
    }
    const i3 = Object(e2).styleSheets || [];
    for (const e3 of i3) if (E2(e3)) {
      for (let i4 = 0, o4 = e3.cssRules; o4[i4]; ++i4) {
        const l4 = Object(o4[i4]);
        if (1 !== l4.type) continue;
        const s2 = Object(o4[i4 + 1]);
        if (4 !== s2.type) continue;
        ++i4;
        const { cssText: a2 } = l4;
        if (!a2.startsWith("--sxs")) continue;
        const c2 = a2.slice(14, -3).trim().split(/\s+/), d3 = j2[c2[0]];
        d3 && (t3 || (t3 = { sheet: e3, reset: r2, rules: {}, toString: n3 }), t3.rules[d3] = { group: s2, index: i4, cache: new Set(c2) });
      }
      if (t3) break;
    }
    if (!t3) {
      const i4 = (e3, t4) => ({ type: t4, cssRules: [], insertRule(e4, t5) {
        this.cssRules.splice(t5, 0, i4(e4, { import: 3, undefined: 1 }[(e4.toLowerCase().match(/^@([a-z]+)/) || [])[1]] || 4));
      }, get cssText() {
        return "@media{}" === e3 ? `@media{${[].map.call(this.cssRules, (e4) => e4.cssText).join("")}}` : e3;
      } });
      t3 = { sheet: e2 ? (e2.head || e2).appendChild(document.createElement("style")).sheet : i4("", "text/css"), rules: {}, reset: r2, toString: n3 };
    }
    const { sheet: o3, rules: l3 } = t3;
    for (let e3 = j2.length - 1; e3 >= 0; --e3) {
      const t4 = j2[e3];
      if (!l3[t4]) {
        const n4 = j2[e3 + 1], r3 = l3[n4] ? l3[n4].index : o3.cssRules.length;
        o3.insertRule("@media{}", r3), o3.insertRule(`--sxs{--sxs:${e3}}`, r3), l3[t4] = { group: o3.cssRules[r3 + 1], index: r3, cache: /* @__PURE__ */ new Set([e3]) };
      }
      v2(l3[t4]);
    }
  };
  return r2(), t3;
};
var v2 = (e2) => {
  const t3 = e2.group;
  let n3 = t3.cssRules.length;
  e2.apply = (e3) => {
    try {
      t3.insertRule(e3, n3), ++n3;
    } catch (e4) {
    }
  };
};
var M2 = Symbol();
var w2 = l2();
var C2 = (e2, t3) => w2(e2, () => (...n3) => {
  let r2 = { type: null, composers: /* @__PURE__ */ new Set() };
  for (const t4 of n3) if (null != t4) if (t4[s]) {
    null == r2.type && (r2.type = t4[s].type);
    for (const e3 of t4[s].composers) r2.composers.add(e3);
  } else t4.constructor !== Object || t4.$$typeof ? null == r2.type && (r2.type = t4) : r2.composers.add(P2(t4, e2));
  return null == r2.type && (r2.type = "span"), r2.composers.size || r2.composers.add(["PJLV", {}, [], [], {}, []]), L(e2, r2, t3);
});
var P2 = ({ variants: e2, compoundVariants: t3, defaultVariants: n3, ...r2 }, i3) => {
  const o3 = `${k2(i3.prefix)}c-${W(r2)}`, l3 = [], s2 = [], a2 = /* @__PURE__ */ Object.create(null), g3 = [];
  for (const e3 in n3) a2[e3] = String(n3[e3]);
  if ("object" == typeof e2 && e2) for (const t4 in e2) {
    p2 = a2, u2 = t4, d2.call(p2, u2) || (a2[t4] = "undefined");
    const n4 = e2[t4];
    for (const e3 in n4) {
      const r3 = { [t4]: String(e3) };
      "undefined" === String(e3) && g3.push(t4);
      const i4 = n4[e3], o4 = [r3, i4, !c(i4)];
      l3.push(o4);
    }
  }
  var p2, u2;
  if ("object" == typeof t3 && t3) for (const e3 of t3) {
    let { css: t4, ...n4 } = e3;
    t4 = "object" == typeof t4 && t4 || {};
    for (const e4 in n4) n4[e4] = String(n4[e4]);
    const r3 = [n4, t4, !c(t4)];
    s2.push(r3);
  }
  return [o3, r2, l3, s2, a2, g3];
};
var L = (e2, t3, n3) => {
  const [r2, i3, o3, l3] = O2(t3.composers), c2 = "function" == typeof t3.type || t3.type.$$typeof ? ((e3) => {
    function t4() {
      for (let n4 = 0; n4 < t4[M2].length; n4++) {
        const [r3, i4] = t4[M2][n4];
        e3.rules[r3].apply(i4);
      }
      return t4[M2] = [], null;
    }
    return t4[M2] = [], t4.rules = {}, j2.forEach((e4) => t4.rules[e4] = { apply: (n4) => t4[M2].push([e4, n4]) }), t4;
  })(n3) : null, d3 = (c2 || n3).rules, g3 = `.${r2}${i3.length > 1 ? `:where(.${i3.slice(1).join(".")})` : ""}`, p2 = (s2) => {
    s2 = "object" == typeof s2 && s2 || D2;
    const { css: a2, ...p3 } = s2, u2 = {};
    for (const e3 in o3) if (delete p3[e3], e3 in s2) {
      let t4 = s2[e3];
      "object" == typeof t4 && t4 ? u2[e3] = { "@initial": o3[e3], ...t4 } : (t4 = String(t4), u2[e3] = "undefined" !== t4 || l3.has(e3) ? t4 : o3[e3]);
    } else u2[e3] = o3[e3];
    const h2 = /* @__PURE__ */ new Set([...i3]);
    for (const [r3, i4, o4, l4] of t3.composers) {
      n3.rules.styled.cache.has(r3) || (n3.rules.styled.cache.add(r3), x2(i4, [`.${r3}`], [], e2, (e3) => {
        d3.styled.apply(e3);
      }));
      const t4 = A2(o4, u2, e2.media), s3 = A2(l4, u2, e2.media, true);
      for (const i5 of t4) if (void 0 !== i5) for (const [t5, o5, l5] of i5) {
        const i6 = `${r3}-${W(o5)}-${t5}`;
        h2.add(i6);
        const s4 = (l5 ? n3.rules.resonevar : n3.rules.onevar).cache, a3 = l5 ? d3.resonevar : d3.onevar;
        s4.has(i6) || (s4.add(i6), x2(o5, [`.${i6}`], [], e2, (e3) => {
          a3.apply(e3);
        }));
      }
      for (const t5 of s3) if (void 0 !== t5) for (const [i5, o5] of t5) {
        const t6 = `${r3}-${W(o5)}-${i5}`;
        h2.add(t6), n3.rules.allvar.cache.has(t6) || (n3.rules.allvar.cache.add(t6), x2(o5, [`.${t6}`], [], e2, (e3) => {
          d3.allvar.apply(e3);
        }));
      }
    }
    if ("object" == typeof a2 && a2) {
      const t4 = `${r2}-i${W(a2)}-css`;
      h2.add(t4), n3.rules.inline.cache.has(t4) || (n3.rules.inline.cache.add(t4), x2(a2, [`.${t4}`], [], e2, (e3) => {
        d3.inline.apply(e3);
      }));
    }
    for (const e3 of String(s2.className || "").trim().split(/\s+/)) e3 && h2.add(e3);
    const f3 = p3.className = [...h2].join(" ");
    return { type: t3.type, className: f3, selector: g3, props: p3, toString: () => f3, deferredInjector: c2 };
  };
  return a(p2, { className: r2, selector: g3, [s]: t3, toString: () => (n3.rules.styled.cache.has(r2) || p2(), r2) });
};
var O2 = (e2) => {
  let t3 = "";
  const n3 = [], r2 = {}, i3 = [];
  for (const [o3, , , , l3, s2] of e2) {
    "" === t3 && (t3 = o3), n3.push(o3), i3.push(...s2);
    for (const e3 in l3) {
      const t4 = l3[e3];
      (void 0 === r2[e3] || "undefined" !== t4 || s2.includes(t4)) && (r2[e3] = t4);
    }
  }
  return [t3, n3, r2, new Set(i3)];
};
var A2 = (e2, t3, n3, r2) => {
  const i3 = [];
  e: for (let [o3, l3, s2] of e2) {
    if (s2) continue;
    let e3, a2 = 0, c2 = false;
    for (e3 in o3) {
      const r3 = o3[e3];
      let i4 = t3[e3];
      if (i4 !== r3) {
        if ("object" != typeof i4 || !i4) continue e;
        {
          let e4, t4, o4 = 0;
          for (const l4 in i4) {
            if (r3 === String(i4[l4])) {
              if ("@initial" !== l4) {
                const e5 = l4.slice(1);
                (t4 = t4 || []).push(e5 in n3 ? n3[e5] : l4.replace(/^@media ?/, "")), c2 = true;
              }
              a2 += o4, e4 = true;
            }
            ++o4;
          }
          if (t4 && t4.length && (l3 = { ["@media " + t4.join(", ")]: l3 }), !e4) continue e;
        }
      }
    }
    (i3[a2] = i3[a2] || []).push([r2 ? "cv" : `${e3}-${o3[e3]}`, l3, c2]);
  }
  return i3;
};
var D2 = {};
var H2 = l2();
var N = (e2, t3) => H2(e2, () => (...n3) => {
  const r2 = () => {
    for (let r3 of n3) {
      r3 = "object" == typeof r3 && r3 || {};
      let n4 = W(r3);
      if (!t3.rules.global.cache.has(n4)) {
        if (t3.rules.global.cache.add(n4), "@import" in r3) {
          let e3 = [].indexOf.call(t3.sheet.cssRules, t3.rules.themed.group) - 1;
          for (let n5 of [].concat(r3["@import"])) n5 = n5.includes('"') || n5.includes("'") ? n5 : `"${n5}"`, t3.sheet.insertRule(`@import ${n5};`, e3++);
          delete r3["@import"];
        }
        x2(r3, [], [], e2, (e3) => {
          t3.rules.global.apply(e3);
        });
      }
    }
    return "";
  };
  return a(r2, { toString: r2 });
});
var V2 = l2();
var G2 = (e2, t3) => V2(e2, () => (n3) => {
  const r2 = `${k2(e2.prefix)}k-${W(n3)}`, i3 = () => {
    if (!t3.rules.global.cache.has(r2)) {
      t3.rules.global.cache.add(r2);
      const i4 = [];
      x2(n3, [], [], e2, (e3) => i4.push(e3));
      const o3 = `@keyframes ${r2}{${i4.join("")}}`;
      t3.rules.global.apply(o3);
    }
    return r2;
  };
  return a(i3, { get name() {
    return i3();
  }, toString: i3 });
});
var F2 = class {
  constructor(e2, t3, n3, r2) {
    this.token = null == e2 ? "" : String(e2), this.value = null == t3 ? "" : String(t3), this.scale = null == n3 ? "" : String(n3), this.prefix = null == r2 ? "" : String(r2);
  }
  get computedValue() {
    return "var(" + this.variable + ")";
  }
  get variable() {
    return "--" + k2(this.prefix) + k2(this.scale) + this.token;
  }
  toString() {
    return this.computedValue;
  }
};
var J2 = l2();
var U2 = (e2, t3) => J2(e2, () => (n3, r2) => {
  r2 = "object" == typeof n3 && n3 || Object(r2);
  const i3 = `.${n3 = (n3 = "string" == typeof n3 ? n3 : "") || `${k2(e2.prefix)}t-${W(r2)}`}`, o3 = {}, l3 = [];
  for (const t4 in r2) {
    o3[t4] = {};
    for (const n4 in r2[t4]) {
      const i4 = `--${k2(e2.prefix)}${t4}-${n4}`, s3 = y(String(r2[t4][n4]), e2.prefix, t4);
      o3[t4][n4] = new F2(n4, s3, t4, e2.prefix), l3.push(`${i4}:${s3}`);
    }
  }
  const s2 = () => {
    if (l3.length && !t3.rules.themed.cache.has(n3)) {
      t3.rules.themed.cache.add(n3);
      const i4 = `${r2 === e2.theme ? ":root," : ""}.${n3}{${l3.join(";")}}`;
      t3.rules.themed.apply(i4);
    }
    return n3;
  };
  return { ...o3, get className() {
    return s2();
  }, selector: i3, toString: s2 };
});
var Z2 = l2();
var X2 = (e2) => {
  let t3 = false;
  const n3 = Z2(e2, (e3) => {
    t3 = true;
    const n4 = "prefix" in (e3 = "object" == typeof e3 && e3 || {}) ? String(e3.prefix) : "", r2 = "object" == typeof e3.media && e3.media || {}, o3 = "object" == typeof e3.root ? e3.root || null : globalThis.document || null, l3 = "object" == typeof e3.theme && e3.theme || {}, s2 = { prefix: n4, media: r2, theme: l3, themeMap: "object" == typeof e3.themeMap && e3.themeMap || { ...i2 }, utils: "object" == typeof e3.utils && e3.utils || {} }, a2 = T2(o3), c2 = { css: C2(s2, a2), globalCss: N(s2, a2), keyframes: G2(s2, a2), createTheme: U2(s2, a2), reset() {
      a2.reset(), c2.theme.toString();
    }, theme: {}, sheet: a2, config: s2, prefix: n4, getCssText: a2.toString, toString: a2.toString };
    return String(c2.theme = c2.createTheme(l3)), c2;
  });
  return t3 || n3.reset(), n3;
};

// node_modules/@codesandbox/sandpack-client/dist/index.mjs
function loadSandpackClient(iframeSelector, sandboxSetup, options) {
  var _a2;
  if (options === void 0) {
    options = {};
  }
  return __awaiter(this, void 0, void 0, function() {
    var template, Client, _b2;
    return __generator(this, function(_c2) {
      switch (_c2.label) {
        case 0:
          template = (_a2 = sandboxSetup.template) !== null && _a2 !== void 0 ? _a2 : "parcel";
          _b2 = template;
          switch (_b2) {
            case "node":
              return [3, 1];
            case "static":
              return [3, 3];
          }
          return [3, 5];
        case 1:
          return [4, import("./node-3RPKOWSK.js").then(function(m2) {
            return m2.SandpackNode;
          })];
        case 2:
          Client = _c2.sent();
          return [3, 7];
        case 3:
          return [4, import("./index-599aeaf7-GSWDXUA3.js").then(function(m2) {
            return m2.SandpackStatic;
          })];
        case 4:
          Client = _c2.sent();
          return [3, 7];
        case 5:
          return [4, import("./runtime-UR6K67E3.js").then(function(m2) {
            return m2.SandpackRuntime;
          })];
        case 6:
          Client = _c2.sent();
          _c2.label = 7;
        case 7:
          return [2, new Client(iframeSelector, sandboxSetup, options)];
      }
    });
  });
}

// node_modules/@codemirror/commands/dist/index.js
var toggleComment = (target) => {
  let { state } = target, line = state.doc.lineAt(state.selection.main.from), config = getConfig(target.state, line.from);
  return config.line ? toggleLineComment(target) : config.block ? toggleBlockCommentByLine(target) : false;
};
function command(f3, option) {
  return ({ state, dispatch }) => {
    if (state.readOnly)
      return false;
    let tr = f3(option, state);
    if (!tr)
      return false;
    dispatch(state.update(tr));
    return true;
  };
}
var toggleLineComment = command(
  changeLineComment,
  0
  /* CommentOption.Toggle */
);
var lineComment = command(
  changeLineComment,
  1
  /* CommentOption.Comment */
);
var lineUncomment = command(
  changeLineComment,
  2
  /* CommentOption.Uncomment */
);
var toggleBlockComment = command(
  changeBlockComment,
  0
  /* CommentOption.Toggle */
);
var blockComment = command(
  changeBlockComment,
  1
  /* CommentOption.Comment */
);
var blockUncomment = command(
  changeBlockComment,
  2
  /* CommentOption.Uncomment */
);
var toggleBlockCommentByLine = command(
  (o3, s2) => changeBlockComment(o3, s2, selectedLineRanges(s2)),
  0
  /* CommentOption.Toggle */
);
function getConfig(state, pos) {
  let data2 = state.languageDataAt("commentTokens", pos);
  return data2.length ? data2[0] : {};
}
var SearchMargin = 50;
function findBlockComment(state, { open, close: close2 }, from, to) {
  let textBefore = state.sliceDoc(from - SearchMargin, from);
  let textAfter = state.sliceDoc(to, to + SearchMargin);
  let spaceBefore = /\s*$/.exec(textBefore)[0].length, spaceAfter = /^\s*/.exec(textAfter)[0].length;
  let beforeOff = textBefore.length - spaceBefore;
  if (textBefore.slice(beforeOff - open.length, beforeOff) == open && textAfter.slice(spaceAfter, spaceAfter + close2.length) == close2) {
    return {
      open: { pos: from - spaceBefore, margin: spaceBefore && 1 },
      close: { pos: to + spaceAfter, margin: spaceAfter && 1 }
    };
  }
  let startText, endText;
  if (to - from <= 2 * SearchMargin) {
    startText = endText = state.sliceDoc(from, to);
  } else {
    startText = state.sliceDoc(from, from + SearchMargin);
    endText = state.sliceDoc(to - SearchMargin, to);
  }
  let startSpace = /^\s*/.exec(startText)[0].length, endSpace = /\s*$/.exec(endText)[0].length;
  let endOff = endText.length - endSpace - close2.length;
  if (startText.slice(startSpace, startSpace + open.length) == open && endText.slice(endOff, endOff + close2.length) == close2) {
    return {
      open: {
        pos: from + startSpace + open.length,
        margin: /\s/.test(startText.charAt(startSpace + open.length)) ? 1 : 0
      },
      close: {
        pos: to - endSpace - close2.length,
        margin: /\s/.test(endText.charAt(endOff - 1)) ? 1 : 0
      }
    };
  }
  return null;
}
function selectedLineRanges(state) {
  let ranges = [];
  for (let r2 of state.selection.ranges) {
    let fromLine2 = state.doc.lineAt(r2.from);
    let toLine2 = r2.to <= fromLine2.to ? fromLine2 : state.doc.lineAt(r2.to);
    if (toLine2.from > fromLine2.from && toLine2.from == r2.to)
      toLine2 = r2.to == fromLine2.to + 1 ? fromLine2 : state.doc.lineAt(r2.to - 1);
    let last = ranges.length - 1;
    if (last >= 0 && ranges[last].to > fromLine2.from)
      ranges[last].to = toLine2.to;
    else
      ranges.push({ from: fromLine2.from + /^\s*/.exec(fromLine2.text)[0].length, to: toLine2.to });
  }
  return ranges;
}
function changeBlockComment(option, state, ranges = state.selection.ranges) {
  let tokens = ranges.map((r2) => getConfig(state, r2.from).block);
  if (!tokens.every((c2) => c2))
    return null;
  let comments = ranges.map((r2, i3) => findBlockComment(state, tokens[i3], r2.from, r2.to));
  if (option != 2 && !comments.every((c2) => c2)) {
    return { changes: state.changes(ranges.map((range, i3) => {
      if (comments[i3])
        return [];
      return [{ from: range.from, insert: tokens[i3].open + " " }, { from: range.to, insert: " " + tokens[i3].close }];
    })) };
  } else if (option != 1 && comments.some((c2) => c2)) {
    let changes = [];
    for (let i3 = 0, comment2; i3 < comments.length; i3++)
      if (comment2 = comments[i3]) {
        let token = tokens[i3], { open, close: close2 } = comment2;
        changes.push({ from: open.pos - token.open.length, to: open.pos + open.margin }, { from: close2.pos - close2.margin, to: close2.pos + token.close.length });
      }
    return { changes };
  }
  return null;
}
function changeLineComment(option, state, ranges = state.selection.ranges) {
  let lines = [];
  let prevLine = -1;
  for (let { from, to } of ranges) {
    let startI = lines.length, minIndent = 1e9;
    let token = getConfig(state, from).line;
    if (!token)
      continue;
    for (let pos = from; pos <= to; ) {
      let line = state.doc.lineAt(pos);
      if (line.from > prevLine && (from == to || to > line.from)) {
        prevLine = line.from;
        let indent2 = /^\s*/.exec(line.text)[0].length;
        let empty5 = indent2 == line.length;
        let comment2 = line.text.slice(indent2, indent2 + token.length) == token ? indent2 : -1;
        if (indent2 < line.text.length && indent2 < minIndent)
          minIndent = indent2;
        lines.push({ line, comment: comment2, token, indent: indent2, empty: empty5, single: false });
      }
      pos = line.to + 1;
    }
    if (minIndent < 1e9) {
      for (let i3 = startI; i3 < lines.length; i3++)
        if (lines[i3].indent < lines[i3].line.text.length)
          lines[i3].indent = minIndent;
    }
    if (lines.length == startI + 1)
      lines[startI].single = true;
  }
  if (option != 2 && lines.some((l3) => l3.comment < 0 && (!l3.empty || l3.single))) {
    let changes = [];
    for (let { line, token, indent: indent2, empty: empty5, single } of lines)
      if (single || !empty5)
        changes.push({ from: line.from + indent2, insert: token + " " });
    let changeSet = state.changes(changes);
    return { changes: changeSet, selection: state.selection.map(changeSet, 1) };
  } else if (option != 1 && lines.some((l3) => l3.comment >= 0)) {
    let changes = [];
    for (let { line, comment: comment2, token } of lines)
      if (comment2 >= 0) {
        let from = line.from + comment2, to = from + token.length;
        if (line.text[to - line.from] == " ")
          to++;
        changes.push({ from, to });
      }
    return { changes };
  }
  return null;
}
var fromHistory = Annotation.define();
var isolateHistory = Annotation.define();
var invertedEffects = Facet.define();
var historyConfig = Facet.define({
  combine(configs) {
    return combineConfig(configs, {
      minDepth: 100,
      newGroupDelay: 500,
      joinToEvent: (_t, isAdjacent2) => isAdjacent2
    }, {
      minDepth: Math.max,
      newGroupDelay: Math.min,
      joinToEvent: (a2, b3) => (tr, adj) => a2(tr, adj) || b3(tr, adj)
    });
  }
});
var historyField_ = StateField.define({
  create() {
    return HistoryState.empty;
  },
  update(state, tr) {
    let config = tr.state.facet(historyConfig);
    let fromHist = tr.annotation(fromHistory);
    if (fromHist) {
      let item = HistEvent.fromTransaction(tr, fromHist.selection), from = fromHist.side;
      let other = from == 0 ? state.undone : state.done;
      if (item)
        other = updateBranch(other, other.length, config.minDepth, item);
      else
        other = addSelection(other, tr.startState.selection);
      return new HistoryState(from == 0 ? fromHist.rest : other, from == 0 ? other : fromHist.rest);
    }
    let isolate = tr.annotation(isolateHistory);
    if (isolate == "full" || isolate == "before")
      state = state.isolate();
    if (tr.annotation(Transaction.addToHistory) === false)
      return !tr.changes.empty ? state.addMapping(tr.changes.desc) : state;
    let event = HistEvent.fromTransaction(tr);
    let time = tr.annotation(Transaction.time), userEvent = tr.annotation(Transaction.userEvent);
    if (event)
      state = state.addChanges(event, time, userEvent, config, tr);
    else if (tr.selection)
      state = state.addSelection(tr.startState.selection, time, userEvent, config.newGroupDelay);
    if (isolate == "full" || isolate == "after")
      state = state.isolate();
    return state;
  },
  toJSON(value2) {
    return { done: value2.done.map((e2) => e2.toJSON()), undone: value2.undone.map((e2) => e2.toJSON()) };
  },
  fromJSON(json2) {
    return new HistoryState(json2.done.map(HistEvent.fromJSON), json2.undone.map(HistEvent.fromJSON));
  }
});
function history(config = {}) {
  return [
    historyField_,
    historyConfig.of(config),
    EditorView.domEventHandlers({
      beforeinput(e2, view) {
        let command2 = e2.inputType == "historyUndo" ? undo2 : e2.inputType == "historyRedo" ? redo2 : null;
        if (!command2)
          return false;
        e2.preventDefault();
        return command2(view);
      }
    })
  ];
}
function cmd(side, selection2) {
  return function({ state, dispatch }) {
    if (!selection2 && state.readOnly)
      return false;
    let historyState = state.field(historyField_, false);
    if (!historyState)
      return false;
    let tr = historyState.pop(side, state, selection2);
    if (!tr)
      return false;
    dispatch(tr);
    return true;
  };
}
var undo2 = cmd(0, false);
var redo2 = cmd(1, false);
var undoSelection = cmd(0, true);
var redoSelection = cmd(1, true);
function depth(side) {
  return function(state) {
    let histState = state.field(historyField_, false);
    if (!histState)
      return 0;
    let branch = side == 0 ? histState.done : histState.undone;
    return branch.length - (branch.length && !branch[0].changes ? 1 : 0);
  };
}
var undoDepth = depth(
  0
  /* BranchName.Done */
);
var redoDepth = depth(
  1
  /* BranchName.Undone */
);
var HistEvent = class _HistEvent {
  constructor(changes, effects, mapped, startSelection, selectionsAfter) {
    this.changes = changes;
    this.effects = effects;
    this.mapped = mapped;
    this.startSelection = startSelection;
    this.selectionsAfter = selectionsAfter;
  }
  setSelAfter(after) {
    return new _HistEvent(this.changes, this.effects, this.mapped, this.startSelection, after);
  }
  toJSON() {
    var _a2, _b2, _c2;
    return {
      changes: (_a2 = this.changes) === null || _a2 === void 0 ? void 0 : _a2.toJSON(),
      mapped: (_b2 = this.mapped) === null || _b2 === void 0 ? void 0 : _b2.toJSON(),
      startSelection: (_c2 = this.startSelection) === null || _c2 === void 0 ? void 0 : _c2.toJSON(),
      selectionsAfter: this.selectionsAfter.map((s2) => s2.toJSON())
    };
  }
  static fromJSON(json2) {
    return new _HistEvent(json2.changes && ChangeSet.fromJSON(json2.changes), [], json2.mapped && ChangeDesc.fromJSON(json2.mapped), json2.startSelection && EditorSelection.fromJSON(json2.startSelection), json2.selectionsAfter.map(EditorSelection.fromJSON));
  }
  // This does not check `addToHistory` and such, it assumes the
  // transaction needs to be converted to an item. Returns null when
  // there are no changes or effects in the transaction.
  static fromTransaction(tr, selection2) {
    let effects = none;
    for (let invert of tr.startState.facet(invertedEffects)) {
      let result = invert(tr);
      if (result.length)
        effects = effects.concat(result);
    }
    if (!effects.length && tr.changes.empty)
      return null;
    return new _HistEvent(tr.changes.invert(tr.startState.doc), effects, void 0, selection2 || tr.startState.selection, none);
  }
  static selection(selections) {
    return new _HistEvent(void 0, none, void 0, void 0, selections);
  }
};
function updateBranch(branch, to, maxLen, newEvent) {
  let start2 = to + 1 > maxLen + 20 ? to - maxLen - 1 : 0;
  let newBranch = branch.slice(start2, to);
  newBranch.push(newEvent);
  return newBranch;
}
function isAdjacent(a2, b3) {
  let ranges = [], isAdjacent2 = false;
  a2.iterChangedRanges((f3, t3) => ranges.push(f3, t3));
  b3.iterChangedRanges((_f, _t, f3, t3) => {
    for (let i3 = 0; i3 < ranges.length; ) {
      let from = ranges[i3++], to = ranges[i3++];
      if (t3 >= from && f3 <= to)
        isAdjacent2 = true;
    }
  });
  return isAdjacent2;
}
function eqSelectionShape(a2, b3) {
  return a2.ranges.length == b3.ranges.length && a2.ranges.filter((r2, i3) => r2.empty != b3.ranges[i3].empty).length === 0;
}
function conc(a2, b3) {
  return !a2.length ? b3 : !b3.length ? a2 : a2.concat(b3);
}
var none = [];
var MaxSelectionsPerEvent = 200;
function addSelection(branch, selection2) {
  if (!branch.length) {
    return [HistEvent.selection([selection2])];
  } else {
    let lastEvent = branch[branch.length - 1];
    let sels = lastEvent.selectionsAfter.slice(Math.max(0, lastEvent.selectionsAfter.length - MaxSelectionsPerEvent));
    if (sels.length && sels[sels.length - 1].eq(selection2))
      return branch;
    sels.push(selection2);
    return updateBranch(branch, branch.length - 1, 1e9, lastEvent.setSelAfter(sels));
  }
}
function popSelection(branch) {
  let last = branch[branch.length - 1];
  let newBranch = branch.slice();
  newBranch[branch.length - 1] = last.setSelAfter(last.selectionsAfter.slice(0, last.selectionsAfter.length - 1));
  return newBranch;
}
function addMappingToBranch(branch, mapping) {
  if (!branch.length)
    return branch;
  let length = branch.length, selections = none;
  while (length) {
    let event = mapEvent(branch[length - 1], mapping, selections);
    if (event.changes && !event.changes.empty || event.effects.length) {
      let result = branch.slice(0, length);
      result[length - 1] = event;
      return result;
    } else {
      mapping = event.mapped;
      length--;
      selections = event.selectionsAfter;
    }
  }
  return selections.length ? [HistEvent.selection(selections)] : none;
}
function mapEvent(event, mapping, extraSelections) {
  let selections = conc(event.selectionsAfter.length ? event.selectionsAfter.map((s2) => s2.map(mapping)) : none, extraSelections);
  if (!event.changes)
    return HistEvent.selection(selections);
  let mappedChanges = event.changes.map(mapping), before = mapping.mapDesc(event.changes, true);
  let fullMapping = event.mapped ? event.mapped.composeDesc(before) : before;
  return new HistEvent(mappedChanges, StateEffect.mapEffects(event.effects, mapping), fullMapping, event.startSelection.map(before), selections);
}
var joinableUserEvent = /^(input\.type|delete)($|\.)/;
var HistoryState = class _HistoryState {
  constructor(done, undone, prevTime = 0, prevUserEvent = void 0) {
    this.done = done;
    this.undone = undone;
    this.prevTime = prevTime;
    this.prevUserEvent = prevUserEvent;
  }
  isolate() {
    return this.prevTime ? new _HistoryState(this.done, this.undone) : this;
  }
  addChanges(event, time, userEvent, config, tr) {
    let done = this.done, lastEvent = done[done.length - 1];
    if (lastEvent && lastEvent.changes && !lastEvent.changes.empty && event.changes && (!userEvent || joinableUserEvent.test(userEvent)) && (!lastEvent.selectionsAfter.length && time - this.prevTime < config.newGroupDelay && config.joinToEvent(tr, isAdjacent(lastEvent.changes, event.changes)) || // For compose (but not compose.start) events, always join with previous event
    userEvent == "input.type.compose")) {
      done = updateBranch(done, done.length - 1, config.minDepth, new HistEvent(event.changes.compose(lastEvent.changes), conc(StateEffect.mapEffects(event.effects, lastEvent.changes), lastEvent.effects), lastEvent.mapped, lastEvent.startSelection, none));
    } else {
      done = updateBranch(done, done.length, config.minDepth, event);
    }
    return new _HistoryState(done, none, time, userEvent);
  }
  addSelection(selection2, time, userEvent, newGroupDelay) {
    let last = this.done.length ? this.done[this.done.length - 1].selectionsAfter : none;
    if (last.length > 0 && time - this.prevTime < newGroupDelay && userEvent == this.prevUserEvent && userEvent && /^select($|\.)/.test(userEvent) && eqSelectionShape(last[last.length - 1], selection2))
      return this;
    return new _HistoryState(addSelection(this.done, selection2), this.undone, time, userEvent);
  }
  addMapping(mapping) {
    return new _HistoryState(addMappingToBranch(this.done, mapping), addMappingToBranch(this.undone, mapping), this.prevTime, this.prevUserEvent);
  }
  pop(side, state, onlySelection) {
    let branch = side == 0 ? this.done : this.undone;
    if (branch.length == 0)
      return null;
    let event = branch[branch.length - 1], selection2 = event.selectionsAfter[0] || state.selection;
    if (onlySelection && event.selectionsAfter.length) {
      return state.update({
        selection: event.selectionsAfter[event.selectionsAfter.length - 1],
        annotations: fromHistory.of({ side, rest: popSelection(branch), selection: selection2 }),
        userEvent: side == 0 ? "select.undo" : "select.redo",
        scrollIntoView: true
      });
    } else if (!event.changes) {
      return null;
    } else {
      let rest = branch.length == 1 ? none : branch.slice(0, branch.length - 1);
      if (event.mapped)
        rest = addMappingToBranch(rest, event.mapped);
      return state.update({
        changes: event.changes,
        selection: event.startSelection,
        effects: event.effects,
        annotations: fromHistory.of({ side, rest, selection: selection2 }),
        filter: false,
        userEvent: side == 0 ? "undo" : "redo",
        scrollIntoView: true
      });
    }
  }
};
HistoryState.empty = new HistoryState(none, none);
var historyKeymap = [
  { key: "Mod-z", run: undo2, preventDefault: true },
  { key: "Mod-y", mac: "Mod-Shift-z", run: redo2, preventDefault: true },
  { linux: "Ctrl-Shift-z", run: redo2, preventDefault: true },
  { key: "Mod-u", run: undoSelection, preventDefault: true },
  { key: "Alt-u", mac: "Mod-Shift-u", run: redoSelection, preventDefault: true }
];
function updateSel(sel, by) {
  return EditorSelection.create(sel.ranges.map(by), sel.mainIndex);
}
function setSel(state, selection2) {
  return state.update({ selection: selection2, scrollIntoView: true, userEvent: "select" });
}
function moveSel({ state, dispatch }, how) {
  let selection2 = updateSel(state.selection, how);
  if (selection2.eq(state.selection, true))
    return false;
  dispatch(setSel(state, selection2));
  return true;
}
function rangeEnd(range, forward) {
  return EditorSelection.cursor(forward ? range.to : range.from);
}
function cursorByChar(view, forward) {
  return moveSel(view, (range) => range.empty ? view.moveByChar(range, forward) : rangeEnd(range, forward));
}
function ltrAtCursor(view) {
  return view.textDirectionAt(view.state.selection.main.head) == Direction.LTR;
}
var cursorCharLeft = (view) => cursorByChar(view, !ltrAtCursor(view));
var cursorCharRight = (view) => cursorByChar(view, ltrAtCursor(view));
function cursorByGroup(view, forward) {
  return moveSel(view, (range) => range.empty ? view.moveByGroup(range, forward) : rangeEnd(range, forward));
}
var cursorGroupLeft = (view) => cursorByGroup(view, !ltrAtCursor(view));
var cursorGroupRight = (view) => cursorByGroup(view, ltrAtCursor(view));
var segmenter = typeof Intl != "undefined" && Intl.Segmenter ? new Intl.Segmenter(void 0, { granularity: "word" }) : null;
function interestingNode(state, node2, bracketProp) {
  if (node2.type.prop(bracketProp))
    return true;
  let len = node2.to - node2.from;
  return len && (len > 2 || /[^\s,.;:]/.test(state.sliceDoc(node2.from, node2.to))) || node2.firstChild;
}
function moveBySyntax(state, start2, forward) {
  let pos = syntaxTree(state).resolveInner(start2.head);
  let bracketProp = forward ? NodeProp.closedBy : NodeProp.openedBy;
  for (let at3 = start2.head; ; ) {
    let next = forward ? pos.childAfter(at3) : pos.childBefore(at3);
    if (!next)
      break;
    if (interestingNode(state, next, bracketProp))
      pos = next;
    else
      at3 = forward ? next.to : next.from;
  }
  let bracket = pos.type.prop(bracketProp), match, newPos;
  if (bracket && (match = forward ? matchBrackets(state, pos.from, 1) : matchBrackets(state, pos.to, -1)) && match.matched)
    newPos = forward ? match.end.to : match.end.from;
  else
    newPos = forward ? pos.to : pos.from;
  return EditorSelection.cursor(newPos, forward ? -1 : 1);
}
var cursorSyntaxLeft = (view) => moveSel(view, (range) => moveBySyntax(view.state, range, !ltrAtCursor(view)));
var cursorSyntaxRight = (view) => moveSel(view, (range) => moveBySyntax(view.state, range, ltrAtCursor(view)));
function cursorByLine(view, forward) {
  return moveSel(view, (range) => {
    if (!range.empty)
      return rangeEnd(range, forward);
    let moved = view.moveVertically(range, forward);
    return moved.head != range.head ? moved : view.moveToLineBoundary(range, forward);
  });
}
var cursorLineUp = (view) => cursorByLine(view, false);
var cursorLineDown = (view) => cursorByLine(view, true);
function pageInfo(view) {
  let selfScroll = view.scrollDOM.clientHeight < view.scrollDOM.scrollHeight - 2;
  let marginTop = 0, marginBottom = 0, height;
  if (selfScroll) {
    for (let source of view.state.facet(EditorView.scrollMargins)) {
      let margins = source(view);
      if (margins === null || margins === void 0 ? void 0 : margins.top)
        marginTop = Math.max(margins === null || margins === void 0 ? void 0 : margins.top, marginTop);
      if (margins === null || margins === void 0 ? void 0 : margins.bottom)
        marginBottom = Math.max(margins === null || margins === void 0 ? void 0 : margins.bottom, marginBottom);
    }
    height = view.scrollDOM.clientHeight - marginTop - marginBottom;
  } else {
    height = (view.dom.ownerDocument.defaultView || window).innerHeight;
  }
  return {
    marginTop,
    marginBottom,
    selfScroll,
    height: Math.max(view.defaultLineHeight, height - 5)
  };
}
function cursorByPage(view, forward) {
  let page = pageInfo(view);
  let { state } = view, selection2 = updateSel(state.selection, (range) => {
    return range.empty ? view.moveVertically(range, forward, page.height) : rangeEnd(range, forward);
  });
  if (selection2.eq(state.selection))
    return false;
  let effect;
  if (page.selfScroll) {
    let startPos = view.coordsAtPos(state.selection.main.head);
    let scrollRect = view.scrollDOM.getBoundingClientRect();
    let scrollTop = scrollRect.top + page.marginTop, scrollBottom = scrollRect.bottom - page.marginBottom;
    if (startPos && startPos.top > scrollTop && startPos.bottom < scrollBottom)
      effect = EditorView.scrollIntoView(selection2.main.head, { y: "start", yMargin: startPos.top - scrollTop });
  }
  view.dispatch(setSel(state, selection2), { effects: effect });
  return true;
}
var cursorPageUp = (view) => cursorByPage(view, false);
var cursorPageDown = (view) => cursorByPage(view, true);
function moveByLineBoundary(view, start2, forward) {
  let line = view.lineBlockAt(start2.head), moved = view.moveToLineBoundary(start2, forward);
  if (moved.head == start2.head && moved.head != (forward ? line.to : line.from))
    moved = view.moveToLineBoundary(start2, forward, false);
  if (!forward && moved.head == line.from && line.length) {
    let space = /^\s*/.exec(view.state.sliceDoc(line.from, Math.min(line.from + 100, line.to)))[0].length;
    if (space && start2.head != line.from + space)
      moved = EditorSelection.cursor(line.from + space);
  }
  return moved;
}
var cursorLineBoundaryForward = (view) => moveSel(view, (range) => moveByLineBoundary(view, range, true));
var cursorLineBoundaryBackward = (view) => moveSel(view, (range) => moveByLineBoundary(view, range, false));
var cursorLineBoundaryLeft = (view) => moveSel(view, (range) => moveByLineBoundary(view, range, !ltrAtCursor(view)));
var cursorLineBoundaryRight = (view) => moveSel(view, (range) => moveByLineBoundary(view, range, ltrAtCursor(view)));
var cursorLineStart = (view) => moveSel(view, (range) => EditorSelection.cursor(view.lineBlockAt(range.head).from, 1));
var cursorLineEnd = (view) => moveSel(view, (range) => EditorSelection.cursor(view.lineBlockAt(range.head).to, -1));
function toMatchingBracket(state, dispatch, extend4) {
  let found = false, selection2 = updateSel(state.selection, (range) => {
    let matching = matchBrackets(state, range.head, -1) || matchBrackets(state, range.head, 1) || range.head > 0 && matchBrackets(state, range.head - 1, 1) || range.head < state.doc.length && matchBrackets(state, range.head + 1, -1);
    if (!matching || !matching.end)
      return range;
    found = true;
    let head = matching.start.from == range.head ? matching.end.to : matching.end.from;
    return extend4 ? EditorSelection.range(range.anchor, head) : EditorSelection.cursor(head);
  });
  if (!found)
    return false;
  dispatch(setSel(state, selection2));
  return true;
}
var cursorMatchingBracket = ({ state, dispatch }) => toMatchingBracket(state, dispatch, false);
function extendSel(target, how) {
  let selection2 = updateSel(target.state.selection, (range) => {
    let head = how(range);
    return EditorSelection.range(range.anchor, head.head, head.goalColumn, head.bidiLevel || void 0);
  });
  if (selection2.eq(target.state.selection))
    return false;
  target.dispatch(setSel(target.state, selection2));
  return true;
}
function selectByChar(view, forward) {
  return extendSel(view, (range) => view.moveByChar(range, forward));
}
var selectCharLeft = (view) => selectByChar(view, !ltrAtCursor(view));
var selectCharRight = (view) => selectByChar(view, ltrAtCursor(view));
function selectByGroup(view, forward) {
  return extendSel(view, (range) => view.moveByGroup(range, forward));
}
var selectGroupLeft = (view) => selectByGroup(view, !ltrAtCursor(view));
var selectGroupRight = (view) => selectByGroup(view, ltrAtCursor(view));
var selectSyntaxLeft = (view) => extendSel(view, (range) => moveBySyntax(view.state, range, !ltrAtCursor(view)));
var selectSyntaxRight = (view) => extendSel(view, (range) => moveBySyntax(view.state, range, ltrAtCursor(view)));
function selectByLine(view, forward) {
  return extendSel(view, (range) => view.moveVertically(range, forward));
}
var selectLineUp = (view) => selectByLine(view, false);
var selectLineDown = (view) => selectByLine(view, true);
function selectByPage(view, forward) {
  return extendSel(view, (range) => view.moveVertically(range, forward, pageInfo(view).height));
}
var selectPageUp = (view) => selectByPage(view, false);
var selectPageDown = (view) => selectByPage(view, true);
var selectLineBoundaryForward = (view) => extendSel(view, (range) => moveByLineBoundary(view, range, true));
var selectLineBoundaryBackward = (view) => extendSel(view, (range) => moveByLineBoundary(view, range, false));
var selectLineBoundaryLeft = (view) => extendSel(view, (range) => moveByLineBoundary(view, range, !ltrAtCursor(view)));
var selectLineBoundaryRight = (view) => extendSel(view, (range) => moveByLineBoundary(view, range, ltrAtCursor(view)));
var selectLineStart = (view) => extendSel(view, (range) => EditorSelection.cursor(view.lineBlockAt(range.head).from));
var selectLineEnd = (view) => extendSel(view, (range) => EditorSelection.cursor(view.lineBlockAt(range.head).to));
var cursorDocStart = ({ state, dispatch }) => {
  dispatch(setSel(state, { anchor: 0 }));
  return true;
};
var cursorDocEnd = ({ state, dispatch }) => {
  dispatch(setSel(state, { anchor: state.doc.length }));
  return true;
};
var selectDocStart = ({ state, dispatch }) => {
  dispatch(setSel(state, { anchor: state.selection.main.anchor, head: 0 }));
  return true;
};
var selectDocEnd = ({ state, dispatch }) => {
  dispatch(setSel(state, { anchor: state.selection.main.anchor, head: state.doc.length }));
  return true;
};
var selectAll = ({ state, dispatch }) => {
  dispatch(state.update({ selection: { anchor: 0, head: state.doc.length }, userEvent: "select" }));
  return true;
};
var selectLine = ({ state, dispatch }) => {
  let ranges = selectedLineBlocks(state).map(({ from, to }) => EditorSelection.range(from, Math.min(to + 1, state.doc.length)));
  dispatch(state.update({ selection: EditorSelection.create(ranges), userEvent: "select" }));
  return true;
};
var selectParentSyntax = ({ state, dispatch }) => {
  let selection2 = updateSel(state.selection, (range) => {
    let tree = syntaxTree(state), stack = tree.resolveStack(range.from, 1);
    if (range.empty) {
      let stackBefore = tree.resolveStack(range.from, -1);
      if (stackBefore.node.from >= stack.node.from && stackBefore.node.to <= stack.node.to)
        stack = stackBefore;
    }
    for (let cur = stack; cur; cur = cur.next) {
      let { node: node2 } = cur;
      if ((node2.from < range.from && node2.to >= range.to || node2.to > range.to && node2.from <= range.from) && cur.next)
        return EditorSelection.range(node2.to, node2.from);
    }
    return range;
  });
  if (selection2.eq(state.selection))
    return false;
  dispatch(setSel(state, selection2));
  return true;
};
var simplifySelection = ({ state, dispatch }) => {
  let cur = state.selection, selection2 = null;
  if (cur.ranges.length > 1)
    selection2 = EditorSelection.create([cur.main]);
  else if (!cur.main.empty)
    selection2 = EditorSelection.create([EditorSelection.cursor(cur.main.head)]);
  if (!selection2)
    return false;
  dispatch(setSel(state, selection2));
  return true;
};
function deleteBy(target, by) {
  if (target.state.readOnly)
    return false;
  let event = "delete.selection", { state } = target;
  let changes = state.changeByRange((range) => {
    let { from, to } = range;
    if (from == to) {
      let towards = by(range);
      if (towards < from) {
        event = "delete.backward";
        towards = skipAtomic(target, towards, false);
      } else if (towards > from) {
        event = "delete.forward";
        towards = skipAtomic(target, towards, true);
      }
      from = Math.min(from, towards);
      to = Math.max(to, towards);
    } else {
      from = skipAtomic(target, from, false);
      to = skipAtomic(target, to, true);
    }
    return from == to ? { range } : { changes: { from, to }, range: EditorSelection.cursor(from, from < range.head ? -1 : 1) };
  });
  if (changes.changes.empty)
    return false;
  target.dispatch(state.update(changes, {
    scrollIntoView: true,
    userEvent: event,
    effects: event == "delete.selection" ? EditorView.announce.of(state.phrase("Selection deleted")) : void 0
  }));
  return true;
}
function skipAtomic(target, pos, forward) {
  if (target instanceof EditorView)
    for (let ranges of target.state.facet(EditorView.atomicRanges).map((f3) => f3(target)))
      ranges.between(pos, pos, (from, to) => {
        if (from < pos && to > pos)
          pos = forward ? to : from;
      });
  return pos;
}
var deleteByChar = (target, forward, byIndentUnit) => deleteBy(target, (range) => {
  let pos = range.from, { state } = target, line = state.doc.lineAt(pos), before, targetPos;
  if (byIndentUnit && !forward && pos > line.from && pos < line.from + 200 && !/[^ \t]/.test(before = line.text.slice(0, pos - line.from))) {
    if (before[before.length - 1] == "	")
      return pos - 1;
    let col = countColumn(before, state.tabSize), drop = col % getIndentUnit(state) || getIndentUnit(state);
    for (let i3 = 0; i3 < drop && before[before.length - 1 - i3] == " "; i3++)
      pos--;
    targetPos = pos;
  } else {
    targetPos = findClusterBreak(line.text, pos - line.from, forward, forward) + line.from;
    if (targetPos == pos && line.number != (forward ? state.doc.lines : 1))
      targetPos += forward ? 1 : -1;
    else if (!forward && /[\ufe00-\ufe0f]/.test(line.text.slice(targetPos - line.from, pos - line.from)))
      targetPos = findClusterBreak(line.text, targetPos - line.from, false, false) + line.from;
  }
  return targetPos;
});
var deleteCharBackward = (view) => deleteByChar(view, false, true);
var deleteCharForward = (view) => deleteByChar(view, true, false);
var deleteByGroup = (target, forward) => deleteBy(target, (range) => {
  let pos = range.head, { state } = target, line = state.doc.lineAt(pos);
  let categorize = state.charCategorizer(pos);
  for (let cat = null; ; ) {
    if (pos == (forward ? line.to : line.from)) {
      if (pos == range.head && line.number != (forward ? state.doc.lines : 1))
        pos += forward ? 1 : -1;
      break;
    }
    let next = findClusterBreak(line.text, pos - line.from, forward) + line.from;
    let nextChar = line.text.slice(Math.min(pos, next) - line.from, Math.max(pos, next) - line.from);
    let nextCat = categorize(nextChar);
    if (cat != null && nextCat != cat)
      break;
    if (nextChar != " " || pos != range.head)
      cat = nextCat;
    pos = next;
  }
  return pos;
});
var deleteGroupBackward = (target) => deleteByGroup(target, false);
var deleteGroupForward = (target) => deleteByGroup(target, true);
var deleteToLineEnd = (view) => deleteBy(view, (range) => {
  let lineEnd = view.lineBlockAt(range.head).to;
  return range.head < lineEnd ? lineEnd : Math.min(view.state.doc.length, range.head + 1);
});
var deleteLineBoundaryBackward = (view) => deleteBy(view, (range) => {
  let lineStart = view.moveToLineBoundary(range, false).head;
  return range.head > lineStart ? lineStart : Math.max(0, range.head - 1);
});
var deleteLineBoundaryForward = (view) => deleteBy(view, (range) => {
  let lineStart = view.moveToLineBoundary(range, true).head;
  return range.head < lineStart ? lineStart : Math.min(view.state.doc.length, range.head + 1);
});
var splitLine = ({ state, dispatch }) => {
  if (state.readOnly)
    return false;
  let changes = state.changeByRange((range) => {
    return {
      changes: { from: range.from, to: range.to, insert: Text2.of(["", ""]) },
      range: EditorSelection.cursor(range.from)
    };
  });
  dispatch(state.update(changes, { scrollIntoView: true, userEvent: "input" }));
  return true;
};
var transposeChars = ({ state, dispatch }) => {
  if (state.readOnly)
    return false;
  let changes = state.changeByRange((range) => {
    if (!range.empty || range.from == 0 || range.from == state.doc.length)
      return { range };
    let pos = range.from, line = state.doc.lineAt(pos);
    let from = pos == line.from ? pos - 1 : findClusterBreak(line.text, pos - line.from, false) + line.from;
    let to = pos == line.to ? pos + 1 : findClusterBreak(line.text, pos - line.from, true) + line.from;
    return {
      changes: { from, to, insert: state.doc.slice(pos, to).append(state.doc.slice(from, pos)) },
      range: EditorSelection.cursor(to)
    };
  });
  if (changes.changes.empty)
    return false;
  dispatch(state.update(changes, { scrollIntoView: true, userEvent: "move.character" }));
  return true;
};
function selectedLineBlocks(state) {
  let blocks = [], upto = -1;
  for (let range of state.selection.ranges) {
    let startLine = state.doc.lineAt(range.from), endLine = state.doc.lineAt(range.to);
    if (!range.empty && range.to == endLine.from)
      endLine = state.doc.lineAt(range.to - 1);
    if (upto >= startLine.number) {
      let prev = blocks[blocks.length - 1];
      prev.to = endLine.to;
      prev.ranges.push(range);
    } else {
      blocks.push({ from: startLine.from, to: endLine.to, ranges: [range] });
    }
    upto = endLine.number + 1;
  }
  return blocks;
}
function moveLine(state, dispatch, forward) {
  if (state.readOnly)
    return false;
  let changes = [], ranges = [];
  for (let block of selectedLineBlocks(state)) {
    if (forward ? block.to == state.doc.length : block.from == 0)
      continue;
    let nextLine = state.doc.lineAt(forward ? block.to + 1 : block.from - 1);
    let size4 = nextLine.length + 1;
    if (forward) {
      changes.push({ from: block.to, to: nextLine.to }, { from: block.from, insert: nextLine.text + state.lineBreak });
      for (let r2 of block.ranges)
        ranges.push(EditorSelection.range(Math.min(state.doc.length, r2.anchor + size4), Math.min(state.doc.length, r2.head + size4)));
    } else {
      changes.push({ from: nextLine.from, to: block.from }, { from: block.to, insert: state.lineBreak + nextLine.text });
      for (let r2 of block.ranges)
        ranges.push(EditorSelection.range(r2.anchor - size4, r2.head - size4));
    }
  }
  if (!changes.length)
    return false;
  dispatch(state.update({
    changes,
    scrollIntoView: true,
    selection: EditorSelection.create(ranges, state.selection.mainIndex),
    userEvent: "move.line"
  }));
  return true;
}
var moveLineUp = ({ state, dispatch }) => moveLine(state, dispatch, false);
var moveLineDown = ({ state, dispatch }) => moveLine(state, dispatch, true);
function copyLine(state, dispatch, forward) {
  if (state.readOnly)
    return false;
  let changes = [];
  for (let block of selectedLineBlocks(state)) {
    if (forward)
      changes.push({ from: block.from, insert: state.doc.slice(block.from, block.to) + state.lineBreak });
    else
      changes.push({ from: block.to, insert: state.lineBreak + state.doc.slice(block.from, block.to) });
  }
  dispatch(state.update({ changes, scrollIntoView: true, userEvent: "input.copyline" }));
  return true;
}
var copyLineUp = ({ state, dispatch }) => copyLine(state, dispatch, false);
var copyLineDown = ({ state, dispatch }) => copyLine(state, dispatch, true);
var deleteLine = (view) => {
  if (view.state.readOnly)
    return false;
  let { state } = view, changes = state.changes(selectedLineBlocks(state).map(({ from, to }) => {
    if (from > 0)
      from--;
    else if (to < state.doc.length)
      to++;
    return { from, to };
  }));
  let selection2 = updateSel(state.selection, (range) => {
    let dist = void 0;
    if (view.lineWrapping) {
      let block = view.lineBlockAt(range.head), pos = view.coordsAtPos(range.head, range.assoc || 1);
      if (pos)
        dist = block.bottom + view.documentTop - pos.bottom + view.defaultLineHeight / 2;
    }
    return view.moveVertically(range, true, dist);
  }).map(changes);
  view.dispatch({ changes, selection: selection2, scrollIntoView: true, userEvent: "delete.line" });
  return true;
};
function isBetweenBrackets(state, pos) {
  if (/\(\)|\[\]|\{\}/.test(state.sliceDoc(pos - 1, pos + 1)))
    return { from: pos, to: pos };
  let context = syntaxTree(state).resolveInner(pos);
  let before = context.childBefore(pos), after = context.childAfter(pos), closedBy;
  if (before && after && before.to <= pos && after.from >= pos && (closedBy = before.type.prop(NodeProp.closedBy)) && closedBy.indexOf(after.name) > -1 && state.doc.lineAt(before.to).from == state.doc.lineAt(after.from).from && !/\S/.test(state.sliceDoc(before.to, after.from)))
    return { from: before.to, to: after.from };
  return null;
}
var insertNewlineAndIndent = newlineAndIndent(false);
var insertBlankLine = newlineAndIndent(true);
function newlineAndIndent(atEof) {
  return ({ state, dispatch }) => {
    if (state.readOnly)
      return false;
    let changes = state.changeByRange((range) => {
      let { from, to } = range, line = state.doc.lineAt(from);
      let explode = !atEof && from == to && isBetweenBrackets(state, from);
      if (atEof)
        from = to = (to <= line.to ? line : state.doc.lineAt(to)).to;
      let cx = new IndentContext(state, { simulateBreak: from, simulateDoubleBreak: !!explode });
      let indent2 = getIndentation(cx, from);
      if (indent2 == null)
        indent2 = countColumn(/^\s*/.exec(state.doc.lineAt(from).text)[0], state.tabSize);
      while (to < line.to && /\s/.test(line.text[to - line.from]))
        to++;
      if (explode)
        ({ from, to } = explode);
      else if (from > line.from && from < line.from + 100 && !/\S/.test(line.text.slice(0, from)))
        from = line.from;
      let insert2 = ["", indentString(state, indent2)];
      if (explode)
        insert2.push(indentString(state, cx.lineIndent(line.from, -1)));
      return {
        changes: { from, to, insert: Text2.of(insert2) },
        range: EditorSelection.cursor(from + 1 + insert2[1].length)
      };
    });
    dispatch(state.update(changes, { scrollIntoView: true, userEvent: "input" }));
    return true;
  };
}
function changeBySelectedLine(state, f3) {
  let atLine = -1;
  return state.changeByRange((range) => {
    let changes = [];
    for (let pos = range.from; pos <= range.to; ) {
      let line = state.doc.lineAt(pos);
      if (line.number > atLine && (range.empty || range.to > line.from)) {
        f3(line, changes, range);
        atLine = line.number;
      }
      pos = line.to + 1;
    }
    let changeSet = state.changes(changes);
    return {
      changes,
      range: EditorSelection.range(changeSet.mapPos(range.anchor, 1), changeSet.mapPos(range.head, 1))
    };
  });
}
var indentSelection = ({ state, dispatch }) => {
  if (state.readOnly)
    return false;
  let updated = /* @__PURE__ */ Object.create(null);
  let context = new IndentContext(state, { overrideIndentation: (start2) => {
    let found = updated[start2];
    return found == null ? -1 : found;
  } });
  let changes = changeBySelectedLine(state, (line, changes2, range) => {
    let indent2 = getIndentation(context, line.from);
    if (indent2 == null)
      return;
    if (!/\S/.test(line.text))
      indent2 = 0;
    let cur = /^\s*/.exec(line.text)[0];
    let norm = indentString(state, indent2);
    if (cur != norm || range.from < line.from + cur.length) {
      updated[line.from] = indent2;
      changes2.push({ from: line.from, to: line.from + cur.length, insert: norm });
    }
  });
  if (!changes.changes.empty)
    dispatch(state.update(changes, { userEvent: "indent" }));
  return true;
};
var indentMore = ({ state, dispatch }) => {
  if (state.readOnly)
    return false;
  dispatch(state.update(changeBySelectedLine(state, (line, changes) => {
    changes.push({ from: line.from, insert: state.facet(indentUnit) });
  }), { userEvent: "input.indent" }));
  return true;
};
var indentLess = ({ state, dispatch }) => {
  if (state.readOnly)
    return false;
  dispatch(state.update(changeBySelectedLine(state, (line, changes) => {
    let space = /^\s*/.exec(line.text)[0];
    if (!space)
      return;
    let col = countColumn(space, state.tabSize), keep = 0;
    let insert2 = indentString(state, Math.max(0, col - getIndentUnit(state)));
    while (keep < space.length && keep < insert2.length && space.charCodeAt(keep) == insert2.charCodeAt(keep))
      keep++;
    changes.push({ from: line.from + keep, to: line.from + space.length, insert: insert2.slice(keep) });
  }), { userEvent: "delete.dedent" }));
  return true;
};
var toggleTabFocusMode = (view) => {
  view.setTabFocusMode();
  return true;
};
var emacsStyleKeymap = [
  { key: "Ctrl-b", run: cursorCharLeft, shift: selectCharLeft, preventDefault: true },
  { key: "Ctrl-f", run: cursorCharRight, shift: selectCharRight },
  { key: "Ctrl-p", run: cursorLineUp, shift: selectLineUp },
  { key: "Ctrl-n", run: cursorLineDown, shift: selectLineDown },
  { key: "Ctrl-a", run: cursorLineStart, shift: selectLineStart },
  { key: "Ctrl-e", run: cursorLineEnd, shift: selectLineEnd },
  { key: "Ctrl-d", run: deleteCharForward },
  { key: "Ctrl-h", run: deleteCharBackward },
  { key: "Ctrl-k", run: deleteToLineEnd },
  { key: "Ctrl-Alt-h", run: deleteGroupBackward },
  { key: "Ctrl-o", run: splitLine },
  { key: "Ctrl-t", run: transposeChars },
  { key: "Ctrl-v", run: cursorPageDown }
];
var standardKeymap = [
  { key: "ArrowLeft", run: cursorCharLeft, shift: selectCharLeft, preventDefault: true },
  { key: "Mod-ArrowLeft", mac: "Alt-ArrowLeft", run: cursorGroupLeft, shift: selectGroupLeft, preventDefault: true },
  { mac: "Cmd-ArrowLeft", run: cursorLineBoundaryLeft, shift: selectLineBoundaryLeft, preventDefault: true },
  { key: "ArrowRight", run: cursorCharRight, shift: selectCharRight, preventDefault: true },
  { key: "Mod-ArrowRight", mac: "Alt-ArrowRight", run: cursorGroupRight, shift: selectGroupRight, preventDefault: true },
  { mac: "Cmd-ArrowRight", run: cursorLineBoundaryRight, shift: selectLineBoundaryRight, preventDefault: true },
  { key: "ArrowUp", run: cursorLineUp, shift: selectLineUp, preventDefault: true },
  { mac: "Cmd-ArrowUp", run: cursorDocStart, shift: selectDocStart },
  { mac: "Ctrl-ArrowUp", run: cursorPageUp, shift: selectPageUp },
  { key: "ArrowDown", run: cursorLineDown, shift: selectLineDown, preventDefault: true },
  { mac: "Cmd-ArrowDown", run: cursorDocEnd, shift: selectDocEnd },
  { mac: "Ctrl-ArrowDown", run: cursorPageDown, shift: selectPageDown },
  { key: "PageUp", run: cursorPageUp, shift: selectPageUp },
  { key: "PageDown", run: cursorPageDown, shift: selectPageDown },
  { key: "Home", run: cursorLineBoundaryBackward, shift: selectLineBoundaryBackward, preventDefault: true },
  { key: "Mod-Home", run: cursorDocStart, shift: selectDocStart },
  { key: "End", run: cursorLineBoundaryForward, shift: selectLineBoundaryForward, preventDefault: true },
  { key: "Mod-End", run: cursorDocEnd, shift: selectDocEnd },
  { key: "Enter", run: insertNewlineAndIndent, shift: insertNewlineAndIndent },
  { key: "Mod-a", run: selectAll },
  { key: "Backspace", run: deleteCharBackward, shift: deleteCharBackward },
  { key: "Delete", run: deleteCharForward },
  { key: "Mod-Backspace", mac: "Alt-Backspace", run: deleteGroupBackward },
  { key: "Mod-Delete", mac: "Alt-Delete", run: deleteGroupForward },
  { mac: "Mod-Backspace", run: deleteLineBoundaryBackward },
  { mac: "Mod-Delete", run: deleteLineBoundaryForward }
].concat(emacsStyleKeymap.map((b3) => ({ mac: b3.key, run: b3.run, shift: b3.shift })));
var defaultKeymap = [
  { key: "Alt-ArrowLeft", mac: "Ctrl-ArrowLeft", run: cursorSyntaxLeft, shift: selectSyntaxLeft },
  { key: "Alt-ArrowRight", mac: "Ctrl-ArrowRight", run: cursorSyntaxRight, shift: selectSyntaxRight },
  { key: "Alt-ArrowUp", run: moveLineUp },
  { key: "Shift-Alt-ArrowUp", run: copyLineUp },
  { key: "Alt-ArrowDown", run: moveLineDown },
  { key: "Shift-Alt-ArrowDown", run: copyLineDown },
  { key: "Escape", run: simplifySelection },
  { key: "Mod-Enter", run: insertBlankLine },
  { key: "Alt-l", mac: "Ctrl-l", run: selectLine },
  { key: "Mod-i", run: selectParentSyntax, preventDefault: true },
  { key: "Mod-[", run: indentLess },
  { key: "Mod-]", run: indentMore },
  { key: "Mod-Alt-\\", run: indentSelection },
  { key: "Shift-Mod-k", run: deleteLine },
  { key: "Shift-Mod-\\", run: cursorMatchingBracket },
  { key: "Mod-/", run: toggleComment },
  { key: "Alt-A", run: toggleBlockComment },
  { key: "Ctrl-m", mac: "Shift-Alt-m", run: toggleTabFocusMode }
].concat(standardKeymap);

// node_modules/intersection-observer/intersection-observer.js
(function() {
  "use strict";
  if (typeof window !== "object") {
    return;
  }
  if ("IntersectionObserver" in window && "IntersectionObserverEntry" in window && "intersectionRatio" in window.IntersectionObserverEntry.prototype) {
    if (!("isIntersecting" in window.IntersectionObserverEntry.prototype)) {
      Object.defineProperty(
        window.IntersectionObserverEntry.prototype,
        "isIntersecting",
        {
          get: function() {
            return this.intersectionRatio > 0;
          }
        }
      );
    }
    return;
  }
  var document4 = window.document;
  var registry = [];
  var crossOriginUpdater = null;
  var crossOriginRect = null;
  function IntersectionObserverEntry(entry) {
    this.time = entry.time;
    this.target = entry.target;
    this.rootBounds = ensureDOMRect(entry.rootBounds);
    this.boundingClientRect = ensureDOMRect(entry.boundingClientRect);
    this.intersectionRect = ensureDOMRect(entry.intersectionRect || getEmptyRect());
    this.isIntersecting = !!entry.intersectionRect;
    var targetRect = this.boundingClientRect;
    var targetArea = targetRect.width * targetRect.height;
    var intersectionRect = this.intersectionRect;
    var intersectionArea = intersectionRect.width * intersectionRect.height;
    if (targetArea) {
      this.intersectionRatio = Number((intersectionArea / targetArea).toFixed(4));
    } else {
      this.intersectionRatio = this.isIntersecting ? 1 : 0;
    }
  }
  function IntersectionObserver2(callback, opt_options) {
    var options = opt_options || {};
    if (typeof callback != "function") {
      throw new Error("callback must be a function");
    }
    if (options.root && options.root.nodeType != 1) {
      throw new Error("root must be an Element");
    }
    this._checkForIntersections = throttle(
      this._checkForIntersections.bind(this),
      this.THROTTLE_TIMEOUT
    );
    this._callback = callback;
    this._observationTargets = [];
    this._queuedEntries = [];
    this._rootMarginValues = this._parseRootMargin(options.rootMargin);
    this.thresholds = this._initThresholds(options.threshold);
    this.root = options.root || null;
    this.rootMargin = this._rootMarginValues.map(function(margin) {
      return margin.value + margin.unit;
    }).join(" ");
    this._monitoringDocuments = [];
    this._monitoringUnsubscribes = [];
  }
  IntersectionObserver2.prototype.THROTTLE_TIMEOUT = 100;
  IntersectionObserver2.prototype.POLL_INTERVAL = null;
  IntersectionObserver2.prototype.USE_MUTATION_OBSERVER = true;
  IntersectionObserver2._setupCrossOriginUpdater = function() {
    if (!crossOriginUpdater) {
      crossOriginUpdater = function(boundingClientRect, intersectionRect) {
        if (!boundingClientRect || !intersectionRect) {
          crossOriginRect = getEmptyRect();
        } else {
          crossOriginRect = convertFromParentRect(boundingClientRect, intersectionRect);
        }
        registry.forEach(function(observer) {
          observer._checkForIntersections();
        });
      };
    }
    return crossOriginUpdater;
  };
  IntersectionObserver2._resetCrossOriginUpdater = function() {
    crossOriginUpdater = null;
    crossOriginRect = null;
  };
  IntersectionObserver2.prototype.observe = function(target) {
    var isTargetAlreadyObserved = this._observationTargets.some(function(item) {
      return item.element == target;
    });
    if (isTargetAlreadyObserved) {
      return;
    }
    if (!(target && target.nodeType == 1)) {
      throw new Error("target must be an Element");
    }
    this._registerInstance();
    this._observationTargets.push({ element: target, entry: null });
    this._monitorIntersections(target.ownerDocument);
    this._checkForIntersections();
  };
  IntersectionObserver2.prototype.unobserve = function(target) {
    this._observationTargets = this._observationTargets.filter(function(item) {
      return item.element != target;
    });
    this._unmonitorIntersections(target.ownerDocument);
    if (this._observationTargets.length == 0) {
      this._unregisterInstance();
    }
  };
  IntersectionObserver2.prototype.disconnect = function() {
    this._observationTargets = [];
    this._unmonitorAllIntersections();
    this._unregisterInstance();
  };
  IntersectionObserver2.prototype.takeRecords = function() {
    var records = this._queuedEntries.slice();
    this._queuedEntries = [];
    return records;
  };
  IntersectionObserver2.prototype._initThresholds = function(opt_threshold) {
    var threshold = opt_threshold || [0];
    if (!Array.isArray(threshold)) threshold = [threshold];
    return threshold.sort().filter(function(t3, i3, a2) {
      if (typeof t3 != "number" || isNaN(t3) || t3 < 0 || t3 > 1) {
        throw new Error("threshold must be a number between 0 and 1 inclusively");
      }
      return t3 !== a2[i3 - 1];
    });
  };
  IntersectionObserver2.prototype._parseRootMargin = function(opt_rootMargin) {
    var marginString = opt_rootMargin || "0px";
    var margins = marginString.split(/\s+/).map(function(margin) {
      var parts = /^(-?\d*\.?\d+)(px|%)$/.exec(margin);
      if (!parts) {
        throw new Error("rootMargin must be specified in pixels or percent");
      }
      return { value: parseFloat(parts[1]), unit: parts[2] };
    });
    margins[1] = margins[1] || margins[0];
    margins[2] = margins[2] || margins[0];
    margins[3] = margins[3] || margins[1];
    return margins;
  };
  IntersectionObserver2.prototype._monitorIntersections = function(doc) {
    var win = doc.defaultView;
    if (!win) {
      return;
    }
    if (this._monitoringDocuments.indexOf(doc) != -1) {
      return;
    }
    var callback = this._checkForIntersections;
    var monitoringInterval = null;
    var domObserver = null;
    if (this.POLL_INTERVAL) {
      monitoringInterval = win.setInterval(callback, this.POLL_INTERVAL);
    } else {
      addEvent(win, "resize", callback, true);
      addEvent(doc, "scroll", callback, true);
      if (this.USE_MUTATION_OBSERVER && "MutationObserver" in win) {
        domObserver = new win.MutationObserver(callback);
        domObserver.observe(doc, {
          attributes: true,
          childList: true,
          characterData: true,
          subtree: true
        });
      }
    }
    this._monitoringDocuments.push(doc);
    this._monitoringUnsubscribes.push(function() {
      var win2 = doc.defaultView;
      if (win2) {
        if (monitoringInterval) {
          win2.clearInterval(monitoringInterval);
        }
        removeEvent(win2, "resize", callback, true);
      }
      removeEvent(doc, "scroll", callback, true);
      if (domObserver) {
        domObserver.disconnect();
      }
    });
    if (doc != (this.root && this.root.ownerDocument || document4)) {
      var frame = getFrameElement2(doc);
      if (frame) {
        this._monitorIntersections(frame.ownerDocument);
      }
    }
  };
  IntersectionObserver2.prototype._unmonitorIntersections = function(doc) {
    var index3 = this._monitoringDocuments.indexOf(doc);
    if (index3 == -1) {
      return;
    }
    var rootDoc = this.root && this.root.ownerDocument || document4;
    var hasDependentTargets = this._observationTargets.some(function(item) {
      var itemDoc = item.element.ownerDocument;
      if (itemDoc == doc) {
        return true;
      }
      while (itemDoc && itemDoc != rootDoc) {
        var frame2 = getFrameElement2(itemDoc);
        itemDoc = frame2 && frame2.ownerDocument;
        if (itemDoc == doc) {
          return true;
        }
      }
      return false;
    });
    if (hasDependentTargets) {
      return;
    }
    var unsubscribe = this._monitoringUnsubscribes[index3];
    this._monitoringDocuments.splice(index3, 1);
    this._monitoringUnsubscribes.splice(index3, 1);
    unsubscribe();
    if (doc != rootDoc) {
      var frame = getFrameElement2(doc);
      if (frame) {
        this._unmonitorIntersections(frame.ownerDocument);
      }
    }
  };
  IntersectionObserver2.prototype._unmonitorAllIntersections = function() {
    var unsubscribes = this._monitoringUnsubscribes.slice(0);
    this._monitoringDocuments.length = 0;
    this._monitoringUnsubscribes.length = 0;
    for (var i3 = 0; i3 < unsubscribes.length; i3++) {
      unsubscribes[i3]();
    }
  };
  IntersectionObserver2.prototype._checkForIntersections = function() {
    if (!this.root && crossOriginUpdater && !crossOriginRect) {
      return;
    }
    var rootIsInDom = this._rootIsInDom();
    var rootRect = rootIsInDom ? this._getRootRect() : getEmptyRect();
    this._observationTargets.forEach(function(item) {
      var target = item.element;
      var targetRect = getBoundingClientRect2(target);
      var rootContainsTarget = this._rootContainsTarget(target);
      var oldEntry = item.entry;
      var intersectionRect = rootIsInDom && rootContainsTarget && this._computeTargetAndRootIntersection(target, targetRect, rootRect);
      var newEntry = item.entry = new IntersectionObserverEntry({
        time: now(),
        target,
        boundingClientRect: targetRect,
        rootBounds: crossOriginUpdater && !this.root ? null : rootRect,
        intersectionRect
      });
      if (!oldEntry) {
        this._queuedEntries.push(newEntry);
      } else if (rootIsInDom && rootContainsTarget) {
        if (this._hasCrossedThreshold(oldEntry, newEntry)) {
          this._queuedEntries.push(newEntry);
        }
      } else {
        if (oldEntry && oldEntry.isIntersecting) {
          this._queuedEntries.push(newEntry);
        }
      }
    }, this);
    if (this._queuedEntries.length) {
      this._callback(this.takeRecords(), this);
    }
  };
  IntersectionObserver2.prototype._computeTargetAndRootIntersection = function(target, targetRect, rootRect) {
    if (window.getComputedStyle(target).display == "none") return;
    var intersectionRect = targetRect;
    var parent = getParentNode2(target);
    var atRoot = false;
    while (!atRoot && parent) {
      var parentRect = null;
      var parentComputedStyle = parent.nodeType == 1 ? window.getComputedStyle(parent) : {};
      if (parentComputedStyle.display == "none") return null;
      if (parent == this.root || parent.nodeType == /* DOCUMENT */
      9) {
        atRoot = true;
        if (parent == this.root || parent == document4) {
          if (crossOriginUpdater && !this.root) {
            if (!crossOriginRect || crossOriginRect.width == 0 && crossOriginRect.height == 0) {
              parent = null;
              parentRect = null;
              intersectionRect = null;
            } else {
              parentRect = crossOriginRect;
            }
          } else {
            parentRect = rootRect;
          }
        } else {
          var frame = getParentNode2(parent);
          var frameRect = frame && getBoundingClientRect2(frame);
          var frameIntersect = frame && this._computeTargetAndRootIntersection(frame, frameRect, rootRect);
          if (frameRect && frameIntersect) {
            parent = frame;
            parentRect = convertFromParentRect(frameRect, frameIntersect);
          } else {
            parent = null;
            intersectionRect = null;
          }
        }
      } else {
        var doc = parent.ownerDocument;
        if (parent != doc.body && parent != doc.documentElement && parentComputedStyle.overflow != "visible") {
          parentRect = getBoundingClientRect2(parent);
        }
      }
      if (parentRect) {
        intersectionRect = computeRectIntersection(parentRect, intersectionRect);
      }
      if (!intersectionRect) break;
      parent = parent && getParentNode2(parent);
    }
    return intersectionRect;
  };
  IntersectionObserver2.prototype._getRootRect = function() {
    var rootRect;
    if (this.root) {
      rootRect = getBoundingClientRect2(this.root);
    } else {
      var html3 = document4.documentElement;
      var body = document4.body;
      rootRect = {
        top: 0,
        left: 0,
        right: html3.clientWidth || body.clientWidth,
        width: html3.clientWidth || body.clientWidth,
        bottom: html3.clientHeight || body.clientHeight,
        height: html3.clientHeight || body.clientHeight
      };
    }
    return this._expandRectByRootMargin(rootRect);
  };
  IntersectionObserver2.prototype._expandRectByRootMargin = function(rect) {
    var margins = this._rootMarginValues.map(function(margin, i3) {
      return margin.unit == "px" ? margin.value : margin.value * (i3 % 2 ? rect.width : rect.height) / 100;
    });
    var newRect = {
      top: rect.top - margins[0],
      right: rect.right + margins[1],
      bottom: rect.bottom + margins[2],
      left: rect.left - margins[3]
    };
    newRect.width = newRect.right - newRect.left;
    newRect.height = newRect.bottom - newRect.top;
    return newRect;
  };
  IntersectionObserver2.prototype._hasCrossedThreshold = function(oldEntry, newEntry) {
    var oldRatio = oldEntry && oldEntry.isIntersecting ? oldEntry.intersectionRatio || 0 : -1;
    var newRatio = newEntry.isIntersecting ? newEntry.intersectionRatio || 0 : -1;
    if (oldRatio === newRatio) return;
    for (var i3 = 0; i3 < this.thresholds.length; i3++) {
      var threshold = this.thresholds[i3];
      if (threshold == oldRatio || threshold == newRatio || threshold < oldRatio !== threshold < newRatio) {
        return true;
      }
    }
  };
  IntersectionObserver2.prototype._rootIsInDom = function() {
    return !this.root || containsDeep(document4, this.root);
  };
  IntersectionObserver2.prototype._rootContainsTarget = function(target) {
    return containsDeep(this.root || document4, target) && (!this.root || this.root.ownerDocument == target.ownerDocument);
  };
  IntersectionObserver2.prototype._registerInstance = function() {
    if (registry.indexOf(this) < 0) {
      registry.push(this);
    }
  };
  IntersectionObserver2.prototype._unregisterInstance = function() {
    var index3 = registry.indexOf(this);
    if (index3 != -1) registry.splice(index3, 1);
  };
  function now() {
    return window.performance && performance.now && performance.now();
  }
  function throttle(fn, timeout) {
    var timer = null;
    return function() {
      if (!timer) {
        timer = setTimeout(function() {
          fn();
          timer = null;
        }, timeout);
      }
    };
  }
  function addEvent(node2, event, fn, opt_useCapture) {
    if (typeof node2.addEventListener == "function") {
      node2.addEventListener(event, fn, opt_useCapture || false);
    } else if (typeof node2.attachEvent == "function") {
      node2.attachEvent("on" + event, fn);
    }
  }
  function removeEvent(node2, event, fn, opt_useCapture) {
    if (typeof node2.removeEventListener == "function") {
      node2.removeEventListener(event, fn, opt_useCapture || false);
    } else if (typeof node2.detatchEvent == "function") {
      node2.detatchEvent("on" + event, fn);
    }
  }
  function computeRectIntersection(rect1, rect2) {
    var top = Math.max(rect1.top, rect2.top);
    var bottom = Math.min(rect1.bottom, rect2.bottom);
    var left = Math.max(rect1.left, rect2.left);
    var right = Math.min(rect1.right, rect2.right);
    var width = right - left;
    var height = bottom - top;
    return width >= 0 && height >= 0 && {
      top,
      bottom,
      left,
      right,
      width,
      height
    } || null;
  }
  function getBoundingClientRect2(el) {
    var rect;
    try {
      rect = el.getBoundingClientRect();
    } catch (err) {
    }
    if (!rect) return getEmptyRect();
    if (!(rect.width && rect.height)) {
      rect = {
        top: rect.top,
        right: rect.right,
        bottom: rect.bottom,
        left: rect.left,
        width: rect.right - rect.left,
        height: rect.bottom - rect.top
      };
    }
    return rect;
  }
  function getEmptyRect() {
    return {
      top: 0,
      bottom: 0,
      left: 0,
      right: 0,
      width: 0,
      height: 0
    };
  }
  function ensureDOMRect(rect) {
    if (!rect || "x" in rect) {
      return rect;
    }
    return {
      top: rect.top,
      y: rect.top,
      bottom: rect.bottom,
      left: rect.left,
      x: rect.left,
      right: rect.right,
      width: rect.width,
      height: rect.height
    };
  }
  function convertFromParentRect(parentBoundingRect, parentIntersectionRect) {
    var top = parentIntersectionRect.top - parentBoundingRect.top;
    var left = parentIntersectionRect.left - parentBoundingRect.left;
    return {
      top,
      left,
      height: parentIntersectionRect.height,
      width: parentIntersectionRect.width,
      bottom: top + parentIntersectionRect.height,
      right: left + parentIntersectionRect.width
    };
  }
  function containsDeep(parent, child) {
    var node2 = child;
    while (node2) {
      if (node2 == parent) return true;
      node2 = getParentNode2(node2);
    }
    return false;
  }
  function getParentNode2(node2) {
    var parent = node2.parentNode;
    if (node2.nodeType == /* DOCUMENT */
    9 && node2 != document4) {
      return getFrameElement2(node2);
    }
    if (parent && parent.nodeType == 11 && parent.host) {
      return parent.host;
    }
    if (parent && parent.assignedSlot) {
      return parent.assignedSlot.parentNode;
    }
    return parent;
  }
  function getFrameElement2(doc) {
    try {
      return doc.defaultView && doc.defaultView.frameElement || null;
    } catch (e2) {
      return null;
    }
  }
  window.IntersectionObserver = IntersectionObserver2;
  window.IntersectionObserverEntry = IntersectionObserverEntry;
})();

// node_modules/@react-hook/intersection-observer/dist/module/index.js
var React42 = __toESM(require_react());

// node_modules/@react-hook/passive-layout-effect/dist/module/index.js
var import_react46 = __toESM(require_react());
var usePassiveLayoutEffect = import_react46.default[typeof document !== "undefined" && document.createElement !== void 0 ? "useLayoutEffect" : "useEffect"];
var module_default = usePassiveLayoutEffect;

// node_modules/@react-hook/intersection-observer/dist/module/index.js
function useIntersectionObserver(target, options = {}) {
  const {
    root: root2 = null,
    pollInterval = null,
    useMutationObserver = false,
    rootMargin = "0px 0px 0px 0px",
    threshold = 0,
    initialIsIntersecting = false
  } = options;
  const [entry, setEntry] = React42.useState(() => ({
    boundingClientRect: null,
    intersectionRatio: 0,
    intersectionRect: null,
    isIntersecting: initialIsIntersecting,
    rootBounds: null,
    target: null,
    time: 0
  }));
  const [observer, setObserver] = React42.useState(() => getIntersectionObserver({
    root: root2,
    pollInterval,
    useMutationObserver,
    rootMargin,
    threshold
  }));
  React42.useEffect(() => {
    const observer2 = getIntersectionObserver({
      root: root2,
      pollInterval,
      useMutationObserver,
      rootMargin,
      threshold
    });
    setObserver(observer2);
  }, [root2, rootMargin, pollInterval, useMutationObserver, JSON.stringify(threshold)]);
  module_default(() => {
    const targetEl = target && "current" in target ? target.current : target;
    if (!observer || !targetEl) return;
    let didUnsubscribe = false;
    observer.observer.observe(targetEl);
    const callback = (entries2) => {
      if (didUnsubscribe) return;
      for (let i3 = 0; i3 < entries2.length; i3++) {
        const entry2 = entries2[i3];
        if (entry2.target === targetEl) {
          setEntry(entry2);
        }
      }
    };
    observer.subscribe(callback);
    return () => {
      didUnsubscribe = true;
      observer.observer.unobserve(targetEl);
      observer.unsubscribe(callback);
    };
  }, [target, observer]);
  return entry;
}
function createIntersectionObserver({
  root: root2 = null,
  pollInterval = null,
  useMutationObserver = false,
  rootMargin = "0px 0px 0px 0px",
  threshold = 0
}) {
  const callbacks = /* @__PURE__ */ new Set();
  if (typeof IntersectionObserver === "undefined") return null;
  const observer = new IntersectionObserver((entries2) => {
    for (const callback of callbacks) callback(entries2, observer);
  }, {
    root: root2,
    rootMargin,
    threshold
  });
  observer.POLL_INTERVAL = pollInterval;
  observer.USE_MUTATION_OBSERVER = useMutationObserver;
  return {
    observer,
    getListeners() {
      return callbacks;
    },
    subscribe: (callback) => callbacks.add(callback),
    unsubscribe: (callback) => callbacks.delete(callback)
  };
}
var _intersectionObserver = /* @__PURE__ */ new Map();
function getIntersectionObserver(options) {
  const {
    root: root2,
    ...keys
  } = options;
  const key2 = JSON.stringify(keys);
  let base = _intersectionObserver.get(root2);
  if (!base) {
    base = {};
    _intersectionObserver.set(root2, base);
  }
  return !base[key2] ? base[key2] = createIntersectionObserver(options) : base[key2];
}
var module_default2 = useIntersectionObserver;

// node_modules/@codesandbox/sandpack-react/dist/index.mjs
var import_anser = __toESM(require_lib(), 1);
var import_escape_carriage = __toESM(require_escape_carriage(), 1);
var import_lz_string = __toESM(require_lz_string(), 1);
var __assign2 = function() {
  __assign2 = Object.assign || function __assign3(t3) {
    for (var s2, i3 = 1, n3 = arguments.length; i3 < n3; i3++) {
      s2 = arguments[i3];
      for (var p2 in s2) if (Object.prototype.hasOwnProperty.call(s2, p2)) t3[p2] = s2[p2];
    }
    return t3;
  };
  return __assign2.apply(this, arguments);
};
function __rest2(s2, e2) {
  var t3 = {};
  for (var p2 in s2) if (Object.prototype.hasOwnProperty.call(s2, p2) && e2.indexOf(p2) < 0)
    t3[p2] = s2[p2];
  if (s2 != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i3 = 0, p2 = Object.getOwnPropertySymbols(s2); i3 < p2.length; i3++) {
      if (e2.indexOf(p2[i3]) < 0 && Object.prototype.propertyIsEnumerable.call(s2, p2[i3]))
        t3[p2[i3]] = s2[p2[i3]];
    }
  return t3;
}
function __awaiter2(thisArg, _arguments, P3, generator) {
  function adopt(value2) {
    return value2 instanceof P3 ? value2 : new P3(function(resolve) {
      resolve(value2);
    });
  }
  return new (P3 || (P3 = Promise))(function(resolve, reject) {
    function fulfilled(value2) {
      try {
        step(generator.next(value2));
      } catch (e2) {
        reject(e2);
      }
    }
    function rejected(value2) {
      try {
        step(generator["throw"](value2));
      } catch (e2) {
        reject(e2);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
}
function __generator2(thisArg, body) {
  var _2 = { label: 0, sent: function() {
    if (t3[0] & 1) throw t3[1];
    return t3[1];
  }, trys: [], ops: [] }, f3, y2, t3, g3;
  return g3 = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g3[Symbol.iterator] = function() {
    return this;
  }), g3;
  function verb(n3) {
    return function(v3) {
      return step([n3, v3]);
    };
  }
  function step(op) {
    if (f3) throw new TypeError("Generator is already executing.");
    while (_2) try {
      if (f3 = 1, y2 && (t3 = op[0] & 2 ? y2["return"] : op[0] ? y2["throw"] || ((t3 = y2["return"]) && t3.call(y2), 0) : y2.next) && !(t3 = t3.call(y2, op[1])).done) return t3;
      if (y2 = 0, t3) op = [op[0] & 2, t3.value];
      switch (op[0]) {
        case 0:
        case 1:
          t3 = op;
          break;
        case 4:
          _2.label++;
          return { value: op[1], done: false };
        case 5:
          _2.label++;
          y2 = op[1];
          op = [0];
          continue;
        case 7:
          op = _2.ops.pop();
          _2.trys.pop();
          continue;
        default:
          if (!(t3 = _2.trys, t3 = t3.length > 0 && t3[t3.length - 1]) && (op[0] === 6 || op[0] === 2)) {
            _2 = 0;
            continue;
          }
          if (op[0] === 3 && (!t3 || op[1] > t3[0] && op[1] < t3[3])) {
            _2.label = op[1];
            break;
          }
          if (op[0] === 6 && _2.label < t3[1]) {
            _2.label = t3[1];
            t3 = op;
            break;
          }
          if (t3 && _2.label < t3[2]) {
            _2.label = t3[2];
            _2.ops.push(op);
            break;
          }
          if (t3[2]) _2.ops.pop();
          _2.trys.pop();
          continue;
      }
      op = body.call(thisArg, _2);
    } catch (e2) {
      op = [6, e2];
      y2 = 0;
    } finally {
      f3 = t3 = 0;
    }
    if (op[0] & 5) throw op[1];
    return { value: op[0] ? op[1] : void 0, done: true };
  }
}
function __spreadArray2(to, from, pack) {
  if (pack || arguments.length === 2) for (var i3 = 0, l3 = from.length, ar; i3 < l3; i3++) {
    if (ar || !(i3 in from)) {
      if (!ar) ar = Array.prototype.slice.call(from, 0, i3);
      ar[i3] = from[i3];
    }
  }
  return to.concat(ar || Array.prototype.slice.call(from));
}
var SVG = function(props) {
  return (0, import_jsx_runtime24.jsx)("svg", __assign2({ fill: "currentColor", height: "16", viewBox: "0 0 16 16", width: "16", xmlns: "http://www.w3.org/2000/svg" }, props));
};
var SignInIcon = function() {
  return (0, import_jsx_runtime24.jsxs)(SVG, { viewBox: "0 0 48 48", children: [(0, import_jsx_runtime24.jsx)("title", { children: "Sign in" }), (0, import_jsx_runtime24.jsx)("path", { d: "M9 42q-1.2 0-2.1-.9Q6 40.2 6 39V9q0-1.2.9-2.1Q7.8 6 9 6h14.55v3H9v30h14.55v3Zm24.3-9.25-2.15-2.15 5.1-5.1h-17.5v-3h17.4l-5.1-5.1 2.15-2.15 8.8 8.8Z" })] });
};
var SignOutIcon = function() {
  return (0, import_jsx_runtime24.jsxs)(SVG, { viewBox: "0 0 48 48", children: [(0, import_jsx_runtime24.jsx)("title", { children: "Sign out" }), (0, import_jsx_runtime24.jsx)("path", { d: "M9 42q-1.2 0-2.1-.9Q6 40.2 6 39V9q0-1.2.9-2.1Q7.8 6 9 6h14.55v3H9v30h14.55v3Zm24.3-9.25-2.15-2.15 5.1-5.1h-17.5v-3h17.4l-5.1-5.1 2.15-2.15 8.8 8.8Z" })] });
};
var RestartIcon = function() {
  return (0, import_jsx_runtime24.jsxs)(SVG, { fill: "none", stroke: "currentColor", children: [(0, import_jsx_runtime24.jsx)("title", { children: "Restart script" }), (0, import_jsx_runtime24.jsx)("path", { d: "M8 2C4.68629 2 2 4.68629 2 8C2 10.0946 3.07333 11.9385 4.7 13.0118", strokeLinecap: "round" }), (0, import_jsx_runtime24.jsx)("path", { d: "M14.0005 7.9998C14.0005 5.82095 12.8391 3.91335 11.1016 2.8623", strokeLinecap: "round" }), (0, import_jsx_runtime24.jsx)("path", { d: "M14.0003 2.3335H11.167C10.8908 2.3335 10.667 2.55735 10.667 2.8335V5.66683", strokeLinecap: "round" }), (0, import_jsx_runtime24.jsx)("path", { d: "M1.99967 13.6665L4.83301 13.6665C5.10915 13.6665 5.33301 13.4426 5.33301 13.1665L5.33301 10.3332", strokeLinecap: "round" }), (0, import_jsx_runtime24.jsx)("path", { d: "M10 10L12 12L10 14", strokeLinecap: "round", strokeLinejoin: "round" }), (0, import_jsx_runtime24.jsx)("path", { d: "M14.667 14L12.667 14", strokeLinecap: "round", strokeLinejoin: "round" })] });
};
var RunIcon = function() {
  return (0, import_jsx_runtime24.jsxs)(SVG, { children: [(0, import_jsx_runtime24.jsx)("title", { children: "Run sandbox" }), (0, import_jsx_runtime24.jsx)("path", { d: "M11.0792 8.1078C11.2793 8.25007 11.27 8.55012 11.0616 8.67981L6.02535 11.8135C5.79638 11.956 5.5 11.7913 5.5 11.5216L5.5 8.40703L5.5 4.80661C5.5 4.52735 5.81537 4.36463 6.04296 4.52647L11.0792 8.1078Z" })] });
};
var BackwardIcon = function() {
  return (0, import_jsx_runtime24.jsxs)(SVG, { children: [(0, import_jsx_runtime24.jsx)("title", { children: "Click to go back" }), (0, import_jsx_runtime24.jsx)("path", { d: "M9.64645 12.3536C9.84171 12.5488 10.1583 12.5488 10.3536 12.3536C10.5488 12.1583 10.5488 11.8417 10.3536 11.6464L9.64645 12.3536ZM10.3536 4.35355C10.5488 4.15829 10.5488 3.84171 10.3536 3.64644C10.1583 3.45118 9.84171 3.45118 9.64645 3.64644L10.3536 4.35355ZM6.07072 7.92929L5.71716 7.57573L6.07072 7.92929ZM10.3536 11.6464L6.42427 7.71716L5.71716 8.42426L9.64645 12.3536L10.3536 11.6464ZM6.42427 8.28284L10.3536 4.35355L9.64645 3.64644L5.71716 7.57573L6.42427 8.28284ZM6.42427 7.71716C6.58048 7.87337 6.58048 8.12663 6.42427 8.28284L5.71716 7.57573C5.48285 7.81005 5.48285 8.18995 5.71716 8.42426L6.42427 7.71716Z" })] });
};
var ForwardIcon = function() {
  return (0, import_jsx_runtime24.jsxs)(SVG, { children: [(0, import_jsx_runtime24.jsx)("title", { children: "Click to go forward" }), (0, import_jsx_runtime24.jsx)("path", { d: "M6.35355 3.64645C6.15829 3.45118 5.84171 3.45118 5.64645 3.64645C5.45118 3.84171 5.45118 4.15829 5.64645 4.35355L6.35355 3.64645ZM5.64645 11.6464C5.45118 11.8417 5.45118 12.1583 5.64645 12.3536C5.84171 12.5488 6.15829 12.5488 6.35355 12.3536L5.64645 11.6464ZM9.92929 8.07071L10.2828 8.42426L9.92929 8.07071ZM5.64645 4.35355L9.57574 8.28284L10.2828 7.57574L6.35355 3.64645L5.64645 4.35355ZM9.57574 7.71716L5.64645 11.6464L6.35355 12.3536L10.2828 8.42426L9.57574 7.71716ZM9.57574 8.28284C9.41952 8.12663 9.41953 7.87337 9.57574 7.71716L10.2828 8.42426C10.5172 8.18995 10.5172 7.81005 10.2828 7.57574L9.57574 8.28284Z" })] });
};
var RefreshIcon = function() {
  return (0, import_jsx_runtime24.jsxs)(SVG, { children: [(0, import_jsx_runtime24.jsx)("title", { children: "Refresh preview" }), (0, import_jsx_runtime24.jsx)("path", { clipRule: "evenodd", d: "M3.83325 7.99992C3.83325 5.69867 5.69853 3.83325 7.99934 3.83325C9.81246 3.83325 11.3563 4.99195 11.9285 6.61097C11.9396 6.6425 11.9536 6.67221 11.97 6.69992H8.80005C8.52391 6.69992 8.30005 6.92378 8.30005 7.19992C8.30005 7.47606 8.52391 7.69992 8.80005 7.69992H12.5667C12.8981 7.69992 13.1667 7.43129 13.1667 7.09992V3.33325C13.1667 3.05711 12.9429 2.83325 12.6667 2.83325C12.3906 2.83325 12.1667 3.05711 12.1667 3.33325V4.94608C11.2268 3.66522 9.7106 2.83325 7.99934 2.83325C5.14613 2.83325 2.83325 5.14651 2.83325 7.99992C2.83325 10.8533 5.14613 13.1666 7.99934 13.1666C9.91218 13.1666 11.5815 12.1266 12.474 10.5836C12.6123 10.3446 12.5306 10.0387 12.2915 9.90044C12.0525 9.76218 11.7466 9.84387 11.6084 10.0829C10.8873 11.3296 9.54072 12.1666 7.99934 12.1666C5.69853 12.1666 3.83325 10.3012 3.83325 7.99992Z", fillRule: "evenodd" })] });
};
var CleanIcon = function() {
  return (0, import_jsx_runtime24.jsxs)(SVG, { fill: "none", stroke: "currentColor", children: [(0, import_jsx_runtime24.jsx)("title", { children: "Clean" }), (0, import_jsx_runtime24.jsx)("circle", { cx: "7.99998", cy: "8.00004", r: "4.66667", strokeLinecap: "round" }), (0, import_jsx_runtime24.jsx)("path", { d: "M4.66669 4.66663L11.3334 11.3333" })] });
};
var ExportIcon = function() {
  return (0, import_jsx_runtime24.jsxs)(SVG, { fill: "none", stroke: "currentColor", children: [(0, import_jsx_runtime24.jsx)("title", { children: "Open on CodeSandbox" }), (0, import_jsx_runtime24.jsx)("path", { d: "M6.66665 3.33337H4.33331C3.78103 3.33337 3.33331 3.78109 3.33331 4.33337V11.6667C3.33331 12.219 3.78103 12.6667 4.33331 12.6667H11.6666C12.2189 12.6667 12.6666 12.219 12.6666 11.6667V9.33337", strokeLinecap: "round" }), (0, import_jsx_runtime24.jsx)("path", { d: "M10 3.33337H12.5667C12.6219 3.33337 12.6667 3.37815 12.6667 3.43337V6.00004", strokeLinecap: "round" }), (0, import_jsx_runtime24.jsx)("path", { d: "M7.33331 8.66668L12.5333 3.46667", strokeLinecap: "round" })] });
};
var CloseIcon = function() {
  return (0, import_jsx_runtime24.jsxs)(SVG, { stroke: "currentColor", children: [(0, import_jsx_runtime24.jsx)("title", { children: "Close file" }), (0, import_jsx_runtime24.jsx)("path", { d: "M12 4L4 12", strokeLinecap: "round" }), (0, import_jsx_runtime24.jsx)("path", { d: "M4 4L12 12", strokeLinecap: "round" })] });
};
var ConsoleIcon = function() {
  return (0, import_jsx_runtime24.jsxs)(SVG, { children: [(0, import_jsx_runtime24.jsx)("title", { children: "Open browser console" }), (0, import_jsx_runtime24.jsx)("path", { d: "M5.65871 3.62037C5.44905 3.44066 5.1334 3.46494 4.95368 3.6746C4.77397 3.88427 4.79825 4.19992 5.00792 4.37963L5.65871 3.62037ZM5.00792 11.6204C4.79825 11.8001 4.77397 12.1157 4.95368 12.3254C5.1334 12.5351 5.44905 12.5593 5.65871 12.3796L5.00792 11.6204ZM9.9114 7.92407L10.2368 7.54445L9.9114 7.92407ZM5.00792 4.37963L9.586 8.3037L10.2368 7.54445L5.65871 3.62037L5.00792 4.37963ZM9.586 7.6963L5.00792 11.6204L5.65871 12.3796L10.2368 8.45555L9.586 7.6963ZM9.586 8.3037C9.39976 8.14407 9.39976 7.85594 9.586 7.6963L10.2368 8.45555C10.5162 8.2161 10.5162 7.7839 10.2368 7.54445L9.586 8.3037Z" }), (0, import_jsx_runtime24.jsx)("path", { d: "M10 11.5C9.72386 11.5 9.5 11.7239 9.5 12C9.5 12.2761 9.72386 12.5 10 12.5V11.5ZM14.6667 12.5C14.9428 12.5 15.1667 12.2761 15.1667 12C15.1667 11.7239 14.9428 11.5 14.6667 11.5V12.5ZM10 12.5H14.6667V11.5H10V12.5Z" })] });
};
var _a$a;
var defaultLight = {
  colors: {
    surface1: "#ffffff",
    surface2: "#EFEFEF",
    surface3: "#F3F3F3",
    disabled: "#C5C5C5",
    base: "#323232",
    clickable: "#808080",
    hover: "#4D4D4D",
    accent: "#3973E0",
    error: "#EA3323",
    errorSurface: "#FCF1F0",
    warning: "#6A4516",
    warningSurface: "#FEF2C0"
  },
  syntax: {
    plain: "#151515",
    comment: { color: "#999", fontStyle: "italic" },
    keyword: "#7C5AE3",
    tag: "#0971F1",
    punctuation: "#3B3B3B",
    definition: "#85A600",
    property: "#3B3B3B",
    static: "#3B3B3B",
    string: "#2E6BD0"
  },
  font: {
    body: '-apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif, "Apple Color Emoji", "Segoe UI Emoji", "Segoe UI Symbol"',
    mono: '"Fira Mono", "DejaVu Sans Mono", Menlo, Consolas, "Liberation Mono", Monaco, "Lucida Console", monospace',
    size: "13px",
    lineHeight: "20px"
  }
};
var defaultDark = {
  colors: {
    surface1: "#151515",
    surface2: "#252525",
    surface3: "#2F2F2F",
    disabled: "#4D4D4D",
    base: "#808080",
    clickable: "#999999",
    hover: "#C5C5C5",
    accent: "#E5E5E5",
    error: "#FFB4A6",
    errorSurface: "#690000",
    warning: "#E7C400",
    warningSurface: "#3A3000"
  },
  syntax: {
    plain: "#FFFFFF",
    comment: { color: "#757575", fontStyle: "italic" },
    keyword: "#77B7D7",
    tag: "#DFAB5C",
    punctuation: "#ffffff",
    definition: "#86D9CA",
    property: "#77B7D7",
    static: "#C64640",
    string: "#977CDC"
  },
  font: {
    body: '-apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif, "Apple Color Emoji", "Segoe UI Emoji", "Segoe UI Symbol"',
    mono: '"Fira Mono", "DejaVu Sans Mono", Menlo, Consolas, "Liberation Mono", Monaco, "Lucida Console", monospace',
    size: "13px",
    lineHeight: "20px"
  }
};
var SANDPACK_THEMES = {
  light: defaultLight,
  dark: defaultDark,
  auto: typeof window !== "undefined" ? ((_a$a = window === null || window === void 0 ? void 0 : window.matchMedia) === null || _a$a === void 0 ? void 0 : _a$a.call(window, "(prefers-color-scheme: dark)").matches) ? defaultDark : defaultLight : defaultLight
};
var getFileName = function(filePath) {
  var lastIndexOfSlash = filePath.lastIndexOf("/");
  return filePath.slice(lastIndexOfSlash + 1);
};
var calculateNearestUniquePath = function(currentPath, otherPaths) {
  var currentPathParts = (currentPath[0] === "/" ? currentPath.slice(1) : currentPath).split("/");
  var resultPathParts = [];
  if (currentPathParts.length === 1) {
    resultPathParts.unshift(currentPathParts[0]);
  } else {
    for (var fileIndex = 0; fileIndex < otherPaths.length; fileIndex++) {
      var otherPathParts = otherPaths[fileIndex].split("/");
      for (var partsFromEnd = 1; partsFromEnd <= currentPathParts.length; partsFromEnd++) {
        var currentPathPart = currentPathParts[currentPathParts.length - partsFromEnd];
        var otherPathPart = otherPathParts[otherPathParts.length - partsFromEnd];
        if (resultPathParts.length < partsFromEnd) {
          resultPathParts.unshift(currentPathPart);
        }
        if (currentPathPart !== otherPathPart) {
          break;
        }
      }
    }
  }
  if (resultPathParts.length < currentPathParts.length) {
    resultPathParts.unshift("..");
  }
  return resultPathParts.join("/");
};
var isDarkColor = function(color4) {
  var r2 = 0;
  var g3 = 0;
  var b3 = 0;
  if (color4.startsWith("#")) {
    if (color4.length < 7) {
      return true;
    }
    r2 = parseInt(color4.substr(1, 2), 16);
    g3 = parseInt(color4.substr(3, 2), 16);
    b3 = parseInt(color4.substr(5, 2), 16);
  } else {
    var rgbValues = color4.replace("rgb(", "").replace("rgba(", "").replace(")", "").split(",");
    if (rgbValues.length < 3) {
      return true;
    }
    r2 = parseInt(rgbValues[0], 10);
    g3 = parseInt(rgbValues[1], 10);
    b3 = parseInt(rgbValues[2], 10);
  }
  var yiq = (r2 * 299 + g3 * 587 + b3 * 114) / 1e3;
  return yiq < 128;
};
var lastCount = 0;
var generateRandomId = function() {
  var random = +(Date.now().toString(10).substr(0, 4) + lastCount++);
  return random.toString(16);
};
var _a$9;
var THEME_PREFIX = "sp";
var createTheme = (_a$9 = X2({
  prefix: THEME_PREFIX
}), _a$9.createTheme);
var css2 = _a$9.css;
var getCssText = _a$9.getCssText;
var keyframes = _a$9.keyframes;
var defaultVariables = {
  space: new Array(11).fill(" ").reduce(function(acc, _2, index3) {
    var _a2;
    return __assign2(__assign2({}, acc), (_a2 = {}, _a2[index3 + 1] = "".concat((index3 + 1) * 4, "px"), _a2));
  }, {}),
  border: { radius: "4px" },
  layout: { height: "300px", headerHeight: "40px" },
  transitions: { default: "150ms ease" },
  zIndices: {
    base: "1",
    overlay: "2",
    top: "3"
  }
};
var standardizeStitchesTheme = function(theme) {
  var syntaxEntries = Object.entries(theme.syntax);
  var syntax = syntaxEntries.reduce(function(tokenAcc, _a2) {
    var _b2;
    var tokenName = _a2[0], tokenValue = _a2[1];
    var newValues = (_b2 = {}, _b2["color-".concat(tokenName)] = tokenValue, _b2);
    if (typeof tokenValue === "object") {
      newValues = Object.entries(tokenValue).reduce(function(valueAcc, _a3) {
        var _b3;
        var styleProp = _a3[0], styleValue = _a3[1];
        return __assign2(__assign2({}, valueAcc), (_b3 = {}, _b3["".concat(styleProp, "-").concat(tokenName)] = styleValue, _b3));
      }, {});
    }
    return __assign2(__assign2({}, tokenAcc), newValues);
  }, {});
  return __assign2(__assign2({}, defaultVariables), { colors: theme.colors, font: theme.font, syntax });
};
var standardizeTheme = function(inputTheme) {
  var _a2, _b2, _c2, _d, _e;
  if (inputTheme === void 0) {
    inputTheme = "light";
  }
  var defaultLightThemeKey = "default";
  if (typeof inputTheme === "string") {
    var predefinedTheme = SANDPACK_THEMES[inputTheme];
    if (!predefinedTheme) {
      throw new Error("[sandpack-react]: invalid theme '".concat(inputTheme, "' provided."));
    }
    return {
      theme: predefinedTheme,
      id: inputTheme,
      mode: isDarkColor(predefinedTheme.colors.surface1) ? "dark" : "light"
    };
  }
  var mode = isDarkColor((_b2 = (_a2 = inputTheme === null || inputTheme === void 0 ? void 0 : inputTheme.colors) === null || _a2 === void 0 ? void 0 : _a2.surface1) !== null && _b2 !== void 0 ? _b2 : defaultLight.colors.surface1) ? "dark" : "light";
  var baseTheme4 = mode === "dark" ? defaultDark : defaultLight;
  var colorsByMode = __assign2(__assign2({}, baseTheme4.colors), (_c2 = inputTheme === null || inputTheme === void 0 ? void 0 : inputTheme.colors) !== null && _c2 !== void 0 ? _c2 : {});
  var syntaxByMode = __assign2(__assign2({}, baseTheme4.syntax), (_d = inputTheme === null || inputTheme === void 0 ? void 0 : inputTheme.syntax) !== null && _d !== void 0 ? _d : {});
  var fontByMode = __assign2(__assign2({}, baseTheme4.font), (_e = inputTheme === null || inputTheme === void 0 ? void 0 : inputTheme.font) !== null && _e !== void 0 ? _e : {});
  var theme = {
    colors: colorsByMode,
    syntax: syntaxByMode,
    font: fontByMode
  };
  var id = inputTheme ? simpleHashFunction(JSON.stringify(theme)) : defaultLightThemeKey;
  return {
    theme,
    id: "sp-".concat(id),
    mode
  };
};
var simpleHashFunction = function(str2) {
  var hash = 0;
  for (var i3 = 0; i3 < str2.length; hash &= hash) {
    hash = 31 * hash + str2.charCodeAt(i3++);
  }
  return Math.abs(hash);
};
var fakeCss = function() {
  return "";
};
fakeCss.toString = fakeCss;
var ClassNamesContext = (0, import_react47.createContext)({});
var ClassNamesProvider = function(_a2) {
  var children = _a2.children, classes = _a2.classes;
  return (0, import_jsx_runtime24.jsx)(ClassNamesContext.Provider, { value: classes || {}, children });
};
var useClassNames = function() {
  var contextClassNames = (0, import_react47.useContext)(ClassNamesContext);
  return function sandpackClassNames(customClassName, allClassNames) {
    if (allClassNames === void 0) {
      allClassNames = [];
    }
    var custom = "".concat(THEME_PREFIX, "-").concat(customClassName);
    return joinClassNames.apply(void 0, __spreadArray2(__spreadArray2([], allClassNames, false), [custom, contextClassNames[custom]], false));
  };
};
var joinClassNames = function() {
  var args = [];
  for (var _i = 0; _i < arguments.length; _i++) {
    args[_i] = arguments[_i];
  }
  return args.filter(Boolean).join(" ");
};
var wrapperClassName$3 = css2({
  all: "initial",
  fontSize: "$font$size",
  fontFamily: "$font$body",
  display: "block",
  boxSizing: "border-box",
  textRendering: "optimizeLegibility",
  WebkitTapHighlightColor: "transparent",
  WebkitFontSmoothing: "subpixel-antialiased",
  variants: {
    variant: {
      dark: { colorScheme: "dark" },
      light: { colorScheme: "light" }
    }
  },
  "@media screen and (min-resolution: 2dppx)": {
    WebkitFontSmoothing: "antialiased",
    MozOsxFontSmoothing: "grayscale"
  },
  "*": { boxSizing: "border-box" },
  ".sp-wrapper:focus": { outline: "0" }
});
var SandpackThemeContext = React43.createContext({
  theme: defaultLight,
  id: "light",
  mode: "light"
});
var SandpackThemeProvider = function(_a2) {
  var themeFromProps = _a2.theme, children = _a2.children, className = _a2.className, props = __rest2(_a2, ["theme", "children", "className"]);
  var _b2 = React43.useState(themeFromProps), prefferedTheme = _b2[0], setPreferredTheme = _b2[1];
  var _c2 = standardizeTheme(prefferedTheme), theme = _c2.theme, id = _c2.id, mode = _c2.mode;
  var classNames14 = useClassNames();
  var themeClassName = React43.useMemo(function() {
    return createTheme(id, standardizeStitchesTheme(theme));
  }, [theme, id]);
  React43.useEffect(function() {
    if (themeFromProps !== "auto") {
      setPreferredTheme(themeFromProps);
      return;
    }
    var colorSchemeChange = function(_a3) {
      var matches = _a3.matches;
      setPreferredTheme(matches ? "dark" : "light");
    };
    window.matchMedia("(prefers-color-scheme: dark)").addEventListener("change", colorSchemeChange);
    return function() {
      window.matchMedia("(prefers-color-scheme: dark)").removeEventListener("change", colorSchemeChange);
    };
  }, [themeFromProps]);
  return (0, import_jsx_runtime24.jsx)(SandpackThemeContext.Provider, { value: { theme, id, mode }, children: (0, import_jsx_runtime24.jsx)("div", __assign2({ className: classNames14("wrapper", [
    themeClassName,
    wrapperClassName$3({ variant: mode }),
    className
  ]) }, props, { children })) });
};
var SandpackThemeConsumer = SandpackThemeContext.Consumer;
var commonFiles = {
  "/styles.css": {
    code: "body {\n  font-family: sans-serif;\n  -webkit-font-smoothing: auto;\n  -moz-font-smoothing: auto;\n  -moz-osx-font-smoothing: grayscale;\n  font-smoothing: auto;\n  text-rendering: optimizeLegibility;\n  font-smooth: always;\n  -webkit-tap-highlight-color: transparent;\n  -webkit-touch-callout: none;\n}\n\nh1 {\n  font-size: 1.5rem;\n}"
  }
};
var ASTRO_TEMPLATE = {
  files: {
    "/src/styles.css": commonFiles["/styles.css"],
    "/src/pages/index.astro": {
      code: '---\nimport "../styles.css";\nconst data = "world";\n---\n\n<h1>Hello {data}</h1>\n\n<style>\n  h1 {\n    font-size: 1.5rem;\n  }\n</style>'
    },
    ".env": {
      code: 'ASTRO_TELEMETRY_DISABLED="1"'
    },
    "/package.json": {
      code: JSON.stringify({
        dependencies: {
          astro: "^1.6.12",
          "esbuild-wasm": "^0.15.16"
        },
        scripts: {
          dev: "astro dev",
          start: "astro dev",
          build: "astro build",
          preview: "astro preview",
          astro: "astro"
        }
      })
    }
  },
  main: "/src/pages/index.astro",
  environment: "node"
};
var NEXTJS_TEMPLATE = {
  files: __assign2(__assign2({}, commonFiles), { "/pages/_app.js": {
    code: "import '../styles.css'\n\nexport default function MyApp({ Component, pageProps }) {\n  return <Component {...pageProps} />\n}"
  }, "/pages/index.js": {
    code: 'export default function Home({ data }) {\n  return (\n    <div>\n      <h1>Hello {data}</h1>\n    </div>\n  );\n}\n  \nexport function getServerSideProps() {\n  return {\n    props: { data: "world" },\n  }\n}\n'
  }, "/next.config.js": {
    code: "/** @type {import('next').NextConfig} */\nconst nextConfig = {\n  reactStrictMode: true,\n  swcMinify: true,\n}\n\nmodule.exports = nextConfig\n"
  }, "/package.json": {
    code: JSON.stringify({
      name: "my-app",
      version: "0.1.0",
      private: true,
      scripts: {
        dev: "NEXT_TELEMETRY_DISABLED=1 next dev",
        build: "next build",
        start: "next start",
        lint: "next lint"
      },
      dependencies: {
        next: "12.1.6",
        react: "18.2.0",
        "react-dom": "18.2.0",
        "@next/swc-wasm-nodejs": "12.1.6"
      }
    })
  } }),
  main: "/pages/index.js",
  environment: "node"
};
var NODE_TEMPLATE = {
  files: {
    "/index.js": {
      code: "const http = require('http');\n\nconst hostname = '127.0.0.1';\nconst port = 3000;\n\nconst server = http.createServer((req, res) => {\n  res.statusCode = 200;\n  res.setHeader('Content-Type', 'text/html');\n  res.end('Hello world');\n});\n\nserver.listen(port, hostname, () => {\n  console.log(`Server running at http://${hostname}:${port}/`);\n});"
    },
    "/package.json": {
      code: JSON.stringify({
        dependencies: {},
        scripts: { start: "node index.js" },
        main: "index.js"
      })
    }
  },
  main: "/index.js",
  environment: "node"
};
var VITE_TEMPLATE = {
  files: __assign2(__assign2({}, commonFiles), { "/index.js": {
    code: 'import "./styles.css";\n\ndocument.getElementById("app").innerHTML = `\n<h1>Hello world</h1>\n`;\n'
  }, "/index.html": {
    code: '<!DOCTYPE html>\n<html lang="en">\n  <head>\n    <meta charset="UTF-8" />\n    <meta name="viewport" content="width=device-width, initial-scale=1.0" />\n    <title>Vite App</title>\n  </head>\n  <body>\n    <div id="app"></div>\n    <script type="module" src="/index.js"><\/script>\n  </body>\n</html>\n'
  }, "/package.json": {
    code: JSON.stringify({
      scripts: {
        dev: "vite",
        build: "vite build",
        preview: "vite preview"
      },
      devDependencies: {
        vite: "4.1.4",
        "esbuild-wasm": "0.17.12"
      }
    })
  } }),
  main: "/index.js",
  environment: "node"
};
var VITE_PREACT_TEMPLATE = {
  files: __assign2(__assign2({}, commonFiles), { "/App.jsx": {
    code: 'export default function App() {\n  const data = "world"\n\n  return <h1>Hello {data}</h1>\n}\n'
  }, "/index.jsx": {
    code: 'import { render } from "preact";\nimport "./styles.css";\n\nimport App from "./App";\n\nconst root = document.getElementById("root");\nrender(<App />, root);\n'
  }, "/index.html": {
    code: '<!DOCTYPE html>\n<html lang="en">\n  <head>\n    <meta charset="UTF-8" />\n    <meta name="viewport" content="width=device-width, initial-scale=1.0" />\n    <title>Vite App</title>\n  </head>\n  <body>\n    <div id="root"></div>\n    <script type="module" src="/index.jsx"><\/script>\n  </body>\n</html>\n'
  }, "/package.json": {
    code: JSON.stringify({
      scripts: {
        dev: "vite",
        build: "vite build",
        preview: "vite preview"
      },
      dependencies: {
        preact: "^10.16.0"
      },
      devDependencies: {
        "@preact/preset-vite": "^2.5.0",
        vite: "4.1.4",
        "esbuild-wasm": "0.17.12"
      }
    })
  }, "/vite.config.js": {
    code: `import { defineConfig } from "vite";
import preact from '@preact/preset-vite'

// https://vitejs.dev/config/
export default defineConfig({
  plugins: [preact()],
});
`
  } }),
  main: "/App.jsx",
  environment: "node"
};
var VITE_PREACT_TS_TEMPLATE = {
  files: __assign2(__assign2({}, commonFiles), { "/App.tsx": {
    code: 'export default function App() {\n  const data: string = "world"\n\n  return <h1>Hello {data}</h1>\n}\n'
  }, "/index.tsx": {
    code: 'import { render } from "preact";\nimport "./styles.css";\n\nimport App from "./App";\n\nconst root = document.getElementById("root") as HTMLElement;\nrender(<App />, root);\n'
  }, "/index.html": {
    code: '<!DOCTYPE html>\n<html lang="en">\n  <head>\n    <meta charset="UTF-8" />\n    <meta name="viewport" content="width=device-width, initial-scale=1.0" />\n    <title>Vite App</title>\n  </head>\n  <body>\n    <div id="root"></div>\n    <script type="module" src="/index.tsx"><\/script>\n  </body>\n</html>\n'
  }, "/tsconfig.json": {
    code: JSON.stringify({
      compilerOptions: {
        target: "ESNext",
        useDefineForClassFields: true,
        lib: ["DOM", "DOM.Iterable", "ESNext"],
        allowJs: false,
        skipLibCheck: true,
        esModuleInterop: false,
        allowSyntheticDefaultImports: true,
        strict: true,
        forceConsistentCasingInFileNames: true,
        module: "ESNext",
        moduleResolution: "Node",
        resolveJsonModule: true,
        isolatedModules: true,
        noEmit: true,
        jsx: "react-jsx",
        jsxImportSource: "preact"
      },
      include: ["src"],
      references: [{ path: "./tsconfig.node.json" }]
    }, null, 2)
  }, "/tsconfig.node.json": {
    code: JSON.stringify({
      compilerOptions: {
        composite: true,
        module: "ESNext",
        moduleResolution: "Node",
        allowSyntheticDefaultImports: true
      },
      include: ["vite.config.ts"]
    }, null, 2)
  }, "/package.json": {
    code: JSON.stringify({
      scripts: {
        dev: "vite",
        build: "tsc && vite build",
        preview: "vite preview"
      },
      dependencies: {
        preact: "^10.16.0"
      },
      devDependencies: {
        "@preact/preset-vite": "^2.5.0",
        typescript: "^4.9.5",
        vite: "4.1.4",
        "esbuild-wasm": "^0.17.12"
      }
    }, null, 2)
  }, "/vite-env.d.ts": {
    code: '/// <reference types="vite/client" />'
  }, "/vite.config.ts": {
    code: "import { defineConfig } from 'vite'\nimport preact from '@preact/preset-vite'\n\n// https://vitejs.dev/config/\nexport default defineConfig({\n  plugins: [preact()],\n})\n"
  } }),
  main: "/App.tsx",
  environment: "node"
};
var VITE_REACT_TEMPLATE = {
  files: __assign2(__assign2({}, commonFiles), { "/App.jsx": {
    code: 'export default function App() {\n  const data = "world"\n\n  return <h1>Hello {data}</h1>\n}\n'
  }, "/index.jsx": {
    code: 'import { StrictMode } from "react";\nimport { createRoot } from "react-dom/client";\nimport "./styles.css";\n\nimport App from "./App";\n\nconst root = createRoot(document.getElementById("root"));\nroot.render(\n  <StrictMode>\n    <App />\n  </StrictMode>\n);'
  }, "/index.html": {
    code: '<!DOCTYPE html>\n<html lang="en">\n  <head>\n    <meta charset="UTF-8" />\n    <meta name="viewport" content="width=device-width, initial-scale=1.0" />\n    <title>Vite App</title>\n  </head>\n  <body>\n    <div id="root"></div>\n    <script type="module" src="/index.jsx"><\/script>\n  </body>\n</html>\n'
  }, "/package.json": {
    code: JSON.stringify({
      scripts: {
        dev: "vite",
        build: "vite build",
        preview: "vite preview"
      },
      dependencies: {
        react: "^18.2.0",
        "react-dom": "^18.2.0"
      },
      devDependencies: {
        "@vitejs/plugin-react": "3.1.0",
        vite: "4.1.4",
        "esbuild-wasm": "0.17.12"
      }
    })
  }, "/vite.config.js": {
    code: 'import { defineConfig } from "vite";\nimport react from "@vitejs/plugin-react";\n\n// https://vitejs.dev/config/\nexport default defineConfig({\n  plugins: [react()],\n});\n'
  } }),
  main: "/App.jsx",
  environment: "node"
};
var VITE_REACT_TS_TEMPLATE = {
  files: __assign2(__assign2({}, commonFiles), { "/App.tsx": {
    code: 'export default function App() {\n  const data: string = "world"\n\n  return <h1>Hello {data}</h1>\n}\n'
  }, "/index.tsx": {
    code: 'import { StrictMode } from "react";\nimport { createRoot } from "react-dom/client";\nimport "./styles.css";\n\nimport App from "./App";\nimport React from "react";\n\nconst root = createRoot(document.getElementById("root") as HTMLElement);\nroot.render(\n  <StrictMode>\n    <App />\n  </StrictMode>\n);\n'
  }, "/index.html": {
    code: '<!DOCTYPE html>\n<html lang="en">\n  <head>\n    <meta charset="UTF-8" />\n    <meta name="viewport" content="width=device-width, initial-scale=1.0" />\n    <title>Vite App</title>\n  </head>\n  <body>\n    <div id="root"></div>\n    <script type="module" src="/index.tsx"><\/script>\n  </body>\n</html>\n'
  }, "/tsconfig.json": {
    code: JSON.stringify({
      compilerOptions: {
        target: "ESNext",
        useDefineForClassFields: true,
        lib: ["DOM", "DOM.Iterable", "ESNext"],
        allowJs: false,
        skipLibCheck: true,
        esModuleInterop: false,
        allowSyntheticDefaultImports: true,
        strict: true,
        forceConsistentCasingInFileNames: true,
        module: "ESNext",
        moduleResolution: "Node",
        resolveJsonModule: true,
        isolatedModules: true,
        noEmit: true,
        jsx: "react-jsx"
      },
      include: ["src"],
      references: [{ path: "./tsconfig.node.json" }]
    }, null, 2)
  }, "/tsconfig.node.json": {
    code: JSON.stringify({
      compilerOptions: {
        composite: true,
        module: "ESNext",
        moduleResolution: "Node",
        allowSyntheticDefaultImports: true
      },
      include: ["vite.config.ts"]
    }, null, 2)
  }, "/package.json": {
    code: JSON.stringify({
      scripts: {
        dev: "vite",
        build: "tsc && vite build",
        preview: "vite preview"
      },
      dependencies: {
        react: "^18.2.0",
        "react-dom": "^18.2.0"
      },
      devDependencies: {
        "@types/react": "^18.0.28",
        "@types/react-dom": "^18.0.11",
        "@vitejs/plugin-react": "^3.1.0",
        typescript: "^4.9.5",
        vite: "4.1.4",
        "esbuild-wasm": "^0.17.12"
      }
    }, null, 2)
  }, "/vite-env.d.ts": {
    code: '/// <reference types="vite/client" />'
  }, "/vite.config.ts": {
    code: "import { defineConfig } from 'vite'\nimport react from '@vitejs/plugin-react'\n\n// https://vitejs.dev/config/\nexport default defineConfig({\n  plugins: [react()],\n})\n"
  } }),
  main: "/App.tsx",
  environment: "node"
};
var VITE_SVELTE_TEMPLATE = {
  files: {
    "/src/styles.css": commonFiles["/styles.css"],
    "/src/App.svelte": {
      code: '<script>\nconst data = "world";\n<\/script>\n\n<h1>Hello {data}</h1>\n\n<style>\nh1 {\n  font-size: 1.5rem;\n}\n</style>'
    },
    "/src/main.js": {
      code: `import App from './App.svelte'
import "./styles.css"

const app = new App({
  target: document.getElementById('app'),
})

export default app`
    },
    "/index.html": {
      code: '<!DOCTYPE html>\n<html lang="en">\n  <head>\n    <meta charset="UTF-8" />\n    <meta name="viewport" content="width=device-width, initial-scale=1.0" />\n    <title>Vite App</title>\n  </head>\n  <body>\n    <div id="app"></div>\n    <script type="module" src="/src/main.js"><\/script>\n  </body>\n</html>\n'
    },
    "/vite.config.js": {
      code: "import { defineConfig } from 'vite'\nimport { svelte } from '@sveltejs/vite-plugin-svelte'\n\n// https://vitejs.dev/config/\nexport default defineConfig({\n  plugins: [svelte()],\n})"
    },
    "/package.json": {
      code: JSON.stringify({
        type: "module",
        scripts: {
          dev: "vite"
        },
        devDependencies: {
          "@sveltejs/vite-plugin-svelte": "^2.0.2",
          svelte: "^3.55.1",
          vite: "4.0.4",
          "esbuild-wasm": "^0.17.12"
        }
      })
    }
  },
  main: "/src/App.svelte",
  environment: "node"
};
var VITE_SVELTE_TS_TEMPLATE = {
  files: {
    "/src/styles.css": commonFiles["/styles.css"],
    "/src/App.svelte": {
      code: '<script lang="ts">\nconst data: string = "world";\n<\/script>\n\n<h1>Hello {data}</h1>\n\n<style>\nh1 {\n  font-size: 1.5rem;\n}\n</style>'
    },
    "/src/main.ts": {
      code: `import App from './App.svelte'
import "./styles.css"

const app = new App({
  target: document.getElementById('app'),
})

export default app`
    },
    "/index.html": {
      code: '<!DOCTYPE html>\n<html lang="en">\n  <head>\n    <meta charset="UTF-8" />\n    <meta name="viewport" content="width=device-width, initial-scale=1.0" />\n    <title>Vite App</title>\n  </head>\n  <body>\n    <div id="app"></div>\n    <script type="module" src="/src/main.ts"><\/script>\n  </body>\n</html>\n'
    },
    "/vite-env.d.ts": {
      code: '/// <reference types="svelte" />\n/// <reference types="vite/client" />'
    },
    "svelte.config.js": {
      code: "import { vitePreprocess } from '@sveltejs/vite-plugin-svelte'\n\nexport default {\n  // Consult https://svelte.dev/docs#compile-time-svelte-preprocess\n  // for more information about preprocessors\n  preprocess: vitePreprocess(),\n}\n"
    },
    "/vite.config.ts": {
      code: "import { defineConfig } from 'vite'\nimport { svelte } from '@sveltejs/vite-plugin-svelte'\n\n// https://vitejs.dev/config/\nexport default defineConfig({\n  plugins: [svelte()],\n})"
    },
    "tsconfig.json": {
      code: JSON.stringify({
        extends: "@tsconfig/svelte/tsconfig.json",
        compilerOptions: {
          target: "ESNext",
          useDefineForClassFields: true,
          module: "ESNext",
          resolveJsonModule: true,
          allowJs: true,
          checkJs: true,
          isolatedModules: true
        },
        include: [
          "src/**/*.d.ts",
          "src/**/*.ts",
          "src/**/*.js",
          "src/**/*.svelte"
        ],
        references: [{ path: "./tsconfig.node.json" }]
      }, null, 2)
    },
    "tsconfig.node.json": {
      code: JSON.stringify({
        compilerOptions: {
          composite: true,
          module: "ESNext",
          moduleResolution: "Node"
        },
        include: ["vite.config.ts"]
      }, null, 2)
    },
    "/package.json": {
      code: JSON.stringify({
        type: "module",
        scripts: {
          dev: "vite"
        },
        devDependencies: {
          "@sveltejs/vite-plugin-svelte": "^2.0.2",
          "@tsconfig/svelte": "^3.0.0",
          svelte: "^3.55.1",
          "svelte-check": "^2.10.3",
          tslib: "^2.5.0",
          vite: "4.1.4",
          "esbuild-wasm": "^0.17.12"
        }
      }, null, 2)
    }
  },
  main: "/src/App.svelte",
  environment: "node"
};
var VITE_VUE_TEMPLATE = {
  files: {
    "/src/styles.css": commonFiles["/styles.css"],
    "/src/App.vue": {
      code: '<script setup>\nimport { ref } from "vue";\n\nconst data = ref("world");\n<\/script>\n\n<template>\n  <h1>Hello {{ data }}</h1>\n</template>\n\n<style>\nh1 {\n  font-size: 1.5rem;\n}\n</style>'
    },
    "/src/main.js": {
      code: `import { createApp } from 'vue'
import App from './App.vue'
import "./styles.css"
            
createApp(App).mount('#app')            
`
    },
    "/index.html": {
      code: '<!DOCTYPE html>\n<html lang="en">\n  <head>\n    <meta charset="UTF-8" />\n    <meta name="viewport" content="width=device-width, initial-scale=1.0" />\n    <title>Vite App</title>\n  </head>\n  <body>\n    <div id="app"></div>\n    <script type="module" src="/src/main.js"><\/script>\n  </body>\n</html>\n'
    },
    "/vite.config.js": {
      code: "import { defineConfig } from 'vite'\nimport vue from '@vitejs/plugin-vue'\n\n// https://vitejs.dev/config/\nexport default defineConfig({\n  plugins: [vue()]\n})\n"
    },
    "/package.json": {
      code: JSON.stringify({
        scripts: {
          dev: "vite",
          build: "vite build",
          preview: "vite preview"
        },
        dependencies: {
          vue: "^3.2.45"
        },
        devDependencies: {
          "@vitejs/plugin-vue": "3.2.0",
          vite: "4.1.4",
          "esbuild-wasm": "0.17.12"
        }
      })
    }
  },
  main: "/src/App.vue",
  environment: "node"
};
var VITE_VUE_TS_TEMPLATE = {
  files: {
    "/src/styles.css": commonFiles["/styles.css"],
    "/src/App.vue": {
      code: '<script setup lang="ts">\nimport { ref } from "vue";\n\nconst data = ref<string>("world");\n<\/script>\n\n<template>\n  <h1>Hello {{ data }}</h1>\n</template>\n\n<style>\nh1 {\n  font-size: 1.5rem;\n}\n</style>'
    },
    "/src/main.ts": {
      code: `import { createApp } from 'vue'
import App from './App.vue'
import "./styles.css"

createApp(App).mount('#app')
`
    },
    "/index.html": {
      code: '<!DOCTYPE html>\n<html lang="en">\n  <head>\n    <meta charset="UTF-8" />\n    <meta name="viewport" content="width=device-width, initial-scale=1.0" />\n    <title>Vite App</title>\n  </head>\n  <body>\n    <div id="app"></div>\n    <script type="module" src="/src/main.ts"><\/script>\n  </body>\n</html>\n'
    },
    "/vite-env.d.ts": {
      code: '/// <reference types="vite/client" />'
    },
    "/vite.config.ts": {
      code: "import { defineConfig } from 'vite'\nimport vue from '@vitejs/plugin-vue'\n\n// https://vitejs.dev/config/\nexport default defineConfig({\n  plugins: [vue()]\n})\n"
    },
    "tsconfig.json": {
      code: JSON.stringify({
        compilerOptions: {
          target: "ESNext",
          useDefineForClassFields: true,
          module: "ESNext",
          moduleResolution: "Node",
          strict: true,
          jsx: "preserve",
          resolveJsonModule: true,
          isolatedModules: true,
          esModuleInterop: true,
          lib: ["ESNext", "DOM"],
          skipLibCheck: true,
          noEmit: true
        },
        include: [
          "src/**/*.ts",
          "src/**/*.d.ts",
          "src/**/*.tsx",
          "src/**/*.vue"
        ],
        references: [{ path: "./tsconfig.node.json" }]
      }, null, 2)
    },
    "tsconfig.node.json": {
      code: JSON.stringify({
        compilerOptions: {
          composite: true,
          module: "ESNext",
          moduleResolution: "Node",
          allowSyntheticDefaultImports: true
        },
        include: ["vite.config.ts"]
      }, null, 2)
    },
    "/package.json": {
      code: JSON.stringify({
        scripts: {
          dev: "vite",
          build: "tsc && vite build",
          preview: "vite preview"
        },
        dependencies: {
          vue: "^3.2.47"
        },
        devDependencies: {
          "@vitejs/plugin-vue": "^4.0.0",
          vite: "4.1.4",
          "vue-tsc": "^1.2.0",
          typescript: "^4.9.5",
          "esbuild-wasm": "^0.17.12"
        }
      }, null, 2)
    }
  },
  main: "/src/App.vue",
  environment: "node"
};
var ANGULAR_TEMPLATE = {
  files: {
    "/src/app/app.component.css": commonFiles["/styles.css"],
    "/src/app/app.component.html": {
      code: "<div>\n<h1>{{ helloWorld }}</h1>\n</div>     \n"
    },
    "/src/app/app.component.ts": {
      code: 'import { Component } from "@angular/core";\n\n@Component({\n  selector: "app-root",\n  templateUrl: "./app.component.html",\n  styleUrls: ["./app.component.css"]\n})\nexport class AppComponent {\n  helloWorld = "Hello world";\n}           \n'
    },
    "/src/app/app.module.ts": {
      code: 'import { BrowserModule } from "@angular/platform-browser";\nimport { NgModule } from "@angular/core";\n      \nimport { AppComponent } from "./app.component";\n      \n@NgModule({\n  declarations: [AppComponent],\n  imports: [BrowserModule],\n  providers: [],\n  bootstrap: [AppComponent]\n})\nexport class AppModule {}       \n'
    },
    "/src/index.html": {
      code: '<!doctype html>\n<html lang="en">\n      \n<head>\n  <meta charset="utf-8">\n  <title>Angular</title>\n  <base href="/">\n      \n  <meta name="viewport" content="width=device-width, initial-scale=1">\n  <link rel="icon" type="image/x-icon" href="favicon.ico">\n</head>\n      \n<body>\n   <app-root></app-root>\n</body>\n      \n</html>\n'
    },
    "/src/main.ts": {
      code: 'import { enableProdMode } from "@angular/core";\nimport { platformBrowserDynamic } from "@angular/platform-browser-dynamic";\n      \nimport { AppModule } from "./app/app.module";      \n\nplatformBrowserDynamic()\n  .bootstrapModule(AppModule)\n  .catch(err => console.log(err));\n      \n'
    },
    "/src/polyfills.ts": {
      code: 'import "core-js/proposals/reflect-metadata";   \n      import "zone.js/dist/zone";\n'
    },
    "/package.json": {
      code: JSON.stringify({
        dependencies: {
          "@angular/core": "^11.2.0",
          "@angular/platform-browser": "^11.2.0",
          "@angular/platform-browser-dynamic": "^11.2.0",
          "@angular/common": "^11.2.0",
          "@angular/compiler": "^11.2.0",
          "zone.js": "0.11.3",
          "core-js": "3.8.3",
          rxjs: "6.6.3"
        },
        main: "/src/main.ts"
      })
    }
  },
  main: "/src/app/app.component.ts",
  environment: "angular-cli"
};
var REACT_TEMPLATE = {
  files: __assign2(__assign2({}, commonFiles), { "/App.js": {
    code: "export default function App() {\n  return <h1>Hello world</h1>\n}\n"
  }, "/index.js": {
    code: 'import React, { StrictMode } from "react";\nimport { createRoot } from "react-dom/client";\nimport "./styles.css";\n\nimport App from "./App";\n\nconst root = createRoot(document.getElementById("root"));\nroot.render(\n  <StrictMode>\n    <App />\n  </StrictMode>\n);'
  }, "/public/index.html": {
    code: '<!DOCTYPE html>\n<html lang="en">\n  <head>\n    <meta charset="UTF-8">\n    <meta name="viewport" content="width=device-width, initial-scale=1.0">\n    <title>Document</title>\n  </head>\n  <body>\n    <div id="root"></div>\n  </body>\n</html>'
  }, "/package.json": {
    code: JSON.stringify({
      dependencies: {
        react: "^18.0.0",
        "react-dom": "^18.0.0",
        "react-scripts": "^5.0.0"
      },
      main: "/index.js"
    })
  } }),
  main: "/App.js",
  environment: "create-react-app"
};
var REACT_TYPESCRIPT_TEMPLATE = {
  files: __assign2(__assign2({}, commonFiles), { "tsconfig.json": {
    code: '{\n  "include": [\n    "./**/*"\n  ],\n  "compilerOptions": {\n    "strict": true,\n    "esModuleInterop": true,\n    "lib": [ "dom", "es2015" ],\n    "jsx": "react-jsx"\n  }\n}'
  }, "/App.tsx": {
    code: "export default function App(): JSX.Element {\n  return <h1>Hello world</h1>\n}\n"
  }, "/index.tsx": {
    code: 'import React, { StrictMode } from "react";\nimport { createRoot } from "react-dom/client";\nimport "./styles.css";\n\nimport App from "./App";\n\nconst root = createRoot(document.getElementById("root"));\nroot.render(\n  <StrictMode>\n    <App />\n  </StrictMode>\n);'
  }, "/public/index.html": {
    code: '<!DOCTYPE html>\n<html lang="en">\n  <head>\n    <meta charset="UTF-8">\n    <meta name="viewport" content="width=device-width, initial-scale=1.0">\n    <title>Document</title>\n  </head>\n  <body>\n    <div id="root"></div>\n  </body>\n</html>'
  }, "/package.json": {
    code: JSON.stringify({
      dependencies: {
        react: "^18.0.0",
        "react-dom": "^18.0.0",
        "react-scripts": "^4.0.0"
      },
      devDependencies: {
        "@types/react": "^18.0.0",
        "@types/react-dom": "^18.0.0",
        typescript: "^4.0.0"
      },
      main: "/index.tsx"
    })
  } }),
  main: "/App.tsx",
  environment: "create-react-app"
};
var SOLID_TEMPLATE = {
  files: __assign2(__assign2({}, commonFiles), { "/App.tsx": {
    code: 'import { Component } from "solid-js";\n\nconst App: Component = () => {\n  return <h1>Hello world</h1>\n};\n\nexport default App;'
  }, "/index.tsx": {
    code: 'import { render } from "solid-js/web";\nimport App from "./App";\n\nimport "./styles.css";\n\nrender(() => <App />, document.getElementById("app"));'
  }, "/index.html": {
    code: '<html>\n<head>\n  <title>Parcel Sandbox</title>\n  <meta charset="UTF-8" />\n</head>\n<body>\n  <div id="app"></div>\n  <script src="src/index.tsx"><\/script>\n</body>\n</html>'
  }, "/package.json": {
    code: JSON.stringify({
      dependencies: {
        "solid-js": "1.3.15"
      },
      main: "/index.tsx"
    })
  } }),
  main: "/App.tsx",
  environment: "solid"
};
var SVELTE_TEMPLATE = {
  files: __assign2(__assign2({}, commonFiles), { "/App.svelte": {
    code: "<style>\n  h1 {\n    font-size: 1.5rem;\n  }\n</style>\n\n<script>\n  let name = 'world';\n<\/script>\n\n<main>\n  <h1>Hello {name}</h1>\n</main>"
  }, "/index.js": {
    code: 'import App from "./App.svelte";\nimport "./styles.css";\n\nconst app = new App({\n  target: document.body\n});\n\nexport default app;\n      '
  }, "/public/index.html": {
    code: '<!DOCTYPE html>\n<html>\n  <head>\n    <meta charset="utf8" />\n    <meta name="viewport" content="width=device-width" />\n\n    <title>Svelte app</title>\n\n    <link rel="stylesheet" href="public/bundle.css" />\n  </head>\n\n  <body>\n    <script src="bundle.js"><\/script>\n  </body>\n</html>'
  }, "/package.json": {
    code: JSON.stringify({
      dependencies: {
        svelte: "^3.0.0"
      },
      main: "/index.js"
    })
  } }),
  main: "/App.svelte",
  environment: "svelte"
};
var TEST_TYPESCRIPT_TEMPLATE = {
  files: {
    "tsconfig.json": {
      code: '{\n  "include": [\n    "./**/*"\n  ],\n  "compilerOptions": {\n    "strict": true,\n    "esModuleInterop": true,\n    "lib": [ "dom", "es2015" ],\n    "jsx": "react-jsx"\n  }\n}'
    },
    "/add.ts": {
      code: "export const add = (a: number, b: number): number => a + b;"
    },
    "/add.test.ts": {
      code: "import { add } from './add';\n\ndescribe('add', () => {\n  test('Commutative Law of Addition', () => {\n    expect(add(1, 2)).toBe(add(2, 1));\n  });\n});"
    },
    "package.json": {
      code: JSON.stringify({
        dependencies: {},
        devDependencies: { typescript: "^4.0.0" },
        main: "/add.ts"
      })
    }
  },
  main: "/add.test.ts",
  environment: "parcel",
  mode: "tests"
};
var VANILLA_TEMPLATE = {
  files: __assign2(__assign2({}, commonFiles), { "/index.js": {
    code: 'import "./styles.css";\n\ndocument.getElementById("app").innerHTML = `\n<h1>Hello world</h1>\n`;\n'
  }, "/index.html": {
    code: '<!DOCTYPE html>\n<html>\n\n<head>\n  <title>Parcel Sandbox</title>\n  <meta charset="UTF-8" />\n</head>\n\n<body>\n  <div id="app"></div>\n\n  <script src="index.js">\n  <\/script>\n</body>\n\n</html>'
  }, "/package.json": {
    code: JSON.stringify({
      dependencies: {},
      main: "/index.js"
    })
  } }),
  main: "/index.js",
  environment: "parcel"
};
var VANILLA_TYPESCRIPT_TEMPLATE = {
  files: __assign2(__assign2({}, commonFiles), { "tsconfig.json": {
    code: '{\n  "compilerOptions": {\n    "strict": true,\n    "module": "commonjs",\n    "jsx": "preserve",\n    "esModuleInterop": true,\n    "sourceMap": true,\n    "allowJs": true,\n    "lib": [\n      "es6",\n      "dom"\n    ],\n    "rootDir": "src",\n    "moduleResolution": "node"\n  }\n}'
  }, "/index.ts": {
    code: 'import "./styles.css";\n\ndocument.getElementById("app").innerHTML = `\n<h1>Hello world</h1>\n`;\n'
  }, "/index.html": {
    code: '<!DOCTYPE html>\n<html>\n\n<head>\n  <title>Parcel Sandbox</title>\n  <meta charset="UTF-8" />\n</head>\n\n<body>\n  <div id="app"></div>\n\n  <script src="index.ts">\n  <\/script>\n</body>\n\n</html>'
  }, "/package.json": {
    code: JSON.stringify({
      dependencies: {},
      devDependencies: {
        typescript: "^4.0.0"
      },
      main: "/index.ts"
    })
  } }),
  main: "/index.ts",
  environment: "parcel"
};
var VUE_TEMPLATE = {
  files: {
    "/src/styles.css": commonFiles["/styles.css"],
    "/src/App.vue": {
      code: "<template>\n  <h1>Hello {{ msg }}</h1>\n</template>\n\n<script setup>\nimport { ref } from 'vue';\nconst msg = ref('world');\n<\/script>"
    },
    "/src/main.js": {
      code: `import { createApp } from 'vue'
import App from './App.vue'
import "./styles.css";

createApp(App).mount('#app')
`
    },
    "/public/index.html": {
      code: `<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge" />
    <meta name="viewport" content="width=device-width,initial-scale=1.0" />
    <title>codesandbox</title>
  </head>
  <body>
    <noscript>
      <strong
        >We're sorry but codesandbox doesn't work properly without JavaScript
        enabled. Please enable it to continue.</strong
      >
    </noscript>
    <div id="app"></div>
    <!-- built files will be auto injected -->
  </body>
</html>
`
    },
    "/package.json": {
      code: JSON.stringify({
        name: "vue3",
        version: "0.1.0",
        private: true,
        main: "/src/main.js",
        scripts: {
          serve: "vue-cli-service serve",
          build: "vue-cli-service build"
        },
        dependencies: {
          "core-js": "^3.26.1",
          vue: "^3.2.45"
        },
        devDependencies: {
          "@vue/cli-plugin-babel": "^5.0.8",
          "@vue/cli-service": "^5.0.8"
        }
      })
    }
  },
  main: "/src/App.vue",
  environment: "vue-cli"
};
var VUE_TS_TEMPLATE = {
  files: {
    "/src/styles.css": commonFiles["/styles.css"],
    "/src/App.vue": {
      code: `<template>
  <h1>Hello {{ msg }}</h1>
</template>

<script setup lang="ts">
import { ref } from 'vue';
const msg = ref<string>('world');
<\/script>`
    },
    "/src/main.ts": {
      code: `import { createApp } from 'vue'
import App from './App.vue'
import "./styles.css";

createApp(App).mount('#app')
`
    },
    "/src/shims-vue.d.ts": '/* eslint-disable */\ndeclare module "*.vue" {\n  import type { DefineComponent } from "vue";\n  const component: DefineComponent<{}, {}, any>;\n  export default component;\n}',
    "/public/index.html": {
      code: `<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge" />
    <meta name="viewport" content="width=device-width,initial-scale=1.0" />
    <title>codesandbox</title>
  </head>
  <body>
    <noscript>
      <strong
        >We're sorry but codesandbox doesn't work properly without JavaScript
        enabled. Please enable it to continue.</strong
      >
    </noscript>
    <div id="app"></div>
    <!-- built files will be auto injected -->
  </body>
</html>
`
    },
    "/package.json": {
      code: JSON.stringify({
        name: "vue3-ts",
        version: "0.1.0",
        private: true,
        main: "/src/main.ts",
        scripts: {
          serve: "vue-cli-service serve",
          build: "vue-cli-service build"
        },
        dependencies: {
          "core-js": "^3.26.1",
          vue: "^3.2.45"
        },
        devDependencies: {
          "@vue/cli-plugin-babel": "^5.0.8",
          "@vue/cli-plugin-typescript": "^5.0.8",
          "@vue/cli-service": "^5.0.8",
          typescript: "^4.9.3"
        }
      })
    },
    "/tsconfig.json": {
      code: JSON.stringify({
        compilerOptions: {
          target: "esnext",
          module: "esnext",
          strict: true,
          jsx: "preserve",
          moduleResolution: "node",
          experimentalDecorators: true,
          skipLibCheck: true,
          esModuleInterop: true,
          allowSyntheticDefaultImports: true,
          forceConsistentCasingInFileNames: true,
          useDefineForClassFields: true,
          sourceMap: false,
          baseUrl: ".",
          types: ["webpack-env"],
          paths: {
            "@/*": ["src/*"]
          },
          lib: ["esnext", "dom", "dom.iterable", "scripthost"]
        },
        include: [
          "src/**/*.ts",
          "src/**/*.tsx",
          "src/**/*.vue",
          "tests/**/*.ts",
          "tests/**/*.tsx"
        ],
        exclude: ["node_modules"]
      })
    }
  },
  main: "/src/App.vue",
  environment: "vue-cli"
};
var STATIC_TEMPLATE = {
  files: __assign2(__assign2({}, commonFiles), { "/index.html": {
    code: '<!DOCTYPE html>\n<html>\n\n<head>\n  <title>Parcel Sandbox</title>\n  <meta charset="UTF-8" />\n  <link rel="stylesheet" href="/styles.css" />\n</head>\n\n<body>\n  <h1>Hello world</h1>\n</body>\n\n</html>'
  }, "/package.json": {
    code: JSON.stringify({
      dependencies: {},
      main: "/index.html"
    })
  } }),
  main: "/index.html",
  environment: "static"
};
var SANDBOX_TEMPLATES = {
  static: STATIC_TEMPLATE,
  angular: ANGULAR_TEMPLATE,
  react: REACT_TEMPLATE,
  "react-ts": REACT_TYPESCRIPT_TEMPLATE,
  solid: SOLID_TEMPLATE,
  svelte: SVELTE_TEMPLATE,
  "test-ts": TEST_TYPESCRIPT_TEMPLATE,
  "vanilla-ts": VANILLA_TYPESCRIPT_TEMPLATE,
  vanilla: VANILLA_TEMPLATE,
  vue: VUE_TEMPLATE,
  "vue-ts": VUE_TS_TEMPLATE,
  node: NODE_TEMPLATE,
  nextjs: NEXTJS_TEMPLATE,
  vite: VITE_TEMPLATE,
  "vite-react": VITE_REACT_TEMPLATE,
  "vite-react-ts": VITE_REACT_TS_TEMPLATE,
  "vite-preact": VITE_PREACT_TEMPLATE,
  "vite-preact-ts": VITE_PREACT_TS_TEMPLATE,
  "vite-vue": VITE_VUE_TEMPLATE,
  "vite-vue-ts": VITE_VUE_TS_TEMPLATE,
  "vite-svelte": VITE_SVELTE_TEMPLATE,
  "vite-svelte-ts": VITE_SVELTE_TS_TEMPLATE,
  astro: ASTRO_TEMPLATE
};
var getSandpackStateFromProps = function(props) {
  var _a2, _b2, _c2, _d, _e, _f;
  var normalizedFilesPath = normalizePath(props.files);
  var projectSetup = combineTemplateFilesToSetup({
    template: props.template,
    customSetup: props.customSetup,
    files: normalizedFilesPath
  });
  var visibleFiles = normalizePath((_b2 = (_a2 = props.options) === null || _a2 === void 0 ? void 0 : _a2.visibleFiles) !== null && _b2 !== void 0 ? _b2 : []);
  var activeFile = ((_c2 = props.options) === null || _c2 === void 0 ? void 0 : _c2.activeFile) ? resolveFile((_d = props.options) === null || _d === void 0 ? void 0 : _d.activeFile, projectSetup.files) : void 0;
  if (visibleFiles.length === 0 && normalizedFilesPath) {
    Object.keys(normalizedFilesPath).forEach(function(filePath) {
      var file = normalizedFilesPath[filePath];
      if (typeof file === "string") {
        visibleFiles.push(filePath);
        return;
      }
      if (!activeFile && file.active) {
        activeFile = filePath;
        if (file.hidden === true) {
          visibleFiles.push(filePath);
        }
      }
      if (!file.hidden) {
        visibleFiles.push(filePath);
      }
    });
  }
  if (visibleFiles.length === 0) {
    visibleFiles = [projectSetup.main];
  }
  if (projectSetup.entry && !projectSetup.files[projectSetup.entry]) {
    projectSetup.entry = resolveFile(projectSetup.entry, projectSetup.files);
  }
  if (!activeFile && projectSetup.main) {
    activeFile = projectSetup.main;
  }
  if (!activeFile || !projectSetup.files[activeFile]) {
    activeFile = visibleFiles[0];
  }
  if (!visibleFiles.includes(activeFile)) {
    visibleFiles.push(activeFile);
  }
  var files = addPackageJSONIfNeeded(projectSetup.files, (_e = projectSetup.dependencies) !== null && _e !== void 0 ? _e : {}, (_f = projectSetup.devDependencies) !== null && _f !== void 0 ? _f : {}, projectSetup.entry);
  var existOpenPath = visibleFiles.filter(function(path) {
    return files[path];
  });
  return {
    visibleFiles: existOpenPath,
    /* eslint-disable-next-line @typescript-eslint/no-non-null-assertion */
    activeFile,
    files,
    environment: projectSetup.environment,
    shouldUpdatePreview: true
  };
};
var resolveFile = function(path, files) {
  var normalizedFilesPath = normalizePath(files);
  var normalizedPath = normalizePath(path);
  if (normalizedPath in normalizedFilesPath) {
    return normalizedPath;
  }
  if (!path) {
    return null;
  }
  var resolvedPath = null;
  var index3 = 0;
  var strategies = [".js", ".jsx", ".ts", ".tsx"];
  while (!resolvedPath && index3 < strategies.length) {
    var removeExtension = normalizedPath.split(".")[0];
    var attemptPath = "".concat(removeExtension).concat(strategies[index3]);
    if (normalizedFilesPath[attemptPath] !== void 0) {
      resolvedPath = attemptPath;
    }
    index3++;
  }
  return resolvedPath;
};
var combineTemplateFilesToSetup = function(_a2) {
  var files = _a2.files, template = _a2.template, customSetup = _a2.customSetup;
  if (!template) {
    if (!customSetup) {
      var defaultTemplate = SANDBOX_TEMPLATES.vanilla;
      return __assign2(__assign2({}, defaultTemplate), { files: __assign2(__assign2({}, defaultTemplate.files), convertedFilesToBundlerFiles(files)) });
    }
    if (!files || Object.keys(files).length === 0) {
      throw new Error("[sandpack-react]: without a template, you must pass at least one file");
    }
    return __assign2(__assign2({}, customSetup), { files: convertedFilesToBundlerFiles(files) });
  }
  var baseTemplate = SANDBOX_TEMPLATES[template];
  if (!baseTemplate) {
    throw new Error('[sandpack-react]: invalid template "'.concat(template, '" provided'));
  }
  if (!customSetup && !files) {
    return baseTemplate;
  }
  return {
    /**
     * The input setup might have files in the simple form Record<string, string>
     * so we convert them to the sandbox template format
     */
    files: convertedFilesToBundlerFiles(__assign2(__assign2({}, baseTemplate.files), files)),
    /**
     * Merge template dependencies and user custom dependencies.
     * As a rule, the custom dependencies must overwrite the template ones.
     */
    dependencies: __assign2(__assign2({}, baseTemplate.dependencies), customSetup === null || customSetup === void 0 ? void 0 : customSetup.dependencies),
    devDependencies: __assign2(__assign2({}, baseTemplate.devDependencies), customSetup === null || customSetup === void 0 ? void 0 : customSetup.devDependencies),
    entry: normalizePath(customSetup === null || customSetup === void 0 ? void 0 : customSetup.entry),
    main: baseTemplate.main,
    environment: (customSetup === null || customSetup === void 0 ? void 0 : customSetup.environment) || baseTemplate.environment
  };
};
var convertedFilesToBundlerFiles = function(files) {
  if (!files)
    return {};
  return Object.keys(files).reduce(function(acc, key2) {
    if (typeof files[key2] === "string") {
      acc[key2] = { code: files[key2] };
    } else {
      acc[key2] = files[key2];
    }
    return acc;
  }, {});
};
var useAppState = function(props, files) {
  var _a2 = (0, import_react47.useState)({
    editorState: "pristine"
  }), state = _a2[0], setState = _a2[1];
  var originalStateFromProps = getSandpackStateFromProps(props);
  var editorState = dequal(originalStateFromProps.files, files) ? "pristine" : "dirty";
  if (editorState !== state.editorState) {
    setState(function(prev) {
      return __assign2(__assign2({}, prev), { editorState });
    });
  }
  return state;
};
var useSandpackId = function() {
  if (typeof import_react47.useId === "function") {
    return (0, import_react47.useId)();
  } else {
    return generateRandomId();
  }
};
var MAX_ID_LENGTH = 9;
var sandpackClientVersion = "2.19.8";
var useAsyncSandpackId = function(files) {
  if (typeof import_react47.useId === "function") {
    var reactDomId_1 = (0, import_react47.useId)();
    return function() {
      return __awaiter2(void 0, void 0, void 0, function() {
        var allCode, sha;
        return __generator2(this, function(_a2) {
          switch (_a2.label) {
            case 0:
              allCode = Object.entries(files).map(function(path, code3) {
                return path + "|" + code3;
              }).join("|||");
              return [4, generateShortId(allCode + reactDomId_1 + sandpackClientVersion)];
            case 1:
              sha = _a2.sent();
              return [2, ensureLength(sha.replace(/:/g, "sp").replace(/[^a-zA-Z]/g, ""), MAX_ID_LENGTH)];
          }
        });
      });
    };
  } else {
    return function() {
      return ensureLength(generateRandomId(), MAX_ID_LENGTH);
    };
  }
};
function ensureLength(str2, length) {
  if (str2.length > length) {
    return str2.slice(0, length);
  } else {
    return str2.padEnd(length, "s");
  }
}
function generateShortId(input) {
  return __awaiter2(this, void 0, void 0, function() {
    var encoder, data2, hashBuffer, hashArray;
    return __generator2(this, function(_a2) {
      switch (_a2.label) {
        case 0:
          encoder = new TextEncoder();
          data2 = encoder.encode(input);
          return [4, crypto.subtle.digest("SHA-256", data2)];
        case 1:
          hashBuffer = _a2.sent();
          hashArray = Array.from(new Uint8Array(hashBuffer));
          return [2, btoa(String.fromCharCode.apply(String, hashArray))];
      }
    });
  });
}
var BUNDLER_TIMEOUT = 4e4;
var useClient = function(_a2, filesState) {
  var _b2, _c2, _d;
  var options = _a2.options, customSetup = _a2.customSetup, teamId = _a2.teamId, sandboxId = _a2.sandboxId;
  options !== null && options !== void 0 ? options : options = {};
  customSetup !== null && customSetup !== void 0 ? customSetup : customSetup = {};
  var initModeFromProps = (options === null || options === void 0 ? void 0 : options.initMode) || "lazy";
  var _e = (0, import_react47.useState)({
    startRoute: options === null || options === void 0 ? void 0 : options.startRoute,
    bundlerState: void 0,
    error: null,
    initMode: initModeFromProps,
    reactDevTools: void 0,
    status: ((_b2 = options === null || options === void 0 ? void 0 : options.autorun) !== null && _b2 !== void 0 ? _b2 : true) ? "initial" : "idle"
  }), state = _e[0], setState = _e[1];
  var intersectionObserverCallback = (0, import_react47.useRef)();
  var intersectionObserver = (0, import_react47.useRef)(null);
  var lazyAnchorRef = (0, import_react47.useRef)(null);
  var registeredIframes = (0, import_react47.useRef)({});
  var clients = (0, import_react47.useRef)({});
  var timeoutHook = (0, import_react47.useRef)(null);
  var unsubscribeClientListeners = (0, import_react47.useRef)({});
  var unsubscribe = (0, import_react47.useRef)();
  var queuedListeners = (0, import_react47.useRef)({ global: {} });
  var debounceHook = (0, import_react47.useRef)();
  var prevEnvironment = (0, import_react47.useRef)(filesState.environment);
  var asyncSandpackId = useAsyncSandpackId(filesState.files);
  var createClient = (0, import_react47.useCallback)(function(iframe, clientId, clientPropsOverride) {
    return __awaiter2(void 0, void 0, void 0, function() {
      var timeOut, shouldSetTimeout, getStableServiceWorkerId, client, _a3, _b3, globalListeners;
      var _c3;
      var _d2, _e2, _f;
      return __generator2(this, function(_g) {
        switch (_g.label) {
          case 0:
            if (clients.current[clientId]) {
              clients.current[clientId].destroy();
            }
            options !== null && options !== void 0 ? options : options = {};
            customSetup !== null && customSetup !== void 0 ? customSetup : customSetup = {};
            timeOut = (_d2 = options === null || options === void 0 ? void 0 : options.bundlerTimeOut) !== null && _d2 !== void 0 ? _d2 : BUNDLER_TIMEOUT;
            if (timeoutHook.current) {
              clearTimeout(timeoutHook.current);
            }
            shouldSetTimeout = typeof unsubscribe.current !== "function";
            if (shouldSetTimeout) {
              timeoutHook.current = setTimeout(function() {
                unregisterAllClients();
                setState(function(prev) {
                  return __assign2(__assign2({}, prev), { status: "timeout" });
                });
              }, timeOut);
            }
            getStableServiceWorkerId = function() {
              return __awaiter2(void 0, void 0, void 0, function() {
                var key2, fixedId;
                return __generator2(this, function(_a4) {
                  switch (_a4.label) {
                    case 0:
                      if (!(options === null || options === void 0 ? void 0 : options.experimental_enableStableServiceWorkerId)) return [3, 3];
                      key2 = "SANDPACK_INTERNAL:URL-CONSISTENT-ID";
                      fixedId = localStorage.getItem(key2);
                      if (!!fixedId) return [3, 2];
                      return [4, asyncSandpackId()];
                    case 1:
                      fixedId = _a4.sent();
                      localStorage.setItem(key2, fixedId);
                      _a4.label = 2;
                    case 2:
                      return [2, fixedId];
                    case 3:
                      return [4, asyncSandpackId()];
                    case 4:
                      return [2, _a4.sent()];
                  }
                });
              });
            };
            _a3 = loadSandpackClient;
            _b3 = [
              iframe,
              {
                files: filesState.files,
                template: filesState.environment
              }
            ];
            _c3 = {
              externalResources: options.externalResources,
              bundlerURL: options.bundlerURL,
              startRoute: (_e2 = clientPropsOverride === null || clientPropsOverride === void 0 ? void 0 : clientPropsOverride.startRoute) !== null && _e2 !== void 0 ? _e2 : options.startRoute,
              fileResolver: options.fileResolver,
              skipEval: (_f = options.skipEval) !== null && _f !== void 0 ? _f : false,
              logLevel: options.logLevel,
              showOpenInCodeSandbox: false,
              showErrorScreen: true,
              showLoadingScreen: false,
              reactDevTools: state.reactDevTools,
              customNpmRegistries: customSetup === null || customSetup === void 0 ? void 0 : customSetup.npmRegistries,
              teamId,
              experimental_enableServiceWorker: !!(options === null || options === void 0 ? void 0 : options.experimental_enableServiceWorker)
            };
            return [4, getStableServiceWorkerId()];
          case 1:
            return [4, _a3.apply(void 0, _b3.concat([(_c3.experimental_stableServiceWorkerId = _g.sent(), _c3.sandboxId = sandboxId, _c3)]))];
          case 2:
            client = _g.sent();
            if (typeof unsubscribe.current !== "function") {
              unsubscribe.current = client.listen(handleMessage);
            }
            unsubscribeClientListeners.current[clientId] = unsubscribeClientListeners.current[clientId] || {};
            if (queuedListeners.current[clientId]) {
              Object.keys(queuedListeners.current[clientId]).forEach(function(listenerId) {
                var listener = queuedListeners.current[clientId][listenerId];
                var unsubscribe2 = client.listen(listener);
                unsubscribeClientListeners.current[clientId][listenerId] = unsubscribe2;
              });
              queuedListeners.current[clientId] = {};
            }
            globalListeners = Object.entries(queuedListeners.current.global);
            globalListeners.forEach(function(_a4) {
              var listenerId = _a4[0], listener = _a4[1];
              var unsubscribe2 = client.listen(listener);
              unsubscribeClientListeners.current[clientId][listenerId] = unsubscribe2;
            });
            clients.current[clientId] = client;
            return [
              2
              /*return*/
            ];
        }
      });
    });
  }, [filesState.environment, filesState.files, state.reactDevTools]);
  var unregisterAllClients = (0, import_react47.useCallback)(function() {
    Object.keys(clients.current).map(unregisterBundler);
    if (typeof unsubscribe.current === "function") {
      unsubscribe.current();
      unsubscribe.current = void 0;
    }
  }, []);
  var runSandpack = (0, import_react47.useCallback)(function() {
    return __awaiter2(void 0, void 0, void 0, function() {
      return __generator2(this, function(_a3) {
        switch (_a3.label) {
          case 0:
            return [4, Promise.all(Object.entries(registeredIframes.current).map(function(_a4) {
              var clientId = _a4[0], _b3 = _a4[1], iframe = _b3.iframe, _c3 = _b3.clientPropsOverride, clientPropsOverride = _c3 === void 0 ? {} : _c3;
              return __awaiter2(void 0, void 0, void 0, function() {
                return __generator2(this, function(_d2) {
                  switch (_d2.label) {
                    case 0:
                      return [4, createClient(iframe, clientId, clientPropsOverride)];
                    case 1:
                      _d2.sent();
                      return [
                        2
                        /*return*/
                      ];
                  }
                });
              });
            }))];
          case 1:
            _a3.sent();
            setState(function(prev) {
              return __assign2(__assign2({}, prev), { error: null, status: "running" });
            });
            return [
              2
              /*return*/
            ];
        }
      });
    });
  }, [createClient]);
  intersectionObserverCallback.current = function(entries2) {
    if (entries2.some(function(entry) {
      return entry.isIntersecting;
    })) {
      runSandpack();
    } else {
      unregisterAllClients();
    }
  };
  var initializeSandpackIframe = (0, import_react47.useCallback)(function() {
    var _a3, _b3, _c3;
    var autorun = (_a3 = options === null || options === void 0 ? void 0 : options.autorun) !== null && _a3 !== void 0 ? _a3 : true;
    if (!autorun) {
      return;
    }
    var observerOptions2 = (_b3 = options === null || options === void 0 ? void 0 : options.initModeObserverOptions) !== null && _b3 !== void 0 ? _b3 : {
      rootMargin: "1000px 0px"
    };
    if (intersectionObserver.current && lazyAnchorRef.current) {
      (_c3 = intersectionObserver.current) === null || _c3 === void 0 ? void 0 : _c3.unobserve(lazyAnchorRef.current);
    }
    if (lazyAnchorRef.current && state.initMode === "lazy") {
      intersectionObserver.current = new IntersectionObserver(function(entries2) {
        var _a4, _b4;
        if (entries2.some(function(entry) {
          return entry.isIntersecting;
        })) {
          if (entries2.some(function(entry) {
            return entry.isIntersecting;
          }) && lazyAnchorRef.current) {
            (_a4 = intersectionObserverCallback.current) === null || _a4 === void 0 ? void 0 : _a4.call(intersectionObserverCallback, entries2);
            (_b4 = intersectionObserver.current) === null || _b4 === void 0 ? void 0 : _b4.unobserve(lazyAnchorRef.current);
          }
        }
      }, observerOptions2);
      intersectionObserver.current.observe(lazyAnchorRef.current);
    } else if (lazyAnchorRef.current && state.initMode === "user-visible") {
      intersectionObserver.current = new IntersectionObserver(function(entries2) {
        var _a4;
        (_a4 = intersectionObserverCallback.current) === null || _a4 === void 0 ? void 0 : _a4.call(intersectionObserverCallback, entries2);
      }, observerOptions2);
      intersectionObserver.current.observe(lazyAnchorRef.current);
    } else {
      runSandpack();
    }
  }, [
    options === null || options === void 0 ? void 0 : options.autorun,
    options === null || options === void 0 ? void 0 : options.initModeObserverOptions,
    runSandpack,
    state.initMode,
    unregisterAllClients
  ]);
  var registerBundler = (0, import_react47.useCallback)(function(iframe, clientId, clientPropsOverride) {
    return __awaiter2(void 0, void 0, void 0, function() {
      return __generator2(this, function(_a3) {
        switch (_a3.label) {
          case 0:
            registeredIframes.current[clientId] = {
              iframe,
              clientPropsOverride
            };
            if (!(state.status === "running")) return [3, 2];
            return [4, createClient(iframe, clientId, clientPropsOverride)];
          case 1:
            _a3.sent();
            _a3.label = 2;
          case 2:
            return [
              2
              /*return*/
            ];
        }
      });
    });
  }, [createClient, state.status]);
  var unregisterBundler = function(clientId) {
    var _a3, _b3;
    var client = clients.current[clientId];
    if (client) {
      client.destroy();
      (_a3 = client.iframe.contentWindow) === null || _a3 === void 0 ? void 0 : _a3.location.replace("about:blank");
      client.iframe.removeAttribute("src");
      delete clients.current[clientId];
    } else {
      delete registeredIframes.current[clientId];
    }
    if (timeoutHook.current) {
      clearTimeout(timeoutHook.current);
    }
    var unsubscribeQueuedClients = Object.values((_b3 = unsubscribeClientListeners.current[clientId]) !== null && _b3 !== void 0 ? _b3 : {});
    unsubscribeQueuedClients.forEach(function(listenerOfClient) {
      var listenerFunctions = Object.values(listenerOfClient);
      listenerFunctions.forEach(function(unsubscribe2) {
        return unsubscribe2();
      });
    });
    var status = Object.keys(clients.current).length > 0 ? "running" : "idle";
    setState(function(prev) {
      return __assign2(__assign2({}, prev), { status });
    });
  };
  var handleMessage = function(msg) {
    if (msg.type === "start") {
      setState(function(prev) {
        return __assign2(__assign2({}, prev), { error: null });
      });
    } else if (msg.type === "state") {
      setState(function(prev) {
        return __assign2(__assign2({}, prev), { bundlerState: msg.state });
      });
    } else if (msg.type === "done" && !msg.compilatonError || msg.type === "connected") {
      if (timeoutHook.current) {
        clearTimeout(timeoutHook.current);
      }
      setState(function(prev) {
        return __assign2(__assign2({}, prev), { error: null });
      });
    } else if (msg.type === "action" && msg.action === "show-error") {
      if (timeoutHook.current) {
        clearTimeout(timeoutHook.current);
      }
      setState(function(prev) {
        return __assign2(__assign2({}, prev), { error: extractErrorDetails(msg) });
      });
    } else if (msg.type === "action" && msg.action === "notification" && msg.notificationType === "error") {
      setState(function(prev) {
        return __assign2(__assign2({}, prev), { error: { message: msg.title } });
      });
    }
  };
  var registerReactDevTools = function(value2) {
    setState(function(prev) {
      return __assign2(__assign2({}, prev), { reactDevTools: value2 });
    });
  };
  var recompileMode = (_c2 = options === null || options === void 0 ? void 0 : options.recompileMode) !== null && _c2 !== void 0 ? _c2 : "delayed";
  var recompileDelay = (_d = options === null || options === void 0 ? void 0 : options.recompileDelay) !== null && _d !== void 0 ? _d : 200;
  var dispatchMessage = function(message, clientId) {
    if (state.status !== "running") {
      console.warn("[sandpack-react]: dispatch cannot be called while in idle mode");
      return;
    }
    if (clientId) {
      clients.current[clientId].dispatch(message);
    } else {
      Object.values(clients.current).forEach(function(client) {
        client.dispatch(message);
      });
    }
  };
  var addListener = function(listener, clientId) {
    if (clientId) {
      if (clients.current[clientId]) {
        var unsubscribeListener = clients.current[clientId].listen(listener);
        return unsubscribeListener;
      } else {
        var listenerId_1 = generateRandomId();
        queuedListeners.current[clientId] = queuedListeners.current[clientId] || {};
        unsubscribeClientListeners.current[clientId] = unsubscribeClientListeners.current[clientId] || {};
        queuedListeners.current[clientId][listenerId_1] = listener;
        var unsubscribeListener = function() {
          if (queuedListeners.current[clientId][listenerId_1]) {
            delete queuedListeners.current[clientId][listenerId_1];
          } else if (unsubscribeClientListeners.current[clientId][listenerId_1]) {
            unsubscribeClientListeners.current[clientId][listenerId_1]();
            delete unsubscribeClientListeners.current[clientId][listenerId_1];
          }
        };
        return unsubscribeListener;
      }
    } else {
      var listenerId_2 = generateRandomId();
      queuedListeners.current.global[listenerId_2] = listener;
      var clientsList = Object.values(clients.current);
      var currentClientUnsubscribeListeners_1 = clientsList.map(function(client) {
        return client.listen(listener);
      });
      var unsubscribeListener = function() {
        currentClientUnsubscribeListeners_1.forEach(function(unsubscribe2) {
          return unsubscribe2();
        });
        delete queuedListeners.current.global[listenerId_2];
        Object.values(unsubscribeClientListeners.current).forEach(function(client) {
          var _a3;
          (_a3 = client === null || client === void 0 ? void 0 : client[listenerId_2]) === null || _a3 === void 0 ? void 0 : _a3.call(client);
        });
      };
      return unsubscribeListener;
    }
  };
  (0, import_react47.useEffect)(function watchFileChanges() {
    if (state.status !== "running" || !filesState.shouldUpdatePreview) {
      return;
    }
    if (prevEnvironment.current !== filesState.environment) {
      prevEnvironment.current = filesState.environment;
      Object.entries(clients.current).forEach(function(_a3) {
        var key2 = _a3[0], client = _a3[1];
        registerBundler(client.iframe, key2);
      });
    }
    if (recompileMode === "immediate") {
      Object.values(clients.current).forEach(function(client) {
        if (client.status === "done") {
          client.updateSandbox({
            files: filesState.files,
            template: filesState.environment
          });
        }
      });
    }
    if (recompileMode === "delayed") {
      if (typeof window === "undefined")
        return;
      window.clearTimeout(debounceHook.current);
      debounceHook.current = window.setTimeout(function() {
        Object.values(clients.current).forEach(function(client) {
          if (client.status === "done") {
            client.updateSandbox({
              files: filesState.files,
              template: filesState.environment
            });
          }
        });
      }, recompileDelay);
    }
    return function() {
      window.clearTimeout(debounceHook.current);
    };
  }, [
    filesState.files,
    filesState.environment,
    filesState.shouldUpdatePreview,
    recompileDelay,
    recompileMode,
    registerBundler,
    state.status
  ]);
  (0, import_react47.useEffect)(function watchInitMode() {
    if (initModeFromProps !== state.initMode) {
      setState(function(prev) {
        return __assign2(__assign2({}, prev), { initMode: initModeFromProps });
      });
      initializeSandpackIframe();
    }
  }, [initModeFromProps, initializeSandpackIframe, state.initMode]);
  (0, import_react47.useEffect)(function() {
    return function unmountClient() {
      if (typeof unsubscribe.current === "function") {
        unsubscribe.current();
      }
      if (timeoutHook.current) {
        clearTimeout(timeoutHook.current);
      }
      if (debounceHook.current) {
        clearTimeout(debounceHook.current);
      }
      if (intersectionObserver.current) {
        intersectionObserver.current.disconnect();
      }
    };
  }, []);
  return [
    state,
    {
      clients: clients.current,
      initializeSandpackIframe,
      runSandpack,
      registerBundler,
      unregisterBundler,
      registerReactDevTools,
      addListener,
      dispatchMessage,
      lazyAnchorRef,
      unsubscribeClientListenersRef: unsubscribeClientListeners,
      queuedListenersRef: queuedListeners
    }
  ];
};
var useFiles = function(props) {
  var originalStateFromProps = getSandpackStateFromProps(props);
  var _a2 = (0, import_react47.useState)(originalStateFromProps), state = _a2[0], setState = _a2[1];
  var isMountedRef = (0, import_react47.useRef)(false);
  (0, import_react47.useEffect)(function() {
    if (isMountedRef.current) {
      setState(getSandpackStateFromProps(props));
    } else {
      isMountedRef.current = true;
    }
  }, [props.files, props.customSetup, props.template]);
  var updateFile = function(pathOrFiles, code3, shouldUpdatePreview) {
    if (shouldUpdatePreview === void 0) {
      shouldUpdatePreview = true;
    }
    setState(function(prev) {
      var _a3;
      var files = prev.files;
      if (typeof pathOrFiles === "string" && typeof code3 === "string") {
        files = __assign2(__assign2({}, files), (_a3 = {}, _a3[pathOrFiles] = __assign2(__assign2({}, files[pathOrFiles]), { code: code3 }), _a3));
      } else if (typeof pathOrFiles === "object") {
        files = __assign2(__assign2({}, files), convertedFilesToBundlerFiles(pathOrFiles));
      }
      return __assign2(__assign2({}, prev), { files: normalizePath(files), shouldUpdatePreview });
    });
  };
  var operations = {
    openFile: function(path) {
      setState(function(_a3) {
        var visibleFiles = _a3.visibleFiles, rest = __rest2(_a3, ["visibleFiles"]);
        var newPaths = visibleFiles.includes(path) ? visibleFiles : __spreadArray2(__spreadArray2([], visibleFiles, true), [path], false);
        return __assign2(__assign2({}, rest), { activeFile: path, visibleFiles: newPaths });
      });
    },
    resetFile: function(path) {
      setState(function(prevState) {
        var _a3;
        return __assign2(__assign2({}, prevState), { files: __assign2(__assign2({}, prevState.files), (_a3 = {}, _a3[path] = originalStateFromProps.files[path], _a3)) });
      });
    },
    resetAllFiles: function() {
      setState(function(prev) {
        return __assign2(__assign2({}, prev), { files: originalStateFromProps.files });
      });
    },
    setActiveFile: function(activeFile) {
      if (state.files[activeFile]) {
        setState(function(prev) {
          return __assign2(__assign2({}, prev), { activeFile });
        });
      }
    },
    updateCurrentFile: function(code3, shouldUpdatePreview) {
      if (shouldUpdatePreview === void 0) {
        shouldUpdatePreview = true;
      }
      updateFile(state.activeFile, code3, shouldUpdatePreview);
    },
    updateFile,
    addFile: updateFile,
    closeFile: function(path) {
      if (state.visibleFiles.length === 1) {
        return;
      }
      setState(function(_a3) {
        var visibleFiles = _a3.visibleFiles, activeFile = _a3.activeFile, prev = __rest2(_a3, ["visibleFiles", "activeFile"]);
        var indexOfRemovedPath = visibleFiles.indexOf(path);
        var newPaths = visibleFiles.filter(function(openPath) {
          return openPath !== path;
        });
        return __assign2(__assign2({}, prev), { activeFile: path === activeFile ? indexOfRemovedPath === 0 ? visibleFiles[1] : visibleFiles[indexOfRemovedPath - 1] : activeFile, visibleFiles: newPaths });
      });
    },
    deleteFile: function(path, shouldUpdatePreview) {
      if (shouldUpdatePreview === void 0) {
        shouldUpdatePreview = true;
      }
      setState(function(_a3) {
        var visibleFiles = _a3.visibleFiles, files = _a3.files, activeFile = _a3.activeFile, rest = __rest2(_a3, ["visibleFiles", "files", "activeFile"]);
        var newFiles = __assign2({}, files);
        delete newFiles[path];
        var remainingVisibleFiles = visibleFiles.filter(function(openPath) {
          return openPath !== path;
        });
        var deletedLastVisibleFile = remainingVisibleFiles.length === 0;
        if (deletedLastVisibleFile) {
          var nextFile = Object.keys(files)[Object.keys(files).length - 1];
          return __assign2(__assign2({}, rest), { visibleFiles: [nextFile], activeFile: nextFile, files: newFiles, shouldUpdatePreview });
        }
        return __assign2(__assign2({}, rest), { visibleFiles: remainingVisibleFiles, activeFile: path === activeFile ? remainingVisibleFiles[remainingVisibleFiles.length - 1] : activeFile, files: newFiles, shouldUpdatePreview });
      });
    }
  };
  return [
    __assign2(__assign2({}, state), { visibleFilesFromProps: originalStateFromProps.visibleFiles }),
    operations
  ];
};
var Sandpack$1 = React43.createContext(null);
var SandpackProvider = function(props) {
  var _a2, _b2, _c2;
  var children = props.children, options = props.options, style = props.style, className = props.className, theme = props.theme;
  var _d = useFiles(props), fileState = _d[0], fileOperations = _d[1];
  var _e = useClient(props, fileState), clientState = _e[0], _f = _e[1], dispatchMessage = _f.dispatchMessage, addListener = _f.addListener, clientOperations = __rest2(_f, ["dispatchMessage", "addListener"]);
  var appState = useAppState(props, fileState.files);
  React43.useEffect(function() {
    clientOperations.initializeSandpackIframe();
  }, []);
  return (0, import_jsx_runtime24.jsx)(Sandpack$1.Provider, { value: __assign2(__assign2(__assign2(__assign2(__assign2(__assign2({}, fileState), clientState), appState), fileOperations), clientOperations), { autoReload: (_b2 = (_a2 = props.options) === null || _a2 === void 0 ? void 0 : _a2.autoReload) !== null && _b2 !== void 0 ? _b2 : true, teamId: props === null || props === void 0 ? void 0 : props.teamId, exportOptions: (_c2 = props === null || props === void 0 ? void 0 : props.customSetup) === null || _c2 === void 0 ? void 0 : _c2.exportOptions, listen: addListener, dispatch: dispatchMessage }), children: (0, import_jsx_runtime24.jsx)(ClassNamesProvider, { classes: options === null || options === void 0 ? void 0 : options.classes, children: (0, import_jsx_runtime24.jsx)(SandpackThemeProvider, { className, style, theme, children }) }) });
};
var SandpackConsumer = Sandpack$1.Consumer;
function useSandpack() {
  var sandpack = React43.useContext(Sandpack$1);
  if (sandpack === null) {
    throw new Error('[sandpack-react]: "useSandpack" must be wrapped by a "SandpackProvider"');
  }
  var dispatch = sandpack.dispatch, listen = sandpack.listen, rest = __rest2(sandpack, ["dispatch", "listen"]);
  return {
    sandpack: __assign2({}, rest),
    dispatch,
    listen
  };
}
var useActiveCode = function() {
  var _a2, _b2, _c2;
  var sandpack = useSandpack().sandpack;
  return {
    code: (_a2 = sandpack.files[sandpack.activeFile]) === null || _a2 === void 0 ? void 0 : _a2.code,
    readOnly: (_c2 = (_b2 = sandpack.files[sandpack.activeFile]) === null || _b2 === void 0 ? void 0 : _b2.readOnly) !== null && _c2 !== void 0 ? _c2 : false,
    updateCode: sandpack.updateCurrentFile
  };
};
var _a$8;
var _b$2;
var _c;
var iconStandaloneClassName = css2({
  svg: { margin: "auto" }
});
var buttonClassName = css2((_a$8 = {
  appearance: "none",
  outline: "none",
  display: "flex",
  alignItems: "center",
  fontSize: "inherit",
  fontFamily: "inherit",
  backgroundColor: "transparent",
  transition: "color $default, background $default",
  cursor: "pointer",
  color: "$colors$clickable",
  border: 0,
  textDecoration: "none",
  "&:disabled": { color: "$colors$disabled" },
  "&:hover:not(:disabled,[data-active='true'])": { color: "$colors$hover" },
  '&[data-active="true"]': { color: "$colors$accent" },
  svg: {
    minWidth: "$space$4",
    width: "$space$4",
    height: "$space$4"
  }
}, _a$8["&.".concat(iconStandaloneClassName)] = {
  padding: "$space$1",
  height: "$space$7",
  display: "flex"
}, // If there's a children besides the icon
_a$8["&.".concat(iconStandaloneClassName, "&:not(:has(span))")] = {
  width: "$space$7"
}, _a$8["&.".concat(iconStandaloneClassName, "&:has(svg + span)")] = {
  paddingRight: "$space$3",
  paddingLeft: "$space$2",
  gap: "$space$1"
}, _a$8));
var roundedButtonClassName = css2({
  backgroundColor: "$colors$surface2",
  borderRadius: "99999px",
  border: "1px solid $colors$surface3",
  '&[data-active="true"]': {
    color: "$colors$surface1",
    background: "$colors$accent"
  },
  "&:hover:not(:disabled,[data-active='true'])": {
    backgroundColor: "$colors$surface3"
  }
});
var iconClassName = css2({ padding: 0 });
var fadeIn = keyframes({
  "0%": {
    opacity: 0
  },
  "100%": {
    opacity: 1
  }
});
var absoluteClassName = css2({
  position: "absolute",
  bottom: "0",
  left: "0",
  right: "0",
  top: "0",
  margin: "0",
  overflow: "auto",
  height: "100%",
  zIndex: "$top"
});
var errorClassName = css2((_b$2 = {
  whiteSpace: "pre-wrap",
  padding: "$space$10",
  backgroundColor: "$colors$surface1",
  display: "flex",
  gap: "$space$2",
  flexDirection: "column"
}, _b$2[".".concat(buttonClassName)] = {
  width: "auto",
  gap: "$space$2",
  padding: "0 $space$3 0 $space$2",
  marginTop: "$space$1"
}, _b$2.variants = {
  solidBg: {
    true: {
      backgroundColor: "$colors$errorSurface"
    }
  }
}, _b$2));
var errorBundlerClassName = css2((_c = {
  padding: "$space$10",
  backgroundColor: "$colors$surface1"
}, _c[".".concat(buttonClassName)] = {
  marginTop: "$space$6",
  width: "auto",
  gap: "$space$2",
  padding: "0 $space$3 0 $space$2"
}, _c));
var errorMessageClassName = css2({
  animation: "".concat(fadeIn, " 150ms ease"),
  color: "$colors$error",
  display: "flex",
  flexDirection: "column",
  gap: "$space$3",
  variants: {
    errorCode: { true: { fontFamily: "$font$mono" } }
  },
  a: {
    color: "inherit"
  },
  p: {
    margin: 0
  }
});
var _a$7;
var tabsClassName = css2({
  borderBottom: "1px solid $colors$surface2",
  background: "$colors$surface1"
});
var tabsScrollableClassName = css2({
  padding: "0 $space$2",
  overflow: "auto",
  display: "flex",
  flexWrap: "nowrap",
  alignItems: "stretch",
  minHeight: "40px",
  marginBottom: "-1px"
});
var tabContainer = css2({
  display: "flex",
  alignItems: "center",
  outline: "none",
  position: "relative",
  paddingRight: "20px",
  margin: "1px 0",
  "&:has(button:focus)": {
    outline: "$colors$accent auto 1px"
  }
});
var closeButtonClassName = css2({
  padding: "0 $space$1 0 $space$1",
  borderRadius: "$border$radius",
  marginLeft: "$space$1",
  width: "$space$5",
  visibility: "hidden",
  cursor: "pointer",
  position: "absolute",
  right: "0px",
  svg: {
    width: "$space$3",
    height: "$space$3",
    display: "block",
    position: "relative",
    top: 1
  }
});
var tabButton = css2((_a$7 = {
  padding: "0 $space$2",
  height: "$layout$headerHeight",
  whiteSpace: "nowrap",
  "&:focus": {
    outline: "none"
  }
}, _a$7["&:hover ~ .".concat(closeButtonClassName)] = { visibility: "visible" }, _a$7));
var FileTabs = function(_a2) {
  var closableTabs = _a2.closableTabs, className = _a2.className, activeFileUniqueId = _a2.activeFileUniqueId, props = __rest2(_a2, ["closableTabs", "className", "activeFileUniqueId"]);
  var sandpack = useSandpack().sandpack;
  var classNames14 = useClassNames();
  var activeFile = sandpack.activeFile, visibleFiles = sandpack.visibleFiles, setActiveFile = sandpack.setActiveFile;
  var _b2 = React43.useState(null), hoveredIndex = _b2[0], setIsHoveredIndex = _b2[1];
  var getTriggerText = function(currentPath) {
    var documentFileName = getFileName(currentPath);
    var pathsWithDuplicateFileNames = visibleFiles.reduce(function(prev, curr) {
      if (curr === currentPath) {
        return prev;
      }
      var fileName = getFileName(curr);
      if (fileName === documentFileName) {
        prev.push(curr);
        return prev;
      }
      return prev;
    }, []);
    if (pathsWithDuplicateFileNames.length === 0) {
      return documentFileName;
    } else {
      return calculateNearestUniquePath(currentPath, pathsWithDuplicateFileNames);
    }
  };
  var onKeyDown2 = function(_a3) {
    var _b3, _c2, _d, _e;
    var e2 = _a3.e, index3 = _a3.index;
    var target = e2.currentTarget;
    switch (e2.key) {
      case "ArrowLeft":
        {
          var leftSibling = target.previousElementSibling;
          if (leftSibling) {
            (_b3 = leftSibling.querySelector("button")) === null || _b3 === void 0 ? void 0 : _b3.focus();
            setActiveFile(visibleFiles[index3 - 1]);
          }
        }
        break;
      case "ArrowRight":
        {
          var rightSibling = target.nextElementSibling;
          if (rightSibling) {
            (_c2 = rightSibling.querySelector("button")) === null || _c2 === void 0 ? void 0 : _c2.focus();
            setActiveFile(visibleFiles[index3 + 1]);
          }
        }
        break;
      case "Home": {
        var parent_1 = target.parentElement;
        var firstChild = parent_1.firstElementChild;
        (_d = firstChild.querySelector("button")) === null || _d === void 0 ? void 0 : _d.focus();
        setActiveFile(visibleFiles[0]);
        break;
      }
      case "End": {
        var parent_2 = target.parentElement;
        var lastChild = parent_2.lastElementChild;
        (_e = lastChild.querySelector("button")) === null || _e === void 0 ? void 0 : _e.focus();
        setActiveFile(visibleFiles[-1]);
        break;
      }
    }
  };
  return (0, import_jsx_runtime24.jsx)("div", __assign2({ className: classNames14("tabs", [tabsClassName, className]), translate: "no" }, props, { children: (0, import_jsx_runtime24.jsx)("div", { "aria-label": "Select active file", className: classNames14("tabs-scrollable-container", [
    tabsScrollableClassName
  ]), role: "tablist", children: visibleFiles.map(function(filePath, index3) {
    return (0, import_jsx_runtime24.jsxs)("div", { "aria-controls": "".concat(filePath, "-").concat(activeFileUniqueId, "-tab-panel"), "aria-selected": filePath === activeFile, className: classNames14("tab-container", [tabContainer]), onKeyDown: function(e2) {
      return onKeyDown2({ e: e2, index: index3 });
    }, onMouseEnter: function() {
      return setIsHoveredIndex(index3);
    }, onMouseLeave: function() {
      return setIsHoveredIndex(null);
    }, role: "tab", children: [(0, import_jsx_runtime24.jsx)("button", { className: classNames14("tab-button", [buttonClassName, tabButton]), "data-active": filePath === activeFile, id: "".concat(filePath, "-").concat(activeFileUniqueId, "-tab"), onClick: function() {
      return setActiveFile(filePath);
    }, tabIndex: filePath === activeFile ? 0 : -1, title: filePath, type: "button", children: getTriggerText(filePath) }), closableTabs && visibleFiles.length > 1 && (0, import_jsx_runtime24.jsx)("span", { className: classNames14("close-button", [closeButtonClassName]), onClick: function(ev) {
      ev.stopPropagation();
      sandpack.closeFile(filePath);
    }, style: {
      visibility: filePath === activeFile || hoveredIndex === index3 ? "visible" : "hidden"
    }, tabIndex: filePath === activeFile ? 0 : -1, children: (0, import_jsx_runtime24.jsx)(CloseIcon, {}) })] }, filePath);
  }) }) }));
};
var RoundedButton = function(_a2) {
  var onClick2 = _a2.onClick, className = _a2.className, children = _a2.children;
  var classNames14 = useClassNames();
  return (0, import_jsx_runtime24.jsx)("button", { className: classNames14("button", [
    classNames14("icon-standalone"),
    buttonClassName,
    iconStandaloneClassName,
    roundedButtonClassName,
    className
  ]), onClick: onClick2, type: "button", children });
};
var runButtonClassName = css2({
  position: "absolute",
  bottom: "$space$2",
  right: "$space$2",
  paddingRight: "$space$3"
});
var RunButton$1 = function(_a2) {
  _a2.className;
  var onClick2 = _a2.onClick, props = __rest2(_a2, ["className", "onClick"]);
  var sandpack = useSandpack().sandpack;
  return (0, import_jsx_runtime24.jsxs)(RoundedButton, __assign2({ className: runButtonClassName.toString(), onClick: function(event) {
    sandpack.runSandpack();
    onClick2 === null || onClick2 === void 0 ? void 0 : onClick2(event);
  } }, props, { children: [(0, import_jsx_runtime24.jsx)(RunIcon, {}), (0, import_jsx_runtime24.jsx)("span", { children: "Run" })] }));
};
var _a$6;
var stackClassName = css2((_a$6 = {
  display: "flex",
  flexDirection: "column",
  width: "100%",
  position: "relative",
  backgroundColor: "$colors$surface1",
  gap: 1
}, _a$6["&:has(.".concat(THEME_PREFIX, "-stack)")] = {
  backgroundColor: "$colors$surface2"
}, _a$6));
var SandpackStack = function(_a2) {
  var className = _a2.className, props = __rest2(_a2, ["className"]);
  var classNames14 = useClassNames();
  return (0, import_jsx_runtime24.jsx)("div", __assign2({ className: classNames14("stack", [stackClassName, className]) }, props));
};
var useSandpackTheme = function() {
  var _a2 = React43.useContext(SandpackThemeContext), theme = _a2.theme, id = _a2.id, mode = _a2.mode;
  return { theme, themeId: id, themeMode: mode };
};
var shallowEqual = function(a2, b3) {
  if (a2.length !== b3.length)
    return false;
  var result = true;
  for (var index3 = 0; index3 < a2.length; index3++) {
    if (a2[index3] !== b3[index3]) {
      result = false;
      break;
    }
  }
  return result;
};
var getCodeMirrorPosition = function(doc, _a2) {
  var line = _a2.line, column = _a2.column;
  return doc.line(line).from + (column !== null && column !== void 0 ? column : 0) - 1;
};
var getEditorTheme = function() {
  return EditorView.theme({
    "&": {
      backgroundColor: "var(--".concat(THEME_PREFIX, "-colors-surface1)"),
      color: "var(--".concat(THEME_PREFIX, "-syntax-color-plain)"),
      height: "100%"
    },
    ".cm-matchingBracket, .cm-nonmatchingBracket, &.cm-focused .cm-matchingBracket, &.cm-focused .cm-nonmatchingBracket": {
      color: "inherit",
      backgroundColor: "rgba(128,128,128,.25)",
      backgroundBlendMode: "difference"
    },
    "&.cm-editor.cm-focused": {
      outline: "none"
    },
    "& .cm-activeLine": {
      backgroundColor: "transparent"
    },
    "&.cm-editor.cm-focused .cm-activeLine": {
      backgroundColor: "var(--".concat(THEME_PREFIX, "-colors-surface3)"),
      borderRadius: "var(--".concat(THEME_PREFIX, "-border-radius)")
    },
    ".cm-errorLine": {
      backgroundColor: "var(--".concat(THEME_PREFIX, "-colors-errorSurface)"),
      borderRadius: "var(--".concat(THEME_PREFIX, "-border-radius)")
    },
    ".cm-content": {
      caretColor: "var(--".concat(THEME_PREFIX, "-colors-accent)"),
      padding: "0 var(--".concat(THEME_PREFIX, "-space-4)")
    },
    ".cm-scroller": {
      fontFamily: "var(--".concat(THEME_PREFIX, "-font-mono)"),
      lineHeight: "var(--".concat(THEME_PREFIX, "-font-lineHeight)")
    },
    ".cm-gutters": {
      backgroundColor: "var(--".concat(THEME_PREFIX, "-colors-surface1)"),
      color: "var(--".concat(THEME_PREFIX, "-colors-disabled)"),
      border: "none",
      paddingLeft: "var(--".concat(THEME_PREFIX, "-space-1)")
    },
    ".cm-gutter.cm-lineNumbers": {
      fontSize: ".6em"
    },
    ".cm-lineNumbers .cm-gutterElement": {
      lineHeight: "var(--".concat(THEME_PREFIX, "-font-lineHeight)"),
      minWidth: "var(--".concat(THEME_PREFIX, "-space-5)")
    },
    ".cm-content .cm-line": { paddingLeft: "var(--".concat(THEME_PREFIX, "-space-1)") },
    ".cm-content.cm-readonly .cm-line": { paddingLeft: 0 }
  });
};
var classNameToken = function(name2) {
  return "".concat(THEME_PREFIX, "-syntax-").concat(name2);
};
var styleTokens = function() {
  var syntaxHighLightTokens = [
    "string",
    "plain",
    "comment",
    "keyword",
    "definition",
    "punctuation",
    "property",
    "tag",
    "static"
  ];
  return syntaxHighLightTokens.reduce(function(acc, token) {
    var _a2;
    return __assign2(__assign2({}, acc), (_a2 = {}, _a2[".".concat(classNameToken(token))] = {
      color: "$syntax$color$".concat(token),
      fontStyle: "$syntax$fontStyle$".concat(token)
    }, _a2));
  }, {});
};
var getSyntaxHighlight = function(theme) {
  return HighlightStyle.define([
    { tag: tags.link, textDecoration: "underline" },
    { tag: tags.emphasis, fontStyle: "italic" },
    { tag: tags.strong, fontWeight: "bold" },
    {
      tag: tags.keyword,
      class: classNameToken("keyword")
    },
    {
      tag: [tags.atom, tags.number, tags.bool],
      class: classNameToken("static")
    },
    {
      tag: tags.variableName,
      class: classNameToken("plain")
    },
    {
      // Standard tags, e.g <h1 />
      tag: tags.standard(tags.tagName),
      class: classNameToken("tag")
    },
    {
      tag: [
        // Highlight function call
        tags.function(tags.variableName),
        // Highlight function definition differently (eg: functional component def in React)
        tags.definition(tags.function(tags.variableName)),
        // "Custom tags", meaning React component
        tags.tagName
      ],
      class: classNameToken("definition")
    },
    {
      tag: tags.propertyName,
      class: classNameToken("property")
    },
    {
      tag: [tags.literal, tags.inserted],
      class: classNameToken(theme.syntax.string ? "string" : "static")
    },
    {
      tag: tags.punctuation,
      class: classNameToken("punctuation")
    },
    {
      tag: [tags.comment, tags.quote],
      class: classNameToken("comment")
    }
  ]);
};
var getLanguageFromFile = function(filePath, fileType, additionalLanguages) {
  if (!filePath && !fileType)
    return "javascript";
  var extension2 = fileType;
  if (!extension2 && filePath) {
    var extensionDotIndex = filePath.lastIndexOf(".");
    extension2 = filePath.slice(extensionDotIndex + 1);
  }
  for (var _i = 0, additionalLanguages_1 = additionalLanguages; _i < additionalLanguages_1.length; _i++) {
    var additionalLanguage = additionalLanguages_1[_i];
    if (extension2 === additionalLanguage.name || additionalLanguage.extensions.includes(extension2 || "")) {
      return additionalLanguage.name;
    }
  }
  switch (extension2) {
    case "ts":
    case "tsx":
      return "typescript";
    case "html":
    case "svelte":
    case "vue":
    case "astro":
      return "html";
    case "css":
    case "less":
    case "scss":
      return "css";
    case "js":
    case "jsx":
    case "json":
    default:
      return "javascript";
  }
};
var getCodeMirrorLanguage = function(extension2, additionalLanguages) {
  var options = {
    javascript: javascript({ jsx: true, typescript: false }),
    typescript: javascript({ jsx: true, typescript: true }),
    html: html(),
    css: css()
  };
  for (var _i = 0, additionalLanguages_2 = additionalLanguages; _i < additionalLanguages_2.length; _i++) {
    var additionalLanguage = additionalLanguages_2[_i];
    if (extension2 === additionalLanguage.name) {
      return additionalLanguage.language;
    }
  }
  return options[extension2];
};
var useCombinedRefs = function() {
  var refs = [];
  for (var _i = 0; _i < arguments.length; _i++) {
    refs[_i] = arguments[_i];
  }
  return React43.useCallback(
    function(element2) {
      return refs.forEach(function(ref2) {
        if (!ref2) {
          return;
        }
        if (typeof ref2 === "function") {
          return ref2(element2);
        }
        ref2.current = element2;
      });
    },
    // eslint-disable-next-line react-hooks/exhaustive-deps
    refs
  );
};
function highlightDecorators(positions) {
  return ViewPlugin.fromClass(
    /** @class */
    function() {
      function class_1(view) {
        this.decorations = this.getDecoration(view);
      }
      class_1.prototype.update = function(update) {
        return;
      };
      class_1.prototype.getDecoration = function(view) {
        if (!positions)
          return Decoration.none;
        var rangesDecorators = positions.map(function(item) {
          var _a2, _b2, _c2;
          var lineDeco2 = Decoration.line({
            attributes: { class: (_a2 = item.className) !== null && _a2 !== void 0 ? _a2 : "" }
          });
          var markDeco = Decoration.mark({
            class: (_b2 = item.className) !== null && _b2 !== void 0 ? _b2 : "",
            attributes: (_c2 = item.elementAttributes) !== null && _c2 !== void 0 ? _c2 : void 0
          });
          var positionLineStart = getCodeMirrorPosition(view.state.doc, {
            line: item.line,
            column: item.startColumn
          }) + 1;
          if (item.startColumn && item.endColumn) {
            var positionLineEnd = getCodeMirrorPosition(view.state.doc, {
              line: item.line,
              column: item.endColumn
            }) + 1;
            return markDeco.range(positionLineStart, positionLineEnd);
          }
          return lineDeco2.range(positionLineStart);
        });
        return Decoration.set(rangesDecorators);
      };
      return class_1;
    }(),
    {
      decorations: function(v3) {
        return v3.decorations;
      }
    }
  );
}
function highlightInlineError() {
  return activeLineHighlighter;
}
var lineDeco = Decoration.line({ attributes: { class: "cm-errorLine" } });
var activeLineHighlighter = ViewPlugin.fromClass(
  /** @class */
  function() {
    function class_1() {
      this.decorations = Decoration.none;
    }
    class_1.prototype.update = function(update) {
      var _this = this;
      update.transactions.forEach(function(trans) {
        var errorValue = trans.annotation("show-error");
        if (errorValue !== void 0) {
          var position2 = getCodeMirrorPosition(update.view.state.doc, {
            line: errorValue
          }) + 1;
          _this.decorations = Decoration.set([lineDeco.range(position2)]);
        } else if (trans.annotation("remove-errors")) {
          _this.decorations = Decoration.none;
        }
      });
    };
    return class_1;
  }(),
  {
    decorations: function(v3) {
      return v3.decorations;
    }
  }
);
var _a$5;
var _b$1;
var placeholderClassName = css2({
  margin: "0",
  display: "block",
  fontFamily: "$font$mono",
  fontSize: "$font$size",
  color: "$syntax$color$plain",
  lineHeight: "$font$lineHeight"
});
var tokensClassName = css2(styleTokens());
var editorClassName = css2((_a$5 = {
  flex: 1,
  position: "relative",
  overflow: "auto",
  background: "$colors$surface1",
  ".cm-scroller": {
    padding: "$space$4 0"
  }
}, _a$5[".".concat(placeholderClassName)] = {
  padding: "$space$4 0"
}, /**
 * For iOS: prevent browser zoom when clicking on sandbox.
 * Does NOT apply to code blocks.
 */
_a$5["@media screen and (max-width: 768px)"] = {
  "@supports (-webkit-overflow-scrolling: touch)": {
    ".cm-content": { fontSize: "16px" }
  }
}, _a$5));
var cmClassName = css2({
  margin: "0",
  outline: "none",
  height: "100%"
});
var readOnlyClassName = css2((_b$1 = {
  fontFamily: "$font$mono",
  fontSize: "0.8em",
  position: "absolute",
  right: "$space$2",
  bottom: "$space$2",
  zIndex: "$top",
  color: "$colors$clickable",
  backgroundColor: "$colors$surface2",
  borderRadius: "99999px",
  padding: "calc($space$1 / 2) $space$2"
}, _b$1["& + .".concat(buttonClassName)] = {
  right: "calc($space$11 * 2)"
}, _b$1));
var useSyntaxHighlight = function(_a2) {
  var langSupport = _a2.langSupport, highlightTheme = _a2.highlightTheme, _b2 = _a2.code, code3 = _b2 === void 0 ? "" : _b2;
  var tree = langSupport.language.parser.parse(code3);
  var offSet = 0;
  var codeElementsRender = [];
  var addElement = function(to, className) {
    if (to > offSet) {
      var children = code3.slice(offSet, to);
      codeElementsRender.push(className ? (0, import_react47.createElement)("span", {
        children,
        className,
        key: "".concat(to).concat(offSet)
      }) : children);
      offSet = to;
    }
  };
  highlightTree(tree, highlightTheme, function(from, to, className) {
    addElement(from, "");
    addElement(to, className);
  });
  if (offSet < code3.length && (code3 === null || code3 === void 0 ? void 0 : code3.includes("\n"))) {
    codeElementsRender.push("\n\n");
  }
  return codeElementsRender;
};
var CodeMirror = React43.forwardRef(function(_a2, ref2) {
  var _b2 = _a2.code, code3 = _b2 === void 0 ? "" : _b2, filePath = _a2.filePath, fileType = _a2.fileType, onCodeUpdate = _a2.onCodeUpdate, _c2 = _a2.showLineNumbers, showLineNumbers = _c2 === void 0 ? false : _c2, _d = _a2.showInlineErrors, showInlineErrors = _d === void 0 ? false : _d, _e = _a2.wrapContent, wrapContent = _e === void 0 ? false : _e, _f = _a2.editorState, editorState = _f === void 0 ? "pristine" : _f, _g = _a2.readOnly, readOnly = _g === void 0 ? false : _g, _h = _a2.showReadOnly, showReadOnly = _h === void 0 ? true : _h, decorators = _a2.decorators, _j = _a2.initMode, initMode = _j === void 0 ? "lazy" : _j, _k = _a2.extensions, extensions = _k === void 0 ? [] : _k, _l = _a2.extensionsKeymap, extensionsKeymap = _l === void 0 ? [] : _l, _m = _a2.additionalLanguages, additionalLanguages = _m === void 0 ? [] : _m;
  var wrapper = React43.useRef(null);
  var combinedRef = useCombinedRefs(wrapper, ref2);
  var cmView = React43.useRef();
  var _o = useSandpackTheme(), theme = _o.theme, themeId = _o.themeId;
  var _p = React43.useState(code3), internalCode = _p[0], setInternalCode = _p[1];
  var _q = React43.useState(initMode === "immediate"), shouldInitEditor = _q[0], setShouldInitEditor = _q[1];
  var classNames14 = useClassNames();
  var _r = useSandpack(), listen = _r.listen, autoReload = _r.sandpack.autoReload;
  var prevExtension = React43.useRef([]);
  var prevExtensionKeymap = React43.useRef([]);
  var isIntersecting = module_default2(wrapper, {
    rootMargin: "600px 0px",
    threshold: 0.2
  }).isIntersecting;
  React43.useImperativeHandle(ref2, function() {
    return {
      getCodemirror: function() {
        return cmView.current;
      }
    };
  });
  React43.useEffect(function() {
    var mode = initMode === "lazy" || initMode === "user-visible";
    if (mode && isIntersecting) {
      setShouldInitEditor(true);
    }
  }, [initMode, isIntersecting]);
  var languageExtension = getLanguageFromFile(filePath, fileType, additionalLanguages);
  var langSupport = getCodeMirrorLanguage(languageExtension, additionalLanguages);
  var highlightTheme = getSyntaxHighlight(theme);
  var syntaxHighlightRender = useSyntaxHighlight({
    langSupport,
    highlightTheme,
    code: code3
  });
  var sortedDecorators = React43.useMemo(function() {
    return decorators ? decorators.sort(function(d1, d22) {
      return d1.line - d22.line;
    }) : decorators;
  }, [decorators]);
  var useStaticReadOnly = readOnly && ((decorators === null || decorators === void 0 ? void 0 : decorators.length) === 0 || decorators === void 0);
  React43.useEffect(function() {
    if (!wrapper.current || !shouldInitEditor || useStaticReadOnly) {
      return;
    }
    var parentDiv = wrapper.current;
    var existingPlaceholder = parentDiv.querySelector(".sp-pre-placeholder");
    if (existingPlaceholder) {
      parentDiv.removeChild(existingPlaceholder);
    }
    var view = new EditorView({
      doc: code3,
      extensions: [],
      parent: parentDiv
    });
    view.contentDOM.setAttribute("data-gramm", "false");
    view.contentDOM.setAttribute("data-lt-active", "false");
    view.contentDOM.setAttribute("aria-label", filePath ? "Code Editor for ".concat(getFileName(filePath)) : "Code Editor");
    view.contentDOM.setAttribute("tabIndex", "-1");
    cmView.current = view;
    return function() {
      var _a3;
      (_a3 = cmView.current) === null || _a3 === void 0 ? void 0 : _a3.destroy();
    };
  }, [shouldInitEditor, readOnly, useStaticReadOnly]);
  React43.useEffect(function() {
    if (useStaticReadOnly) {
      return;
    }
    if (cmView.current) {
      var customCommandsKeymap = [
        {
          key: "Tab",
          run: function(view) {
            var _a3, _b3;
            indentMore(view);
            var customKey = extensionsKeymap.find(function(_a4) {
              var key2 = _a4.key;
              return key2 === "Tab";
            });
            return (_b3 = (_a3 = customKey === null || customKey === void 0 ? void 0 : customKey.run) === null || _a3 === void 0 ? void 0 : _a3.call(customKey, view)) !== null && _b3 !== void 0 ? _b3 : true;
          }
        },
        {
          key: "Shift-Tab",
          run: function(view) {
            var _a3, _b3;
            indentLess({ state: view.state, dispatch: view.dispatch });
            var customKey = extensionsKeymap.find(function(_a4) {
              var key2 = _a4.key;
              return key2 === "Shift-Tab";
            });
            return (_b3 = (_a3 = customKey === null || customKey === void 0 ? void 0 : customKey.run) === null || _a3 === void 0 ? void 0 : _a3.call(customKey, view)) !== null && _b3 !== void 0 ? _b3 : true;
          }
        },
        {
          key: "Escape",
          run: function() {
            if (readOnly)
              return true;
            if (wrapper.current) {
              wrapper.current.focus();
            }
            return true;
          }
        },
        {
          key: "mod-Backspace",
          run: deleteGroupBackward
        }
      ];
      var extensionList = __spreadArray2(__spreadArray2([
        highlightSpecialChars(),
        history(),
        closeBrackets()
      ], extensions, true), [
        keymap.of(__spreadArray2(__spreadArray2(__spreadArray2(__spreadArray2(__spreadArray2([], closeBracketsKeymap, true), defaultKeymap, true), historyKeymap, true), customCommandsKeymap, true), extensionsKeymap, true)),
        langSupport,
        getEditorTheme(),
        syntaxHighlighting(highlightTheme),
        EditorView.updateListener.of(function(update) {
          if (update.docChanged) {
            var newCode = update.state.doc.toString();
            setInternalCode(newCode);
            onCodeUpdate === null || onCodeUpdate === void 0 ? void 0 : onCodeUpdate(newCode);
          }
        })
      ], false);
      if (readOnly) {
        extensionList.push(EditorState.readOnly.of(true));
        extensionList.push(EditorView.editable.of(false));
      } else {
        extensionList.push(bracketMatching());
        extensionList.push(highlightActiveLine());
      }
      if (sortedDecorators) {
        extensionList.push(highlightDecorators(sortedDecorators));
      }
      if (wrapContent) {
        extensionList.push(EditorView.lineWrapping);
      }
      if (showLineNumbers) {
        extensionList.push(lineNumbers());
      }
      if (showInlineErrors) {
        extensionList.push(highlightInlineError());
      }
      cmView.current.dispatch({
        effects: StateEffect.reconfigure.of(extensionList)
      });
    }
  }, [
    shouldInitEditor,
    sortedDecorators,
    showLineNumbers,
    wrapContent,
    themeId,
    readOnly,
    useStaticReadOnly,
    autoReload
  ]);
  React43.useEffect(function applyExtensions() {
    var view = cmView.current;
    var dependenciesAreDiff = !shallowEqual(extensions, prevExtension.current) || !shallowEqual(extensionsKeymap, prevExtensionKeymap.current);
    if (view && dependenciesAreDiff) {
      view.dispatch({
        effects: StateEffect.appendConfig.of(extensions)
      });
      view.dispatch({
        effects: StateEffect.appendConfig.of(keymap.of(__spreadArray2([], extensionsKeymap, true)))
      });
      prevExtension.current = extensions;
      prevExtensionKeymap.current = extensionsKeymap;
    }
  }, [extensions, extensionsKeymap]);
  React43.useEffect(function() {
    if (cmView.current && editorState === "dirty" && window.matchMedia("(min-width: 768px)").matches) {
      cmView.current.contentDOM.focus();
    }
  }, []);
  React43.useEffect(function() {
    if (cmView.current && typeof code3 === "string" && code3 !== internalCode) {
      var view = cmView.current;
      var selection2 = view.state.selection.ranges.some(function(_a3) {
        var to = _a3.to, from = _a3.from;
        return to > code3.length || from > code3.length;
      }) ? EditorSelection.cursor(code3.length) : view.state.selection;
      var changes = { from: 0, to: view.state.doc.length, insert: code3 };
      view.dispatch({ changes, selection: selection2 });
    }
  }, [code3]);
  React43.useEffect(function messageToInlineError() {
    if (!showInlineErrors)
      return;
    var unsubscribe = listen(function(message) {
      var view = cmView.current;
      if (message.type === "success") {
        view === null || view === void 0 ? void 0 : view.dispatch({
          // @ts-ignore
          annotations: [new Annotation("remove-errors", true)]
        });
      } else if (message.type === "action" && message.action === "show-error" && message.path === filePath && message.line) {
        view === null || view === void 0 ? void 0 : view.dispatch({
          // @ts-ignore
          annotations: [new Annotation("show-error", message.line)]
        });
      }
    });
    return function() {
      return unsubscribe();
    };
  }, [listen, showInlineErrors]);
  var handleContainerKeyDown = function(evt) {
    if (evt.key === "Enter" && cmView.current) {
      evt.preventDefault();
      cmView.current.contentDOM.focus();
    }
  };
  var gutterLineOffset = function() {
    var offset5 = 4;
    if (showLineNumbers) {
      offset5 += 6;
    }
    if (!readOnly) {
      offset5 += 1;
    }
    return "var(--".concat(THEME_PREFIX, "-space-").concat(offset5, ")");
  };
  if (useStaticReadOnly) {
    return (0, import_jsx_runtime24.jsxs)(import_jsx_runtime24.Fragment, { children: [(0, import_jsx_runtime24.jsx)("pre", { ref: combinedRef, className: classNames14("cm", [
      classNames14(editorState),
      classNames14(languageExtension),
      cmClassName,
      tokensClassName
    ]), translate: "no", children: (0, import_jsx_runtime24.jsx)("code", { className: classNames14("pre-placeholder", [placeholderClassName]), style: { marginLeft: gutterLineOffset() }, children: syntaxHighlightRender }) }), readOnly && showReadOnly && (0, import_jsx_runtime24.jsx)("span", __assign2({ className: classNames14("read-only", [readOnlyClassName]) }, {}, { children: "Read-only" }))] });
  }
  return (0, import_jsx_runtime24.jsx)("div", { ref: combinedRef, "aria-autocomplete": "list", "aria-label": filePath ? "Code Editor for ".concat(getFileName(filePath)) : "Code Editor", "aria-multiline": "true", className: classNames14("cm", [
    classNames14(editorState),
    classNames14(languageExtension),
    cmClassName,
    tokensClassName
  ]), onKeyDown: handleContainerKeyDown, role: "textbox", tabIndex: 0, translate: "no", suppressHydrationWarning: true, children: (0, import_jsx_runtime24.jsx)("pre", { className: classNames14("pre-placeholder", [placeholderClassName]), style: { marginLeft: gutterLineOffset() }, children: syntaxHighlightRender }) });
});
var SandpackCodeEditor = (0, import_react47.forwardRef)(function(_a2, ref2) {
  var showTabs = _a2.showTabs, _b2 = _a2.showLineNumbers, showLineNumbers = _b2 === void 0 ? false : _b2, _c2 = _a2.showInlineErrors, showInlineErrors = _c2 === void 0 ? false : _c2, _d = _a2.showRunButton, showRunButton = _d === void 0 ? true : _d, _e = _a2.wrapContent, wrapContent = _e === void 0 ? false : _e, _f = _a2.closableTabs, closableTabs = _f === void 0 ? false : _f, initMode = _a2.initMode, extensions = _a2.extensions, extensionsKeymap = _a2.extensionsKeymap, readOnly = _a2.readOnly, showReadOnly = _a2.showReadOnly, additionalLanguages = _a2.additionalLanguages, className = _a2.className, props = __rest2(_a2, ["showTabs", "showLineNumbers", "showInlineErrors", "showRunButton", "wrapContent", "closableTabs", "initMode", "extensions", "extensionsKeymap", "readOnly", "showReadOnly", "additionalLanguages", "className"]);
  var sandpack = useSandpack().sandpack;
  var _g = useActiveCode(), code3 = _g.code, updateCode = _g.updateCode, readOnlyFile = _g.readOnly;
  var activeFile = sandpack.activeFile, status = sandpack.status, editorState = sandpack.editorState;
  var shouldShowTabs = showTabs !== null && showTabs !== void 0 ? showTabs : sandpack.visibleFiles.length > 1;
  var classNames14 = useClassNames();
  var handleCodeUpdate = function(newCode, shouldUpdatePreview) {
    if (shouldUpdatePreview === void 0) {
      shouldUpdatePreview = true;
    }
    updateCode(newCode, shouldUpdatePreview);
  };
  var activeFileUniqueId = useSandpackId();
  return (0, import_jsx_runtime24.jsxs)(SandpackStack, __assign2({ className: classNames14("editor", [className]) }, props, { children: [shouldShowTabs && (0, import_jsx_runtime24.jsx)(FileTabs, { activeFileUniqueId, closableTabs }), (0, import_jsx_runtime24.jsxs)("div", { "aria-labelledby": "".concat(activeFile, "-").concat(activeFileUniqueId, "-tab"), className: classNames14("code-editor", [editorClassName]), id: "".concat(activeFile, "-").concat(activeFileUniqueId, "-tab-panel"), role: "tabpanel", children: [(0, import_jsx_runtime24.jsx)(CodeMirror, { ref: ref2, additionalLanguages, code: code3, editorState, extensions, extensionsKeymap, filePath: activeFile, initMode: initMode || sandpack.initMode, onCodeUpdate: function(newCode) {
    var _a3;
    return handleCodeUpdate(newCode, (_a3 = sandpack.autoReload) !== null && _a3 !== void 0 ? _a3 : true);
  }, readOnly: readOnly || readOnlyFile, showInlineErrors, showLineNumbers, showReadOnly, wrapContent }, activeFile), showRunButton && (!sandpack.autoReload || status === "idle") ? (0, import_jsx_runtime24.jsx)(RunButton$1, {}) : null] })] }));
});
var SandpackCodeViewer = React43.forwardRef(function(_a2, ref2) {
  var showTabs = _a2.showTabs, showLineNumbers = _a2.showLineNumbers, decorators = _a2.decorators, propCode = _a2.code, initMode = _a2.initMode, wrapContent = _a2.wrapContent, additionalLanguages = _a2.additionalLanguages, props = __rest2(_a2, ["showTabs", "showLineNumbers", "decorators", "code", "initMode", "wrapContent", "additionalLanguages"]);
  var sandpack = useSandpack().sandpack;
  var code3 = useActiveCode().code;
  var classNames14 = useClassNames();
  var shouldShowTabs = showTabs !== null && showTabs !== void 0 ? showTabs : sandpack.visibleFiles.length > 1;
  var activeFileUniqueId = useSandpackId();
  return (0, import_jsx_runtime24.jsxs)(SandpackStack, __assign2({ className: classNames14("editor-viewer") }, props, { children: [shouldShowTabs ? (0, import_jsx_runtime24.jsx)(FileTabs, { activeFileUniqueId }) : null, (0, import_jsx_runtime24.jsx)("div", { "aria-labelledby": "".concat(sandpack.activeFile, "-").concat(activeFileUniqueId, "-tab"), className: classNames14("code-editor", [editorClassName]), id: "".concat(sandpack.activeFile, "-").concat(activeFileUniqueId, "-tab-panel"), role: "tabpanel", children: (0, import_jsx_runtime24.jsx)(CodeMirror, { ref: ref2, additionalLanguages, code: propCode !== null && propCode !== void 0 ? propCode : code3, decorators, filePath: sandpack.activeFile, initMode: initMode || sandpack.initMode, showLineNumbers, showReadOnly: false, wrapContent, readOnly: true }) }), sandpack.status === "idle" ? (0, import_jsx_runtime24.jsx)(RunButton$1, {}) : null] }));
});
var _a$4;
var _b;
var layoutClassName = css2((_a$4 = {
  border: "1px solid $colors$surface2",
  display: "flex",
  flexWrap: "wrap",
  alignItems: "stretch",
  borderRadius: "$border$radius",
  overflow: "hidden",
  position: "relative",
  backgroundColor: "$colors$surface2",
  gap: 1
}, _a$4["> .".concat(stackClassName)] = {
  flexGrow: 1,
  flexShrink: 1,
  flexBasis: "0",
  height: "$layout$height",
  overflow: "hidden",
  "@media print": {
    height: "auto",
    display: "block"
  },
  "@media screen and (max-width: 768px)": (_b = {}, _b["&:not(.".concat(THEME_PREFIX, "-preview, .").concat(THEME_PREFIX, "-editor, .").concat(THEME_PREFIX, "-preset-column)")] = {
    height: "calc($layout$height / 2)"
  }, /* triggers the layout break at the 768px breakpoint, not when the component is less then 700px */
  _b.minWidth = "100%;", _b)
}, _a$4["> .".concat(THEME_PREFIX, "-file-explorer")] = {
  flex: 0.2,
  minWidth: 200,
  "@media screen and (max-width: 768px)": {
    flex: 1
  }
}, _a$4));
var SandpackLayout = React43.forwardRef(function(_a2, ref2) {
  var children = _a2.children, className = _a2.className, props = __rest2(_a2, ["children", "className"]);
  var sandpack = useSandpack().sandpack;
  var classNames14 = useClassNames();
  var combinedRef = useCombinedRefs(sandpack.lazyAnchorRef, ref2);
  return (0, import_jsx_runtime24.jsx)("div", __assign2({ ref: combinedRef, className: classNames14("layout", [layoutClassName, className]) }, props, { children }));
});
var useErrorMessage = function() {
  var _a2;
  var sandpack = useSandpack().sandpack;
  var error = sandpack.error;
  return (_a2 = error === null || error === void 0 ? void 0 : error.message) !== null && _a2 !== void 0 ? _a2 : null;
};
var FADE_ANIMATION_DURATION = 200;
var useLoadingOverlayState = function(clientId, externalLoading) {
  var _a2 = useSandpack(), sandpack = _a2.sandpack, listen = _a2.listen;
  var _b2 = React43.useState("LOADING"), state = _b2[0], setState = _b2[1];
  React43.useEffect(function() {
    var unsubscribe = listen(function(message) {
      if (message.type === "start" && message.firstLoad === true) {
        setState("LOADING");
      }
      if (message.type === "done") {
        setState(function(prev) {
          return prev === "LOADING" ? "PRE_FADING" : "HIDDEN";
        });
      }
    }, clientId);
    return function() {
      unsubscribe();
    };
  }, [clientId, sandpack.status === "idle"]);
  React43.useEffect(function() {
    var fadeTimeout;
    if (state === "PRE_FADING" && !externalLoading) {
      setState("FADING");
    } else if (state === "FADING") {
      fadeTimeout = setTimeout(function() {
        return setState("HIDDEN");
      }, FADE_ANIMATION_DURATION);
    }
    return function() {
      clearTimeout(fadeTimeout);
    };
  }, [state, externalLoading]);
  if (sandpack.status === "timeout") {
    return "TIMEOUT";
  }
  if (sandpack.status !== "running") {
    return "HIDDEN";
  }
  return state;
};
var useSandpackNavigation = function(clientId) {
  var dispatch = useSandpack().dispatch;
  return {
    refresh: function() {
      return dispatch({ type: "refresh" }, clientId);
    },
    back: function() {
      return dispatch({ type: "urlback" }, clientId);
    },
    forward: function() {
      return dispatch({ type: "urlforward" }, clientId);
    }
  };
};
var useSandpackClient = function(clientPropsOverride) {
  var _a2 = useSandpack(), sandpack = _a2.sandpack, listen = _a2.listen, dispatch = _a2.dispatch;
  var iframeRef = React43.useRef(null);
  var clientId = React43.useRef(generateRandomId());
  React43.useEffect(function() {
    var iframeElement = iframeRef.current;
    var clientIdValue = clientId.current;
    if (iframeElement !== null) {
      sandpack.registerBundler(iframeElement, clientIdValue, clientPropsOverride);
    }
    return function() {
      return sandpack.unregisterBundler(clientIdValue);
    };
  }, []);
  var getClient = function() {
    return sandpack.clients[clientId.current] || null;
  };
  return {
    sandpack,
    getClient,
    clientId: clientId.current,
    iframe: iframeRef,
    listen: function(listener) {
      return listen(listener, clientId.current);
    },
    dispatch: function(message) {
      return dispatch(message, clientId.current);
    }
  };
};
var useSandpackShell = function(clientId) {
  var dispatch = useSandpack().dispatch;
  return {
    restart: function() {
      return dispatch({ type: "shell/restart" }, clientId);
    },
    openPreview: function() {
      return dispatch({ type: "shell/openPreview" }, clientId);
    }
  };
};
var mapProgressMessage = function(originalMessage, firstTotalPending) {
  var _a2;
  switch (originalMessage.state) {
    case "downloading_manifest":
      return "[1/3] Downloading manifest";
    case "downloaded_module":
      return "[2/3] Downloaded ".concat(originalMessage.name, " (").concat(firstTotalPending - originalMessage.totalPending, "/").concat(firstTotalPending, ")");
    case "starting_command":
      return "[3/3] Starting command";
    case "command_running":
      return '[3/3] Running "'.concat((_a2 = originalMessage.command) === null || _a2 === void 0 ? void 0 : _a2.trim(), '"');
  }
};
var useSandpackPreviewProgress = function(props) {
  var _a2 = React43.useState(false), isReady = _a2[0], setIsReady = _a2[1];
  var _b2 = React43.useState(), totalDependencies = _b2[0], setTotalDependencies = _b2[1];
  var _c2 = React43.useState(null), loadingMessage = _c2[0], setLoadingMessage = _c2[1];
  var timeout = props === null || props === void 0 ? void 0 : props.timeout;
  var clientId = props === null || props === void 0 ? void 0 : props.clientId;
  var listen = useSandpack().listen;
  React43.useEffect(function() {
    var timer;
    var unsubscribe = listen(function(message) {
      if (message.type === "start" && message.firstLoad) {
        setIsReady(false);
      }
      if (timeout) {
        timer = setTimeout(function() {
          setLoadingMessage(null);
        }, timeout);
      }
      if (message.type === "dependencies") {
        setLoadingMessage(function() {
          switch (message.data.state) {
            case "downloading_manifest":
              return "[1/3] Downloading manifest";
            case "downloaded_module":
              return "[2/3] Downloaded ".concat(message.data.name, " (").concat(message.data.progress, "/").concat(message.data.total, ")");
            case "starting":
              return "[3/3] Starting";
          }
          return null;
        });
      } else if (message.type === "shell/progress" && !isReady) {
        if (!totalDependencies && message.data.state === "downloaded_module") {
          setTotalDependencies(message.data.totalPending);
        }
        if (totalDependencies !== void 0) {
          setLoadingMessage(mapProgressMessage(message.data, totalDependencies));
        }
      }
      if (message.type === "done" && message.compilatonError === false) {
        setLoadingMessage(null);
        setIsReady(true);
        clearTimeout(timer);
      }
    }, clientId);
    return function() {
      if (timer) {
        clearTimeout(timer);
      }
      unsubscribe();
    };
  }, [clientId, isReady, totalDependencies, timeout]);
  return loadingMessage;
};
var MAX_MESSAGE_COUNT$1 = 400 * 2;
var useSandpackShellStdout = function(_a2) {
  var clientId = _a2.clientId, _b2 = _a2.maxMessageCount, maxMessageCount = _b2 === void 0 ? MAX_MESSAGE_COUNT$1 : _b2;
  _a2.resetOnPreviewRestart;
  var _d = React43.useState([]), logs = _d[0], setLogs = _d[1];
  var listen = useSandpack().listen;
  React43.useEffect(function() {
    var unsubscribe = listen(function(message) {
      if (message.type === "start") {
        setLogs([]);
      } else if (message.type === "stdout" && message.payload.data && Boolean(message.payload.data.trim())) {
        setLogs(function(prev) {
          var messages2 = __spreadArray2(__spreadArray2([], prev, true), [
            { data: message.payload.data, id: generateRandomId() }
          ], false);
          while (messages2.length > maxMessageCount) {
            messages2.shift();
          }
          return messages2;
        });
      }
    }, clientId);
    return unsubscribe;
  }, [maxMessageCount, clientId]);
  return { logs, reset: function() {
    return setLogs([]);
  } };
};
var mapBundlerErrors = function(originalMessage) {
  var errorMessage = originalMessage.replace("[sandpack-client]: ", "");
  if (/process.exit/.test(errorMessage)) {
    var exitCode = errorMessage.match(/process.exit\((\d+)\)/);
    if (!exitCode)
      return errorMessage;
    if (Number(exitCode[1]) === 0) {
      return "Server is not running, would you like to start it again?";
    }
    return "Server has crashed with status code ".concat(exitCode[1], ", would you like to restart the server?");
  }
  return errorMessage;
};
var ErrorOverlay = function(props) {
  var children = props.children, className = props.className, otherProps = __rest2(props, ["children", "className"]);
  var errorMessage = useErrorMessage();
  var restart = useSandpackShell().restart;
  var classNames14 = useClassNames();
  var _a2 = useSandpack().sandpack, runSandpack = _a2.runSandpack, teamId = _a2.teamId;
  var dispatch = useSandpack().dispatch;
  if (!errorMessage && !children) {
    return null;
  }
  var isSandpackBundlerError = errorMessage === null || errorMessage === void 0 ? void 0 : errorMessage.startsWith("[sandpack-client]");
  var privateDependencyError = errorMessage === null || errorMessage === void 0 ? void 0 : errorMessage.includes("NPM_REGISTRY_UNAUTHENTICATED_REQUEST");
  var onSignIn = function() {
    if (teamId) {
      dispatch({ type: "sign-in", teamId });
    }
  };
  if (privateDependencyError) {
    return (0, import_jsx_runtime24.jsxs)("div", __assign2({ className: classNames14("overlay", [
      classNames14("error"),
      absoluteClassName,
      errorBundlerClassName,
      className
    ]) }, props, { children: [(0, import_jsx_runtime24.jsx)("p", { className: classNames14("error-message", [errorMessageClassName]), children: (0, import_jsx_runtime24.jsx)("strong", { children: "Unable to fetch required dependency." }) }), (0, import_jsx_runtime24.jsx)("div", { className: classNames14("error-message", [errorMessageClassName]), children: (0, import_jsx_runtime24.jsxs)("p", { children: ["Authentication required. Please sign in to your account (make sure to allow pop-ups to this page) and try again. If the issue persists, contact", " ", (0, import_jsx_runtime24.jsx)("a", { href: "mailto:hello@codesandbox.io?subject=Sandpack Timeout Error", children: "support" }), " ", "for further assistance."] }) }), (0, import_jsx_runtime24.jsx)("div", { children: (0, import_jsx_runtime24.jsxs)("button", { className: classNames14("button", [
      buttonClassName,
      iconStandaloneClassName,
      roundedButtonClassName
    ]), onClick: onSignIn, children: [(0, import_jsx_runtime24.jsx)(SignInIcon, {}), (0, import_jsx_runtime24.jsx)("span", { children: "Sign in" })] }) })] }));
  }
  if (isSandpackBundlerError && errorMessage) {
    return (0, import_jsx_runtime24.jsx)("div", __assign2({ className: classNames14("overlay", [
      classNames14("error"),
      absoluteClassName,
      errorBundlerClassName,
      className
    ]) }, otherProps, { children: (0, import_jsx_runtime24.jsxs)("div", { className: classNames14("error-message", [errorMessageClassName]), children: [(0, import_jsx_runtime24.jsx)("p", { className: classNames14("error-title", [css2({ fontWeight: "bold" })]), children: "Couldn't connect to server" }), (0, import_jsx_runtime24.jsx)("p", { children: mapBundlerErrors(errorMessage) }), (0, import_jsx_runtime24.jsx)("div", { children: (0, import_jsx_runtime24.jsxs)("button", { className: classNames14("button", [
      classNames14("icon-standalone"),
      buttonClassName,
      iconStandaloneClassName,
      roundedButtonClassName
    ]), onClick: function() {
      restart();
      runSandpack();
    }, title: "Restart script", type: "button", children: [(0, import_jsx_runtime24.jsx)(RestartIcon, {}), " ", (0, import_jsx_runtime24.jsx)("span", { children: "Restart" })] }) })] }) }));
  }
  return (0, import_jsx_runtime24.jsxs)("div", __assign2({ className: classNames14("overlay", [
    classNames14("error"),
    absoluteClassName,
    errorClassName({ solidBg: true }),
    className
  ]), translate: "no" }, otherProps, { children: [(0, import_jsx_runtime24.jsx)("p", { className: classNames14("error-message", [errorMessageClassName]), children: (0, import_jsx_runtime24.jsx)("strong", { children: "Something went wrong" }) }), (0, import_jsx_runtime24.jsx)("p", { className: classNames14("error-message", [
    errorMessageClassName({ errorCode: true })
  ]), children: errorMessage || children })] }));
};
function ansiToJSON(input, use_classes) {
  if (use_classes === void 0) {
    use_classes = false;
  }
  input = (0, import_escape_carriage.escapeCarriageReturn)(fixBackspace(input));
  return import_anser.default.ansiToJson(input, {
    json: true,
    remove_empty: true,
    use_classes
  });
}
function createClass(bundle) {
  var classNames14 = "";
  if (bundle.bg) {
    classNames14 += "".concat(bundle.bg, "-bg ");
  }
  if (bundle.fg) {
    classNames14 += "".concat(bundle.fg, "-fg ");
  }
  if (bundle.decoration) {
    classNames14 += "ansi-".concat(bundle.decoration, " ");
  }
  if (classNames14 === "") {
    return null;
  }
  classNames14 = classNames14.substring(0, classNames14.length - 1);
  return classNames14;
}
function createStyle(bundle) {
  var style = {};
  if (bundle.bg) {
    style.backgroundColor = "rgb(".concat(bundle.bg, ")");
  }
  if (bundle.fg) {
    style.color = "rgb(".concat(bundle.fg, ")");
  }
  switch (bundle.decoration) {
    case "bold":
      style.fontWeight = "bold";
      break;
    case "dim":
      style.opacity = "0.5";
      break;
    case "italic":
      style.fontStyle = "italic";
      break;
    case "hidden":
      style.visibility = "hidden";
      break;
    case "strikethrough":
      style.textDecoration = "line-through";
      break;
    case "underline":
      style.textDecoration = "underline";
      break;
    case "blink":
      style.textDecoration = "blink";
      break;
  }
  return style;
}
function convertBundleIntoReact(linkify, useClasses, bundle, key2) {
  var style = useClasses ? null : createStyle(bundle);
  var className = useClasses ? createClass(bundle) : null;
  if (!linkify) {
    return React43.createElement("span", { style, key: key2, className }, bundle.content);
  }
  var content3 = [];
  var linkRegex = /(\s|^)(https?:\/\/(?:www\.|(?!www))[^\s.]+\.[^\s]{2,}|www\.[^\s]+\.[^\s]{2,})/g;
  var index3 = 0;
  var match;
  while ((match = linkRegex.exec(bundle.content)) !== null) {
    var pre = match[1], url = match[2];
    var startIndex = match.index + pre.length;
    if (startIndex > index3) {
      content3.push(bundle.content.substring(index3, startIndex));
    }
    var href = url.startsWith("www.") ? "http://".concat(url) : url;
    content3.push(React43.createElement("a", {
      key: index3,
      href,
      target: "_blank"
    }, "".concat(url)));
    index3 = linkRegex.lastIndex;
  }
  if (index3 < bundle.content.length) {
    content3.push(bundle.content.substring(index3));
  }
  return React43.createElement("span", { style, key: key2, className }, content3);
}
function Ansi(props) {
  var className = props.className, useClasses = props.useClasses, children = props.children, linkify = props.linkify;
  return React43.createElement("code", { className }, ansiToJSON(children !== null && children !== void 0 ? children : "", useClasses !== null && useClasses !== void 0 ? useClasses : false).map(convertBundleIntoReact.bind(null, linkify !== null && linkify !== void 0 ? linkify : false, useClasses !== null && useClasses !== void 0 ? useClasses : false)));
}
function fixBackspace(txt) {
  var tmp = txt;
  do {
    txt = tmp;
    tmp = txt.replace(/[^\n]\x08/gm, "");
  } while (tmp.length < txt.length);
  return txt;
}
var StdoutList = function(_a2) {
  var data2 = _a2.data;
  var classNames14 = useClassNames();
  return (0, import_jsx_runtime24.jsx)(import_jsx_runtime24.Fragment, { children: data2.map(function(_a3) {
    var data3 = _a3.data, id = _a3.id;
    return (0, import_jsx_runtime24.jsx)("div", { className: classNames14("console-item", [consoleItemClassName$1]), children: (0, import_jsx_runtime24.jsx)(Ansi, { children: data3 }) }, id);
  }) });
};
var consoleItemClassName$1 = css2({
  width: "100%",
  padding: "$space$3 $space$2",
  fontSize: ".85em",
  position: "relative",
  whiteSpace: "pre",
  "&:not(:first-child):after": {
    content: "",
    position: "absolute",
    top: 0,
    left: 0,
    right: 0,
    height: 1,
    background: "$colors$surface3"
  }
});
var getParameters = function(parameters) {
  return import_lz_string.default.compressToBase64(JSON.stringify(parameters)).replace(/\+/g, "-").replace(/\//g, "_").replace(/=+$/, "");
};
var CSB_URL = "https://codesandbox.io/api/v1/sandboxes/define";
var getFileParameters = function(files, environment) {
  var normalizedFiles = Object.keys(files).reduce(function(prev, next) {
    var _a2;
    var fileName = next.replace("/", "");
    var value2 = {
      content: files[next].code,
      isBinary: false
    };
    return __assign2(__assign2({}, prev), (_a2 = {}, _a2[fileName] = value2, _a2));
  }, {});
  return getParameters(__assign2({ files: normalizedFiles }, environment ? { template: environment } : null));
};
var UnstyledOpenInCodeSandboxButton = function(props) {
  var sandpack = useSandpack().sandpack;
  if (sandpack.exportOptions) {
    return (0, import_jsx_runtime24.jsx)(ExportToWorkspaceButton, __assign2({ state: sandpack }, props));
  }
  return (0, import_jsx_runtime24.jsx)(RegularExportButton, __assign2({ state: sandpack }, props));
};
var ExportToWorkspaceButton = function(_a2) {
  var children = _a2.children, state = _a2.state, props = __rest2(_a2, ["children", "state"]);
  var submit = function() {
    return __awaiter2(void 0, void 0, void 0, function() {
      var normalizedFiles, response, data2;
      var _a3;
      return __generator2(this, function(_b2) {
        switch (_b2.label) {
          case 0:
            if (!((_a3 = state.exportOptions) === null || _a3 === void 0 ? void 0 : _a3.apiToken)) {
              throw new Error("Missing `apiToken` property");
            }
            normalizedFiles = Object.keys(state.files).reduce(function(prev, next) {
              var _a4;
              var fileName = next.replace("/", "");
              return __assign2(__assign2({}, prev), (_a4 = {}, _a4[fileName] = state.files[next], _a4));
            }, {});
            return [4, fetch("https://api.codesandbox.io/sandbox", {
              method: "POST",
              body: JSON.stringify({
                template: state.environment,
                files: normalizedFiles,
                privacy: state.exportOptions.privacy === "public" ? 0 : 2
              }),
              headers: {
                Authorization: "Bearer ".concat(state.exportOptions.apiToken),
                "Content-Type": "application/json",
                "X-CSB-API-Version": "2023-07-01"
              }
            })];
          case 1:
            response = _b2.sent();
            return [4, response.json()];
          case 2:
            data2 = _b2.sent();
            window.open("https://codesandbox.io/p/sandbox/".concat(data2.data.alias, "?file=/").concat(state.activeFile, "&utm-source=storybook-addon"), "_blank");
            return [
              2
              /*return*/
            ];
        }
      });
    });
  };
  return (0, import_jsx_runtime24.jsx)("button", __assign2({ onClick: submit, title: "Export to workspace in CodeSandbox", type: "button" }, props, { children }));
};
var RegularExportButton = function(_a2) {
  var _b2, _c2, _d;
  var children = _a2.children, state = _a2.state, props = __rest2(_a2, ["children", "state"]);
  var formRef = React43.useRef(null);
  var _e = React43.useState(), paramsValues = _e[0], setParamsValues = _e[1];
  React43.useEffect(function debounce2() {
    var timer = setTimeout(function() {
      var params = getFileParameters(state.files, state.environment);
      var searchParams = new URLSearchParams({
        parameters: params,
        query: new URLSearchParams({
          file: state.activeFile,
          utm_medium: "sandpack"
        }).toString()
      });
      setParamsValues(searchParams);
    }, 600);
    return function() {
      clearTimeout(timer);
    };
  }, [state.activeFile, state.environment, state.files]);
  if (((_d = (_c2 = (_b2 = paramsValues === null || paramsValues === void 0 ? void 0 : paramsValues.get) === null || _b2 === void 0 ? void 0 : _b2.call(paramsValues, "parameters")) === null || _c2 === void 0 ? void 0 : _c2.length) !== null && _d !== void 0 ? _d : 0) > 1500) {
    return (0, import_jsx_runtime24.jsxs)("button", __assign2({ onClick: function() {
      var _a3;
      return (_a3 = formRef.current) === null || _a3 === void 0 ? void 0 : _a3.submit();
    }, title: "Open in CodeSandbox", type: "button" }, props, { children: [(0, import_jsx_runtime24.jsxs)("form", { ref: formRef, action: CSB_URL, method: "POST", style: { visibility: "hidden" }, target: "_blank", children: [(0, import_jsx_runtime24.jsx)("input", { name: "environment", type: "hidden", value: state.environment === "node" ? "server" : state.environment }), Array.from(paramsValues, function(_a3) {
      var key2 = _a3[0], value2 = _a3[1];
      return (0, import_jsx_runtime24.jsx)("input", { name: key2, type: "hidden", value: value2 }, key2);
    })] }), children] }));
  }
  return (0, import_jsx_runtime24.jsx)("a", __assign2({ href: "".concat(CSB_URL, "?").concat(paramsValues === null || paramsValues === void 0 ? void 0 : paramsValues.toString(), "&environment=").concat(state.environment === "node" ? "server" : state.environment), rel: "noreferrer noopener", target: "_blank", title: "Open in CodeSandbox" }, props, { children }));
};
var OpenInCodeSandboxButton = function() {
  var classNames14 = useClassNames();
  return (0, import_jsx_runtime24.jsxs)(UnstyledOpenInCodeSandboxButton, { className: classNames14("button", [
    classNames14("icon-standalone"),
    buttonClassName,
    iconStandaloneClassName,
    roundedButtonClassName
  ]), children: [(0, import_jsx_runtime24.jsx)(ExportIcon, {}), (0, import_jsx_runtime24.jsx)("span", { children: "Open Sandbox" })] });
};
var _a$3;
var cubeClassName = css2({
  transform: "translate(-4px, 9px) scale(0.13, 0.13)",
  "*": { position: "absolute", width: "96px", height: "96px" }
});
var wrapperClassName$2 = css2((_a$3 = {
  position: "absolute",
  right: "$space$2",
  bottom: "$space$2",
  zIndex: "$top",
  width: "32px",
  height: "32px",
  borderRadius: "$border$radius"
}, _a$3[".".concat(cubeClassName)] = { display: "flex" }, _a$3[".sp-button.".concat(buttonClassName)] = { display: "none" }, _a$3["&:hover .sp-button.".concat(buttonClassName)] = { display: "flex" }, _a$3["&:hover .sp-button.".concat(buttonClassName, " > span")] = { display: "none" }, _a$3["&:hover .".concat(cubeClassName)] = { display: "none" }, _a$3));
var cubeRotate = keyframes({
  "0%": {
    transform: "rotateX(-25.5deg) rotateY(45deg)"
  },
  "100%": {
    transform: "rotateX(-25.5deg) rotateY(405deg)"
  }
});
var sidesClassNames = css2({
  animation: "".concat(cubeRotate, " 1s linear infinite"),
  animationFillMode: "forwards",
  transformStyle: "preserve-3d",
  transform: "rotateX(-25.5deg) rotateY(45deg)",
  "*": {
    border: "10px solid $colors$clickable",
    borderRadius: "8px",
    background: "$colors$surface1"
  },
  ".top": {
    transform: "rotateX(90deg) translateZ(44px)",
    transformOrigin: "50% 50%"
  },
  ".bottom": {
    transform: "rotateX(-90deg) translateZ(44px)",
    transformOrigin: "50% 50%"
  },
  ".front": {
    transform: "rotateY(0deg) translateZ(44px)",
    transformOrigin: "50% 50%"
  },
  ".back": {
    transform: "rotateY(-180deg) translateZ(44px)",
    transformOrigin: "50% 50%"
  },
  ".left": {
    transform: "rotateY(-90deg) translateZ(44px)",
    transformOrigin: "50% 50%"
  },
  ".right": {
    transform: "rotateY(90deg) translateZ(44px)",
    transformOrigin: "50% 50%"
  }
});
var Loading = function(_a2) {
  var className = _a2.className, showOpenInCodeSandbox = _a2.showOpenInCodeSandbox, props = __rest2(_a2, ["className", "showOpenInCodeSandbox"]);
  var classNames14 = useClassNames();
  return (0, import_jsx_runtime24.jsxs)("div", __assign2({ className: classNames14("cube-wrapper", [wrapperClassName$2, className]), title: "Open in CodeSandbox" }, props, { children: [showOpenInCodeSandbox && (0, import_jsx_runtime24.jsx)(OpenInCodeSandboxButton, {}), (0, import_jsx_runtime24.jsx)("div", { className: classNames14("cube", [cubeClassName]), children: (0, import_jsx_runtime24.jsxs)("div", { className: classNames14("sides", [sidesClassNames]), children: [(0, import_jsx_runtime24.jsx)("div", { className: "top" }), (0, import_jsx_runtime24.jsx)("div", { className: "right" }), (0, import_jsx_runtime24.jsx)("div", { className: "bottom" }), (0, import_jsx_runtime24.jsx)("div", { className: "left" }), (0, import_jsx_runtime24.jsx)("div", { className: "front" }), (0, import_jsx_runtime24.jsx)("div", { className: "back" })] }) })] }));
};
var loadingClassName = css2({
  backgroundColor: "$colors$surface1"
});
var LoadingOverlay = function(_a2) {
  var clientId = _a2.clientId, loading = _a2.loading, className = _a2.className, style = _a2.style, showOpenInCodeSandbox = _a2.showOpenInCodeSandbox, props = __rest2(_a2, ["clientId", "loading", "className", "style", "showOpenInCodeSandbox"]);
  var classNames14 = useClassNames();
  var _b2 = useSandpack().sandpack, runSandpack = _b2.runSandpack, environment = _b2.environment;
  var _c2 = React43.useState(false), shouldShowStdout = _c2[0], setShouldShowStdout = _c2[1];
  var loadingOverlayState = useLoadingOverlayState(clientId, loading);
  var progressMessage = useSandpackPreviewProgress({ clientId });
  var stdoutData = useSandpackShellStdout({ clientId }).logs;
  React43.useEffect(function() {
    var timer;
    if (progressMessage === null || progressMessage === void 0 ? void 0 : progressMessage.includes("Running")) {
      timer = setTimeout(function() {
        setShouldShowStdout(true);
      }, 3e3);
    }
    return function() {
      if (timer) {
        clearTimeout(timer);
      }
    };
  }, [progressMessage]);
  if (loadingOverlayState === "HIDDEN") {
    return null;
  }
  if (loadingOverlayState === "TIMEOUT") {
    return (0, import_jsx_runtime24.jsx)("div", __assign2({ className: classNames14("overlay", [
      classNames14("error"),
      absoluteClassName,
      errorClassName,
      errorBundlerClassName,
      className
    ]) }, props, { children: (0, import_jsx_runtime24.jsxs)("div", { className: classNames14("error-message", [errorMessageClassName]), children: [(0, import_jsx_runtime24.jsx)("p", { className: classNames14("error-title", [css2({ fontWeight: "bold" })]), children: "Couldn't connect to server" }), (0, import_jsx_runtime24.jsx)("div", { className: classNames14("error-message", [errorMessageClassName]), children: (0, import_jsx_runtime24.jsxs)("p", { children: ["This means sandpack cannot connect to the runtime or your network is having some issues. Please check the network tab in your browser and try again. If the problem persists, report it via", " ", (0, import_jsx_runtime24.jsx)("a", { href: "mailto:hello@codesandbox.io?subject=Sandpack Timeout Error", children: "email" }), " ", "or submit an issue on", " ", (0, import_jsx_runtime24.jsx)("a", { href: "https://github.com/codesandbox/sandpack/issues", rel: "noreferrer noopener", target: "_blank", children: "GitHub." })] }) }), (0, import_jsx_runtime24.jsxs)("p", { className: classNames14("error-message", [
      errorMessageClassName({ errorCode: true })
    ]), children: ["ENV: ", environment, (0, import_jsx_runtime24.jsx)("br", {}), "ERROR: TIME_OUT"] }), (0, import_jsx_runtime24.jsx)("div", { children: (0, import_jsx_runtime24.jsxs)("button", { className: classNames14("button", [
      classNames14("icon-standalone"),
      buttonClassName,
      iconStandaloneClassName,
      roundedButtonClassName
    ]), onClick: runSandpack, title: "Restart script", type: "button", children: [(0, import_jsx_runtime24.jsx)(RestartIcon, {}), " ", (0, import_jsx_runtime24.jsx)("span", { children: "Try again" })] }) })] }) }));
  }
  var stillLoading = loadingOverlayState === "LOADING" || loadingOverlayState === "PRE_FADING";
  return (0, import_jsx_runtime24.jsxs)(import_jsx_runtime24.Fragment, { children: [(0, import_jsx_runtime24.jsxs)("div", __assign2({ className: classNames14("overlay", [
    classNames14("loading"),
    absoluteClassName,
    loadingClassName,
    className
  ]), style: __assign2(__assign2({}, style), { opacity: stillLoading ? 1 : 0, transition: "opacity ".concat(FADE_ANIMATION_DURATION, "ms ease-out") }) }, props, { children: [shouldShowStdout && (0, import_jsx_runtime24.jsx)("div", { className: stdoutPreview.toString(), children: (0, import_jsx_runtime24.jsx)(StdoutList, { data: stdoutData }) }), (0, import_jsx_runtime24.jsx)(Loading, { showOpenInCodeSandbox })] })), progressMessage && (0, import_jsx_runtime24.jsx)("div", { className: progressClassName$1.toString(), children: (0, import_jsx_runtime24.jsx)("p", { children: progressMessage }) })] });
};
var stdoutPreview = css2({
  position: "absolute",
  left: 0,
  right: 0,
  bottom: "$space$8",
  overflow: "auto",
  opacity: 0.5,
  overflowX: "hidden"
});
var progressClassName$1 = css2({
  position: "absolute",
  left: "$space$5",
  bottom: "$space$4",
  zIndex: "$top",
  color: "$colors$clickable",
  animation: "".concat(fadeIn, " 150ms ease"),
  fontFamily: "$font$mono",
  fontSize: ".8em",
  width: "75%",
  p: {
    whiteSpace: "nowrap",
    margin: 0,
    textOverflow: "ellipsis",
    overflow: "hidden"
  }
});
var DependenciesProgress = function(_a2) {
  var clientId = _a2.clientId;
  var progressMessage = useSandpackPreviewProgress({
    timeout: 3e3,
    clientId
  });
  if (!progressMessage) {
    return null;
  }
  return (0, import_jsx_runtime24.jsx)("div", { className: progressClassName.toString(), children: (0, import_jsx_runtime24.jsx)("p", { children: progressMessage }) });
};
var progressClassName = css2({
  position: "absolute",
  left: "$space$5",
  bottom: "$space$4",
  zIndex: "$top",
  color: "$colors$clickable",
  animation: "".concat(fadeIn, " 150ms ease"),
  fontFamily: "$font$mono",
  fontSize: ".8em",
  width: "75%",
  p: {
    whiteSpace: "nowrap",
    margin: 0,
    textOverflow: "ellipsis",
    overflow: "hidden"
  }
});
var explorerClassName = css2({
  borderRadius: "0",
  width: "100%",
  padding: 0,
  marginBottom: "$space$2",
  span: {
    textOverflow: "ellipsis",
    whiteSpace: "nowrap",
    overflow: "hidden"
  },
  svg: {
    marginRight: "$space$1"
  }
});
var fileExplorerClassName = css2({
  padding: "$space$3",
  overflow: "auto",
  height: "100%"
});
var splitUrl = function(url) {
  var match = url.match(/(https?:\/\/.*?)\//);
  if (match && match[1]) {
    return [match[1], url.replace(match[1], "")];
  }
  return [url, "/"];
};
var navigatorClassName = css2({
  display: "flex",
  alignItems: "center",
  height: "$layout$headerHeight",
  borderBottom: "1px solid $colors$surface2",
  padding: "$space$3 $space$2",
  background: "$colors$surface1"
});
var inputClassName = css2({
  backgroundColor: "$colors$surface2",
  color: "$colors$clickable",
  padding: "$space$1 $space$3",
  borderRadius: "99999px",
  border: "1px solid $colors$surface2",
  height: "24px",
  lineHeight: "24px",
  fontSize: "inherit",
  outline: "none",
  flex: 1,
  marginLeft: "$space$4",
  width: "0",
  transition: "background $transitions$default",
  "&:hover": {
    backgroundColor: "$colors$surface3"
  },
  "&:focus": {
    backgroundColor: "$surface1",
    border: "1px solid $colors$accent",
    color: "$colors$base"
  }
});
var Navigator = function(_a2) {
  var _b2;
  var clientId = _a2.clientId, onURLChange = _a2.onURLChange, className = _a2.className, startRoute = _a2.startRoute, props = __rest2(_a2, ["clientId", "onURLChange", "className", "startRoute"]);
  var _c2 = React43.useState(""), baseUrl = _c2[0], setBaseUrl = _c2[1];
  var _d = useSandpack(), sandpack = _d.sandpack, dispatch = _d.dispatch, listen = _d.listen;
  var _e = React43.useState((_b2 = startRoute !== null && startRoute !== void 0 ? startRoute : sandpack.startRoute) !== null && _b2 !== void 0 ? _b2 : "/"), relativeUrl = _e[0], setRelativeUrl = _e[1];
  var _f = React43.useState(false), backEnabled = _f[0], setBackEnabled = _f[1];
  var _g = React43.useState(false), forwardEnabled = _g[0], setForwardEnabled = _g[1];
  var classNames14 = useClassNames();
  React43.useEffect(function() {
    var unsub = listen(function(message) {
      if (message.type === "urlchange") {
        var url = message.url, back = message.back, forward = message.forward;
        var _a3 = splitUrl(url), newBaseUrl = _a3[0], newRelativeUrl = _a3[1];
        setBaseUrl(newBaseUrl);
        setRelativeUrl(newRelativeUrl);
        setBackEnabled(back);
        setForwardEnabled(forward);
      }
    }, clientId);
    return function() {
      return unsub();
    };
  }, []);
  var handleInputChange = function(e2) {
    var path = e2.target.value.startsWith("/") ? e2.target.value : "/".concat(e2.target.value);
    setRelativeUrl(path);
  };
  var handleKeyDown = function(e2) {
    if (e2.code === "Enter") {
      e2.preventDefault();
      e2.stopPropagation();
      if (typeof onURLChange === "function") {
        onURLChange(baseUrl + e2.currentTarget.value);
      }
    }
  };
  var handleRefresh = function() {
    dispatch({ type: "refresh" });
  };
  var handleBack = function() {
    dispatch({ type: "urlback" });
  };
  var handleForward = function() {
    dispatch({ type: "urlforward" });
  };
  var buttonsClassNames = classNames14("button", [
    classNames14("icon"),
    buttonClassName,
    iconClassName,
    css2({
      minWidth: "$space$6",
      justifyContent: "center"
    })
  ]);
  return (0, import_jsx_runtime24.jsxs)("div", __assign2({ className: classNames14("navigator", [navigatorClassName, className]) }, props, { children: [(0, import_jsx_runtime24.jsx)("button", { "aria-label": "Go back one page", className: buttonsClassNames, disabled: !backEnabled, onClick: handleBack, type: "button", children: (0, import_jsx_runtime24.jsx)(BackwardIcon, {}) }), (0, import_jsx_runtime24.jsx)("button", { "aria-label": "Go forward one page", className: buttonsClassNames, disabled: !forwardEnabled, onClick: handleForward, type: "button", children: (0, import_jsx_runtime24.jsx)(ForwardIcon, {}) }), (0, import_jsx_runtime24.jsx)("button", { "aria-label": "Refresh page", className: buttonsClassNames, onClick: handleRefresh, type: "button", children: (0, import_jsx_runtime24.jsx)(RefreshIcon, {}) }), (0, import_jsx_runtime24.jsx)("input", { "aria-label": "Current Sandpack URL", className: classNames14("input", [inputClassName]), name: "Current Sandpack URL", onChange: handleInputChange, onKeyDown: handleKeyDown, type: "text", value: relativeUrl })] }));
};
var _a$2;
var previewClassName = css2((_a$2 = {
  flex: 1,
  display: "flex",
  flexDirection: "column",
  background: "white",
  overflow: "auto",
  position: "relative"
}, _a$2[".".concat(THEME_PREFIX, "-bridge-frame")] = {
  border: 0,
  position: "absolute",
  left: "$space$2",
  bottom: "$space$2",
  zIndex: "$top",
  height: 12,
  width: "30%",
  mixBlendMode: "multiply",
  pointerEvents: "none"
}, _a$2));
var previewIframe = css2({
  border: "0",
  outline: "0",
  width: "100%",
  height: "100%",
  minHeight: "160px",
  maxHeight: "2000px",
  flex: 1
});
var previewActionsClassName$1 = css2({
  display: "flex",
  position: "absolute",
  bottom: "$space$2",
  right: "$space$2",
  zIndex: "$overlay",
  gap: "$space$2"
});
var SandpackPreview = React43.forwardRef(function(_a2, ref2) {
  var _b2 = _a2.showNavigator, showNavigator = _b2 === void 0 ? false : _b2, _c2 = _a2.showRefreshButton, showRefreshButton = _c2 === void 0 ? true : _c2, _d = _a2.showOpenInCodeSandbox, showOpenInCodeSandbox = _d === void 0 ? true : _d, _e = _a2.showSandpackErrorOverlay, showSandpackErrorOverlay = _e === void 0 ? true : _e;
  _a2.showOpenNewtab;
  var _g = _a2.showRestartButton, showRestartButton = _g === void 0 ? true : _g, _h = _a2.actionsChildren, actionsChildren = _h === void 0 ? (0, import_jsx_runtime24.jsx)(import_jsx_runtime24.Fragment, {}) : _h, children = _a2.children, className = _a2.className, _j = _a2.startRoute, startRoute = _j === void 0 ? "/" : _j, props = __rest2(_a2, ["showNavigator", "showRefreshButton", "showOpenInCodeSandbox", "showSandpackErrorOverlay", "showOpenNewtab", "showRestartButton", "actionsChildren", "children", "className", "startRoute"]);
  var _k = useSandpackClient({ startRoute }), sandpack = _k.sandpack, listen = _k.listen, iframe = _k.iframe, getClient = _k.getClient, clientId = _k.clientId, dispatch = _k.dispatch;
  var _l = React43.useState(null), iframeComputedHeight = _l[0], setComputedAutoHeight = _l[1];
  var status = sandpack.status;
  var refresh = useSandpackNavigation(clientId).refresh;
  var restart = useSandpackShell(clientId).restart;
  var classNames14 = useClassNames();
  React43.useEffect(function() {
    var unsubscribe = listen(function(message) {
      if (message.type === "resize") {
        setComputedAutoHeight(message.height);
      }
    });
    return unsubscribe;
  }, []);
  React43.useImperativeHandle(ref2, function() {
    return {
      clientId,
      getClient
    };
  }, [getClient, clientId]);
  var handleNewURL = function(newUrl) {
    if (!iframe.current) {
      return;
    }
    iframe.current.src = newUrl;
  };
  return (0, import_jsx_runtime24.jsxs)(SandpackStack, __assign2({ className: classNames14("preview", [className]) }, props, { children: [showNavigator && (0, import_jsx_runtime24.jsx)(Navigator, { clientId, onURLChange: handleNewURL, startRoute }), (0, import_jsx_runtime24.jsxs)("div", { className: classNames14("preview-container", [previewClassName]), children: [(0, import_jsx_runtime24.jsx)("iframe", { ref: iframe, className: classNames14("preview-iframe", [previewIframe]), style: {
    // set height based on the content only in auto mode
    // and when the computed height was returned by the bundler
    height: iframeComputedHeight ? iframeComputedHeight : void 0
  }, title: "Sandpack Preview" }), (0, import_jsx_runtime24.jsxs)("div", { className: classNames14("preview-actions", [previewActionsClassName$1]), children: [actionsChildren, showRestartButton && sandpack.environment === "node" && (0, import_jsx_runtime24.jsx)(RoundedButton, { onClick: restart, children: (0, import_jsx_runtime24.jsx)(RestartIcon, {}) }), !showNavigator && showRefreshButton && status === "running" && (0, import_jsx_runtime24.jsx)(RoundedButton, { onClick: refresh, children: (0, import_jsx_runtime24.jsx)(RefreshIcon, {}) }), sandpack.teamId && (0, import_jsx_runtime24.jsx)("button", { className: classNames14("button", [
    classNames14("icon-standalone"),
    buttonClassName,
    iconStandaloneClassName,
    roundedButtonClassName
  ]), onClick: function() {
    return dispatch({ type: "sign-out" });
  }, title: "Sign out", type: "button", children: (0, import_jsx_runtime24.jsx)(SignOutIcon, {}) }), showOpenInCodeSandbox && (0, import_jsx_runtime24.jsx)(OpenInCodeSandboxButton, {})] }), (0, import_jsx_runtime24.jsx)(LoadingOverlay, { clientId, showOpenInCodeSandbox }), showSandpackErrorOverlay && (0, import_jsx_runtime24.jsx)(ErrorOverlay, {}), children] })] }));
});
var _a$1;
var transpiledCodeClassName = css2((_a$1 = {
  display: "flex",
  flexDirection: "column",
  width: "100%",
  position: "relative",
  overflow: "auto",
  minHeight: "160px",
  flex: 1
}, _a$1[".".concat(THEME_PREFIX, "-stack")] = {
  height: "100%"
}, _a$1));
var wrapperClassName$1 = css2({
  justifyContent: "space-between",
  borderBottom: "1px solid $colors$surface2",
  padding: "0 $space$2",
  fontFamily: "$font$mono",
  height: "$layout$headerHeight",
  minHeight: "$layout$headerHeight",
  overflowX: "auto",
  whiteSpace: "nowrap"
});
var flexClassName$1 = css2({
  display: "flex",
  flexDirection: "row",
  alignItems: "center",
  gap: "$space$2"
});
var color3 = css2({
  variants: {
    status: {
      pass: { color: "var(--test-pass)" },
      fail: { color: "var(--test-fail)" },
      skip: { color: "var(--test-skip)" },
      title: { color: "var(--test-title)" }
    }
  }
});
var passTextClassName = color3({ status: "pass" });
var failTextClassName = color3({ status: "fail" });
var skipTextClassName = color3({ status: "skip" });
var titleTextClassName = color3({ status: "title" });
var background = css2({
  variants: {
    status: {
      pass: { background: "var(--test-pass)", color: "$colors$surface1" },
      fail: { background: "var(--test-fail)", color: "$colors$surface1" },
      run: { background: "var(--test-run)", color: "$colors$surface1" }
    }
  }
});
var runBackgroundClassName = background({ status: "run" });
var passBackgroundClassName = background({ status: "pass" });
var failBackgroundClassName = background({ status: "fail" });
var testContainerClassName = css2({
  marginLeft: "$space$4"
});
var containerClassName$4 = css2({
  marginBottom: "$space$2",
  color: "$colors$clickable"
});
var testClassName = css2({
  marginBottom: "$space$2",
  color: "$colors$hover"
});
var durationClassName = css2({
  marginLeft: "$space$2"
});
var gapRightClassName = css2({
  marginRight: "$space$2"
});
var nameClassName = css2({
  color: "$colors$hover",
  marginBottom: "$space$2"
});
var containerClassName$3 = css2({
  marginLeft: "$space$4"
});
var containerClassName$2 = css2({
  color: "$colors$hover",
  fontSize: "$font$size",
  padding: "$space$2",
  whiteSpace: "pre-wrap"
});
var fileContainer = css2({
  display: "flex",
  flexDirection: "row",
  alignItems: "center",
  marginBottom: "$space$2"
});
var gapBottomClassName$1 = css2({
  marginBottom: "$space$2"
});
var failTestClassName = css2({
  fontWeight: "bold"
});
var labelClassName$1 = css2({
  borderRadius: "calc($border$radius / 2)"
});
var specLabelClassName = css2({
  padding: "$space$1 $space$2",
  fontFamily: "$font$mono",
  textTransform: "uppercase",
  marginRight: "$space$2"
});
var filePathButtonClassName = css2({
  fontFamily: "$font$mono",
  cursor: "pointer",
  display: "inline-block"
});
var filePathClassName = css2({
  color: "$colors$clickable",
  textDecorationStyle: "dotted",
  textDecorationLine: "underline"
});
var fileNameClassName = css2({
  color: "$colors$hover",
  fontWeight: "bold",
  textDecorationStyle: "dotted",
  textDecorationLine: "underline"
});
var gapBottomClassName = css2({
  marginBottom: "$space$2"
});
var labelClassName = css2({
  fontWeight: "bold",
  color: "$colors$hover",
  whiteSpace: "pre-wrap"
});
var containerClassName$1 = css2({
  fontWeight: "bold",
  color: "$colors$clickable"
});
var previewActionsClassName = css2({
  display: "flex",
  position: "absolute",
  bottom: "$space$2",
  right: "$space$2",
  zIndex: "$overlay",
  "> *": { marginLeft: "$space$2" }
});
var containerClassName = css2({
  padding: "$space$4",
  height: "100%",
  overflow: "auto",
  display: "flex",
  flexDirection: "column",
  position: "relative",
  fontFamily: "$font$mono"
});
var fileErrorContainerClassName = css2({
  fontWeight: "bold",
  color: "$colors$base"
});
var SYNTAX_ERROR_PATTERN = ["SyntaxError: ", "Error in sandbox:"];
var CLEAR_LOG = {
  id: "random",
  method: "clear",
  data: ["Console was cleared"]
};
var TRANSFORMED_TYPE_KEY = "@t";
var TRANSFORMED_TYPE_KEY_ALTERNATE = "#@t";
var CIRCULAR_REF_KEY = "@r";
var MAX_LENGTH_STRING = 1e4;
var MAX_NEST_LEVEL = 2;
var MAX_KEYS = 400;
var MAX_MESSAGE_COUNT = MAX_KEYS * 2;
var GLOBAL = function getGlobal() {
  if (typeof globalThis !== "undefined")
    return globalThis;
  if (typeof window !== "undefined")
    return window;
  if (typeof global !== "undefined")
    return global;
  if (typeof self !== "undefined")
    return self;
  throw Error("Unable to locate global object");
}();
var ARRAY_BUFFER_SUPPORTED = typeof ArrayBuffer === "function";
var MAP_SUPPORTED = typeof Map === "function";
var SET_SUPPORTED = typeof Set === "function";
var Arithmetic;
(function(Arithmetic2) {
  Arithmetic2[Arithmetic2["infinity"] = 0] = "infinity";
  Arithmetic2[Arithmetic2["minusInfinity"] = 1] = "minusInfinity";
  Arithmetic2[Arithmetic2["minusZero"] = 2] = "minusZero";
})(Arithmetic || (Arithmetic = {}));
var transformers = {
  Arithmetic: function(data2) {
    if (data2 === Arithmetic.infinity)
      return Infinity;
    if (data2 === Arithmetic.minusInfinity)
      return -Infinity;
    if (data2 === Arithmetic.minusZero)
      return -0;
    return data2;
  },
  HTMLElement: function(data2) {
    var sandbox = document.implementation.createHTMLDocument("sandbox");
    try {
      var element2 = sandbox.createElement(data2.tagName);
      element2.innerHTML = data2.innerHTML;
      for (var _i = 0, _a2 = Object.keys(data2.attributes); _i < _a2.length; _i++) {
        var attribute = _a2[_i];
        try {
          element2.setAttribute(attribute, data2.attributes[attribute]);
        } catch (_b2) {
        }
      }
      return element2;
    } catch (e2) {
      return data2;
    }
  },
  Function: function(data2) {
    var tempFun = function() {
    };
    Object.defineProperty(tempFun, "toString", {
      value: function() {
        return "function ".concat(data2.name, "() {").concat(data2.body, "}");
      }
    });
    return tempFun;
  },
  "[[NaN]]": function() {
    return NaN;
  },
  "[[undefined]]": function() {
    return void 0;
  },
  "[[Date]]": function(val) {
    var date = /* @__PURE__ */ new Date();
    date.setTime(val);
    return date;
  },
  "[[RegExp]]": function(val) {
    return new RegExp(val.src, val.flags);
  },
  "[[Error]]": function(val) {
    var Ctor = GLOBAL[val.name] || Error;
    var err = new Ctor(val.message);
    err.stack = val.stack;
    return err;
  },
  "[[ArrayBuffer]]": function(val) {
    if (ARRAY_BUFFER_SUPPORTED) {
      var buffer = new ArrayBuffer(val.length);
      var view = new Int8Array(buffer);
      view.set(val);
      return buffer;
    }
    return val;
  },
  "[[TypedArray]]": function(val) {
    return typeof GLOBAL[val.ctorName] === "function" ? new GLOBAL[val.ctorName](val.arr) : val.arr;
  },
  "[[Map]]": function(val) {
    if (MAP_SUPPORTED) {
      var map5 = /* @__PURE__ */ new Map();
      for (var i3 = 0; i3 < val.length; i3 += 2)
        map5.set(val[i3], val[i3 + 1]);
      return map5;
    }
    var kvArr = [];
    for (var j3 = 0; j3 < val.length; j3 += 2)
      kvArr.push([val[i3], val[i3 + 1]]);
    return kvArr;
  },
  "[[Set]]": function(val) {
    if (SET_SUPPORTED) {
      var set3 = /* @__PURE__ */ new Set();
      for (var i3 = 0; i3 < val.length; i3++)
        set3.add(val[i3]);
      return set3;
    }
    return val;
  }
};
var formatSymbols = function(message) {
  var _a2;
  if (typeof message === "string" || typeof message === "number" || message === null) {
    return message;
  } else if (Array.isArray(message)) {
    return message.map(formatSymbols);
  } else if (typeof message == "object" && TRANSFORMED_TYPE_KEY in message) {
    var type2 = message[TRANSFORMED_TYPE_KEY];
    var transform = transformers[type2];
    return transform(message.data);
  } else if (typeof message == "object" && TRANSFORMED_TYPE_KEY_ALTERNATE in message) {
    var type2 = message[TRANSFORMED_TYPE_KEY_ALTERNATE];
    var transform = transformers[type2];
    return transform(message.data);
  } else if (typeof message == "object" && ((_a2 = message.constructor) === null || _a2 === void 0 ? void 0 : _a2.name) === "NodeList") {
    var NodeList_1 = {};
    Object.entries(message).forEach(function(_a3) {
      var key2 = _a3[0], value2 = _a3[1];
      NodeList_1[key2] = formatSymbols(value2);
    });
    return NodeList_1;
  }
  return message;
};
var arrayToString = function(output, references, level) {
  var mergeArray = output.reduce(function(acc, curr, index3) {
    return "".concat(acc).concat(index3 ? ", " : "").concat(fromConsoleToString(curr, references, level));
  }, "");
  return "[".concat(mergeArray, "]");
};
var objectToString = function(output, references, level) {
  var constructorName = output.constructor.name !== "Object" ? "".concat(output.constructor.name, " ") : "";
  if (level > MAX_NEST_LEVEL) {
    return constructorName;
  }
  var entries2 = Object.entries(output);
  var formattedObject = Object.entries(output).reduce(function(acc, _a2, index3) {
    var key2 = _a2[0], value2 = _a2[1];
    var comma = index3 === 0 ? "" : ", ";
    var breakLine = entries2.length > 10 ? "\n  " : "";
    var formatted = fromConsoleToString(value2, references, level);
    if (index3 === MAX_KEYS) {
      return acc + breakLine + "...";
    } else if (index3 > MAX_KEYS) {
      return acc;
    }
    return acc + "".concat(comma).concat(breakLine).concat(key2, ": ") + formatted;
  }, "");
  return "".concat(constructorName, "{ ").concat(formattedObject).concat(entries2.length > 10 ? "\n" : " ", "}");
};
var fromConsoleToString = function(message, references, level) {
  var _a2;
  if (level === void 0) {
    level = 0;
  }
  try {
    var output_1 = formatSymbols(message);
    if (Array.isArray(output_1)) {
      return arrayToString(output_1, references, level + 1);
    }
    switch (typeof output_1) {
      case "string":
        return '"'.concat(output_1, '"').slice(0, MAX_LENGTH_STRING);
      case "number":
      case "function":
      case "symbol":
        return output_1.toString();
      case "boolean":
        return String(output_1);
      case "undefined":
        return "undefined";
      case "object":
      default:
        if (output_1 instanceof RegExp || output_1 instanceof Error || output_1 instanceof Date) {
          return output_1.toString();
        }
        if (output_1 === null) {
          return String(null);
        }
        if (output_1 instanceof HTMLElement) {
          return output_1.outerHTML.slice(0, MAX_LENGTH_STRING);
        }
        if (Object.entries(output_1).length === 0) {
          return "{}";
        }
        if (CIRCULAR_REF_KEY in output_1) {
          if (level > MAX_NEST_LEVEL) {
            return "Unable to print information";
          }
          var newMessage = references[output_1[CIRCULAR_REF_KEY]];
          return fromConsoleToString(newMessage, references, level + 1);
        }
        if (((_a2 = output_1.constructor) === null || _a2 === void 0 ? void 0 : _a2.name) === "NodeList") {
          var length_1 = output_1.length;
          var nodes = new Array(length_1).fill(null).map(function(_2, index3) {
            return fromConsoleToString(output_1[index3], references);
          });
          return "NodeList(".concat(output_1.length, ")[").concat(nodes, "]");
        }
        return objectToString(output_1, references, level + 1);
    }
  } catch (_b2) {
    return "Unable to print information";
  }
};
var getType = function(message) {
  switch (message) {
    case "warn":
      return "warning";
    case "clear":
      return "clear";
    case "error":
      return "error";
    case "log":
    case "info":
    default:
      return "info";
  }
};
var _a;
var ConsoleList = function(_a2) {
  var data2 = _a2.data;
  var classNames14 = useClassNames();
  return (0, import_jsx_runtime24.jsx)(import_jsx_runtime24.Fragment, { children: data2.map(function(_a3, logIndex, references) {
    var data3 = _a3.data, id = _a3.id, method = _a3.method;
    if (!data3)
      return null;
    if (Array.isArray(data3)) {
      return (0, import_jsx_runtime24.jsx)(React43.Fragment, { children: data3.map(function(msg, msgIndex) {
        var fixReferences = references.slice(logIndex, references.length);
        return (0, import_jsx_runtime24.jsx)("div", { className: classNames14("console-item", [
          consoleItemClassName({ variant: getType(method) })
        ]), children: (0, import_jsx_runtime24.jsx)(CodeMirror, { code: method === "clear" ? msg : fromConsoleToString(msg, fixReferences), fileType: "js", initMode: "user-visible", showReadOnly: false, readOnly: true, wrapContent: true }) }, "".concat(id, "-").concat(msgIndex));
      }) }, id);
    }
    return null;
  }) });
};
var consoleItemClassName = css2((_a = {
  width: "100%",
  padding: "$space$3 $space$2",
  fontSize: ".8em",
  position: "relative",
  "&:not(:first-child):after": {
    content: "",
    position: "absolute",
    top: 0,
    left: 0,
    right: 0,
    height: 1,
    background: "$colors$surface3"
  },
  /**
   * Editor reset
   */
  ".sp-cm": {
    padding: 0
  },
  ".cm-editor": {
    background: "none"
  },
  ".cm-content": {
    padding: 0
  }
}, _a[".".concat(THEME_PREFIX, "-pre-placeholder")] = {
  margin: "0 !important",
  fontSize: "1em"
}, _a.variants = {
  variant: {
    error: {
      color: "$colors$error",
      background: "$colors$errorSurface",
      "&:not(:first-child):after": {
        background: "$colors$error",
        opacity: 0.07
      }
    },
    warning: {
      color: "$colors$warning",
      background: "$colors$warningSurface",
      "&:not(:first-child):after": {
        background: "$colors$warning",
        opacity: 0.07
      }
    },
    clear: {
      fontStyle: "italic"
    },
    info: {}
  }
}, _a));
var wrapperClassName = css2({
  justifyContent: "space-between",
  borderBottom: "1px solid $colors$surface2",
  padding: "0 $space$2",
  fontFamily: "$font$mono",
  height: "$layout$headerHeight",
  minHeight: "$layout$headerHeight",
  overflowX: "auto",
  whiteSpace: "nowrap"
});
var flexClassName = css2({
  display: "flex",
  flexDirection: "row",
  alignItems: "center",
  gap: "$space$2"
});
var Header = function(_a2) {
  var currentTab = _a2.currentTab, setCurrentTab = _a2.setCurrentTab, node2 = _a2.node;
  var classNames14 = useClassNames();
  var buttonsClassName = classNames14("console-header-button", [
    buttonClassName,
    roundedButtonClassName,
    css2({ padding: "$space$1 $space$3" })
  ]);
  return (0, import_jsx_runtime24.jsxs)("div", { className: classNames14("console-header", [
    wrapperClassName,
    flexClassName
  ]), children: [(0, import_jsx_runtime24.jsxs)("p", { className: classNames14("console-header-title", [
    css2({
      lineHeight: 1,
      margin: 0,
      color: "$colors$base",
      fontSize: "$font$size",
      display: "flex",
      alignItems: "center",
      gap: "$space$2"
    })
  ]), children: [(0, import_jsx_runtime24.jsx)(ConsoleIcon, {}), (0, import_jsx_runtime24.jsx)("span", { children: "Terminal" })] }), node2 && (0, import_jsx_runtime24.jsxs)("div", { className: classNames14("console-header-actions", [flexClassName]), children: [(0, import_jsx_runtime24.jsx)("button", { className: buttonsClassName, "data-active": currentTab === "server", onClick: function() {
    return setCurrentTab("server");
  }, type: "button", children: "Server" }), (0, import_jsx_runtime24.jsx)("button", { className: buttonsClassName, "data-active": currentTab === "client", onClick: function() {
    return setCurrentTab("client");
  }, type: "button", children: "Client" })] })] });
};
var useSandpackConsole = function(_a2) {
  var clientId = _a2.clientId, _b2 = _a2.maxMessageCount, maxMessageCount = _b2 === void 0 ? MAX_MESSAGE_COUNT : _b2, _c2 = _a2.showSyntaxError, showSyntaxError = _c2 === void 0 ? false : _c2, _d = _a2.resetOnPreviewRestart, resetOnPreviewRestart = _d === void 0 ? false : _d;
  var _e = React43.useState([]), logs = _e[0], setLogs = _e[1];
  var listen = useSandpack().listen;
  React43.useEffect(function() {
    var unsubscribe = listen(function(message) {
      if (resetOnPreviewRestart && message.type === "start") {
        setLogs([]);
      } else if (message.type === "console" && message.codesandbox) {
        var payloadLog = Array.isArray(message.log) ? message.log : [message.log];
        if (payloadLog.find(function(_a3) {
          var method = _a3.method;
          return method === "clear";
        })) {
          return setLogs([CLEAR_LOG]);
        }
        var logsMessages_1 = showSyntaxError ? payloadLog : payloadLog.filter(function(messageItem) {
          var _a3, _b3, _c3;
          var messagesWithoutSyntaxErrors = (_c3 = (_b3 = (_a3 = messageItem === null || messageItem === void 0 ? void 0 : messageItem.data) === null || _a3 === void 0 ? void 0 : _a3.filter) === null || _b3 === void 0 ? void 0 : _b3.call(_a3, function(dataItem) {
            if (typeof dataItem !== "string")
              return true;
            var matches = SYNTAX_ERROR_PATTERN.filter(function(lookFor) {
              return dataItem.startsWith(lookFor);
            });
            return matches.length === 0;
          })) !== null && _c3 !== void 0 ? _c3 : [];
          return messagesWithoutSyntaxErrors.length > 0;
        });
        if (!logsMessages_1)
          return;
        setLogs(function(prev) {
          var messages2 = __spreadArray2(__spreadArray2([], prev, true), logsMessages_1, true).filter(function(value2, index3, self2) {
            return index3 === self2.findIndex(function(s2) {
              return s2.id === value2.id;
            });
          });
          while (messages2.length > maxMessageCount) {
            messages2.shift();
          }
          return messages2;
        });
      }
    }, clientId);
    return unsubscribe;
  }, [showSyntaxError, maxMessageCount, clientId, resetOnPreviewRestart]);
  return { logs, reset: function() {
    return setLogs([]);
  } };
};
var SandpackConsole = React43.forwardRef(function(_a2, ref2) {
  var _b2;
  var _c2 = _a2.showHeader, showHeader = _c2 === void 0 ? true : _c2, _d = _a2.showSyntaxError, showSyntaxError = _d === void 0 ? false : _d, maxMessageCount = _a2.maxMessageCount, onLogsChange = _a2.onLogsChange, className = _a2.className;
  _a2.showSetupProgress;
  var _f = _a2.showResetConsoleButton, showResetConsoleButton = _f === void 0 ? true : _f, _g = _a2.showRestartButton, showRestartButton = _g === void 0 ? true : _g, _h = _a2.resetOnPreviewRestart, resetOnPreviewRestart = _h === void 0 ? false : _h, _j = _a2.actionsChildren, actionsChildren = _j === void 0 ? (0, import_jsx_runtime24.jsx)(import_jsx_runtime24.Fragment, {}) : _j, _k = _a2.standalone, standalone = _k === void 0 ? false : _k, props = __rest2(_a2, ["showHeader", "showSyntaxError", "maxMessageCount", "onLogsChange", "className", "showSetupProgress", "showResetConsoleButton", "showRestartButton", "resetOnPreviewRestart", "actionsChildren", "standalone"]);
  var environment = useSandpack().sandpack.environment;
  var _l = useSandpackClient(), iframe = _l.iframe, internalClientId = _l.clientId;
  var restart = useSandpackShell().restart;
  var _m = React43.useState(environment === "node" ? "server" : "client"), currentTab = _m[0], setCurrentTab = _m[1];
  var clientId = standalone ? internalClientId : void 0;
  var _o = useSandpackConsole({
    maxMessageCount,
    showSyntaxError,
    resetOnPreviewRestart,
    clientId
  }), consoleData = _o.logs, resetConsole = _o.reset;
  var _p = useSandpackShellStdout({
    maxMessageCount,
    resetOnPreviewRestart,
    clientId
  }), stdoutData = _p.logs, resetStdout = _p.reset;
  var wrapperRef = React43.useRef(null);
  React43.useEffect(function() {
    onLogsChange === null || onLogsChange === void 0 ? void 0 : onLogsChange(consoleData);
    if (wrapperRef.current) {
      wrapperRef.current.scrollTop = wrapperRef.current.scrollHeight;
    }
  }, [onLogsChange, consoleData, stdoutData, currentTab]);
  var isServerTab = currentTab === "server";
  var isNodeEnvironment = environment === "node";
  React43.useImperativeHandle(ref2, function() {
    return {
      reset: function() {
        resetConsole();
        resetStdout();
      }
    };
  });
  var classNames14 = useClassNames();
  return (0, import_jsx_runtime24.jsxs)(SandpackStack, __assign2({ className: classNames14("console", [
    css2((_b2 = {
      height: "100%",
      background: "$surface1",
      iframe: { display: "none" }
    }, _b2[".".concat(THEME_PREFIX, "-bridge-frame")] = {
      display: "block",
      border: 0,
      position: "absolute",
      left: "$space$2",
      bottom: "$space$2",
      zIndex: "$top",
      height: 12,
      width: "30%",
      mixBlendMode: "multiply",
      pointerEvents: "none"
    }, _b2)),
    className
  ]) }, props, { children: [showHeader && isNodeEnvironment && (0, import_jsx_runtime24.jsx)(Header, { currentTab, node: isNodeEnvironment, setCurrentTab }), (0, import_jsx_runtime24.jsx)("div", { ref: wrapperRef, className: classNames14("console-list", [
    css2({ overflow: "auto", scrollBehavior: "smooth" })
  ]), children: isServerTab ? (0, import_jsx_runtime24.jsx)(StdoutList, { data: stdoutData }) : (0, import_jsx_runtime24.jsx)(ConsoleList, { data: consoleData }) }), (0, import_jsx_runtime24.jsxs)("div", { className: classNames14("console-actions", [
    css2({
      position: "absolute",
      bottom: "$space$2",
      right: "$space$2",
      display: "flex",
      gap: "$space$2"
    })
  ]), children: [actionsChildren, showRestartButton && isServerTab && (0, import_jsx_runtime24.jsx)(RoundedButton, { onClick: function() {
    restart();
    resetConsole();
    resetStdout();
  }, children: (0, import_jsx_runtime24.jsx)(RestartIcon, {}) }), showResetConsoleButton && (0, import_jsx_runtime24.jsx)(RoundedButton, { onClick: function() {
    if (currentTab === "client") {
      resetConsole();
    } else {
      resetStdout();
    }
  }, children: (0, import_jsx_runtime24.jsx)(CleanIcon, {}) })] }), standalone && (0, import_jsx_runtime24.jsxs)(import_jsx_runtime24.Fragment, { children: [(0, import_jsx_runtime24.jsx)(DependenciesProgress, { clientId }), (0, import_jsx_runtime24.jsx)("iframe", { ref: iframe })] })] }));
});
var dragHandler = css2({
  position: "absolute",
  zIndex: "$top",
  variants: {
    direction: {
      vertical: {
        right: 0,
        left: 0,
        height: 10,
        cursor: "ns-resize"
      },
      horizontal: {
        top: 0,
        bottom: 0,
        width: 10,
        cursor: "ew-resize"
      }
    }
  },
  "@media screen and (max-width: 768px)": {
    display: "none"
  }
});
var buttonCounter = css2({
  position: "relative",
  strong: {
    background: "$colors$clickable",
    color: "$colors$surface1",
    minWidth: 12,
    height: 12,
    padding: "0 2px",
    borderRadius: 12,
    fontSize: 8,
    lineHeight: "12px",
    position: "absolute",
    top: 0,
    right: 0,
    fontWeight: "normal"
  }
});
var consoleWrapper = css2({
  width: "100%",
  overflow: "hidden"
});
var rtlLayoutClassName = css2({
  flexDirection: "row-reverse",
  "@media screen and (max-width: 768px)": {
    flexFlow: "wrap-reverse !important",
    flexDirection: "initial"
  }
});

// node_modules/@mdxeditor/editor/dist/plugins/sandpack/SandpackEditor.js
var import_react49 = __toESM(require_react(), 1);

// node_modules/@mdxeditor/editor/dist/plugins/sandpack/useCodeMirrorRef.js
var import_react48 = __toESM(require_react(), 1);
function useCodeMirrorRef(nodeKey, editorType, language2, focusEmitter) {
  const activeEditor2 = E(activeEditor$);
  const setEditorInFocus = A(editorInFocus$);
  const codeMirrorRef = import_react48.default.useRef(null);
  const { lexicalNode } = useCodeBlockEditorContext();
  const atBottom = import_react48.default.useRef(false);
  const atTop = import_react48.default.useRef(false);
  const onFocusHandler = import_react48.default.useCallback(() => {
    setEditorInFocus({
      editorType,
      rootNode: lexicalNode
    });
  }, [editorType, lexicalNode, setEditorInFocus]);
  const onKeyDownHandler = import_react48.default.useCallback(
    (e2) => {
      var _a2, _b2, _c2, _d, _e, _f;
      if (e2.key === "ArrowDown") {
        const state = (_b2 = (_a2 = codeMirrorRef.current) == null ? void 0 : _a2.getCodemirror()) == null ? void 0 : _b2.state;
        if (state) {
          const docLength = state.doc.length;
          const selectionEnd = state.selection.ranges[0].to;
          if (docLength === selectionEnd) {
            if (!atBottom.current) {
              atBottom.current = true;
            } else {
              activeEditor2 == null ? void 0 : activeEditor2.update(() => {
                var _a22, _b22;
                const node2 = $getNodeByKey(nodeKey);
                const nextSibling = node2.getNextSibling();
                if (nextSibling) {
                  (_b22 = (_a22 = codeMirrorRef.current) == null ? void 0 : _a22.getCodemirror()) == null ? void 0 : _b22.contentDOM.blur();
                  node2.selectNext();
                } else {
                  node2.insertAfter($createParagraphNode());
                }
              });
              atBottom.current = false;
            }
          }
        }
      } else if (e2.key === "ArrowUp") {
        const state = (_d = (_c2 = codeMirrorRef.current) == null ? void 0 : _c2.getCodemirror()) == null ? void 0 : _d.state;
        if (state) {
          const selectionStart = state.selection.ranges[0].from;
          if (selectionStart === 0) {
            if (!atTop.current) {
              atTop.current = true;
            } else {
              activeEditor2 == null ? void 0 : activeEditor2.update(() => {
                var _a22, _b22;
                const node2 = $getNodeByKey(nodeKey);
                const previousSibling = node2.getPreviousSibling();
                if (previousSibling) {
                  (_b22 = (_a22 = codeMirrorRef.current) == null ? void 0 : _a22.getCodemirror()) == null ? void 0 : _b22.contentDOM.blur();
                  node2.selectPrevious();
                }
              });
              atTop.current = false;
            }
          }
        }
      } else if (e2.key === "Enter") {
        e2.stopPropagation();
      } else if (e2.key === "Backspace" || e2.key === "Delete") {
        const state = (_f = (_e = codeMirrorRef.current) == null ? void 0 : _e.getCodemirror()) == null ? void 0 : _f.state;
        const docLength = state == null ? void 0 : state.doc.length;
        if (docLength === 0) {
          activeEditor2 == null ? void 0 : activeEditor2.update(() => {
            const node2 = $getNodeByKey(nodeKey);
            node2.remove();
          });
        }
      }
    },
    [activeEditor2, nodeKey]
  );
  import_react48.default.useEffect(() => {
    const codeMirror = codeMirrorRef.current;
    setTimeout(() => {
      var _a2, _b2;
      (_a2 = codeMirror == null ? void 0 : codeMirror.getCodemirror()) == null ? void 0 : _a2.contentDOM.addEventListener("focus", onFocusHandler);
      (_b2 = codeMirror == null ? void 0 : codeMirror.getCodemirror()) == null ? void 0 : _b2.contentDOM.addEventListener("keydown", onKeyDownHandler);
    }, 300);
    return () => {
      var _a2, _b2;
      (_a2 = codeMirror == null ? void 0 : codeMirror.getCodemirror()) == null ? void 0 : _a2.contentDOM.removeEventListener("focus", onFocusHandler);
      (_b2 = codeMirror == null ? void 0 : codeMirror.getCodemirror()) == null ? void 0 : _b2.contentDOM.removeEventListener("keydown", onKeyDownHandler);
    };
  }, [codeMirrorRef, onFocusHandler, onKeyDownHandler, language2]);
  import_react48.default.useEffect(() => {
    focusEmitter.subscribe(() => {
      var _a2, _b2;
      (_b2 = (_a2 = codeMirrorRef.current) == null ? void 0 : _a2.getCodemirror()) == null ? void 0 : _b2.focus();
      onFocusHandler();
    });
  }, [focusEmitter, codeMirrorRef, nodeKey, onFocusHandler]);
  return codeMirrorRef;
}

// node_modules/@mdxeditor/editor/dist/plugins/sandpack/SandpackEditor.js
var CodeUpdateEmitter = ({ onChange, snippetFileName }) => {
  const { sandpack } = useSandpack();
  onChange(sandpack.files[snippetFileName].code);
  return null;
};
var SandpackEditor = ({ nodeKey, code: code3, focusEmitter, preset }) => {
  const codeMirrorRef = useCodeMirrorRef(nodeKey, "sandpack", "jsx", focusEmitter);
  const [readOnly, iconComponentFor] = X(readOnly$, iconComponentFor$);
  const { setCode } = useCodeBlockEditorContext();
  const { parentEditor, lexicalNode } = useCodeBlockEditorContext();
  const t3 = useTranslation();
  return import_react49.default.createElement("div", { className: styles.sandPackWrapper }, import_react49.default.createElement("div", { className: styles.codeMirrorToolbar }, import_react49.default.createElement(
    "button",
    {
      className: styles.iconButton,
      type: "button",
      title: t3("codeblock.delete", "Delete code block"),
      onClick: (e2) => {
        e2.preventDefault();
        parentEditor.update(() => {
          lexicalNode.remove();
        });
      }
    },
    iconComponentFor("delete_small")
  )), import_react49.default.createElement(
    SandpackProvider,
    {
      template: preset.sandpackTemplate,
      theme: preset.sandpackTheme,
      files: {
        [preset.snippetFileName]: code3,
        ...Object.entries(preset.files ?? {}).reduce(
          (acc, [filePath, fileContents]) => ({ ...acc, ...{ [filePath]: { code: fileContents, readOnly: true } } }),
          {}
        )
      },
      customSetup: {
        dependencies: preset.dependencies
      }
    },
    import_react49.default.createElement(SandpackLayout, null, import_react49.default.createElement(SandpackCodeEditor, { readOnly, showLineNumbers: true, showInlineErrors: true, ref: codeMirrorRef }), import_react49.default.createElement(SandpackPreview, null)),
    import_react49.default.createElement(CodeUpdateEmitter, { onChange: setCode, snippetFileName: preset.snippetFileName })
  ));
};

// node_modules/@mdxeditor/editor/dist/plugins/sandpack/index.js
var defaultSnippetContent = `
export default function App() {
  return (
    <div className="App">
      <h1>Hello CodeSandbox</h1>
      <h2>Start editing to see some magic happen!</h2>
    </div>
  );
}
`;
var defaultSandpackConfig = {
  defaultPreset: "react",
  presets: [
    {
      name: "react",
      meta: "live react",
      label: "React",
      sandpackTemplate: "react",
      sandpackTheme: "light",
      snippetFileName: "/App.js",
      snippetLanguage: "jsx",
      initialSnippetContent: defaultSnippetContent
    }
  ]
};
var sandpackConfig$ = $(defaultSandpackConfig);
var insertSandpack$ = K((r2) => {
  r2.link(
    r2.pipe(
      insertSandpack$,
      tt(sandpackConfig$),
      _(([presetName, sandpackConfig]) => {
        const preset = presetName ? sandpackConfig.presets.find((preset2) => preset2.name === presetName) : sandpackConfig.presets.find((preset2) => preset2.name == sandpackConfig.defaultPreset);
        if (!preset) {
          throw new Error(`No sandpack preset found with name ${presetName}`);
        }
        return {
          code: preset.initialSnippetContent ?? "",
          language: preset.snippetLanguage ?? "jsx",
          meta: preset.meta
        };
      })
    ),
    insertCodeBlock$
  );
});
var sandpackPlugin = realmPlugin({
  init(realm, params) {
    realm.pubIn({
      [sandpackConfig$]: params == null ? void 0 : params.sandpackConfig,
      [appendCodeBlockEditorDescriptor$]: sandpackCodeBlockDescriptor()
    });
  },
  update(realm, params) {
    realm.pub(sandpackConfig$, params == null ? void 0 : params.sandpackConfig);
  }
});
function sandpackCodeBlockDescriptor() {
  return {
    match(_language, meta) {
      return Boolean(meta == null ? void 0 : meta.startsWith("live"));
    },
    Editor(props) {
      const config = E(sandpackConfig$);
      const preset = config.presets.find((preset2) => preset2.meta === props.meta);
      if (!preset) {
        throw new Error(`No sandpack preset found with ${props.meta}`);
      }
      return import_react50.default.createElement(SandpackEditor, { ...props, preset });
    },
    priority: 1
  };
}

// node_modules/@mdxeditor/editor/dist/plugins/codemirror/CodeMirrorEditor.js
var import_react53 = __toESM(require_react(), 1);

// node_modules/@codemirror/language-data/dist/index.js
function legacy(parser) {
  return new LanguageSupport(StreamLanguage.define(parser));
}
function sql(dialectName) {
  return import("./dist-EDYD6LB5.js").then((m2) => m2.sql({ dialect: m2[dialectName] }));
}
var languages = [
  // New-style language modes
  LanguageDescription.of({
    name: "C",
    extensions: ["c", "h", "ino"],
    load() {
      return import("./dist-RLJVAQEQ.js").then((m2) => m2.cpp());
    }
  }),
  LanguageDescription.of({
    name: "C++",
    alias: ["cpp"],
    extensions: ["cpp", "c++", "cc", "cxx", "hpp", "h++", "hh", "hxx"],
    load() {
      return import("./dist-RLJVAQEQ.js").then((m2) => m2.cpp());
    }
  }),
  LanguageDescription.of({
    name: "CQL",
    alias: ["cassandra"],
    extensions: ["cql"],
    load() {
      return sql("Cassandra");
    }
  }),
  LanguageDescription.of({
    name: "CSS",
    extensions: ["css"],
    load() {
      return import("./dist-FYXQLDB3.js").then((m2) => m2.css());
    }
  }),
  LanguageDescription.of({
    name: "Go",
    extensions: ["go"],
    load() {
      return import("./dist-USQ2FJGF.js").then((m2) => m2.go());
    }
  }),
  LanguageDescription.of({
    name: "HTML",
    alias: ["xhtml"],
    extensions: ["html", "htm", "handlebars", "hbs"],
    load() {
      return import("./dist-HFBHW773.js").then((m2) => m2.html());
    }
  }),
  LanguageDescription.of({
    name: "Java",
    extensions: ["java"],
    load() {
      return import("./dist-2ECLO77D.js").then((m2) => m2.java());
    }
  }),
  LanguageDescription.of({
    name: "JavaScript",
    alias: ["ecmascript", "js", "node"],
    extensions: ["js", "mjs", "cjs"],
    load() {
      return import("./dist-IW4SMDGF.js").then((m2) => m2.javascript());
    }
  }),
  LanguageDescription.of({
    name: "JSON",
    alias: ["json5"],
    extensions: ["json", "map"],
    load() {
      return import("./dist-B34SAD5O.js").then((m2) => m2.json());
    }
  }),
  LanguageDescription.of({
    name: "JSX",
    extensions: ["jsx"],
    load() {
      return import("./dist-IW4SMDGF.js").then((m2) => m2.javascript({ jsx: true }));
    }
  }),
  LanguageDescription.of({
    name: "LESS",
    extensions: ["less"],
    load() {
      return import("./dist-YZZBG36N.js").then((m2) => m2.less());
    }
  }),
  LanguageDescription.of({
    name: "Liquid",
    extensions: ["liquid"],
    load() {
      return import("./dist-G65TCPM2.js").then((m2) => m2.liquid());
    }
  }),
  LanguageDescription.of({
    name: "MariaDB SQL",
    load() {
      return sql("MariaSQL");
    }
  }),
  LanguageDescription.of({
    name: "Markdown",
    extensions: ["md", "markdown", "mkd"],
    load() {
      return import("./dist-KZCNBQ46.js").then((m2) => m2.markdown());
    }
  }),
  LanguageDescription.of({
    name: "MS SQL",
    load() {
      return sql("MSSQL");
    }
  }),
  LanguageDescription.of({
    name: "MySQL",
    load() {
      return sql("MySQL");
    }
  }),
  LanguageDescription.of({
    name: "PHP",
    extensions: ["php", "php3", "php4", "php5", "php7", "phtml"],
    load() {
      return import("./dist-FNKYAR4W.js").then((m2) => m2.php());
    }
  }),
  LanguageDescription.of({
    name: "PLSQL",
    extensions: ["pls"],
    load() {
      return sql("PLSQL");
    }
  }),
  LanguageDescription.of({
    name: "PostgreSQL",
    load() {
      return sql("PostgreSQL");
    }
  }),
  LanguageDescription.of({
    name: "Python",
    extensions: ["BUILD", "bzl", "py", "pyw"],
    filename: /^(BUCK|BUILD)$/,
    load() {
      return import("./dist-4BOQUGLL.js").then((m2) => m2.python());
    }
  }),
  LanguageDescription.of({
    name: "Rust",
    extensions: ["rs"],
    load() {
      return import("./dist-JM7BHAQH.js").then((m2) => m2.rust());
    }
  }),
  LanguageDescription.of({
    name: "Sass",
    extensions: ["sass"],
    load() {
      return import("./dist-NOLN6JPZ.js").then((m2) => m2.sass({ indented: true }));
    }
  }),
  LanguageDescription.of({
    name: "SCSS",
    extensions: ["scss"],
    load() {
      return import("./dist-NOLN6JPZ.js").then((m2) => m2.sass());
    }
  }),
  LanguageDescription.of({
    name: "SQL",
    extensions: ["sql"],
    load() {
      return sql("StandardSQL");
    }
  }),
  LanguageDescription.of({
    name: "SQLite",
    load() {
      return sql("SQLite");
    }
  }),
  LanguageDescription.of({
    name: "TSX",
    extensions: ["tsx"],
    load() {
      return import("./dist-IW4SMDGF.js").then((m2) => m2.javascript({ jsx: true, typescript: true }));
    }
  }),
  LanguageDescription.of({
    name: "TypeScript",
    alias: ["ts"],
    extensions: ["ts", "mts", "cts"],
    load() {
      return import("./dist-IW4SMDGF.js").then((m2) => m2.javascript({ typescript: true }));
    }
  }),
  LanguageDescription.of({
    name: "WebAssembly",
    extensions: ["wat", "wast"],
    load() {
      return import("./dist-LSBRCR6G.js").then((m2) => m2.wast());
    }
  }),
  LanguageDescription.of({
    name: "XML",
    alias: ["rss", "wsdl", "xsd"],
    extensions: ["xml", "xsl", "xsd", "svg"],
    load() {
      return import("./dist-6DENLKK5.js").then((m2) => m2.xml());
    }
  }),
  LanguageDescription.of({
    name: "YAML",
    alias: ["yml"],
    extensions: ["yaml", "yml"],
    load() {
      return import("./dist-JFB33JAZ.js").then((m2) => m2.yaml());
    }
  }),
  // Legacy modes ported from CodeMirror 5
  LanguageDescription.of({
    name: "APL",
    extensions: ["dyalog", "apl"],
    load() {
      return import("./apl-6MXXZEY6.js").then((m2) => legacy(m2.apl));
    }
  }),
  LanguageDescription.of({
    name: "PGP",
    alias: ["asciiarmor"],
    extensions: ["asc", "pgp", "sig"],
    load() {
      return import("./asciiarmor-CDBOAFNH.js").then((m2) => legacy(m2.asciiArmor));
    }
  }),
  LanguageDescription.of({
    name: "ASN.1",
    extensions: ["asn", "asn1"],
    load() {
      return import("./asn1-XRB2HMLL.js").then((m2) => legacy(m2.asn1({})));
    }
  }),
  LanguageDescription.of({
    name: "Asterisk",
    filename: /^extensions\.conf$/i,
    load() {
      return import("./asterisk-72JYQHW7.js").then((m2) => legacy(m2.asterisk));
    }
  }),
  LanguageDescription.of({
    name: "Brainfuck",
    extensions: ["b", "bf"],
    load() {
      return import("./brainfuck-UFTHPR3Y.js").then((m2) => legacy(m2.brainfuck));
    }
  }),
  LanguageDescription.of({
    name: "Cobol",
    extensions: ["cob", "cpy"],
    load() {
      return import("./cobol-J2ZBVYU2.js").then((m2) => legacy(m2.cobol));
    }
  }),
  LanguageDescription.of({
    name: "C#",
    alias: ["csharp", "cs"],
    extensions: ["cs"],
    load() {
      return import("./clike-EFQ4Y77O.js").then((m2) => legacy(m2.csharp));
    }
  }),
  LanguageDescription.of({
    name: "Clojure",
    extensions: ["clj", "cljc", "cljx"],
    load() {
      return import("./clojure-JRH7UMZG.js").then((m2) => legacy(m2.clojure));
    }
  }),
  LanguageDescription.of({
    name: "ClojureScript",
    extensions: ["cljs"],
    load() {
      return import("./clojure-JRH7UMZG.js").then((m2) => legacy(m2.clojure));
    }
  }),
  LanguageDescription.of({
    name: "Closure Stylesheets (GSS)",
    extensions: ["gss"],
    load() {
      return import("./css-6UELPOE6.js").then((m2) => legacy(m2.gss));
    }
  }),
  LanguageDescription.of({
    name: "CMake",
    extensions: ["cmake", "cmake.in"],
    filename: /^CMakeLists\.txt$/,
    load() {
      return import("./cmake-MLZTK564.js").then((m2) => legacy(m2.cmake));
    }
  }),
  LanguageDescription.of({
    name: "CoffeeScript",
    alias: ["coffee", "coffee-script"],
    extensions: ["coffee"],
    load() {
      return import("./coffeescript-P7RRBNCA.js").then((m2) => legacy(m2.coffeeScript));
    }
  }),
  LanguageDescription.of({
    name: "Common Lisp",
    alias: ["lisp"],
    extensions: ["cl", "lisp", "el"],
    load() {
      return import("./commonlisp-NRB7T5KH.js").then((m2) => legacy(m2.commonLisp));
    }
  }),
  LanguageDescription.of({
    name: "Cypher",
    extensions: ["cyp", "cypher"],
    load() {
      return import("./cypher-Z56O26JS.js").then((m2) => legacy(m2.cypher));
    }
  }),
  LanguageDescription.of({
    name: "Cython",
    extensions: ["pyx", "pxd", "pxi"],
    load() {
      return import("./python-HFHSXOHW.js").then((m2) => legacy(m2.cython));
    }
  }),
  LanguageDescription.of({
    name: "Crystal",
    extensions: ["cr"],
    load() {
      return import("./crystal-MP34Y5MW.js").then((m2) => legacy(m2.crystal));
    }
  }),
  LanguageDescription.of({
    name: "D",
    extensions: ["d"],
    load() {
      return import("./d-OZVIYDJK.js").then((m2) => legacy(m2.d));
    }
  }),
  LanguageDescription.of({
    name: "Dart",
    extensions: ["dart"],
    load() {
      return import("./clike-EFQ4Y77O.js").then((m2) => legacy(m2.dart));
    }
  }),
  LanguageDescription.of({
    name: "diff",
    extensions: ["diff", "patch"],
    load() {
      return import("./diff-6IAQ26KL.js").then((m2) => legacy(m2.diff));
    }
  }),
  LanguageDescription.of({
    name: "Dockerfile",
    filename: /^Dockerfile$/,
    load() {
      return import("./dockerfile-HMJMLTYL.js").then((m2) => legacy(m2.dockerFile));
    }
  }),
  LanguageDescription.of({
    name: "DTD",
    extensions: ["dtd"],
    load() {
      return import("./dtd-5T2R5S52.js").then((m2) => legacy(m2.dtd));
    }
  }),
  LanguageDescription.of({
    name: "Dylan",
    extensions: ["dylan", "dyl", "intr"],
    load() {
      return import("./dylan-4SGE4VHC.js").then((m2) => legacy(m2.dylan));
    }
  }),
  LanguageDescription.of({
    name: "EBNF",
    load() {
      return import("./ebnf-4TTPFRTM.js").then((m2) => legacy(m2.ebnf));
    }
  }),
  LanguageDescription.of({
    name: "ECL",
    extensions: ["ecl"],
    load() {
      return import("./ecl-ZUE4JBCD.js").then((m2) => legacy(m2.ecl));
    }
  }),
  LanguageDescription.of({
    name: "edn",
    extensions: ["edn"],
    load() {
      return import("./clojure-JRH7UMZG.js").then((m2) => legacy(m2.clojure));
    }
  }),
  LanguageDescription.of({
    name: "Eiffel",
    extensions: ["e"],
    load() {
      return import("./eiffel-TY7434GI.js").then((m2) => legacy(m2.eiffel));
    }
  }),
  LanguageDescription.of({
    name: "Elm",
    extensions: ["elm"],
    load() {
      return import("./elm-KUNXWOES.js").then((m2) => legacy(m2.elm));
    }
  }),
  LanguageDescription.of({
    name: "Erlang",
    extensions: ["erl"],
    load() {
      return import("./erlang-CJNFV3JP.js").then((m2) => legacy(m2.erlang));
    }
  }),
  LanguageDescription.of({
    name: "Esper",
    load() {
      return import("./sql-JLBN6IJ7.js").then((m2) => legacy(m2.esper));
    }
  }),
  LanguageDescription.of({
    name: "Factor",
    extensions: ["factor"],
    load() {
      return import("./factor-KO52SJGE.js").then((m2) => legacy(m2.factor));
    }
  }),
  LanguageDescription.of({
    name: "FCL",
    load() {
      return import("./fcl-QIHQM6XB.js").then((m2) => legacy(m2.fcl));
    }
  }),
  LanguageDescription.of({
    name: "Forth",
    extensions: ["forth", "fth", "4th"],
    load() {
      return import("./forth-JNWAR55X.js").then((m2) => legacy(m2.forth));
    }
  }),
  LanguageDescription.of({
    name: "Fortran",
    extensions: ["f", "for", "f77", "f90", "f95"],
    load() {
      return import("./fortran-WUKVYLI4.js").then((m2) => legacy(m2.fortran));
    }
  }),
  LanguageDescription.of({
    name: "F#",
    alias: ["fsharp"],
    extensions: ["fs"],
    load() {
      return import("./mllike-T4NAP7OQ.js").then((m2) => legacy(m2.fSharp));
    }
  }),
  LanguageDescription.of({
    name: "Gas",
    extensions: ["s"],
    load() {
      return import("./gas-KMGH3ND5.js").then((m2) => legacy(m2.gas));
    }
  }),
  LanguageDescription.of({
    name: "Gherkin",
    extensions: ["feature"],
    load() {
      return import("./gherkin-4BU72JTM.js").then((m2) => legacy(m2.gherkin));
    }
  }),
  LanguageDescription.of({
    name: "Groovy",
    extensions: ["groovy", "gradle"],
    filename: /^Jenkinsfile$/,
    load() {
      return import("./groovy-X6223LLD.js").then((m2) => legacy(m2.groovy));
    }
  }),
  LanguageDescription.of({
    name: "Haskell",
    extensions: ["hs"],
    load() {
      return import("./haskell-BH243WIU.js").then((m2) => legacy(m2.haskell));
    }
  }),
  LanguageDescription.of({
    name: "Haxe",
    extensions: ["hx"],
    load() {
      return import("./haxe-47SADJ76.js").then((m2) => legacy(m2.haxe));
    }
  }),
  LanguageDescription.of({
    name: "HXML",
    extensions: ["hxml"],
    load() {
      return import("./haxe-47SADJ76.js").then((m2) => legacy(m2.hxml));
    }
  }),
  LanguageDescription.of({
    name: "HTTP",
    load() {
      return import("./http-ZRAZWAZT.js").then((m2) => legacy(m2.http));
    }
  }),
  LanguageDescription.of({
    name: "IDL",
    extensions: ["pro"],
    load() {
      return import("./idl-INYQQDLK.js").then((m2) => legacy(m2.idl));
    }
  }),
  LanguageDescription.of({
    name: "JSON-LD",
    alias: ["jsonld"],
    extensions: ["jsonld"],
    load() {
      return import("./javascript-VZTQ4YF7.js").then((m2) => legacy(m2.jsonld));
    }
  }),
  LanguageDescription.of({
    name: "Jinja2",
    extensions: ["j2", "jinja", "jinja2"],
    load() {
      return import("./jinja2-EMGDW4WP.js").then((m2) => legacy(m2.jinja2));
    }
  }),
  LanguageDescription.of({
    name: "Julia",
    extensions: ["jl"],
    load() {
      return import("./julia-6BEIYDVH.js").then((m2) => legacy(m2.julia));
    }
  }),
  LanguageDescription.of({
    name: "Kotlin",
    extensions: ["kt", "kts"],
    load() {
      return import("./clike-EFQ4Y77O.js").then((m2) => legacy(m2.kotlin));
    }
  }),
  LanguageDescription.of({
    name: "LiveScript",
    alias: ["ls"],
    extensions: ["ls"],
    load() {
      return import("./livescript-VPXK66V2.js").then((m2) => legacy(m2.liveScript));
    }
  }),
  LanguageDescription.of({
    name: "Lua",
    extensions: ["lua"],
    load() {
      return import("./lua-7DZC2HQJ.js").then((m2) => legacy(m2.lua));
    }
  }),
  LanguageDescription.of({
    name: "mIRC",
    extensions: ["mrc"],
    load() {
      return import("./mirc-56XHS7ZF.js").then((m2) => legacy(m2.mirc));
    }
  }),
  LanguageDescription.of({
    name: "Mathematica",
    extensions: ["m", "nb", "wl", "wls"],
    load() {
      return import("./mathematica-5ASAFYEP.js").then((m2) => legacy(m2.mathematica));
    }
  }),
  LanguageDescription.of({
    name: "Modelica",
    extensions: ["mo"],
    load() {
      return import("./modelica-QKGLZPJV.js").then((m2) => legacy(m2.modelica));
    }
  }),
  LanguageDescription.of({
    name: "MUMPS",
    extensions: ["mps"],
    load() {
      return import("./mumps-QIRHTTLP.js").then((m2) => legacy(m2.mumps));
    }
  }),
  LanguageDescription.of({
    name: "Mbox",
    extensions: ["mbox"],
    load() {
      return import("./mbox-2LMBHPMY.js").then((m2) => legacy(m2.mbox));
    }
  }),
  LanguageDescription.of({
    name: "Nginx",
    filename: /nginx.*\.conf$/i,
    load() {
      return import("./nginx-QYTUGSS3.js").then((m2) => legacy(m2.nginx));
    }
  }),
  LanguageDescription.of({
    name: "NSIS",
    extensions: ["nsh", "nsi"],
    load() {
      return import("./nsis-4H72KCU3.js").then((m2) => legacy(m2.nsis));
    }
  }),
  LanguageDescription.of({
    name: "NTriples",
    extensions: ["nt", "nq"],
    load() {
      return import("./ntriples-HQPE4FSP.js").then((m2) => legacy(m2.ntriples));
    }
  }),
  LanguageDescription.of({
    name: "Objective-C",
    alias: ["objective-c", "objc"],
    extensions: ["m"],
    load() {
      return import("./clike-EFQ4Y77O.js").then((m2) => legacy(m2.objectiveC));
    }
  }),
  LanguageDescription.of({
    name: "Objective-C++",
    alias: ["objective-c++", "objc++"],
    extensions: ["mm"],
    load() {
      return import("./clike-EFQ4Y77O.js").then((m2) => legacy(m2.objectiveCpp));
    }
  }),
  LanguageDescription.of({
    name: "OCaml",
    extensions: ["ml", "mli", "mll", "mly"],
    load() {
      return import("./mllike-T4NAP7OQ.js").then((m2) => legacy(m2.oCaml));
    }
  }),
  LanguageDescription.of({
    name: "Octave",
    extensions: ["m"],
    load() {
      return import("./octave-TVD65STR.js").then((m2) => legacy(m2.octave));
    }
  }),
  LanguageDescription.of({
    name: "Oz",
    extensions: ["oz"],
    load() {
      return import("./oz-H2CHMS3C.js").then((m2) => legacy(m2.oz));
    }
  }),
  LanguageDescription.of({
    name: "Pascal",
    extensions: ["p", "pas"],
    load() {
      return import("./pascal-UPUUFYBB.js").then((m2) => legacy(m2.pascal));
    }
  }),
  LanguageDescription.of({
    name: "Perl",
    extensions: ["pl", "pm"],
    load() {
      return import("./perl-X454HARD.js").then((m2) => legacy(m2.perl));
    }
  }),
  LanguageDescription.of({
    name: "Pig",
    extensions: ["pig"],
    load() {
      return import("./pig-ZGRKIMIQ.js").then((m2) => legacy(m2.pig));
    }
  }),
  LanguageDescription.of({
    name: "PowerShell",
    extensions: ["ps1", "psd1", "psm1"],
    load() {
      return import("./powershell-QKLVZGSL.js").then((m2) => legacy(m2.powerShell));
    }
  }),
  LanguageDescription.of({
    name: "Properties files",
    alias: ["ini", "properties"],
    extensions: ["properties", "ini", "in"],
    load() {
      return import("./properties-SWSOUNIV.js").then((m2) => legacy(m2.properties));
    }
  }),
  LanguageDescription.of({
    name: "ProtoBuf",
    extensions: ["proto"],
    load() {
      return import("./protobuf-3GURGZVG.js").then((m2) => legacy(m2.protobuf));
    }
  }),
  LanguageDescription.of({
    name: "Pug",
    alias: ["jade"],
    extensions: ["pug", "jade"],
    load() {
      return import("./pug-5YY7IJP4.js").then((m2) => legacy(m2.pug));
    }
  }),
  LanguageDescription.of({
    name: "Puppet",
    extensions: ["pp"],
    load() {
      return import("./puppet-QNGI72BB.js").then((m2) => legacy(m2.puppet));
    }
  }),
  LanguageDescription.of({
    name: "Q",
    extensions: ["q"],
    load() {
      return import("./q-TBXID7NH.js").then((m2) => legacy(m2.q));
    }
  }),
  LanguageDescription.of({
    name: "R",
    alias: ["rscript"],
    extensions: ["r", "R"],
    load() {
      return import("./r-MQKJZ5LK.js").then((m2) => legacy(m2.r));
    }
  }),
  LanguageDescription.of({
    name: "RPM Changes",
    load() {
      return import("./rpm-NAVPKFGC.js").then((m2) => legacy(m2.rpmChanges));
    }
  }),
  LanguageDescription.of({
    name: "RPM Spec",
    extensions: ["spec"],
    load() {
      return import("./rpm-NAVPKFGC.js").then((m2) => legacy(m2.rpmSpec));
    }
  }),
  LanguageDescription.of({
    name: "Ruby",
    alias: ["jruby", "macruby", "rake", "rb", "rbx"],
    extensions: ["rb"],
    filename: /^(Gemfile|Rakefile)$/,
    load() {
      return import("./ruby-4LE3DDAX.js").then((m2) => legacy(m2.ruby));
    }
  }),
  LanguageDescription.of({
    name: "SAS",
    extensions: ["sas"],
    load() {
      return import("./sas-GICGSYB7.js").then((m2) => legacy(m2.sas));
    }
  }),
  LanguageDescription.of({
    name: "Scala",
    extensions: ["scala"],
    load() {
      return import("./clike-EFQ4Y77O.js").then((m2) => legacy(m2.scala));
    }
  }),
  LanguageDescription.of({
    name: "Scheme",
    extensions: ["scm", "ss"],
    load() {
      return import("./scheme-AG6OWG46.js").then((m2) => legacy(m2.scheme));
    }
  }),
  LanguageDescription.of({
    name: "Shell",
    alias: ["bash", "sh", "zsh"],
    extensions: ["sh", "ksh", "bash"],
    filename: /^PKGBUILD$/,
    load() {
      return import("./shell-YIRZSGA7.js").then((m2) => legacy(m2.shell));
    }
  }),
  LanguageDescription.of({
    name: "Sieve",
    extensions: ["siv", "sieve"],
    load() {
      return import("./sieve-K5QATXGN.js").then((m2) => legacy(m2.sieve));
    }
  }),
  LanguageDescription.of({
    name: "Smalltalk",
    extensions: ["st"],
    load() {
      return import("./smalltalk-6UKEHQDE.js").then((m2) => legacy(m2.smalltalk));
    }
  }),
  LanguageDescription.of({
    name: "Solr",
    load() {
      return import("./solr-FSV3FG4M.js").then((m2) => legacy(m2.solr));
    }
  }),
  LanguageDescription.of({
    name: "SML",
    extensions: ["sml", "sig", "fun", "smackspec"],
    load() {
      return import("./mllike-T4NAP7OQ.js").then((m2) => legacy(m2.sml));
    }
  }),
  LanguageDescription.of({
    name: "SPARQL",
    alias: ["sparul"],
    extensions: ["rq", "sparql"],
    load() {
      return import("./sparql-RX62IXYG.js").then((m2) => legacy(m2.sparql));
    }
  }),
  LanguageDescription.of({
    name: "Spreadsheet",
    alias: ["excel", "formula"],
    load() {
      return import("./spreadsheet-YSVIF56G.js").then((m2) => legacy(m2.spreadsheet));
    }
  }),
  LanguageDescription.of({
    name: "Squirrel",
    extensions: ["nut"],
    load() {
      return import("./clike-EFQ4Y77O.js").then((m2) => legacy(m2.squirrel));
    }
  }),
  LanguageDescription.of({
    name: "Stylus",
    extensions: ["styl"],
    load() {
      return import("./stylus-VKEBB3MJ.js").then((m2) => legacy(m2.stylus));
    }
  }),
  LanguageDescription.of({
    name: "Swift",
    extensions: ["swift"],
    load() {
      return import("./swift-XJS7G63T.js").then((m2) => legacy(m2.swift));
    }
  }),
  LanguageDescription.of({
    name: "sTeX",
    load() {
      return import("./stex-ALD5DZMG.js").then((m2) => legacy(m2.stex));
    }
  }),
  LanguageDescription.of({
    name: "LaTeX",
    alias: ["tex"],
    extensions: ["text", "ltx", "tex"],
    load() {
      return import("./stex-ALD5DZMG.js").then((m2) => legacy(m2.stex));
    }
  }),
  LanguageDescription.of({
    name: "SystemVerilog",
    extensions: ["v", "sv", "svh"],
    load() {
      return import("./verilog-HJN4Q5LJ.js").then((m2) => legacy(m2.verilog));
    }
  }),
  LanguageDescription.of({
    name: "Tcl",
    extensions: ["tcl"],
    load() {
      return import("./tcl-MA6EQJGX.js").then((m2) => legacy(m2.tcl));
    }
  }),
  LanguageDescription.of({
    name: "Textile",
    extensions: ["textile"],
    load() {
      return import("./textile-Y5PGP7KD.js").then((m2) => legacy(m2.textile));
    }
  }),
  LanguageDescription.of({
    name: "TiddlyWiki",
    load() {
      return import("./tiddlywiki-YSA4KDS3.js").then((m2) => legacy(m2.tiddlyWiki));
    }
  }),
  LanguageDescription.of({
    name: "Tiki wiki",
    load() {
      return import("./tiki-QL3RVUES.js").then((m2) => legacy(m2.tiki));
    }
  }),
  LanguageDescription.of({
    name: "TOML",
    extensions: ["toml"],
    load() {
      return import("./toml-HOP556DX.js").then((m2) => legacy(m2.toml));
    }
  }),
  LanguageDescription.of({
    name: "Troff",
    extensions: ["1", "2", "3", "4", "5", "6", "7", "8", "9"],
    load() {
      return import("./troff-TEYO4ZQM.js").then((m2) => legacy(m2.troff));
    }
  }),
  LanguageDescription.of({
    name: "TTCN",
    extensions: ["ttcn", "ttcn3", "ttcnpp"],
    load() {
      return import("./ttcn-OMXMZDEI.js").then((m2) => legacy(m2.ttcn));
    }
  }),
  LanguageDescription.of({
    name: "TTCN_CFG",
    extensions: ["cfg"],
    load() {
      return import("./ttcn-cfg-GGLRBJIV.js").then((m2) => legacy(m2.ttcnCfg));
    }
  }),
  LanguageDescription.of({
    name: "Turtle",
    extensions: ["ttl"],
    load() {
      return import("./turtle-QP35OE7W.js").then((m2) => legacy(m2.turtle));
    }
  }),
  LanguageDescription.of({
    name: "Web IDL",
    extensions: ["webidl"],
    load() {
      return import("./webidl-HHYE6737.js").then((m2) => legacy(m2.webIDL));
    }
  }),
  LanguageDescription.of({
    name: "VB.NET",
    extensions: ["vb"],
    load() {
      return import("./vb-C3WWW2VO.js").then((m2) => legacy(m2.vb));
    }
  }),
  LanguageDescription.of({
    name: "VBScript",
    extensions: ["vbs"],
    load() {
      return import("./vbscript-USLP5NTN.js").then((m2) => legacy(m2.vbScript));
    }
  }),
  LanguageDescription.of({
    name: "Velocity",
    extensions: ["vtl"],
    load() {
      return import("./velocity-3GO3PLCV.js").then((m2) => legacy(m2.velocity));
    }
  }),
  LanguageDescription.of({
    name: "Verilog",
    extensions: ["v"],
    load() {
      return import("./verilog-HJN4Q5LJ.js").then((m2) => legacy(m2.verilog));
    }
  }),
  LanguageDescription.of({
    name: "VHDL",
    extensions: ["vhd", "vhdl"],
    load() {
      return import("./vhdl-JRYJCGFG.js").then((m2) => legacy(m2.vhdl));
    }
  }),
  LanguageDescription.of({
    name: "XQuery",
    extensions: ["xy", "xquery"],
    load() {
      return import("./xquery-N4YJFD5F.js").then((m2) => legacy(m2.xQuery));
    }
  }),
  LanguageDescription.of({
    name: "Yacas",
    extensions: ["ys"],
    load() {
      return import("./yacas-5Z3VTSNS.js").then((m2) => legacy(m2.yacas));
    }
  }),
  LanguageDescription.of({
    name: "Z80",
    extensions: ["z80"],
    load() {
      return import("./z80-UXAUE3V5.js").then((m2) => legacy(m2.z80));
    }
  }),
  LanguageDescription.of({
    name: "MscGen",
    extensions: ["mscgen", "mscin", "msc"],
    load() {
      return import("./mscgen-EMZUVBN4.js").then((m2) => legacy(m2.mscgen));
    }
  }),
  LanguageDescription.of({
    name: "Xù",
    extensions: ["xu"],
    load() {
      return import("./mscgen-EMZUVBN4.js").then((m2) => legacy(m2.xu));
    }
  }),
  LanguageDescription.of({
    name: "MsGenny",
    extensions: ["msgenny"],
    load() {
      return import("./mscgen-EMZUVBN4.js").then((m2) => legacy(m2.msgenny));
    }
  }),
  LanguageDescription.of({
    name: "Vue",
    extensions: ["vue"],
    load() {
      return import("./dist-R55RQZGC.js").then((m2) => m2.vue());
    }
  }),
  LanguageDescription.of({
    name: "Angular Template",
    load() {
      return import("./dist-5L5ZSMI7.js").then((m2) => m2.angular());
    }
  })
];

// node_modules/cm6-theme-basic-light/dist/index.js
var base00 = "#2e3440";
var base01 = "#3b4252";
var base02 = "#434c5e";
var base03 = "#4c566a";
var base05 = "#e5e9f0";
var base06 = "#eceff4";
var base07 = "#8fbcbb";
var base08 = "#88c0d0";
var base09 = "#81a1c1";
var base0A = "#5e81ac";
var base0b = "#bf616a";
var base0C = "#d08770";
var base0D = "#ebcb8b";
var base0E = "#a3be8c";
var base0F = "#b48ead";
var invalid2 = "#d30102";
var darkBackground = base06;
var highlightBackground = darkBackground;
var background2 = "#ffffff";
var tooltipBackground = base01;
var selection = darkBackground;
var cursor = base01;
var basicLightTheme = EditorView.theme({
  "&": {
    color: base00,
    backgroundColor: background2
  },
  ".cm-content": {
    caretColor: cursor
  },
  ".cm-cursor, .cm-dropCursor": { borderLeftColor: cursor },
  "&.cm-focused .cm-selectionBackground, .cm-selectionBackground, .cm-content ::selection": { backgroundColor: selection },
  ".cm-panels": { backgroundColor: darkBackground, color: base03 },
  ".cm-panels.cm-panels-top": { borderBottom: "2px solid black" },
  ".cm-panels.cm-panels-bottom": { borderTop: "2px solid black" },
  ".cm-searchMatch": {
    backgroundColor: "#72a1ff59",
    outline: `1px solid ${base03}`
  },
  ".cm-searchMatch.cm-searchMatch-selected": {
    backgroundColor: base05
  },
  ".cm-activeLine": { backgroundColor: highlightBackground },
  ".cm-selectionMatch": { backgroundColor: base05 },
  "&.cm-focused .cm-matchingBracket, &.cm-focused .cm-nonmatchingBracket": {
    outline: `1px solid ${base03}`
  },
  "&.cm-focused .cm-matchingBracket": {
    backgroundColor: base06
  },
  ".cm-gutters": {
    backgroundColor: base06,
    color: base00,
    border: "none"
  },
  ".cm-activeLineGutter": {
    backgroundColor: highlightBackground
  },
  ".cm-foldPlaceholder": {
    backgroundColor: "transparent",
    border: "none",
    color: "#ddd"
  },
  ".cm-tooltip": {
    border: "none",
    backgroundColor: tooltipBackground
  },
  ".cm-tooltip .cm-tooltip-arrow:before": {
    borderTopColor: "transparent",
    borderBottomColor: "transparent"
  },
  ".cm-tooltip .cm-tooltip-arrow:after": {
    borderTopColor: tooltipBackground,
    borderBottomColor: tooltipBackground
  },
  ".cm-tooltip-autocomplete": {
    "& > ul > li[aria-selected]": {
      backgroundColor: highlightBackground,
      color: base03
    }
  }
}, { dark: false });
var basicLightHighlightStyle = HighlightStyle.define([
  { tag: tags.keyword, color: base0A },
  {
    tag: [tags.name, tags.deleted, tags.character, tags.propertyName, tags.macroName],
    color: base0C
  },
  { tag: [tags.variableName], color: base0C },
  { tag: [tags.function(tags.variableName)], color: base0A },
  { tag: [tags.labelName], color: base09 },
  {
    tag: [tags.color, tags.constant(tags.name), tags.standard(tags.name)],
    color: base0A
  },
  { tag: [tags.definition(tags.name), tags.separator], color: base0E },
  { tag: [tags.brace], color: base07 },
  {
    tag: [tags.annotation],
    color: invalid2
  },
  {
    tag: [tags.number, tags.changed, tags.annotation, tags.modifier, tags.self, tags.namespace],
    color: base08
  },
  {
    tag: [tags.typeName, tags.className],
    color: base0D
  },
  {
    tag: [tags.operator, tags.operatorKeyword],
    color: base0E
  },
  {
    tag: [tags.tagName],
    color: base0F
  },
  {
    tag: [tags.squareBracket],
    color: base0b
  },
  {
    tag: [tags.angleBracket],
    color: base0C
  },
  {
    tag: [tags.attributeName],
    color: base0D
  },
  {
    tag: [tags.regexp],
    color: base0A
  },
  {
    tag: [tags.quote],
    color: base01
  },
  { tag: [tags.string], color: base0C },
  {
    tag: tags.link,
    color: base07,
    textDecoration: "underline",
    textUnderlinePosition: "under"
  },
  {
    tag: [tags.url, tags.escape, tags.special(tags.string)],
    color: base0C
  },
  { tag: [tags.meta], color: base08 },
  { tag: [tags.comment], color: base02, fontStyle: "italic" },
  { tag: tags.strong, fontWeight: "bold", color: base0A },
  { tag: tags.emphasis, fontStyle: "italic", color: base0A },
  { tag: tags.strikethrough, textDecoration: "line-through" },
  { tag: tags.heading, fontWeight: "bold", color: base0A },
  { tag: tags.special(tags.heading1), fontWeight: "bold", color: base0A },
  { tag: tags.heading1, fontWeight: "bold", color: base0A },
  {
    tag: [tags.heading2, tags.heading3, tags.heading4],
    fontWeight: "bold",
    color: base0A
  },
  {
    tag: [tags.heading5, tags.heading6],
    color: base0A
  },
  { tag: [tags.atom, tags.bool, tags.special(tags.variableName)], color: base0C },
  {
    tag: [tags.processingInstruction, tags.inserted],
    color: base07
  },
  {
    tag: [tags.contentSeparator],
    color: base0D
  },
  { tag: tags.invalid, color: base02, borderBottom: `1px dotted ${invalid2}` }
]);
var basicLight = [
  basicLightTheme,
  syntaxHighlighting(basicLightHighlightStyle)
];

// node_modules/crelt/index.js
function crelt() {
  var elt = arguments[0];
  if (typeof elt == "string") elt = document.createElement(elt);
  var i3 = 1, next = arguments[1];
  if (next && typeof next == "object" && next.nodeType == null && !Array.isArray(next)) {
    for (var name2 in next) if (Object.prototype.hasOwnProperty.call(next, name2)) {
      var value2 = next[name2];
      if (typeof value2 == "string") elt.setAttribute(name2, value2);
      else if (value2 != null) elt[name2] = value2;
    }
    i3++;
  }
  for (; i3 < arguments.length; i3++) add(elt, arguments[i3]);
  return elt;
}
function add(elt, child) {
  if (typeof child == "string") {
    elt.appendChild(document.createTextNode(child));
  } else if (child == null) {
  } else if (child.nodeType != null) {
    elt.appendChild(child);
  } else if (Array.isArray(child)) {
    for (var i3 = 0; i3 < child.length; i3++) add(elt, child[i3]);
  } else {
    throw new RangeError("Unsupported child node: " + child);
  }
}

// node_modules/@codemirror/search/dist/index.js
var basicNormalize = typeof String.prototype.normalize == "function" ? (x3) => x3.normalize("NFKD") : (x3) => x3;
var SearchCursor = class {
  /**
  Create a text cursor. The query is the search string, `from` to
  `to` provides the region to search.
  
  When `normalize` is given, it will be called, on both the query
  string and the content it is matched against, before comparing.
  You can, for example, create a case-insensitive search by
  passing `s => s.toLowerCase()`.
  
  Text is always normalized with
  [`.normalize("NFKD")`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/normalize)
  (when supported).
  */
  constructor(text4, query, from = 0, to = text4.length, normalize2, test) {
    this.test = test;
    this.value = { from: 0, to: 0 };
    this.done = false;
    this.matches = [];
    this.buffer = "";
    this.bufferPos = 0;
    this.iter = text4.iterRange(from, to);
    this.bufferStart = from;
    this.normalize = normalize2 ? (x3) => normalize2(basicNormalize(x3)) : basicNormalize;
    this.query = this.normalize(query);
  }
  peek() {
    if (this.bufferPos == this.buffer.length) {
      this.bufferStart += this.buffer.length;
      this.iter.next();
      if (this.iter.done)
        return -1;
      this.bufferPos = 0;
      this.buffer = this.iter.value;
    }
    return codePointAt(this.buffer, this.bufferPos);
  }
  /**
  Look for the next match. Updates the iterator's
  [`value`](https://codemirror.net/6/docs/ref/#search.SearchCursor.value) and
  [`done`](https://codemirror.net/6/docs/ref/#search.SearchCursor.done) properties. Should be called
  at least once before using the cursor.
  */
  next() {
    while (this.matches.length)
      this.matches.pop();
    return this.nextOverlapping();
  }
  /**
  The `next` method will ignore matches that partially overlap a
  previous match. This method behaves like `next`, but includes
  such matches.
  */
  nextOverlapping() {
    for (; ; ) {
      let next = this.peek();
      if (next < 0) {
        this.done = true;
        return this;
      }
      let str2 = fromCodePoint(next), start2 = this.bufferStart + this.bufferPos;
      this.bufferPos += codePointSize(next);
      let norm = this.normalize(str2);
      if (norm.length)
        for (let i3 = 0, pos = start2; ; i3++) {
          let code3 = norm.charCodeAt(i3);
          let match = this.match(code3, pos, this.bufferPos + this.bufferStart);
          if (i3 == norm.length - 1) {
            if (match) {
              this.value = match;
              return this;
            }
            break;
          }
          if (pos == start2 && i3 < str2.length && str2.charCodeAt(i3) == code3)
            pos++;
        }
    }
  }
  match(code3, pos, end) {
    let match = null;
    for (let i3 = 0; i3 < this.matches.length; i3 += 2) {
      let index3 = this.matches[i3], keep = false;
      if (this.query.charCodeAt(index3) == code3) {
        if (index3 == this.query.length - 1) {
          match = { from: this.matches[i3 + 1], to: end };
        } else {
          this.matches[i3]++;
          keep = true;
        }
      }
      if (!keep) {
        this.matches.splice(i3, 2);
        i3 -= 2;
      }
    }
    if (this.query.charCodeAt(0) == code3) {
      if (this.query.length == 1)
        match = { from: pos, to: end };
      else
        this.matches.push(1, pos);
    }
    if (match && this.test && !this.test(match.from, match.to, this.buffer, this.bufferStart))
      match = null;
    return match;
  }
};
if (typeof Symbol != "undefined")
  SearchCursor.prototype[Symbol.iterator] = function() {
    return this;
  };
var empty4 = { from: -1, to: -1, match: /.*/.exec("") };
var baseFlags = "gm" + (/x/.unicode == null ? "" : "u");
var RegExpCursor = class {
  /**
  Create a cursor that will search the given range in the given
  document. `query` should be the raw pattern (as you'd pass it to
  `new RegExp`).
  */
  constructor(text4, query, options, from = 0, to = text4.length) {
    this.text = text4;
    this.to = to;
    this.curLine = "";
    this.done = false;
    this.value = empty4;
    if (/\\[sWDnr]|\n|\r|\[\^/.test(query))
      return new MultilineRegExpCursor(text4, query, options, from, to);
    this.re = new RegExp(query, baseFlags + ((options === null || options === void 0 ? void 0 : options.ignoreCase) ? "i" : ""));
    this.test = options === null || options === void 0 ? void 0 : options.test;
    this.iter = text4.iter();
    let startLine = text4.lineAt(from);
    this.curLineStart = startLine.from;
    this.matchPos = toCharEnd(text4, from);
    this.getLine(this.curLineStart);
  }
  getLine(skip) {
    this.iter.next(skip);
    if (this.iter.lineBreak) {
      this.curLine = "";
    } else {
      this.curLine = this.iter.value;
      if (this.curLineStart + this.curLine.length > this.to)
        this.curLine = this.curLine.slice(0, this.to - this.curLineStart);
      this.iter.next();
    }
  }
  nextLine() {
    this.curLineStart = this.curLineStart + this.curLine.length + 1;
    if (this.curLineStart > this.to)
      this.curLine = "";
    else
      this.getLine(0);
  }
  /**
  Move to the next match, if there is one.
  */
  next() {
    for (let off = this.matchPos - this.curLineStart; ; ) {
      this.re.lastIndex = off;
      let match = this.matchPos <= this.to && this.re.exec(this.curLine);
      if (match) {
        let from = this.curLineStart + match.index, to = from + match[0].length;
        this.matchPos = toCharEnd(this.text, to + (from == to ? 1 : 0));
        if (from == this.curLineStart + this.curLine.length)
          this.nextLine();
        if ((from < to || from > this.value.to) && (!this.test || this.test(from, to, match))) {
          this.value = { from, to, match };
          return this;
        }
        off = this.matchPos - this.curLineStart;
      } else if (this.curLineStart + this.curLine.length < this.to) {
        this.nextLine();
        off = 0;
      } else {
        this.done = true;
        return this;
      }
    }
  }
};
var flattened = /* @__PURE__ */ new WeakMap();
var FlattenedDoc = class _FlattenedDoc {
  constructor(from, text4) {
    this.from = from;
    this.text = text4;
  }
  get to() {
    return this.from + this.text.length;
  }
  static get(doc, from, to) {
    let cached = flattened.get(doc);
    if (!cached || cached.from >= to || cached.to <= from) {
      let flat = new _FlattenedDoc(from, doc.sliceString(from, to));
      flattened.set(doc, flat);
      return flat;
    }
    if (cached.from == from && cached.to == to)
      return cached;
    let { text: text4, from: cachedFrom } = cached;
    if (cachedFrom > from) {
      text4 = doc.sliceString(from, cachedFrom) + text4;
      cachedFrom = from;
    }
    if (cached.to < to)
      text4 += doc.sliceString(cached.to, to);
    flattened.set(doc, new _FlattenedDoc(cachedFrom, text4));
    return new _FlattenedDoc(from, text4.slice(from - cachedFrom, to - cachedFrom));
  }
};
var MultilineRegExpCursor = class {
  constructor(text4, query, options, from, to) {
    this.text = text4;
    this.to = to;
    this.done = false;
    this.value = empty4;
    this.matchPos = toCharEnd(text4, from);
    this.re = new RegExp(query, baseFlags + ((options === null || options === void 0 ? void 0 : options.ignoreCase) ? "i" : ""));
    this.test = options === null || options === void 0 ? void 0 : options.test;
    this.flat = FlattenedDoc.get(text4, from, this.chunkEnd(
      from + 5e3
      /* Chunk.Base */
    ));
  }
  chunkEnd(pos) {
    return pos >= this.to ? this.to : this.text.lineAt(pos).to;
  }
  next() {
    for (; ; ) {
      let off = this.re.lastIndex = this.matchPos - this.flat.from;
      let match = this.re.exec(this.flat.text);
      if (match && !match[0] && match.index == off) {
        this.re.lastIndex = off + 1;
        match = this.re.exec(this.flat.text);
      }
      if (match) {
        let from = this.flat.from + match.index, to = from + match[0].length;
        if ((this.flat.to >= this.to || match.index + match[0].length <= this.flat.text.length - 10) && (!this.test || this.test(from, to, match))) {
          this.value = { from, to, match };
          this.matchPos = toCharEnd(this.text, to + (from == to ? 1 : 0));
          return this;
        }
      }
      if (this.flat.to == this.to) {
        this.done = true;
        return this;
      }
      this.flat = FlattenedDoc.get(this.text, this.flat.from, this.chunkEnd(this.flat.from + this.flat.text.length * 2));
    }
  }
};
if (typeof Symbol != "undefined") {
  RegExpCursor.prototype[Symbol.iterator] = MultilineRegExpCursor.prototype[Symbol.iterator] = function() {
    return this;
  };
}
function validRegExp(source) {
  try {
    new RegExp(source, baseFlags);
    return true;
  } catch (_a2) {
    return false;
  }
}
function toCharEnd(text4, pos) {
  if (pos >= text4.length)
    return pos;
  let line = text4.lineAt(pos), next;
  while (pos < line.to && (next = line.text.charCodeAt(pos - line.from)) >= 56320 && next < 57344)
    pos++;
  return pos;
}
function createLineDialog(view) {
  let line = String(view.state.doc.lineAt(view.state.selection.main.head).number);
  let input = crelt("input", { class: "cm-textfield", name: "line", value: line });
  let dom = crelt("form", {
    class: "cm-gotoLine",
    onkeydown: (event) => {
      if (event.keyCode == 27) {
        event.preventDefault();
        view.dispatch({ effects: dialogEffect.of(false) });
        view.focus();
      } else if (event.keyCode == 13) {
        event.preventDefault();
        go();
      }
    },
    onsubmit: (event) => {
      event.preventDefault();
      go();
    }
  }, crelt("label", view.state.phrase("Go to line"), ": ", input), " ", crelt("button", { class: "cm-button", type: "submit" }, view.state.phrase("go")));
  function go() {
    let match = /^([+-])?(\d+)?(:\d+)?(%)?$/.exec(input.value);
    if (!match)
      return;
    let { state } = view, startLine = state.doc.lineAt(state.selection.main.head);
    let [, sign, ln, cl, percent] = match;
    let col = cl ? +cl.slice(1) : 0;
    let line2 = ln ? +ln : startLine.number;
    if (ln && percent) {
      let pc = line2 / 100;
      if (sign)
        pc = pc * (sign == "-" ? -1 : 1) + startLine.number / state.doc.lines;
      line2 = Math.round(state.doc.lines * pc);
    } else if (ln && sign) {
      line2 = line2 * (sign == "-" ? -1 : 1) + startLine.number;
    }
    let docLine = state.doc.line(Math.max(1, Math.min(state.doc.lines, line2)));
    let selection2 = EditorSelection.cursor(docLine.from + Math.max(0, Math.min(col, docLine.length)));
    view.dispatch({
      effects: [dialogEffect.of(false), EditorView.scrollIntoView(selection2.from, { y: "center" })],
      selection: selection2
    });
    view.focus();
  }
  return { dom };
}
var dialogEffect = StateEffect.define();
var dialogField = StateField.define({
  create() {
    return true;
  },
  update(value2, tr) {
    for (let e2 of tr.effects)
      if (e2.is(dialogEffect))
        value2 = e2.value;
    return value2;
  },
  provide: (f3) => showPanel.from(f3, (val) => val ? createLineDialog : null)
});
var gotoLine = (view) => {
  let panel = getPanel(view, createLineDialog);
  if (!panel) {
    let effects = [dialogEffect.of(true)];
    if (view.state.field(dialogField, false) == null)
      effects.push(StateEffect.appendConfig.of([dialogField, baseTheme$1]));
    view.dispatch({ effects });
    panel = getPanel(view, createLineDialog);
  }
  if (panel)
    panel.dom.querySelector("input").select();
  return true;
};
var baseTheme$1 = EditorView.baseTheme({
  ".cm-panel.cm-gotoLine": {
    padding: "2px 6px 4px",
    "& label": { fontSize: "80%" }
  }
});
var defaultHighlightOptions = {
  highlightWordAroundCursor: false,
  minSelectionLength: 1,
  maxMatches: 100,
  wholeWords: false
};
var highlightConfig = Facet.define({
  combine(options) {
    return combineConfig(options, defaultHighlightOptions, {
      highlightWordAroundCursor: (a2, b3) => a2 || b3,
      minSelectionLength: Math.min,
      maxMatches: Math.min
    });
  }
});
function highlightSelectionMatches(options) {
  let ext = [defaultTheme, matchHighlighter];
  if (options)
    ext.push(highlightConfig.of(options));
  return ext;
}
var matchDeco = Decoration.mark({ class: "cm-selectionMatch" });
var mainMatchDeco = Decoration.mark({ class: "cm-selectionMatch cm-selectionMatch-main" });
function insideWordBoundaries(check, state, from, to) {
  return (from == 0 || check(state.sliceDoc(from - 1, from)) != CharCategory.Word) && (to == state.doc.length || check(state.sliceDoc(to, to + 1)) != CharCategory.Word);
}
function insideWord(check, state, from, to) {
  return check(state.sliceDoc(from, from + 1)) == CharCategory.Word && check(state.sliceDoc(to - 1, to)) == CharCategory.Word;
}
var matchHighlighter = ViewPlugin.fromClass(class {
  constructor(view) {
    this.decorations = this.getDeco(view);
  }
  update(update) {
    if (update.selectionSet || update.docChanged || update.viewportChanged)
      this.decorations = this.getDeco(update.view);
  }
  getDeco(view) {
    let conf = view.state.facet(highlightConfig);
    let { state } = view, sel = state.selection;
    if (sel.ranges.length > 1)
      return Decoration.none;
    let range = sel.main, query, check = null;
    if (range.empty) {
      if (!conf.highlightWordAroundCursor)
        return Decoration.none;
      let word = state.wordAt(range.head);
      if (!word)
        return Decoration.none;
      check = state.charCategorizer(range.head);
      query = state.sliceDoc(word.from, word.to);
    } else {
      let len = range.to - range.from;
      if (len < conf.minSelectionLength || len > 200)
        return Decoration.none;
      if (conf.wholeWords) {
        query = state.sliceDoc(range.from, range.to);
        check = state.charCategorizer(range.head);
        if (!(insideWordBoundaries(check, state, range.from, range.to) && insideWord(check, state, range.from, range.to)))
          return Decoration.none;
      } else {
        query = state.sliceDoc(range.from, range.to);
        if (!query)
          return Decoration.none;
      }
    }
    let deco = [];
    for (let part of view.visibleRanges) {
      let cursor2 = new SearchCursor(state.doc, query, part.from, part.to);
      while (!cursor2.next().done) {
        let { from, to } = cursor2.value;
        if (!check || insideWordBoundaries(check, state, from, to)) {
          if (range.empty && from <= range.from && to >= range.to)
            deco.push(mainMatchDeco.range(from, to));
          else if (from >= range.to || to <= range.from)
            deco.push(matchDeco.range(from, to));
          if (deco.length > conf.maxMatches)
            return Decoration.none;
        }
      }
    }
    return Decoration.set(deco);
  }
}, {
  decorations: (v3) => v3.decorations
});
var defaultTheme = EditorView.baseTheme({
  ".cm-selectionMatch": { backgroundColor: "#99ff7780" },
  ".cm-searchMatch .cm-selectionMatch": { backgroundColor: "transparent" }
});
var selectWord = ({ state, dispatch }) => {
  let { selection: selection2 } = state;
  let newSel = EditorSelection.create(selection2.ranges.map((range) => state.wordAt(range.head) || EditorSelection.cursor(range.head)), selection2.mainIndex);
  if (newSel.eq(selection2))
    return false;
  dispatch(state.update({ selection: newSel }));
  return true;
};
function findNextOccurrence(state, query) {
  let { main, ranges } = state.selection;
  let word = state.wordAt(main.head), fullWord = word && word.from == main.from && word.to == main.to;
  for (let cycled = false, cursor2 = new SearchCursor(state.doc, query, ranges[ranges.length - 1].to); ; ) {
    cursor2.next();
    if (cursor2.done) {
      if (cycled)
        return null;
      cursor2 = new SearchCursor(state.doc, query, 0, Math.max(0, ranges[ranges.length - 1].from - 1));
      cycled = true;
    } else {
      if (cycled && ranges.some((r2) => r2.from == cursor2.value.from))
        continue;
      if (fullWord) {
        let word2 = state.wordAt(cursor2.value.from);
        if (!word2 || word2.from != cursor2.value.from || word2.to != cursor2.value.to)
          continue;
      }
      return cursor2.value;
    }
  }
}
var selectNextOccurrence = ({ state, dispatch }) => {
  let { ranges } = state.selection;
  if (ranges.some((sel) => sel.from === sel.to))
    return selectWord({ state, dispatch });
  let searchedText = state.sliceDoc(ranges[0].from, ranges[0].to);
  if (state.selection.ranges.some((r2) => state.sliceDoc(r2.from, r2.to) != searchedText))
    return false;
  let range = findNextOccurrence(state, searchedText);
  if (!range)
    return false;
  dispatch(state.update({
    selection: state.selection.addRange(EditorSelection.range(range.from, range.to), false),
    effects: EditorView.scrollIntoView(range.to)
  }));
  return true;
};
var searchConfigFacet = Facet.define({
  combine(configs) {
    return combineConfig(configs, {
      top: false,
      caseSensitive: false,
      literal: false,
      regexp: false,
      wholeWord: false,
      createPanel: (view) => new SearchPanel(view),
      scrollToMatch: (range) => EditorView.scrollIntoView(range)
    });
  }
});
var SearchQuery = class {
  /**
  Create a query object.
  */
  constructor(config) {
    this.search = config.search;
    this.caseSensitive = !!config.caseSensitive;
    this.literal = !!config.literal;
    this.regexp = !!config.regexp;
    this.replace = config.replace || "";
    this.valid = !!this.search && (!this.regexp || validRegExp(this.search));
    this.unquoted = this.unquote(this.search);
    this.wholeWord = !!config.wholeWord;
  }
  /**
  @internal
  */
  unquote(text4) {
    return this.literal ? text4 : text4.replace(/\\([nrt\\])/g, (_2, ch) => ch == "n" ? "\n" : ch == "r" ? "\r" : ch == "t" ? "	" : "\\");
  }
  /**
  Compare this query to another query.
  */
  eq(other) {
    return this.search == other.search && this.replace == other.replace && this.caseSensitive == other.caseSensitive && this.regexp == other.regexp && this.wholeWord == other.wholeWord;
  }
  /**
  @internal
  */
  create() {
    return this.regexp ? new RegExpQuery(this) : new StringQuery(this);
  }
  /**
  Get a search cursor for this query, searching through the given
  range in the given state.
  */
  getCursor(state, from = 0, to) {
    let st2 = state.doc ? state : EditorState.create({ doc: state });
    if (to == null)
      to = st2.doc.length;
    return this.regexp ? regexpCursor(this, st2, from, to) : stringCursor(this, st2, from, to);
  }
};
var QueryType = class {
  constructor(spec) {
    this.spec = spec;
  }
};
function stringCursor(spec, state, from, to) {
  return new SearchCursor(state.doc, spec.unquoted, from, to, spec.caseSensitive ? void 0 : (x3) => x3.toLowerCase(), spec.wholeWord ? stringWordTest(state.doc, state.charCategorizer(state.selection.main.head)) : void 0);
}
function stringWordTest(doc, categorizer) {
  return (from, to, buf, bufPos) => {
    if (bufPos > from || bufPos + buf.length < to) {
      bufPos = Math.max(0, from - 2);
      buf = doc.sliceString(bufPos, Math.min(doc.length, to + 2));
    }
    return (categorizer(charBefore(buf, from - bufPos)) != CharCategory.Word || categorizer(charAfter(buf, from - bufPos)) != CharCategory.Word) && (categorizer(charAfter(buf, to - bufPos)) != CharCategory.Word || categorizer(charBefore(buf, to - bufPos)) != CharCategory.Word);
  };
}
var StringQuery = class extends QueryType {
  constructor(spec) {
    super(spec);
  }
  nextMatch(state, curFrom, curTo) {
    let cursor2 = stringCursor(this.spec, state, curTo, state.doc.length).nextOverlapping();
    if (cursor2.done) {
      let end = Math.min(state.doc.length, curFrom + this.spec.unquoted.length);
      cursor2 = stringCursor(this.spec, state, 0, end).nextOverlapping();
    }
    return cursor2.done || cursor2.value.from == curFrom && cursor2.value.to == curTo ? null : cursor2.value;
  }
  // Searching in reverse is, rather than implementing an inverted search
  // cursor, done by scanning chunk after chunk forward.
  prevMatchInRange(state, from, to) {
    for (let pos = to; ; ) {
      let start2 = Math.max(from, pos - 1e4 - this.spec.unquoted.length);
      let cursor2 = stringCursor(this.spec, state, start2, pos), range = null;
      while (!cursor2.nextOverlapping().done)
        range = cursor2.value;
      if (range)
        return range;
      if (start2 == from)
        return null;
      pos -= 1e4;
    }
  }
  prevMatch(state, curFrom, curTo) {
    let found = this.prevMatchInRange(state, 0, curFrom);
    if (!found)
      found = this.prevMatchInRange(state, Math.max(0, curTo - this.spec.unquoted.length), state.doc.length);
    return found && (found.from != curFrom || found.to != curTo) ? found : null;
  }
  getReplacement(_result) {
    return this.spec.unquote(this.spec.replace);
  }
  matchAll(state, limit) {
    let cursor2 = stringCursor(this.spec, state, 0, state.doc.length), ranges = [];
    while (!cursor2.next().done) {
      if (ranges.length >= limit)
        return null;
      ranges.push(cursor2.value);
    }
    return ranges;
  }
  highlight(state, from, to, add2) {
    let cursor2 = stringCursor(this.spec, state, Math.max(0, from - this.spec.unquoted.length), Math.min(to + this.spec.unquoted.length, state.doc.length));
    while (!cursor2.next().done)
      add2(cursor2.value.from, cursor2.value.to);
  }
};
function regexpCursor(spec, state, from, to) {
  return new RegExpCursor(state.doc, spec.search, {
    ignoreCase: !spec.caseSensitive,
    test: spec.wholeWord ? regexpWordTest(state.charCategorizer(state.selection.main.head)) : void 0
  }, from, to);
}
function charBefore(str2, index3) {
  return str2.slice(findClusterBreak(str2, index3, false), index3);
}
function charAfter(str2, index3) {
  return str2.slice(index3, findClusterBreak(str2, index3));
}
function regexpWordTest(categorizer) {
  return (_from, _to, match) => !match[0].length || (categorizer(charBefore(match.input, match.index)) != CharCategory.Word || categorizer(charAfter(match.input, match.index)) != CharCategory.Word) && (categorizer(charAfter(match.input, match.index + match[0].length)) != CharCategory.Word || categorizer(charBefore(match.input, match.index + match[0].length)) != CharCategory.Word);
}
var RegExpQuery = class extends QueryType {
  nextMatch(state, curFrom, curTo) {
    let cursor2 = regexpCursor(this.spec, state, curTo, state.doc.length).next();
    if (cursor2.done)
      cursor2 = regexpCursor(this.spec, state, 0, curFrom).next();
    return cursor2.done ? null : cursor2.value;
  }
  prevMatchInRange(state, from, to) {
    for (let size4 = 1; ; size4++) {
      let start2 = Math.max(
        from,
        to - size4 * 1e4
        /* FindPrev.ChunkSize */
      );
      let cursor2 = regexpCursor(this.spec, state, start2, to), range = null;
      while (!cursor2.next().done)
        range = cursor2.value;
      if (range && (start2 == from || range.from > start2 + 10))
        return range;
      if (start2 == from)
        return null;
    }
  }
  prevMatch(state, curFrom, curTo) {
    return this.prevMatchInRange(state, 0, curFrom) || this.prevMatchInRange(state, curTo, state.doc.length);
  }
  getReplacement(result) {
    return this.spec.unquote(this.spec.replace).replace(/\$([$&]|\d+)/g, (m2, i3) => {
      if (i3 == "&")
        return result.match[0];
      if (i3 == "$")
        return "$";
      for (let l3 = i3.length; l3 > 0; l3--) {
        let n3 = +i3.slice(0, l3);
        if (n3 > 0 && n3 < result.match.length)
          return result.match[n3] + i3.slice(l3);
      }
      return m2;
    });
  }
  matchAll(state, limit) {
    let cursor2 = regexpCursor(this.spec, state, 0, state.doc.length), ranges = [];
    while (!cursor2.next().done) {
      if (ranges.length >= limit)
        return null;
      ranges.push(cursor2.value);
    }
    return ranges;
  }
  highlight(state, from, to, add2) {
    let cursor2 = regexpCursor(this.spec, state, Math.max(
      0,
      from - 250
      /* RegExp.HighlightMargin */
    ), Math.min(to + 250, state.doc.length));
    while (!cursor2.next().done)
      add2(cursor2.value.from, cursor2.value.to);
  }
};
var setSearchQuery = StateEffect.define();
var togglePanel = StateEffect.define();
var searchState = StateField.define({
  create(state) {
    return new SearchState(defaultQuery(state).create(), null);
  },
  update(value2, tr) {
    for (let effect of tr.effects) {
      if (effect.is(setSearchQuery))
        value2 = new SearchState(effect.value.create(), value2.panel);
      else if (effect.is(togglePanel))
        value2 = new SearchState(value2.query, effect.value ? createSearchPanel : null);
    }
    return value2;
  },
  provide: (f3) => showPanel.from(f3, (val) => val.panel)
});
var SearchState = class {
  constructor(query, panel) {
    this.query = query;
    this.panel = panel;
  }
};
var matchMark = Decoration.mark({ class: "cm-searchMatch" });
var selectedMatchMark = Decoration.mark({ class: "cm-searchMatch cm-searchMatch-selected" });
var searchHighlighter = ViewPlugin.fromClass(class {
  constructor(view) {
    this.view = view;
    this.decorations = this.highlight(view.state.field(searchState));
  }
  update(update) {
    let state = update.state.field(searchState);
    if (state != update.startState.field(searchState) || update.docChanged || update.selectionSet || update.viewportChanged)
      this.decorations = this.highlight(state);
  }
  highlight({ query, panel }) {
    if (!panel || !query.spec.valid)
      return Decoration.none;
    let { view } = this;
    let builder = new RangeSetBuilder();
    for (let i3 = 0, ranges = view.visibleRanges, l3 = ranges.length; i3 < l3; i3++) {
      let { from, to } = ranges[i3];
      while (i3 < l3 - 1 && to > ranges[i3 + 1].from - 2 * 250)
        to = ranges[++i3].to;
      query.highlight(view.state, from, to, (from2, to2) => {
        let selected = view.state.selection.ranges.some((r2) => r2.from == from2 && r2.to == to2);
        builder.add(from2, to2, selected ? selectedMatchMark : matchMark);
      });
    }
    return builder.finish();
  }
}, {
  decorations: (v3) => v3.decorations
});
function searchCommand(f3) {
  return (view) => {
    let state = view.state.field(searchState, false);
    return state && state.query.spec.valid ? f3(view, state) : openSearchPanel(view);
  };
}
var findNext = searchCommand((view, { query }) => {
  let { to } = view.state.selection.main;
  let next = query.nextMatch(view.state, to, to);
  if (!next)
    return false;
  let selection2 = EditorSelection.single(next.from, next.to);
  let config = view.state.facet(searchConfigFacet);
  view.dispatch({
    selection: selection2,
    effects: [announceMatch(view, next), config.scrollToMatch(selection2.main, view)],
    userEvent: "select.search"
  });
  selectSearchInput(view);
  return true;
});
var findPrevious = searchCommand((view, { query }) => {
  let { state } = view, { from } = state.selection.main;
  let prev = query.prevMatch(state, from, from);
  if (!prev)
    return false;
  let selection2 = EditorSelection.single(prev.from, prev.to);
  let config = view.state.facet(searchConfigFacet);
  view.dispatch({
    selection: selection2,
    effects: [announceMatch(view, prev), config.scrollToMatch(selection2.main, view)],
    userEvent: "select.search"
  });
  selectSearchInput(view);
  return true;
});
var selectMatches = searchCommand((view, { query }) => {
  let ranges = query.matchAll(view.state, 1e3);
  if (!ranges || !ranges.length)
    return false;
  view.dispatch({
    selection: EditorSelection.create(ranges.map((r2) => EditorSelection.range(r2.from, r2.to))),
    userEvent: "select.search.matches"
  });
  return true;
});
var selectSelectionMatches = ({ state, dispatch }) => {
  let sel = state.selection;
  if (sel.ranges.length > 1 || sel.main.empty)
    return false;
  let { from, to } = sel.main;
  let ranges = [], main = 0;
  for (let cur = new SearchCursor(state.doc, state.sliceDoc(from, to)); !cur.next().done; ) {
    if (ranges.length > 1e3)
      return false;
    if (cur.value.from == from)
      main = ranges.length;
    ranges.push(EditorSelection.range(cur.value.from, cur.value.to));
  }
  dispatch(state.update({
    selection: EditorSelection.create(ranges, main),
    userEvent: "select.search.matches"
  }));
  return true;
};
var replaceNext = searchCommand((view, { query }) => {
  let { state } = view, { from, to } = state.selection.main;
  if (state.readOnly)
    return false;
  let match = query.nextMatch(state, from, from);
  if (!match)
    return false;
  let next = match;
  let changes = [], selection2, replacement;
  let effects = [];
  if (next.from == from && next.to == to) {
    replacement = state.toText(query.getReplacement(next));
    changes.push({ from: next.from, to: next.to, insert: replacement });
    next = query.nextMatch(state, next.from, next.to);
    effects.push(EditorView.announce.of(state.phrase("replaced match on line $", state.doc.lineAt(from).number) + "."));
  }
  if (next) {
    let off = changes.length == 0 || changes[0].from >= match.to ? 0 : match.to - match.from - replacement.length;
    selection2 = EditorSelection.single(next.from - off, next.to - off);
    effects.push(announceMatch(view, next));
    effects.push(state.facet(searchConfigFacet).scrollToMatch(selection2.main, view));
  }
  view.dispatch({
    changes,
    selection: selection2,
    effects,
    userEvent: "input.replace"
  });
  return true;
});
var replaceAll = searchCommand((view, { query }) => {
  if (view.state.readOnly)
    return false;
  let changes = query.matchAll(view.state, 1e9).map((match) => {
    let { from, to } = match;
    return { from, to, insert: query.getReplacement(match) };
  });
  if (!changes.length)
    return false;
  let announceText = view.state.phrase("replaced $ matches", changes.length) + ".";
  view.dispatch({
    changes,
    effects: EditorView.announce.of(announceText),
    userEvent: "input.replace.all"
  });
  return true;
});
function createSearchPanel(view) {
  return view.state.facet(searchConfigFacet).createPanel(view);
}
function defaultQuery(state, fallback) {
  var _a2, _b2, _c2, _d, _e;
  let sel = state.selection.main;
  let selText = sel.empty || sel.to > sel.from + 100 ? "" : state.sliceDoc(sel.from, sel.to);
  if (fallback && !selText)
    return fallback;
  let config = state.facet(searchConfigFacet);
  return new SearchQuery({
    search: ((_a2 = fallback === null || fallback === void 0 ? void 0 : fallback.literal) !== null && _a2 !== void 0 ? _a2 : config.literal) ? selText : selText.replace(/\n/g, "\\n"),
    caseSensitive: (_b2 = fallback === null || fallback === void 0 ? void 0 : fallback.caseSensitive) !== null && _b2 !== void 0 ? _b2 : config.caseSensitive,
    literal: (_c2 = fallback === null || fallback === void 0 ? void 0 : fallback.literal) !== null && _c2 !== void 0 ? _c2 : config.literal,
    regexp: (_d = fallback === null || fallback === void 0 ? void 0 : fallback.regexp) !== null && _d !== void 0 ? _d : config.regexp,
    wholeWord: (_e = fallback === null || fallback === void 0 ? void 0 : fallback.wholeWord) !== null && _e !== void 0 ? _e : config.wholeWord
  });
}
function getSearchInput(view) {
  let panel = getPanel(view, createSearchPanel);
  return panel && panel.dom.querySelector("[main-field]");
}
function selectSearchInput(view) {
  let input = getSearchInput(view);
  if (input && input == view.root.activeElement)
    input.select();
}
var openSearchPanel = (view) => {
  let state = view.state.field(searchState, false);
  if (state && state.panel) {
    let searchInput = getSearchInput(view);
    if (searchInput && searchInput != view.root.activeElement) {
      let query = defaultQuery(view.state, state.query.spec);
      if (query.valid)
        view.dispatch({ effects: setSearchQuery.of(query) });
      searchInput.focus();
      searchInput.select();
    }
  } else {
    view.dispatch({ effects: [
      togglePanel.of(true),
      state ? setSearchQuery.of(defaultQuery(view.state, state.query.spec)) : StateEffect.appendConfig.of(searchExtensions)
    ] });
  }
  return true;
};
var closeSearchPanel = (view) => {
  let state = view.state.field(searchState, false);
  if (!state || !state.panel)
    return false;
  let panel = getPanel(view, createSearchPanel);
  if (panel && panel.dom.contains(view.root.activeElement))
    view.focus();
  view.dispatch({ effects: togglePanel.of(false) });
  return true;
};
var searchKeymap = [
  { key: "Mod-f", run: openSearchPanel, scope: "editor search-panel" },
  { key: "F3", run: findNext, shift: findPrevious, scope: "editor search-panel", preventDefault: true },
  { key: "Mod-g", run: findNext, shift: findPrevious, scope: "editor search-panel", preventDefault: true },
  { key: "Escape", run: closeSearchPanel, scope: "editor search-panel" },
  { key: "Mod-Shift-l", run: selectSelectionMatches },
  { key: "Mod-Alt-g", run: gotoLine },
  { key: "Mod-d", run: selectNextOccurrence, preventDefault: true }
];
var SearchPanel = class {
  constructor(view) {
    this.view = view;
    let query = this.query = view.state.field(searchState).query.spec;
    this.commit = this.commit.bind(this);
    this.searchField = crelt("input", {
      value: query.search,
      placeholder: phrase(view, "Find"),
      "aria-label": phrase(view, "Find"),
      class: "cm-textfield",
      name: "search",
      form: "",
      "main-field": "true",
      onchange: this.commit,
      onkeyup: this.commit
    });
    this.replaceField = crelt("input", {
      value: query.replace,
      placeholder: phrase(view, "Replace"),
      "aria-label": phrase(view, "Replace"),
      class: "cm-textfield",
      name: "replace",
      form: "",
      onchange: this.commit,
      onkeyup: this.commit
    });
    this.caseField = crelt("input", {
      type: "checkbox",
      name: "case",
      form: "",
      checked: query.caseSensitive,
      onchange: this.commit
    });
    this.reField = crelt("input", {
      type: "checkbox",
      name: "re",
      form: "",
      checked: query.regexp,
      onchange: this.commit
    });
    this.wordField = crelt("input", {
      type: "checkbox",
      name: "word",
      form: "",
      checked: query.wholeWord,
      onchange: this.commit
    });
    function button(name2, onclick, content3) {
      return crelt("button", { class: "cm-button", name: name2, onclick, type: "button" }, content3);
    }
    this.dom = crelt("div", { onkeydown: (e2) => this.keydown(e2), class: "cm-search" }, [
      this.searchField,
      button("next", () => findNext(view), [phrase(view, "next")]),
      button("prev", () => findPrevious(view), [phrase(view, "previous")]),
      button("select", () => selectMatches(view), [phrase(view, "all")]),
      crelt("label", null, [this.caseField, phrase(view, "match case")]),
      crelt("label", null, [this.reField, phrase(view, "regexp")]),
      crelt("label", null, [this.wordField, phrase(view, "by word")]),
      ...view.state.readOnly ? [] : [
        crelt("br"),
        this.replaceField,
        button("replace", () => replaceNext(view), [phrase(view, "replace")]),
        button("replaceAll", () => replaceAll(view), [phrase(view, "replace all")])
      ],
      crelt("button", {
        name: "close",
        onclick: () => closeSearchPanel(view),
        "aria-label": phrase(view, "close"),
        type: "button"
      }, ["×"])
    ]);
  }
  commit() {
    let query = new SearchQuery({
      search: this.searchField.value,
      caseSensitive: this.caseField.checked,
      regexp: this.reField.checked,
      wholeWord: this.wordField.checked,
      replace: this.replaceField.value
    });
    if (!query.eq(this.query)) {
      this.query = query;
      this.view.dispatch({ effects: setSearchQuery.of(query) });
    }
  }
  keydown(e2) {
    if (runScopeHandlers(this.view, e2, "search-panel")) {
      e2.preventDefault();
    } else if (e2.keyCode == 13 && e2.target == this.searchField) {
      e2.preventDefault();
      (e2.shiftKey ? findPrevious : findNext)(this.view);
    } else if (e2.keyCode == 13 && e2.target == this.replaceField) {
      e2.preventDefault();
      replaceNext(this.view);
    }
  }
  update(update) {
    for (let tr of update.transactions)
      for (let effect of tr.effects) {
        if (effect.is(setSearchQuery) && !effect.value.eq(this.query))
          this.setQuery(effect.value);
      }
  }
  setQuery(query) {
    this.query = query;
    this.searchField.value = query.search;
    this.replaceField.value = query.replace;
    this.caseField.checked = query.caseSensitive;
    this.reField.checked = query.regexp;
    this.wordField.checked = query.wholeWord;
  }
  mount() {
    this.searchField.select();
  }
  get pos() {
    return 80;
  }
  get top() {
    return this.view.state.facet(searchConfigFacet).top;
  }
};
function phrase(view, phrase2) {
  return view.state.phrase(phrase2);
}
var AnnounceMargin = 30;
var Break = /[\s\.,:;?!]/;
function announceMatch(view, { from, to }) {
  let line = view.state.doc.lineAt(from), lineEnd = view.state.doc.lineAt(to).to;
  let start2 = Math.max(line.from, from - AnnounceMargin), end = Math.min(lineEnd, to + AnnounceMargin);
  let text4 = view.state.sliceDoc(start2, end);
  if (start2 != line.from) {
    for (let i3 = 0; i3 < AnnounceMargin; i3++)
      if (!Break.test(text4[i3 + 1]) && Break.test(text4[i3])) {
        text4 = text4.slice(i3);
        break;
      }
  }
  if (end != lineEnd) {
    for (let i3 = text4.length - 1; i3 > text4.length - AnnounceMargin; i3--)
      if (!Break.test(text4[i3 - 1]) && Break.test(text4[i3])) {
        text4 = text4.slice(0, i3);
        break;
      }
  }
  return EditorView.announce.of(`${view.state.phrase("current match")}. ${text4} ${view.state.phrase("on line")} ${line.number}.`);
}
var baseTheme = EditorView.baseTheme({
  ".cm-panel.cm-search": {
    padding: "2px 6px 4px",
    position: "relative",
    "& [name=close]": {
      position: "absolute",
      top: "0",
      right: "4px",
      backgroundColor: "inherit",
      border: "none",
      font: "inherit",
      padding: 0,
      margin: 0
    },
    "& input, & button, & label": {
      margin: ".2em .6em .2em 0"
    },
    "& input[type=checkbox]": {
      marginRight: ".2em"
    },
    "& label": {
      fontSize: "80%",
      whiteSpace: "pre"
    }
  },
  "&light .cm-searchMatch": { backgroundColor: "#ffff0054" },
  "&dark .cm-searchMatch": { backgroundColor: "#00ffff8a" },
  "&light .cm-searchMatch-selected": { backgroundColor: "#ff6a0054" },
  "&dark .cm-searchMatch-selected": { backgroundColor: "#ff00ff8a" }
});
var searchExtensions = [
  searchState,
  Prec.low(searchHighlighter),
  baseTheme
];

// node_modules/@codemirror/lint/dist/index.js
var SelectedDiagnostic = class {
  constructor(from, to, diagnostic) {
    this.from = from;
    this.to = to;
    this.diagnostic = diagnostic;
  }
};
var LintState = class _LintState {
  constructor(diagnostics, panel, selected) {
    this.diagnostics = diagnostics;
    this.panel = panel;
    this.selected = selected;
  }
  static init(diagnostics, panel, state) {
    let markedDiagnostics = diagnostics;
    let diagnosticFilter = state.facet(lintConfig).markerFilter;
    if (diagnosticFilter)
      markedDiagnostics = diagnosticFilter(markedDiagnostics, state);
    let sorted = diagnostics.slice().sort((a2, b3) => a2.from - b3.from || a2.to - b3.to);
    let deco = new RangeSetBuilder(), active = [], pos = 0;
    for (let i3 = 0; ; ) {
      let next = i3 == sorted.length ? null : sorted[i3];
      if (!next && !active.length)
        break;
      let from, to;
      if (active.length) {
        from = pos;
        to = active.reduce((p2, d3) => Math.min(p2, d3.to), next && next.from > from ? next.from : 1e8);
      } else {
        from = next.from;
        to = next.to;
        active.push(next);
        i3++;
      }
      while (i3 < sorted.length) {
        let next2 = sorted[i3];
        if (next2.from == from && (next2.to > next2.from || next2.to == from)) {
          active.push(next2);
          i3++;
          to = Math.min(next2.to, to);
        } else {
          to = Math.min(next2.from, to);
          break;
        }
      }
      let sev = maxSeverity(active);
      if (active.some((d3) => d3.from == d3.to || d3.from == d3.to - 1 && state.doc.lineAt(d3.from).to == d3.from)) {
        deco.add(from, from, Decoration.widget({
          widget: new DiagnosticWidget(sev),
          diagnostics: active.slice()
        }));
      } else {
        let markClass = active.reduce((c2, d3) => d3.markClass ? c2 + " " + d3.markClass : c2, "");
        deco.add(from, to, Decoration.mark({
          class: "cm-lintRange cm-lintRange-" + sev + markClass,
          diagnostics: active.slice(),
          inclusiveEnd: active.some((a2) => a2.to > to)
        }));
      }
      pos = to;
      for (let i4 = 0; i4 < active.length; i4++)
        if (active[i4].to <= pos)
          active.splice(i4--, 1);
    }
    let set3 = deco.finish();
    return new _LintState(set3, panel, findDiagnostic(set3));
  }
};
function findDiagnostic(diagnostics, diagnostic = null, after = 0) {
  let found = null;
  diagnostics.between(after, 1e9, (from, to, { spec }) => {
    if (diagnostic && spec.diagnostics.indexOf(diagnostic) < 0)
      return;
    if (!found)
      found = new SelectedDiagnostic(from, to, diagnostic || spec.diagnostics[0]);
    else if (spec.diagnostics.indexOf(found.diagnostic) < 0)
      return false;
    else
      found = new SelectedDiagnostic(found.from, to, found.diagnostic);
  });
  return found;
}
function hideTooltip(tr, tooltip) {
  let from = tooltip.pos, to = tooltip.end || from;
  let result = tr.state.facet(lintConfig).hideOn(tr, from, to);
  if (result != null)
    return result;
  let line = tr.startState.doc.lineAt(tooltip.pos);
  return !!(tr.effects.some((e2) => e2.is(setDiagnosticsEffect)) || tr.changes.touchesRange(line.from, Math.max(line.to, to)));
}
function maybeEnableLint(state, effects) {
  return state.field(lintState, false) ? effects : effects.concat(StateEffect.appendConfig.of(lintExtensions));
}
function setDiagnostics(state, diagnostics) {
  return {
    effects: maybeEnableLint(state, [setDiagnosticsEffect.of(diagnostics)])
  };
}
var setDiagnosticsEffect = StateEffect.define();
var togglePanel2 = StateEffect.define();
var movePanelSelection = StateEffect.define();
var lintState = StateField.define({
  create() {
    return new LintState(Decoration.none, null, null);
  },
  update(value2, tr) {
    if (tr.docChanged && value2.diagnostics.size) {
      let mapped = value2.diagnostics.map(tr.changes), selected = null, panel = value2.panel;
      if (value2.selected) {
        let selPos = tr.changes.mapPos(value2.selected.from, 1);
        selected = findDiagnostic(mapped, value2.selected.diagnostic, selPos) || findDiagnostic(mapped, null, selPos);
      }
      if (!mapped.size && panel && tr.state.facet(lintConfig).autoPanel)
        panel = null;
      value2 = new LintState(mapped, panel, selected);
    }
    for (let effect of tr.effects) {
      if (effect.is(setDiagnosticsEffect)) {
        let panel = !tr.state.facet(lintConfig).autoPanel ? value2.panel : effect.value.length ? LintPanel.open : null;
        value2 = LintState.init(effect.value, panel, tr.state);
      } else if (effect.is(togglePanel2)) {
        value2 = new LintState(value2.diagnostics, effect.value ? LintPanel.open : null, value2.selected);
      } else if (effect.is(movePanelSelection)) {
        value2 = new LintState(value2.diagnostics, value2.panel, effect.value);
      }
    }
    return value2;
  },
  provide: (f3) => [
    showPanel.from(f3, (val) => val.panel),
    EditorView.decorations.from(f3, (s2) => s2.diagnostics)
  ]
});
var activeMark = Decoration.mark({ class: "cm-lintRange cm-lintRange-active" });
function lintTooltip(view, pos, side) {
  let { diagnostics } = view.state.field(lintState);
  let found, start2 = -1, end = -1;
  diagnostics.between(pos - (side < 0 ? 1 : 0), pos + (side > 0 ? 1 : 0), (from, to, { spec }) => {
    if (pos >= from && pos <= to && (from == to || (pos > from || side > 0) && (pos < to || side < 0))) {
      found = spec.diagnostics;
      start2 = from;
      end = to;
      return false;
    }
  });
  let diagnosticFilter = view.state.facet(lintConfig).tooltipFilter;
  if (found && diagnosticFilter)
    found = diagnosticFilter(found, view.state);
  if (!found)
    return null;
  return {
    pos: start2,
    end,
    above: view.state.doc.lineAt(start2).to < end,
    create() {
      return { dom: diagnosticsTooltip(view, found) };
    }
  };
}
function diagnosticsTooltip(view, diagnostics) {
  return crelt("ul", { class: "cm-tooltip-lint" }, diagnostics.map((d3) => renderDiagnostic(view, d3, false)));
}
var openLintPanel = (view) => {
  let field = view.state.field(lintState, false);
  if (!field || !field.panel)
    view.dispatch({ effects: maybeEnableLint(view.state, [togglePanel2.of(true)]) });
  let panel = getPanel(view, LintPanel.open);
  if (panel)
    panel.dom.querySelector(".cm-panel-lint ul").focus();
  return true;
};
var closeLintPanel = (view) => {
  let field = view.state.field(lintState, false);
  if (!field || !field.panel)
    return false;
  view.dispatch({ effects: togglePanel2.of(false) });
  return true;
};
var nextDiagnostic = (view) => {
  let field = view.state.field(lintState, false);
  if (!field)
    return false;
  let sel = view.state.selection.main, next = field.diagnostics.iter(sel.to + 1);
  if (!next.value) {
    next = field.diagnostics.iter(0);
    if (!next.value || next.from == sel.from && next.to == sel.to)
      return false;
  }
  view.dispatch({ selection: { anchor: next.from, head: next.to }, scrollIntoView: true });
  return true;
};
var lintKeymap = [
  { key: "Mod-Shift-m", run: openLintPanel, preventDefault: true },
  { key: "F8", run: nextDiagnostic }
];
var lintPlugin = ViewPlugin.fromClass(class {
  constructor(view) {
    this.view = view;
    this.timeout = -1;
    this.set = true;
    let { delay } = view.state.facet(lintConfig);
    this.lintTime = Date.now() + delay;
    this.run = this.run.bind(this);
    this.timeout = setTimeout(this.run, delay);
  }
  run() {
    clearTimeout(this.timeout);
    let now = Date.now();
    if (now < this.lintTime - 10) {
      this.timeout = setTimeout(this.run, this.lintTime - now);
    } else {
      this.set = false;
      let { state } = this.view, { sources } = state.facet(lintConfig);
      if (sources.length)
        batchResults(sources.map((s2) => Promise.resolve(s2(this.view))), (annotations) => {
          if (this.view.state.doc == state.doc)
            this.view.dispatch(setDiagnostics(this.view.state, annotations.reduce((a2, b3) => a2.concat(b3))));
        }, (error) => {
          logException(this.view.state, error);
        });
    }
  }
  update(update) {
    let config = update.state.facet(lintConfig);
    if (update.docChanged || config != update.startState.facet(lintConfig) || config.needsRefresh && config.needsRefresh(update)) {
      this.lintTime = Date.now() + config.delay;
      if (!this.set) {
        this.set = true;
        this.timeout = setTimeout(this.run, config.delay);
      }
    }
  }
  force() {
    if (this.set) {
      this.lintTime = Date.now();
      this.run();
    }
  }
  destroy() {
    clearTimeout(this.timeout);
  }
});
function batchResults(promises, sink, error) {
  let collected = [], timeout = -1;
  for (let p2 of promises)
    p2.then((value2) => {
      collected.push(value2);
      clearTimeout(timeout);
      if (collected.length == promises.length)
        sink(collected);
      else
        timeout = setTimeout(() => sink(collected), 200);
    }, error);
}
var lintConfig = Facet.define({
  combine(input) {
    return Object.assign({ sources: input.map((i3) => i3.source).filter((x3) => x3 != null) }, combineConfig(input.map((i3) => i3.config), {
      delay: 750,
      markerFilter: null,
      tooltipFilter: null,
      needsRefresh: null,
      hideOn: () => null
    }, {
      needsRefresh: (a2, b3) => !a2 ? b3 : !b3 ? a2 : (u2) => a2(u2) || b3(u2)
    }));
  }
});
function assignKeys(actions) {
  let assigned = [];
  if (actions)
    actions: for (let { name: name2 } of actions) {
      for (let i3 = 0; i3 < name2.length; i3++) {
        let ch = name2[i3];
        if (/[a-zA-Z]/.test(ch) && !assigned.some((c2) => c2.toLowerCase() == ch.toLowerCase())) {
          assigned.push(ch);
          continue actions;
        }
      }
      assigned.push("");
    }
  return assigned;
}
function renderDiagnostic(view, diagnostic, inPanel) {
  var _a2;
  let keys = inPanel ? assignKeys(diagnostic.actions) : [];
  return crelt("li", { class: "cm-diagnostic cm-diagnostic-" + diagnostic.severity }, crelt("span", { class: "cm-diagnosticText" }, diagnostic.renderMessage ? diagnostic.renderMessage(view) : diagnostic.message), (_a2 = diagnostic.actions) === null || _a2 === void 0 ? void 0 : _a2.map((action, i3) => {
    let fired = false, click = (e2) => {
      e2.preventDefault();
      if (fired)
        return;
      fired = true;
      let found = findDiagnostic(view.state.field(lintState).diagnostics, diagnostic);
      if (found)
        action.apply(view, found.from, found.to);
    };
    let { name: name2 } = action, keyIndex = keys[i3] ? name2.indexOf(keys[i3]) : -1;
    let nameElt = keyIndex < 0 ? name2 : [
      name2.slice(0, keyIndex),
      crelt("u", name2.slice(keyIndex, keyIndex + 1)),
      name2.slice(keyIndex + 1)
    ];
    return crelt("button", {
      type: "button",
      class: "cm-diagnosticAction",
      onclick: click,
      onmousedown: click,
      "aria-label": ` Action: ${name2}${keyIndex < 0 ? "" : ` (access key "${keys[i3]})"`}.`
    }, nameElt);
  }), diagnostic.source && crelt("div", { class: "cm-diagnosticSource" }, diagnostic.source));
}
var DiagnosticWidget = class extends WidgetType {
  constructor(sev) {
    super();
    this.sev = sev;
  }
  eq(other) {
    return other.sev == this.sev;
  }
  toDOM() {
    return crelt("span", { class: "cm-lintPoint cm-lintPoint-" + this.sev });
  }
};
var PanelItem = class {
  constructor(view, diagnostic) {
    this.diagnostic = diagnostic;
    this.id = "item_" + Math.floor(Math.random() * 4294967295).toString(16);
    this.dom = renderDiagnostic(view, diagnostic, true);
    this.dom.id = this.id;
    this.dom.setAttribute("role", "option");
  }
};
var LintPanel = class _LintPanel {
  constructor(view) {
    this.view = view;
    this.items = [];
    let onkeydown = (event) => {
      if (event.keyCode == 27) {
        closeLintPanel(this.view);
        this.view.focus();
      } else if (event.keyCode == 38 || event.keyCode == 33) {
        this.moveSelection((this.selectedIndex - 1 + this.items.length) % this.items.length);
      } else if (event.keyCode == 40 || event.keyCode == 34) {
        this.moveSelection((this.selectedIndex + 1) % this.items.length);
      } else if (event.keyCode == 36) {
        this.moveSelection(0);
      } else if (event.keyCode == 35) {
        this.moveSelection(this.items.length - 1);
      } else if (event.keyCode == 13) {
        this.view.focus();
      } else if (event.keyCode >= 65 && event.keyCode <= 90 && this.selectedIndex >= 0) {
        let { diagnostic } = this.items[this.selectedIndex], keys = assignKeys(diagnostic.actions);
        for (let i3 = 0; i3 < keys.length; i3++)
          if (keys[i3].toUpperCase().charCodeAt(0) == event.keyCode) {
            let found = findDiagnostic(this.view.state.field(lintState).diagnostics, diagnostic);
            if (found)
              diagnostic.actions[i3].apply(view, found.from, found.to);
          }
      } else {
        return;
      }
      event.preventDefault();
    };
    let onclick = (event) => {
      for (let i3 = 0; i3 < this.items.length; i3++) {
        if (this.items[i3].dom.contains(event.target))
          this.moveSelection(i3);
      }
    };
    this.list = crelt("ul", {
      tabIndex: 0,
      role: "listbox",
      "aria-label": this.view.state.phrase("Diagnostics"),
      onkeydown,
      onclick
    });
    this.dom = crelt("div", { class: "cm-panel-lint" }, this.list, crelt("button", {
      type: "button",
      name: "close",
      "aria-label": this.view.state.phrase("close"),
      onclick: () => closeLintPanel(this.view)
    }, "×"));
    this.update();
  }
  get selectedIndex() {
    let selected = this.view.state.field(lintState).selected;
    if (!selected)
      return -1;
    for (let i3 = 0; i3 < this.items.length; i3++)
      if (this.items[i3].diagnostic == selected.diagnostic)
        return i3;
    return -1;
  }
  update() {
    let { diagnostics, selected } = this.view.state.field(lintState);
    let i3 = 0, needsSync = false, newSelectedItem = null;
    let seen = /* @__PURE__ */ new Set();
    diagnostics.between(0, this.view.state.doc.length, (_start, _end, { spec }) => {
      for (let diagnostic of spec.diagnostics) {
        if (seen.has(diagnostic))
          continue;
        seen.add(diagnostic);
        let found = -1, item;
        for (let j3 = i3; j3 < this.items.length; j3++)
          if (this.items[j3].diagnostic == diagnostic) {
            found = j3;
            break;
          }
        if (found < 0) {
          item = new PanelItem(this.view, diagnostic);
          this.items.splice(i3, 0, item);
          needsSync = true;
        } else {
          item = this.items[found];
          if (found > i3) {
            this.items.splice(i3, found - i3);
            needsSync = true;
          }
        }
        if (selected && item.diagnostic == selected.diagnostic) {
          if (!item.dom.hasAttribute("aria-selected")) {
            item.dom.setAttribute("aria-selected", "true");
            newSelectedItem = item;
          }
        } else if (item.dom.hasAttribute("aria-selected")) {
          item.dom.removeAttribute("aria-selected");
        }
        i3++;
      }
    });
    while (i3 < this.items.length && !(this.items.length == 1 && this.items[0].diagnostic.from < 0)) {
      needsSync = true;
      this.items.pop();
    }
    if (this.items.length == 0) {
      this.items.push(new PanelItem(this.view, {
        from: -1,
        to: -1,
        severity: "info",
        message: this.view.state.phrase("No diagnostics")
      }));
      needsSync = true;
    }
    if (newSelectedItem) {
      this.list.setAttribute("aria-activedescendant", newSelectedItem.id);
      this.view.requestMeasure({
        key: this,
        read: () => ({ sel: newSelectedItem.dom.getBoundingClientRect(), panel: this.list.getBoundingClientRect() }),
        write: ({ sel, panel }) => {
          let scaleY = panel.height / this.list.offsetHeight;
          if (sel.top < panel.top)
            this.list.scrollTop -= (panel.top - sel.top) / scaleY;
          else if (sel.bottom > panel.bottom)
            this.list.scrollTop += (sel.bottom - panel.bottom) / scaleY;
        }
      });
    } else if (this.selectedIndex < 0) {
      this.list.removeAttribute("aria-activedescendant");
    }
    if (needsSync)
      this.sync();
  }
  sync() {
    let domPos = this.list.firstChild;
    function rm2() {
      let prev = domPos;
      domPos = prev.nextSibling;
      prev.remove();
    }
    for (let item of this.items) {
      if (item.dom.parentNode == this.list) {
        while (domPos != item.dom)
          rm2();
        domPos = item.dom.nextSibling;
      } else {
        this.list.insertBefore(item.dom, domPos);
      }
    }
    while (domPos)
      rm2();
  }
  moveSelection(selectedIndex) {
    if (this.selectedIndex < 0)
      return;
    let field = this.view.state.field(lintState);
    let selection2 = findDiagnostic(field.diagnostics, this.items[selectedIndex].diagnostic);
    if (!selection2)
      return;
    this.view.dispatch({
      selection: { anchor: selection2.from, head: selection2.to },
      scrollIntoView: true,
      effects: movePanelSelection.of(selection2)
    });
  }
  static open(view) {
    return new _LintPanel(view);
  }
};
function svg(content3, attrs = `viewBox="0 0 40 40"`) {
  return `url('data:image/svg+xml,<svg xmlns="http://www.w3.org/2000/svg" ${attrs}>${encodeURIComponent(content3)}</svg>')`;
}
function underline2(color4) {
  return svg(`<path d="m0 2.5 l2 -1.5 l1 0 l2 1.5 l1 0" stroke="${color4}" fill="none" stroke-width=".7"/>`, `width="6" height="3"`);
}
var baseTheme2 = EditorView.baseTheme({
  ".cm-diagnostic": {
    padding: "3px 6px 3px 8px",
    marginLeft: "-1px",
    display: "block",
    whiteSpace: "pre-wrap"
  },
  ".cm-diagnostic-error": { borderLeft: "5px solid #d11" },
  ".cm-diagnostic-warning": { borderLeft: "5px solid orange" },
  ".cm-diagnostic-info": { borderLeft: "5px solid #999" },
  ".cm-diagnostic-hint": { borderLeft: "5px solid #66d" },
  ".cm-diagnosticAction": {
    font: "inherit",
    border: "none",
    padding: "2px 4px",
    backgroundColor: "#444",
    color: "white",
    borderRadius: "3px",
    marginLeft: "8px",
    cursor: "pointer"
  },
  ".cm-diagnosticSource": {
    fontSize: "70%",
    opacity: 0.7
  },
  ".cm-lintRange": {
    backgroundPosition: "left bottom",
    backgroundRepeat: "repeat-x",
    paddingBottom: "0.7px"
  },
  ".cm-lintRange-error": { backgroundImage: underline2("#d11") },
  ".cm-lintRange-warning": { backgroundImage: underline2("orange") },
  ".cm-lintRange-info": { backgroundImage: underline2("#999") },
  ".cm-lintRange-hint": { backgroundImage: underline2("#66d") },
  ".cm-lintRange-active": { backgroundColor: "#ffdd9980" },
  ".cm-tooltip-lint": {
    padding: 0,
    margin: 0
  },
  ".cm-lintPoint": {
    position: "relative",
    "&:after": {
      content: '""',
      position: "absolute",
      bottom: 0,
      left: "-2px",
      borderLeft: "3px solid transparent",
      borderRight: "3px solid transparent",
      borderBottom: "4px solid #d11"
    }
  },
  ".cm-lintPoint-warning": {
    "&:after": { borderBottomColor: "orange" }
  },
  ".cm-lintPoint-info": {
    "&:after": { borderBottomColor: "#999" }
  },
  ".cm-lintPoint-hint": {
    "&:after": { borderBottomColor: "#66d" }
  },
  ".cm-panel.cm-panel-lint": {
    position: "relative",
    "& ul": {
      maxHeight: "100px",
      overflowY: "auto",
      "& [aria-selected]": {
        backgroundColor: "#ddd",
        "& u": { textDecoration: "underline" }
      },
      "&:focus [aria-selected]": {
        background_fallback: "#bdf",
        backgroundColor: "Highlight",
        color_fallback: "white",
        color: "HighlightText"
      },
      "& u": { textDecoration: "none" },
      padding: 0,
      margin: 0
    },
    "& [name=close]": {
      position: "absolute",
      top: "0",
      right: "2px",
      background: "inherit",
      border: "none",
      font: "inherit",
      padding: 0,
      margin: 0
    }
  }
});
function severityWeight(sev) {
  return sev == "error" ? 4 : sev == "warning" ? 3 : sev == "info" ? 2 : 1;
}
function maxSeverity(diagnostics) {
  let sev = "hint", weight = 1;
  for (let d3 of diagnostics) {
    let w3 = severityWeight(d3.severity);
    if (w3 > weight) {
      weight = w3;
      sev = d3.severity;
    }
  }
  return sev;
}
var LintGutterMarker = class extends GutterMarker {
  constructor(diagnostics) {
    super();
    this.diagnostics = diagnostics;
    this.severity = maxSeverity(diagnostics);
  }
  toDOM(view) {
    let elt = document.createElement("div");
    elt.className = "cm-lint-marker cm-lint-marker-" + this.severity;
    let diagnostics = this.diagnostics;
    let diagnosticsFilter = view.state.facet(lintGutterConfig).tooltipFilter;
    if (diagnosticsFilter)
      diagnostics = diagnosticsFilter(diagnostics, view.state);
    if (diagnostics.length)
      elt.onmouseover = () => gutterMarkerMouseOver(view, elt, diagnostics);
    return elt;
  }
};
function trackHoverOn(view, marker) {
  let mousemove = (event) => {
    let rect = marker.getBoundingClientRect();
    if (event.clientX > rect.left - 10 && event.clientX < rect.right + 10 && event.clientY > rect.top - 10 && event.clientY < rect.bottom + 10)
      return;
    for (let target = event.target; target; target = target.parentNode) {
      if (target.nodeType == 1 && target.classList.contains("cm-tooltip-lint"))
        return;
    }
    window.removeEventListener("mousemove", mousemove);
    if (view.state.field(lintGutterTooltip))
      view.dispatch({ effects: setLintGutterTooltip.of(null) });
  };
  window.addEventListener("mousemove", mousemove);
}
function gutterMarkerMouseOver(view, marker, diagnostics) {
  function hovered() {
    let line = view.elementAtHeight(marker.getBoundingClientRect().top + 5 - view.documentTop);
    const linePos = view.coordsAtPos(line.from);
    if (linePos) {
      view.dispatch({ effects: setLintGutterTooltip.of({
        pos: line.from,
        above: false,
        clip: false,
        create() {
          return {
            dom: diagnosticsTooltip(view, diagnostics),
            getCoords: () => marker.getBoundingClientRect()
          };
        }
      }) });
    }
    marker.onmouseout = marker.onmousemove = null;
    trackHoverOn(view, marker);
  }
  let { hoverTime } = view.state.facet(lintGutterConfig);
  let hoverTimeout = setTimeout(hovered, hoverTime);
  marker.onmouseout = () => {
    clearTimeout(hoverTimeout);
    marker.onmouseout = marker.onmousemove = null;
  };
  marker.onmousemove = () => {
    clearTimeout(hoverTimeout);
    hoverTimeout = setTimeout(hovered, hoverTime);
  };
}
function markersForDiagnostics(doc, diagnostics) {
  let byLine = /* @__PURE__ */ Object.create(null);
  for (let diagnostic of diagnostics) {
    let line = doc.lineAt(diagnostic.from);
    (byLine[line.from] || (byLine[line.from] = [])).push(diagnostic);
  }
  let markers2 = [];
  for (let line in byLine) {
    markers2.push(new LintGutterMarker(byLine[line]).range(+line));
  }
  return RangeSet.of(markers2, true);
}
var lintGutterExtension = gutter({
  class: "cm-gutter-lint",
  markers: (view) => view.state.field(lintGutterMarkers),
  widgetMarker: (view, widget, block) => {
    let diagnostics = [];
    view.state.field(lintGutterMarkers).between(block.from, block.to, (from, to, value2) => {
      if (from > block.from && from < block.to)
        diagnostics.push(...value2.diagnostics);
    });
    return diagnostics.length ? new LintGutterMarker(diagnostics) : null;
  }
});
var lintGutterMarkers = StateField.define({
  create() {
    return RangeSet.empty;
  },
  update(markers2, tr) {
    markers2 = markers2.map(tr.changes);
    let diagnosticFilter = tr.state.facet(lintGutterConfig).markerFilter;
    for (let effect of tr.effects) {
      if (effect.is(setDiagnosticsEffect)) {
        let diagnostics = effect.value;
        if (diagnosticFilter)
          diagnostics = diagnosticFilter(diagnostics || [], tr.state);
        markers2 = markersForDiagnostics(tr.state.doc, diagnostics.slice(0));
      }
    }
    return markers2;
  }
});
var setLintGutterTooltip = StateEffect.define();
var lintGutterTooltip = StateField.define({
  create() {
    return null;
  },
  update(tooltip, tr) {
    if (tooltip && tr.docChanged)
      tooltip = hideTooltip(tr, tooltip) ? null : Object.assign(Object.assign({}, tooltip), { pos: tr.changes.mapPos(tooltip.pos) });
    return tr.effects.reduce((t3, e2) => e2.is(setLintGutterTooltip) ? e2.value : t3, tooltip);
  },
  provide: (field) => showTooltip.from(field)
});
var lintGutterTheme = EditorView.baseTheme({
  ".cm-gutter-lint": {
    width: "1.4em",
    "& .cm-gutterElement": {
      padding: ".2em"
    }
  },
  ".cm-lint-marker": {
    width: "1em",
    height: "1em"
  },
  ".cm-lint-marker-info": {
    content: svg(`<path fill="#aaf" stroke="#77e" stroke-width="6" stroke-linejoin="round" d="M5 5L35 5L35 35L5 35Z"/>`)
  },
  ".cm-lint-marker-warning": {
    content: svg(`<path fill="#fe8" stroke="#fd7" stroke-width="6" stroke-linejoin="round" d="M20 6L37 35L3 35Z"/>`)
  },
  ".cm-lint-marker-error": {
    content: svg(`<circle cx="20" cy="20" r="15" fill="#f87" stroke="#f43" stroke-width="6"/>`)
  }
});
var lintExtensions = [
  lintState,
  EditorView.decorations.compute([lintState], (state) => {
    let { selected, panel } = state.field(lintState);
    return !selected || !panel || selected.from == selected.to ? Decoration.none : Decoration.set([
      activeMark.range(selected.from, selected.to)
    ]);
  }),
  hoverTooltip(lintTooltip, { hideOn: hideTooltip }),
  baseTheme2
];
var lintGutterConfig = Facet.define({
  combine(configs) {
    return combineConfig(configs, {
      hoverTime: 300,
      markerFilter: null,
      tooltipFilter: null
    });
  }
});

// node_modules/codemirror/dist/index.js
var basicSetup = (() => [
  lineNumbers(),
  highlightActiveLineGutter(),
  highlightSpecialChars(),
  history(),
  foldGutter(),
  drawSelection(),
  dropCursor(),
  EditorState.allowMultipleSelections.of(true),
  indentOnInput(),
  syntaxHighlighting(defaultHighlightStyle, { fallback: true }),
  bracketMatching(),
  closeBrackets(),
  autocompletion(),
  rectangularSelection(),
  crosshairCursor(),
  highlightActiveLine(),
  highlightSelectionMatches(),
  keymap.of([
    ...closeBracketsKeymap,
    ...defaultKeymap,
    ...searchKeymap,
    ...historyKeymap,
    ...foldKeymap,
    ...completionKeymap,
    ...lintKeymap
  ])
])();
var minimalSetup = (() => [
  highlightSpecialChars(),
  history(),
  drawSelection(),
  syntaxHighlighting(defaultHighlightStyle, { fallback: true }),
  keymap.of([
    ...defaultKeymap,
    ...historyKeymap
  ])
])();

// node_modules/@mdxeditor/editor/dist/plugins/toolbar/primitives/select.js
var import_react52 = __toESM(require_react(), 1);

// node_modules/@radix-ui/react-select/dist/index.mjs
var React46 = __toESM(require_react(), 1);
var ReactDOM4 = __toESM(require_react_dom(), 1);

// node_modules/@radix-ui/number/dist/index.mjs
function clamp3(value2, [min2, max2]) {
  return Math.min(max2, Math.max(min2, value2));
}

// node_modules/@radix-ui/react-use-previous/dist/index.mjs
var React44 = __toESM(require_react(), 1);
function usePrevious(value2) {
  const ref2 = React44.useRef({ value: value2, previous: value2 });
  return React44.useMemo(() => {
    if (ref2.current.value !== value2) {
      ref2.current.previous = ref2.current.value;
      ref2.current.value = value2;
    }
    return ref2.current.previous;
  }, [value2]);
}

// node_modules/@radix-ui/react-visually-hidden/dist/index.mjs
var React45 = __toESM(require_react(), 1);
var import_jsx_runtime25 = __toESM(require_jsx_runtime(), 1);
var NAME4 = "VisuallyHidden";
var VisuallyHidden = React45.forwardRef(
  (props, forwardedRef) => {
    return (0, import_jsx_runtime25.jsx)(
      Primitive.span,
      {
        ...props,
        ref: forwardedRef,
        style: {
          // See: https://github.com/twbs/bootstrap/blob/main/scss/mixins/_visually-hidden.scss
          position: "absolute",
          border: 0,
          width: 1,
          height: 1,
          padding: 0,
          margin: -1,
          overflow: "hidden",
          clip: "rect(0, 0, 0, 0)",
          whiteSpace: "nowrap",
          wordWrap: "normal",
          ...props.style
        }
      }
    );
  }
);
VisuallyHidden.displayName = NAME4;
var Root6 = VisuallyHidden;

// node_modules/@radix-ui/react-select/dist/index.mjs
var import_jsx_runtime26 = __toESM(require_jsx_runtime(), 1);
var OPEN_KEYS = [" ", "Enter", "ArrowUp", "ArrowDown"];
var SELECTION_KEYS = [" ", "Enter"];
var SELECT_NAME = "Select";
var [Collection2, useCollection2, createCollectionScope2] = createCollection(SELECT_NAME);
var [createSelectContext, createSelectScope] = createContextScope(SELECT_NAME, [
  createCollectionScope2,
  createPopperScope
]);
var usePopperScope2 = createPopperScope();
var [SelectProvider, useSelectContext] = createSelectContext(SELECT_NAME);
var [SelectNativeOptionsProvider, useSelectNativeOptionsContext] = createSelectContext(SELECT_NAME);
var Select = (props) => {
  const {
    __scopeSelect,
    children,
    open: openProp,
    defaultOpen,
    onOpenChange,
    value: valueProp,
    defaultValue,
    onValueChange,
    dir,
    name: name2,
    autoComplete,
    disabled,
    required,
    form
  } = props;
  const popperScope = usePopperScope2(__scopeSelect);
  const [trigger, setTrigger] = React46.useState(null);
  const [valueNode, setValueNode] = React46.useState(null);
  const [valueNodeHasChildren, setValueNodeHasChildren] = React46.useState(false);
  const direction = useDirection(dir);
  const [open = false, setOpen] = useControllableState({
    prop: openProp,
    defaultProp: defaultOpen,
    onChange: onOpenChange
  });
  const [value2, setValue] = useControllableState({
    prop: valueProp,
    defaultProp: defaultValue,
    onChange: onValueChange
  });
  const triggerPointerDownPosRef = React46.useRef(null);
  const isFormControl = trigger ? form || !!trigger.closest("form") : true;
  const [nativeOptionsSet, setNativeOptionsSet] = React46.useState(/* @__PURE__ */ new Set());
  const nativeSelectKey = Array.from(nativeOptionsSet).map((option) => option.props.value).join(";");
  return (0, import_jsx_runtime26.jsx)(Root2, { ...popperScope, children: (0, import_jsx_runtime26.jsxs)(
    SelectProvider,
    {
      required,
      scope: __scopeSelect,
      trigger,
      onTriggerChange: setTrigger,
      valueNode,
      onValueNodeChange: setValueNode,
      valueNodeHasChildren,
      onValueNodeHasChildrenChange: setValueNodeHasChildren,
      contentId: useId(),
      value: value2,
      onValueChange: setValue,
      open,
      onOpenChange: setOpen,
      dir: direction,
      triggerPointerDownPosRef,
      disabled,
      children: [
        (0, import_jsx_runtime26.jsx)(Collection2.Provider, { scope: __scopeSelect, children: (0, import_jsx_runtime26.jsx)(
          SelectNativeOptionsProvider,
          {
            scope: props.__scopeSelect,
            onNativeOptionAdd: React46.useCallback((option) => {
              setNativeOptionsSet((prev) => new Set(prev).add(option));
            }, []),
            onNativeOptionRemove: React46.useCallback((option) => {
              setNativeOptionsSet((prev) => {
                const optionsSet = new Set(prev);
                optionsSet.delete(option);
                return optionsSet;
              });
            }, []),
            children
          }
        ) }),
        isFormControl ? (0, import_jsx_runtime26.jsxs)(
          BubbleSelect,
          {
            "aria-hidden": true,
            required,
            tabIndex: -1,
            name: name2,
            autoComplete,
            value: value2,
            onChange: (event) => setValue(event.target.value),
            disabled,
            form,
            children: [
              value2 === void 0 ? (0, import_jsx_runtime26.jsx)("option", { value: "" }) : null,
              Array.from(nativeOptionsSet)
            ]
          },
          nativeSelectKey
        ) : null
      ]
    }
  ) });
};
Select.displayName = SELECT_NAME;
var TRIGGER_NAME3 = "SelectTrigger";
var SelectTrigger = React46.forwardRef(
  (props, forwardedRef) => {
    const { __scopeSelect, disabled = false, ...triggerProps } = props;
    const popperScope = usePopperScope2(__scopeSelect);
    const context = useSelectContext(TRIGGER_NAME3, __scopeSelect);
    const isDisabled = context.disabled || disabled;
    const composedRefs = useComposedRefs(forwardedRef, context.onTriggerChange);
    const getItems = useCollection2(__scopeSelect);
    const pointerTypeRef = React46.useRef("touch");
    const [searchRef, handleTypeaheadSearch, resetTypeahead] = useTypeaheadSearch((search2) => {
      const enabledItems = getItems().filter((item) => !item.disabled);
      const currentItem = enabledItems.find((item) => item.value === context.value);
      const nextItem = findNextItem(enabledItems, search2, currentItem);
      if (nextItem !== void 0) {
        context.onValueChange(nextItem.value);
      }
    });
    const handleOpen = (pointerEvent) => {
      if (!isDisabled) {
        context.onOpenChange(true);
        resetTypeahead();
      }
      if (pointerEvent) {
        context.triggerPointerDownPosRef.current = {
          x: Math.round(pointerEvent.pageX),
          y: Math.round(pointerEvent.pageY)
        };
      }
    };
    return (0, import_jsx_runtime26.jsx)(Anchor, { asChild: true, ...popperScope, children: (0, import_jsx_runtime26.jsx)(
      Primitive.button,
      {
        type: "button",
        role: "combobox",
        "aria-controls": context.contentId,
        "aria-expanded": context.open,
        "aria-required": context.required,
        "aria-autocomplete": "none",
        dir: context.dir,
        "data-state": context.open ? "open" : "closed",
        disabled: isDisabled,
        "data-disabled": isDisabled ? "" : void 0,
        "data-placeholder": shouldShowPlaceholder(context.value) ? "" : void 0,
        ...triggerProps,
        ref: composedRefs,
        onClick: composeEventHandlers(triggerProps.onClick, (event) => {
          event.currentTarget.focus();
          if (pointerTypeRef.current !== "mouse") {
            handleOpen(event);
          }
        }),
        onPointerDown: composeEventHandlers(triggerProps.onPointerDown, (event) => {
          pointerTypeRef.current = event.pointerType;
          const target = event.target;
          if (target.hasPointerCapture(event.pointerId)) {
            target.releasePointerCapture(event.pointerId);
          }
          if (event.button === 0 && event.ctrlKey === false && event.pointerType === "mouse") {
            handleOpen(event);
            event.preventDefault();
          }
        }),
        onKeyDown: composeEventHandlers(triggerProps.onKeyDown, (event) => {
          const isTypingAhead = searchRef.current !== "";
          const isModifierKey = event.ctrlKey || event.altKey || event.metaKey;
          if (!isModifierKey && event.key.length === 1) handleTypeaheadSearch(event.key);
          if (isTypingAhead && event.key === " ") return;
          if (OPEN_KEYS.includes(event.key)) {
            handleOpen();
            event.preventDefault();
          }
        })
      }
    ) });
  }
);
SelectTrigger.displayName = TRIGGER_NAME3;
var VALUE_NAME = "SelectValue";
var SelectValue = React46.forwardRef(
  (props, forwardedRef) => {
    const { __scopeSelect, className, style, children, placeholder: placeholder2 = "", ...valueProps } = props;
    const context = useSelectContext(VALUE_NAME, __scopeSelect);
    const { onValueNodeHasChildrenChange } = context;
    const hasChildren = children !== void 0;
    const composedRefs = useComposedRefs(forwardedRef, context.onValueNodeChange);
    useLayoutEffect22(() => {
      onValueNodeHasChildrenChange(hasChildren);
    }, [onValueNodeHasChildrenChange, hasChildren]);
    return (0, import_jsx_runtime26.jsx)(
      Primitive.span,
      {
        ...valueProps,
        ref: composedRefs,
        style: { pointerEvents: "none" },
        children: shouldShowPlaceholder(context.value) ? (0, import_jsx_runtime26.jsx)(import_jsx_runtime26.Fragment, { children: placeholder2 }) : children
      }
    );
  }
);
SelectValue.displayName = VALUE_NAME;
var ICON_NAME = "SelectIcon";
var SelectIcon = React46.forwardRef(
  (props, forwardedRef) => {
    const { __scopeSelect, children, ...iconProps } = props;
    return (0, import_jsx_runtime26.jsx)(Primitive.span, { "aria-hidden": true, ...iconProps, ref: forwardedRef, children: children || "▼" });
  }
);
SelectIcon.displayName = ICON_NAME;
var PORTAL_NAME4 = "SelectPortal";
var SelectPortal = (props) => {
  return (0, import_jsx_runtime26.jsx)(Portal, { asChild: true, ...props });
};
SelectPortal.displayName = PORTAL_NAME4;
var CONTENT_NAME4 = "SelectContent";
var SelectContent = React46.forwardRef(
  (props, forwardedRef) => {
    const context = useSelectContext(CONTENT_NAME4, props.__scopeSelect);
    const [fragment, setFragment] = React46.useState();
    useLayoutEffect22(() => {
      setFragment(new DocumentFragment());
    }, []);
    if (!context.open) {
      const frag = fragment;
      return frag ? ReactDOM4.createPortal(
        (0, import_jsx_runtime26.jsx)(SelectContentProvider, { scope: props.__scopeSelect, children: (0, import_jsx_runtime26.jsx)(Collection2.Slot, { scope: props.__scopeSelect, children: (0, import_jsx_runtime26.jsx)("div", { children: props.children }) }) }),
        frag
      ) : null;
    }
    return (0, import_jsx_runtime26.jsx)(SelectContentImpl, { ...props, ref: forwardedRef });
  }
);
SelectContent.displayName = CONTENT_NAME4;
var CONTENT_MARGIN = 10;
var [SelectContentProvider, useSelectContentContext] = createSelectContext(CONTENT_NAME4);
var CONTENT_IMPL_NAME = "SelectContentImpl";
var SelectContentImpl = React46.forwardRef(
  (props, forwardedRef) => {
    const {
      __scopeSelect,
      position: position2 = "item-aligned",
      onCloseAutoFocus,
      onEscapeKeyDown,
      onPointerDownOutside,
      //
      // PopperContent props
      side,
      sideOffset,
      align,
      alignOffset,
      arrowPadding,
      collisionBoundary,
      collisionPadding,
      sticky,
      hideWhenDetached,
      avoidCollisions,
      //
      ...contentProps
    } = props;
    const context = useSelectContext(CONTENT_NAME4, __scopeSelect);
    const [content3, setContent2] = React46.useState(null);
    const [viewport, setViewport] = React46.useState(null);
    const composedRefs = useComposedRefs(forwardedRef, (node2) => setContent2(node2));
    const [selectedItem, setSelectedItem] = React46.useState(null);
    const [selectedItemText, setSelectedItemText] = React46.useState(
      null
    );
    const getItems = useCollection2(__scopeSelect);
    const [isPositioned, setIsPositioned] = React46.useState(false);
    const firstValidItemFoundRef = React46.useRef(false);
    React46.useEffect(() => {
      if (content3) return hideOthers(content3);
    }, [content3]);
    useFocusGuards();
    const focusFirst3 = React46.useCallback(
      (candidates) => {
        const [firstItem, ...restItems] = getItems().map((item) => item.ref.current);
        const [lastItem] = restItems.slice(-1);
        const PREVIOUSLY_FOCUSED_ELEMENT = document.activeElement;
        for (const candidate of candidates) {
          if (candidate === PREVIOUSLY_FOCUSED_ELEMENT) return;
          candidate == null ? void 0 : candidate.scrollIntoView({ block: "nearest" });
          if (candidate === firstItem && viewport) viewport.scrollTop = 0;
          if (candidate === lastItem && viewport) viewport.scrollTop = viewport.scrollHeight;
          candidate == null ? void 0 : candidate.focus();
          if (document.activeElement !== PREVIOUSLY_FOCUSED_ELEMENT) return;
        }
      },
      [getItems, viewport]
    );
    const focusSelectedItem = React46.useCallback(
      () => focusFirst3([selectedItem, content3]),
      [focusFirst3, selectedItem, content3]
    );
    React46.useEffect(() => {
      if (isPositioned) {
        focusSelectedItem();
      }
    }, [isPositioned, focusSelectedItem]);
    const { onOpenChange, triggerPointerDownPosRef } = context;
    React46.useEffect(() => {
      if (content3) {
        let pointerMoveDelta = { x: 0, y: 0 };
        const handlePointerMove = (event) => {
          var _a2, _b2;
          pointerMoveDelta = {
            x: Math.abs(Math.round(event.pageX) - (((_a2 = triggerPointerDownPosRef.current) == null ? void 0 : _a2.x) ?? 0)),
            y: Math.abs(Math.round(event.pageY) - (((_b2 = triggerPointerDownPosRef.current) == null ? void 0 : _b2.y) ?? 0))
          };
        };
        const handlePointerUp = (event) => {
          if (pointerMoveDelta.x <= 10 && pointerMoveDelta.y <= 10) {
            event.preventDefault();
          } else {
            if (!content3.contains(event.target)) {
              onOpenChange(false);
            }
          }
          document.removeEventListener("pointermove", handlePointerMove);
          triggerPointerDownPosRef.current = null;
        };
        if (triggerPointerDownPosRef.current !== null) {
          document.addEventListener("pointermove", handlePointerMove);
          document.addEventListener("pointerup", handlePointerUp, { capture: true, once: true });
        }
        return () => {
          document.removeEventListener("pointermove", handlePointerMove);
          document.removeEventListener("pointerup", handlePointerUp, { capture: true });
        };
      }
    }, [content3, onOpenChange, triggerPointerDownPosRef]);
    React46.useEffect(() => {
      const close2 = () => onOpenChange(false);
      window.addEventListener("blur", close2);
      window.addEventListener("resize", close2);
      return () => {
        window.removeEventListener("blur", close2);
        window.removeEventListener("resize", close2);
      };
    }, [onOpenChange]);
    const [searchRef, handleTypeaheadSearch] = useTypeaheadSearch((search2) => {
      const enabledItems = getItems().filter((item) => !item.disabled);
      const currentItem = enabledItems.find((item) => item.ref.current === document.activeElement);
      const nextItem = findNextItem(enabledItems, search2, currentItem);
      if (nextItem) {
        setTimeout(() => nextItem.ref.current.focus());
      }
    });
    const itemRefCallback = React46.useCallback(
      (node2, value2, disabled) => {
        const isFirstValidItem = !firstValidItemFoundRef.current && !disabled;
        const isSelectedItem = context.value !== void 0 && context.value === value2;
        if (isSelectedItem || isFirstValidItem) {
          setSelectedItem(node2);
          if (isFirstValidItem) firstValidItemFoundRef.current = true;
        }
      },
      [context.value]
    );
    const handleItemLeave = React46.useCallback(() => content3 == null ? void 0 : content3.focus(), [content3]);
    const itemTextRefCallback = React46.useCallback(
      (node2, value2, disabled) => {
        const isFirstValidItem = !firstValidItemFoundRef.current && !disabled;
        const isSelectedItem = context.value !== void 0 && context.value === value2;
        if (isSelectedItem || isFirstValidItem) {
          setSelectedItemText(node2);
        }
      },
      [context.value]
    );
    const SelectPosition = position2 === "popper" ? SelectPopperPosition : SelectItemAlignedPosition;
    const popperContentProps = SelectPosition === SelectPopperPosition ? {
      side,
      sideOffset,
      align,
      alignOffset,
      arrowPadding,
      collisionBoundary,
      collisionPadding,
      sticky,
      hideWhenDetached,
      avoidCollisions
    } : {};
    return (0, import_jsx_runtime26.jsx)(
      SelectContentProvider,
      {
        scope: __scopeSelect,
        content: content3,
        viewport,
        onViewportChange: setViewport,
        itemRefCallback,
        selectedItem,
        onItemLeave: handleItemLeave,
        itemTextRefCallback,
        focusSelectedItem,
        selectedItemText,
        position: position2,
        isPositioned,
        searchRef,
        children: (0, import_jsx_runtime26.jsx)(Combination_default, { as: Slot, allowPinchZoom: true, children: (0, import_jsx_runtime26.jsx)(
          FocusScope,
          {
            asChild: true,
            trapped: context.open,
            onMountAutoFocus: (event) => {
              event.preventDefault();
            },
            onUnmountAutoFocus: composeEventHandlers(onCloseAutoFocus, (event) => {
              var _a2;
              (_a2 = context.trigger) == null ? void 0 : _a2.focus({ preventScroll: true });
              event.preventDefault();
            }),
            children: (0, import_jsx_runtime26.jsx)(
              DismissableLayer,
              {
                asChild: true,
                disableOutsidePointerEvents: true,
                onEscapeKeyDown,
                onPointerDownOutside,
                onFocusOutside: (event) => event.preventDefault(),
                onDismiss: () => context.onOpenChange(false),
                children: (0, import_jsx_runtime26.jsx)(
                  SelectPosition,
                  {
                    role: "listbox",
                    id: context.contentId,
                    "data-state": context.open ? "open" : "closed",
                    dir: context.dir,
                    onContextMenu: (event) => event.preventDefault(),
                    ...contentProps,
                    ...popperContentProps,
                    onPlaced: () => setIsPositioned(true),
                    ref: composedRefs,
                    style: {
                      // flex layout so we can place the scroll buttons properly
                      display: "flex",
                      flexDirection: "column",
                      // reset the outline by default as the content MAY get focused
                      outline: "none",
                      ...contentProps.style
                    },
                    onKeyDown: composeEventHandlers(contentProps.onKeyDown, (event) => {
                      const isModifierKey = event.ctrlKey || event.altKey || event.metaKey;
                      if (event.key === "Tab") event.preventDefault();
                      if (!isModifierKey && event.key.length === 1) handleTypeaheadSearch(event.key);
                      if (["ArrowUp", "ArrowDown", "Home", "End"].includes(event.key)) {
                        const items = getItems().filter((item) => !item.disabled);
                        let candidateNodes = items.map((item) => item.ref.current);
                        if (["ArrowUp", "End"].includes(event.key)) {
                          candidateNodes = candidateNodes.slice().reverse();
                        }
                        if (["ArrowUp", "ArrowDown"].includes(event.key)) {
                          const currentElement = event.target;
                          const currentIndex = candidateNodes.indexOf(currentElement);
                          candidateNodes = candidateNodes.slice(currentIndex + 1);
                        }
                        setTimeout(() => focusFirst3(candidateNodes));
                        event.preventDefault();
                      }
                    })
                  }
                )
              }
            )
          }
        ) })
      }
    );
  }
);
SelectContentImpl.displayName = CONTENT_IMPL_NAME;
var ITEM_ALIGNED_POSITION_NAME = "SelectItemAlignedPosition";
var SelectItemAlignedPosition = React46.forwardRef((props, forwardedRef) => {
  const { __scopeSelect, onPlaced, ...popperProps } = props;
  const context = useSelectContext(CONTENT_NAME4, __scopeSelect);
  const contentContext = useSelectContentContext(CONTENT_NAME4, __scopeSelect);
  const [contentWrapper, setContentWrapper] = React46.useState(null);
  const [content3, setContent2] = React46.useState(null);
  const composedRefs = useComposedRefs(forwardedRef, (node2) => setContent2(node2));
  const getItems = useCollection2(__scopeSelect);
  const shouldExpandOnScrollRef = React46.useRef(false);
  const shouldRepositionRef = React46.useRef(true);
  const { viewport, selectedItem, selectedItemText, focusSelectedItem } = contentContext;
  const position2 = React46.useCallback(() => {
    if (context.trigger && context.valueNode && contentWrapper && content3 && viewport && selectedItem && selectedItemText) {
      const triggerRect = context.trigger.getBoundingClientRect();
      const contentRect = content3.getBoundingClientRect();
      const valueNodeRect = context.valueNode.getBoundingClientRect();
      const itemTextRect = selectedItemText.getBoundingClientRect();
      if (context.dir !== "rtl") {
        const itemTextOffset = itemTextRect.left - contentRect.left;
        const left = valueNodeRect.left - itemTextOffset;
        const leftDelta = triggerRect.left - left;
        const minContentWidth = triggerRect.width + leftDelta;
        const contentWidth = Math.max(minContentWidth, contentRect.width);
        const rightEdge = window.innerWidth - CONTENT_MARGIN;
        const clampedLeft = clamp3(left, [
          CONTENT_MARGIN,
          // Prevents the content from going off the starting edge of the
          // viewport. It may still go off the ending edge, but this can be
          // controlled by the user since they may want to manage overflow in a
          // specific way.
          // https://github.com/radix-ui/primitives/issues/2049
          Math.max(CONTENT_MARGIN, rightEdge - contentWidth)
        ]);
        contentWrapper.style.minWidth = minContentWidth + "px";
        contentWrapper.style.left = clampedLeft + "px";
      } else {
        const itemTextOffset = contentRect.right - itemTextRect.right;
        const right = window.innerWidth - valueNodeRect.right - itemTextOffset;
        const rightDelta = window.innerWidth - triggerRect.right - right;
        const minContentWidth = triggerRect.width + rightDelta;
        const contentWidth = Math.max(minContentWidth, contentRect.width);
        const leftEdge = window.innerWidth - CONTENT_MARGIN;
        const clampedRight = clamp3(right, [
          CONTENT_MARGIN,
          Math.max(CONTENT_MARGIN, leftEdge - contentWidth)
        ]);
        contentWrapper.style.minWidth = minContentWidth + "px";
        contentWrapper.style.right = clampedRight + "px";
      }
      const items = getItems();
      const availableHeight = window.innerHeight - CONTENT_MARGIN * 2;
      const itemsHeight = viewport.scrollHeight;
      const contentStyles = window.getComputedStyle(content3);
      const contentBorderTopWidth = parseInt(contentStyles.borderTopWidth, 10);
      const contentPaddingTop = parseInt(contentStyles.paddingTop, 10);
      const contentBorderBottomWidth = parseInt(contentStyles.borderBottomWidth, 10);
      const contentPaddingBottom = parseInt(contentStyles.paddingBottom, 10);
      const fullContentHeight = contentBorderTopWidth + contentPaddingTop + itemsHeight + contentPaddingBottom + contentBorderBottomWidth;
      const minContentHeight = Math.min(selectedItem.offsetHeight * 5, fullContentHeight);
      const viewportStyles = window.getComputedStyle(viewport);
      const viewportPaddingTop = parseInt(viewportStyles.paddingTop, 10);
      const viewportPaddingBottom = parseInt(viewportStyles.paddingBottom, 10);
      const topEdgeToTriggerMiddle = triggerRect.top + triggerRect.height / 2 - CONTENT_MARGIN;
      const triggerMiddleToBottomEdge = availableHeight - topEdgeToTriggerMiddle;
      const selectedItemHalfHeight = selectedItem.offsetHeight / 2;
      const itemOffsetMiddle = selectedItem.offsetTop + selectedItemHalfHeight;
      const contentTopToItemMiddle = contentBorderTopWidth + contentPaddingTop + itemOffsetMiddle;
      const itemMiddleToContentBottom = fullContentHeight - contentTopToItemMiddle;
      const willAlignWithoutTopOverflow = contentTopToItemMiddle <= topEdgeToTriggerMiddle;
      if (willAlignWithoutTopOverflow) {
        const isLastItem = items.length > 0 && selectedItem === items[items.length - 1].ref.current;
        contentWrapper.style.bottom = "0px";
        const viewportOffsetBottom = content3.clientHeight - viewport.offsetTop - viewport.offsetHeight;
        const clampedTriggerMiddleToBottomEdge = Math.max(
          triggerMiddleToBottomEdge,
          selectedItemHalfHeight + // viewport might have padding bottom, include it to avoid a scrollable viewport
          (isLastItem ? viewportPaddingBottom : 0) + viewportOffsetBottom + contentBorderBottomWidth
        );
        const height = contentTopToItemMiddle + clampedTriggerMiddleToBottomEdge;
        contentWrapper.style.height = height + "px";
      } else {
        const isFirstItem = items.length > 0 && selectedItem === items[0].ref.current;
        contentWrapper.style.top = "0px";
        const clampedTopEdgeToTriggerMiddle = Math.max(
          topEdgeToTriggerMiddle,
          contentBorderTopWidth + viewport.offsetTop + // viewport might have padding top, include it to avoid a scrollable viewport
          (isFirstItem ? viewportPaddingTop : 0) + selectedItemHalfHeight
        );
        const height = clampedTopEdgeToTriggerMiddle + itemMiddleToContentBottom;
        contentWrapper.style.height = height + "px";
        viewport.scrollTop = contentTopToItemMiddle - topEdgeToTriggerMiddle + viewport.offsetTop;
      }
      contentWrapper.style.margin = `${CONTENT_MARGIN}px 0`;
      contentWrapper.style.minHeight = minContentHeight + "px";
      contentWrapper.style.maxHeight = availableHeight + "px";
      onPlaced == null ? void 0 : onPlaced();
      requestAnimationFrame(() => shouldExpandOnScrollRef.current = true);
    }
  }, [
    getItems,
    context.trigger,
    context.valueNode,
    contentWrapper,
    content3,
    viewport,
    selectedItem,
    selectedItemText,
    context.dir,
    onPlaced
  ]);
  useLayoutEffect22(() => position2(), [position2]);
  const [contentZIndex, setContentZIndex] = React46.useState();
  useLayoutEffect22(() => {
    if (content3) setContentZIndex(window.getComputedStyle(content3).zIndex);
  }, [content3]);
  const handleScrollButtonChange = React46.useCallback(
    (node2) => {
      if (node2 && shouldRepositionRef.current === true) {
        position2();
        focusSelectedItem == null ? void 0 : focusSelectedItem();
        shouldRepositionRef.current = false;
      }
    },
    [position2, focusSelectedItem]
  );
  return (0, import_jsx_runtime26.jsx)(
    SelectViewportProvider,
    {
      scope: __scopeSelect,
      contentWrapper,
      shouldExpandOnScrollRef,
      onScrollButtonChange: handleScrollButtonChange,
      children: (0, import_jsx_runtime26.jsx)(
        "div",
        {
          ref: setContentWrapper,
          style: {
            display: "flex",
            flexDirection: "column",
            position: "fixed",
            zIndex: contentZIndex
          },
          children: (0, import_jsx_runtime26.jsx)(
            Primitive.div,
            {
              ...popperProps,
              ref: composedRefs,
              style: {
                // When we get the height of the content, it includes borders. If we were to set
                // the height without having `boxSizing: 'border-box'` it would be too big.
                boxSizing: "border-box",
                // We need to ensure the content doesn't get taller than the wrapper
                maxHeight: "100%",
                ...popperProps.style
              }
            }
          )
        }
      )
    }
  );
});
SelectItemAlignedPosition.displayName = ITEM_ALIGNED_POSITION_NAME;
var POPPER_POSITION_NAME = "SelectPopperPosition";
var SelectPopperPosition = React46.forwardRef((props, forwardedRef) => {
  const {
    __scopeSelect,
    align = "start",
    collisionPadding = CONTENT_MARGIN,
    ...popperProps
  } = props;
  const popperScope = usePopperScope2(__scopeSelect);
  return (0, import_jsx_runtime26.jsx)(
    Content,
    {
      ...popperScope,
      ...popperProps,
      ref: forwardedRef,
      align,
      collisionPadding,
      style: {
        // Ensure border-box for floating-ui calculations
        boxSizing: "border-box",
        ...popperProps.style,
        // re-namespace exposed content custom properties
        ...{
          "--radix-select-content-transform-origin": "var(--radix-popper-transform-origin)",
          "--radix-select-content-available-width": "var(--radix-popper-available-width)",
          "--radix-select-content-available-height": "var(--radix-popper-available-height)",
          "--radix-select-trigger-width": "var(--radix-popper-anchor-width)",
          "--radix-select-trigger-height": "var(--radix-popper-anchor-height)"
        }
      }
    }
  );
});
SelectPopperPosition.displayName = POPPER_POSITION_NAME;
var [SelectViewportProvider, useSelectViewportContext] = createSelectContext(CONTENT_NAME4, {});
var VIEWPORT_NAME = "SelectViewport";
var SelectViewport = React46.forwardRef(
  (props, forwardedRef) => {
    const { __scopeSelect, nonce, ...viewportProps } = props;
    const contentContext = useSelectContentContext(VIEWPORT_NAME, __scopeSelect);
    const viewportContext = useSelectViewportContext(VIEWPORT_NAME, __scopeSelect);
    const composedRefs = useComposedRefs(forwardedRef, contentContext.onViewportChange);
    const prevScrollTopRef = React46.useRef(0);
    return (0, import_jsx_runtime26.jsxs)(import_jsx_runtime26.Fragment, { children: [
      (0, import_jsx_runtime26.jsx)(
        "style",
        {
          dangerouslySetInnerHTML: {
            __html: `[data-radix-select-viewport]{scrollbar-width:none;-ms-overflow-style:none;-webkit-overflow-scrolling:touch;}[data-radix-select-viewport]::-webkit-scrollbar{display:none}`
          },
          nonce
        }
      ),
      (0, import_jsx_runtime26.jsx)(Collection2.Slot, { scope: __scopeSelect, children: (0, import_jsx_runtime26.jsx)(
        Primitive.div,
        {
          "data-radix-select-viewport": "",
          role: "presentation",
          ...viewportProps,
          ref: composedRefs,
          style: {
            // we use position: 'relative' here on the `viewport` so that when we call
            // `selectedItem.offsetTop` in calculations, the offset is relative to the viewport
            // (independent of the scrollUpButton).
            position: "relative",
            flex: 1,
            // Viewport should only be scrollable in the vertical direction.
            // This won't work in vertical writing modes, so we'll need to
            // revisit this if/when that is supported
            // https://developer.chrome.com/blog/vertical-form-controls
            overflow: "hidden auto",
            ...viewportProps.style
          },
          onScroll: composeEventHandlers(viewportProps.onScroll, (event) => {
            const viewport = event.currentTarget;
            const { contentWrapper, shouldExpandOnScrollRef } = viewportContext;
            if ((shouldExpandOnScrollRef == null ? void 0 : shouldExpandOnScrollRef.current) && contentWrapper) {
              const scrolledBy = Math.abs(prevScrollTopRef.current - viewport.scrollTop);
              if (scrolledBy > 0) {
                const availableHeight = window.innerHeight - CONTENT_MARGIN * 2;
                const cssMinHeight = parseFloat(contentWrapper.style.minHeight);
                const cssHeight = parseFloat(contentWrapper.style.height);
                const prevHeight = Math.max(cssMinHeight, cssHeight);
                if (prevHeight < availableHeight) {
                  const nextHeight = prevHeight + scrolledBy;
                  const clampedNextHeight = Math.min(availableHeight, nextHeight);
                  const heightDiff = nextHeight - clampedNextHeight;
                  contentWrapper.style.height = clampedNextHeight + "px";
                  if (contentWrapper.style.bottom === "0px") {
                    viewport.scrollTop = heightDiff > 0 ? heightDiff : 0;
                    contentWrapper.style.justifyContent = "flex-end";
                  }
                }
              }
            }
            prevScrollTopRef.current = viewport.scrollTop;
          })
        }
      ) })
    ] });
  }
);
SelectViewport.displayName = VIEWPORT_NAME;
var GROUP_NAME2 = "SelectGroup";
var [SelectGroupContextProvider, useSelectGroupContext] = createSelectContext(GROUP_NAME2);
var SelectGroup = React46.forwardRef(
  (props, forwardedRef) => {
    const { __scopeSelect, ...groupProps } = props;
    const groupId = useId();
    return (0, import_jsx_runtime26.jsx)(SelectGroupContextProvider, { scope: __scopeSelect, id: groupId, children: (0, import_jsx_runtime26.jsx)(Primitive.div, { role: "group", "aria-labelledby": groupId, ...groupProps, ref: forwardedRef }) });
  }
);
SelectGroup.displayName = GROUP_NAME2;
var LABEL_NAME = "SelectLabel";
var SelectLabel = React46.forwardRef(
  (props, forwardedRef) => {
    const { __scopeSelect, ...labelProps } = props;
    const groupContext = useSelectGroupContext(LABEL_NAME, __scopeSelect);
    return (0, import_jsx_runtime26.jsx)(Primitive.div, { id: groupContext.id, ...labelProps, ref: forwardedRef });
  }
);
SelectLabel.displayName = LABEL_NAME;
var ITEM_NAME3 = "SelectItem";
var [SelectItemContextProvider, useSelectItemContext] = createSelectContext(ITEM_NAME3);
var SelectItem = React46.forwardRef(
  (props, forwardedRef) => {
    const {
      __scopeSelect,
      value: value2,
      disabled = false,
      textValue: textValueProp,
      ...itemProps
    } = props;
    const context = useSelectContext(ITEM_NAME3, __scopeSelect);
    const contentContext = useSelectContentContext(ITEM_NAME3, __scopeSelect);
    const isSelected = context.value === value2;
    const [textValue, setTextValue] = React46.useState(textValueProp ?? "");
    const [isFocused, setIsFocused] = React46.useState(false);
    const composedRefs = useComposedRefs(
      forwardedRef,
      (node2) => {
        var _a2;
        return (_a2 = contentContext.itemRefCallback) == null ? void 0 : _a2.call(contentContext, node2, value2, disabled);
      }
    );
    const textId = useId();
    const pointerTypeRef = React46.useRef("touch");
    const handleSelect = () => {
      if (!disabled) {
        context.onValueChange(value2);
        context.onOpenChange(false);
      }
    };
    if (value2 === "") {
      throw new Error(
        "A <Select.Item /> must have a value prop that is not an empty string. This is because the Select value can be set to an empty string to clear the selection and show the placeholder."
      );
    }
    return (0, import_jsx_runtime26.jsx)(
      SelectItemContextProvider,
      {
        scope: __scopeSelect,
        value: value2,
        disabled,
        textId,
        isSelected,
        onItemTextChange: React46.useCallback((node2) => {
          setTextValue((prevTextValue) => prevTextValue || ((node2 == null ? void 0 : node2.textContent) ?? "").trim());
        }, []),
        children: (0, import_jsx_runtime26.jsx)(
          Collection2.ItemSlot,
          {
            scope: __scopeSelect,
            value: value2,
            disabled,
            textValue,
            children: (0, import_jsx_runtime26.jsx)(
              Primitive.div,
              {
                role: "option",
                "aria-labelledby": textId,
                "data-highlighted": isFocused ? "" : void 0,
                "aria-selected": isSelected && isFocused,
                "data-state": isSelected ? "checked" : "unchecked",
                "aria-disabled": disabled || void 0,
                "data-disabled": disabled ? "" : void 0,
                tabIndex: disabled ? void 0 : -1,
                ...itemProps,
                ref: composedRefs,
                onFocus: composeEventHandlers(itemProps.onFocus, () => setIsFocused(true)),
                onBlur: composeEventHandlers(itemProps.onBlur, () => setIsFocused(false)),
                onClick: composeEventHandlers(itemProps.onClick, () => {
                  if (pointerTypeRef.current !== "mouse") handleSelect();
                }),
                onPointerUp: composeEventHandlers(itemProps.onPointerUp, () => {
                  if (pointerTypeRef.current === "mouse") handleSelect();
                }),
                onPointerDown: composeEventHandlers(itemProps.onPointerDown, (event) => {
                  pointerTypeRef.current = event.pointerType;
                }),
                onPointerMove: composeEventHandlers(itemProps.onPointerMove, (event) => {
                  var _a2;
                  pointerTypeRef.current = event.pointerType;
                  if (disabled) {
                    (_a2 = contentContext.onItemLeave) == null ? void 0 : _a2.call(contentContext);
                  } else if (pointerTypeRef.current === "mouse") {
                    event.currentTarget.focus({ preventScroll: true });
                  }
                }),
                onPointerLeave: composeEventHandlers(itemProps.onPointerLeave, (event) => {
                  var _a2;
                  if (event.currentTarget === document.activeElement) {
                    (_a2 = contentContext.onItemLeave) == null ? void 0 : _a2.call(contentContext);
                  }
                }),
                onKeyDown: composeEventHandlers(itemProps.onKeyDown, (event) => {
                  var _a2;
                  const isTypingAhead = ((_a2 = contentContext.searchRef) == null ? void 0 : _a2.current) !== "";
                  if (isTypingAhead && event.key === " ") return;
                  if (SELECTION_KEYS.includes(event.key)) handleSelect();
                  if (event.key === " ") event.preventDefault();
                })
              }
            )
          }
        )
      }
    );
  }
);
SelectItem.displayName = ITEM_NAME3;
var ITEM_TEXT_NAME = "SelectItemText";
var SelectItemText = React46.forwardRef(
  (props, forwardedRef) => {
    const { __scopeSelect, className, style, ...itemTextProps } = props;
    const context = useSelectContext(ITEM_TEXT_NAME, __scopeSelect);
    const contentContext = useSelectContentContext(ITEM_TEXT_NAME, __scopeSelect);
    const itemContext = useSelectItemContext(ITEM_TEXT_NAME, __scopeSelect);
    const nativeOptionsContext = useSelectNativeOptionsContext(ITEM_TEXT_NAME, __scopeSelect);
    const [itemTextNode, setItemTextNode] = React46.useState(null);
    const composedRefs = useComposedRefs(
      forwardedRef,
      (node2) => setItemTextNode(node2),
      itemContext.onItemTextChange,
      (node2) => {
        var _a2;
        return (_a2 = contentContext.itemTextRefCallback) == null ? void 0 : _a2.call(contentContext, node2, itemContext.value, itemContext.disabled);
      }
    );
    const textContent = itemTextNode == null ? void 0 : itemTextNode.textContent;
    const nativeOption = React46.useMemo(
      () => (0, import_jsx_runtime26.jsx)("option", { value: itemContext.value, disabled: itemContext.disabled, children: textContent }, itemContext.value),
      [itemContext.disabled, itemContext.value, textContent]
    );
    const { onNativeOptionAdd, onNativeOptionRemove } = nativeOptionsContext;
    useLayoutEffect22(() => {
      onNativeOptionAdd(nativeOption);
      return () => onNativeOptionRemove(nativeOption);
    }, [onNativeOptionAdd, onNativeOptionRemove, nativeOption]);
    return (0, import_jsx_runtime26.jsxs)(import_jsx_runtime26.Fragment, { children: [
      (0, import_jsx_runtime26.jsx)(Primitive.span, { id: itemContext.textId, ...itemTextProps, ref: composedRefs }),
      itemContext.isSelected && context.valueNode && !context.valueNodeHasChildren ? ReactDOM4.createPortal(itemTextProps.children, context.valueNode) : null
    ] });
  }
);
SelectItemText.displayName = ITEM_TEXT_NAME;
var ITEM_INDICATOR_NAME = "SelectItemIndicator";
var SelectItemIndicator = React46.forwardRef(
  (props, forwardedRef) => {
    const { __scopeSelect, ...itemIndicatorProps } = props;
    const itemContext = useSelectItemContext(ITEM_INDICATOR_NAME, __scopeSelect);
    return itemContext.isSelected ? (0, import_jsx_runtime26.jsx)(Primitive.span, { "aria-hidden": true, ...itemIndicatorProps, ref: forwardedRef }) : null;
  }
);
SelectItemIndicator.displayName = ITEM_INDICATOR_NAME;
var SCROLL_UP_BUTTON_NAME = "SelectScrollUpButton";
var SelectScrollUpButton = React46.forwardRef((props, forwardedRef) => {
  const contentContext = useSelectContentContext(SCROLL_UP_BUTTON_NAME, props.__scopeSelect);
  const viewportContext = useSelectViewportContext(SCROLL_UP_BUTTON_NAME, props.__scopeSelect);
  const [canScrollUp, setCanScrollUp] = React46.useState(false);
  const composedRefs = useComposedRefs(forwardedRef, viewportContext.onScrollButtonChange);
  useLayoutEffect22(() => {
    if (contentContext.viewport && contentContext.isPositioned) {
      let handleScroll22 = function() {
        const canScrollUp2 = viewport.scrollTop > 0;
        setCanScrollUp(canScrollUp2);
      };
      var handleScroll2 = handleScroll22;
      const viewport = contentContext.viewport;
      handleScroll22();
      viewport.addEventListener("scroll", handleScroll22);
      return () => viewport.removeEventListener("scroll", handleScroll22);
    }
  }, [contentContext.viewport, contentContext.isPositioned]);
  return canScrollUp ? (0, import_jsx_runtime26.jsx)(
    SelectScrollButtonImpl,
    {
      ...props,
      ref: composedRefs,
      onAutoScroll: () => {
        const { viewport, selectedItem } = contentContext;
        if (viewport && selectedItem) {
          viewport.scrollTop = viewport.scrollTop - selectedItem.offsetHeight;
        }
      }
    }
  ) : null;
});
SelectScrollUpButton.displayName = SCROLL_UP_BUTTON_NAME;
var SCROLL_DOWN_BUTTON_NAME = "SelectScrollDownButton";
var SelectScrollDownButton = React46.forwardRef((props, forwardedRef) => {
  const contentContext = useSelectContentContext(SCROLL_DOWN_BUTTON_NAME, props.__scopeSelect);
  const viewportContext = useSelectViewportContext(SCROLL_DOWN_BUTTON_NAME, props.__scopeSelect);
  const [canScrollDown, setCanScrollDown] = React46.useState(false);
  const composedRefs = useComposedRefs(forwardedRef, viewportContext.onScrollButtonChange);
  useLayoutEffect22(() => {
    if (contentContext.viewport && contentContext.isPositioned) {
      let handleScroll22 = function() {
        const maxScroll = viewport.scrollHeight - viewport.clientHeight;
        const canScrollDown2 = Math.ceil(viewport.scrollTop) < maxScroll;
        setCanScrollDown(canScrollDown2);
      };
      var handleScroll2 = handleScroll22;
      const viewport = contentContext.viewport;
      handleScroll22();
      viewport.addEventListener("scroll", handleScroll22);
      return () => viewport.removeEventListener("scroll", handleScroll22);
    }
  }, [contentContext.viewport, contentContext.isPositioned]);
  return canScrollDown ? (0, import_jsx_runtime26.jsx)(
    SelectScrollButtonImpl,
    {
      ...props,
      ref: composedRefs,
      onAutoScroll: () => {
        const { viewport, selectedItem } = contentContext;
        if (viewport && selectedItem) {
          viewport.scrollTop = viewport.scrollTop + selectedItem.offsetHeight;
        }
      }
    }
  ) : null;
});
SelectScrollDownButton.displayName = SCROLL_DOWN_BUTTON_NAME;
var SelectScrollButtonImpl = React46.forwardRef((props, forwardedRef) => {
  const { __scopeSelect, onAutoScroll, ...scrollIndicatorProps } = props;
  const contentContext = useSelectContentContext("SelectScrollButton", __scopeSelect);
  const autoScrollTimerRef = React46.useRef(null);
  const getItems = useCollection2(__scopeSelect);
  const clearAutoScrollTimer = React46.useCallback(() => {
    if (autoScrollTimerRef.current !== null) {
      window.clearInterval(autoScrollTimerRef.current);
      autoScrollTimerRef.current = null;
    }
  }, []);
  React46.useEffect(() => {
    return () => clearAutoScrollTimer();
  }, [clearAutoScrollTimer]);
  useLayoutEffect22(() => {
    var _a2;
    const activeItem = getItems().find((item) => item.ref.current === document.activeElement);
    (_a2 = activeItem == null ? void 0 : activeItem.ref.current) == null ? void 0 : _a2.scrollIntoView({ block: "nearest" });
  }, [getItems]);
  return (0, import_jsx_runtime26.jsx)(
    Primitive.div,
    {
      "aria-hidden": true,
      ...scrollIndicatorProps,
      ref: forwardedRef,
      style: { flexShrink: 0, ...scrollIndicatorProps.style },
      onPointerDown: composeEventHandlers(scrollIndicatorProps.onPointerDown, () => {
        if (autoScrollTimerRef.current === null) {
          autoScrollTimerRef.current = window.setInterval(onAutoScroll, 50);
        }
      }),
      onPointerMove: composeEventHandlers(scrollIndicatorProps.onPointerMove, () => {
        var _a2;
        (_a2 = contentContext.onItemLeave) == null ? void 0 : _a2.call(contentContext);
        if (autoScrollTimerRef.current === null) {
          autoScrollTimerRef.current = window.setInterval(onAutoScroll, 50);
        }
      }),
      onPointerLeave: composeEventHandlers(scrollIndicatorProps.onPointerLeave, () => {
        clearAutoScrollTimer();
      })
    }
  );
});
var SEPARATOR_NAME2 = "SelectSeparator";
var SelectSeparator = React46.forwardRef(
  (props, forwardedRef) => {
    const { __scopeSelect, ...separatorProps } = props;
    return (0, import_jsx_runtime26.jsx)(Primitive.div, { "aria-hidden": true, ...separatorProps, ref: forwardedRef });
  }
);
SelectSeparator.displayName = SEPARATOR_NAME2;
var ARROW_NAME3 = "SelectArrow";
var SelectArrow = React46.forwardRef(
  (props, forwardedRef) => {
    const { __scopeSelect, ...arrowProps } = props;
    const popperScope = usePopperScope2(__scopeSelect);
    const context = useSelectContext(ARROW_NAME3, __scopeSelect);
    const contentContext = useSelectContentContext(ARROW_NAME3, __scopeSelect);
    return context.open && contentContext.position === "popper" ? (0, import_jsx_runtime26.jsx)(Arrow2, { ...popperScope, ...arrowProps, ref: forwardedRef }) : null;
  }
);
SelectArrow.displayName = ARROW_NAME3;
function shouldShowPlaceholder(value2) {
  return value2 === "" || value2 === void 0;
}
var BubbleSelect = React46.forwardRef(
  (props, forwardedRef) => {
    const { value: value2, ...selectProps } = props;
    const ref2 = React46.useRef(null);
    const composedRefs = useComposedRefs(forwardedRef, ref2);
    const prevValue = usePrevious(value2);
    React46.useEffect(() => {
      const select = ref2.current;
      const selectProto = window.HTMLSelectElement.prototype;
      const descriptor = Object.getOwnPropertyDescriptor(
        selectProto,
        "value"
      );
      const setValue = descriptor.set;
      if (prevValue !== value2 && setValue) {
        const event = new Event("change", { bubbles: true });
        setValue.call(select, value2);
        select.dispatchEvent(event);
      }
    }, [prevValue, value2]);
    return (0, import_jsx_runtime26.jsx)(VisuallyHidden, { asChild: true, children: (0, import_jsx_runtime26.jsx)("select", { ...selectProps, ref: composedRefs, defaultValue: value2 }) });
  }
);
BubbleSelect.displayName = "BubbleSelect";
function useTypeaheadSearch(onSearchChange) {
  const handleSearchChange = useCallbackRef(onSearchChange);
  const searchRef = React46.useRef("");
  const timerRef = React46.useRef(0);
  const handleTypeaheadSearch = React46.useCallback(
    (key2) => {
      const search2 = searchRef.current + key2;
      handleSearchChange(search2);
      (function updateSearch(value2) {
        searchRef.current = value2;
        window.clearTimeout(timerRef.current);
        if (value2 !== "") timerRef.current = window.setTimeout(() => updateSearch(""), 1e3);
      })(search2);
    },
    [handleSearchChange]
  );
  const resetTypeahead = React46.useCallback(() => {
    searchRef.current = "";
    window.clearTimeout(timerRef.current);
  }, []);
  React46.useEffect(() => {
    return () => window.clearTimeout(timerRef.current);
  }, []);
  return [searchRef, handleTypeaheadSearch, resetTypeahead];
}
function findNextItem(items, search2, currentItem) {
  const isRepeated = search2.length > 1 && Array.from(search2).every((char) => char === search2[0]);
  const normalizedSearch = isRepeated ? search2[0] : search2;
  const currentItemIndex = currentItem ? items.indexOf(currentItem) : -1;
  let wrappedItems = wrapArray2(items, Math.max(currentItemIndex, 0));
  const excludeCurrentItem = normalizedSearch.length === 1;
  if (excludeCurrentItem) wrappedItems = wrappedItems.filter((v3) => v3 !== currentItem);
  const nextItem = wrappedItems.find(
    (item) => item.textValue.toLowerCase().startsWith(normalizedSearch.toLowerCase())
  );
  return nextItem !== currentItem ? nextItem : void 0;
}
function wrapArray2(array, startIndex) {
  return array.map((_2, index3) => array[(startIndex + index3) % array.length]);
}
var Root24 = Select;
var Trigger3 = SelectTrigger;
var Value = SelectValue;
var Icon = SelectIcon;
var Portal4 = SelectPortal;
var Content22 = SelectContent;
var Viewport = SelectViewport;
var Item3 = SelectItem;
var ItemText = SelectItemText;
var Separator3 = SelectSeparator;

// node_modules/@mdxeditor/editor/dist/plugins/toolbar/primitives/select.js
var import_classnames9 = __toESM(require_classnames(), 1);

// node_modules/@radix-ui/react-tooltip/dist/index.mjs
var React47 = __toESM(require_react(), 1);
var import_jsx_runtime27 = __toESM(require_jsx_runtime(), 1);
var [createTooltipContext, createTooltipScope] = createContextScope("Tooltip", [
  createPopperScope
]);
var usePopperScope3 = createPopperScope();
var PROVIDER_NAME = "TooltipProvider";
var DEFAULT_DELAY_DURATION = 700;
var TOOLTIP_OPEN = "tooltip.open";
var [TooltipProviderContextProvider, useTooltipProviderContext] = createTooltipContext(PROVIDER_NAME);
var TooltipProvider = (props) => {
  const {
    __scopeTooltip,
    delayDuration = DEFAULT_DELAY_DURATION,
    skipDelayDuration = 300,
    disableHoverableContent = false,
    children
  } = props;
  const [isOpenDelayed, setIsOpenDelayed] = React47.useState(true);
  const isPointerInTransitRef = React47.useRef(false);
  const skipDelayTimerRef = React47.useRef(0);
  React47.useEffect(() => {
    const skipDelayTimer = skipDelayTimerRef.current;
    return () => window.clearTimeout(skipDelayTimer);
  }, []);
  return (0, import_jsx_runtime27.jsx)(
    TooltipProviderContextProvider,
    {
      scope: __scopeTooltip,
      isOpenDelayed,
      delayDuration,
      onOpen: React47.useCallback(() => {
        window.clearTimeout(skipDelayTimerRef.current);
        setIsOpenDelayed(false);
      }, []),
      onClose: React47.useCallback(() => {
        window.clearTimeout(skipDelayTimerRef.current);
        skipDelayTimerRef.current = window.setTimeout(
          () => setIsOpenDelayed(true),
          skipDelayDuration
        );
      }, [skipDelayDuration]),
      isPointerInTransitRef,
      onPointerInTransitChange: React47.useCallback((inTransit) => {
        isPointerInTransitRef.current = inTransit;
      }, []),
      disableHoverableContent,
      children
    }
  );
};
TooltipProvider.displayName = PROVIDER_NAME;
var TOOLTIP_NAME = "Tooltip";
var [TooltipContextProvider, useTooltipContext] = createTooltipContext(TOOLTIP_NAME);
var Tooltip = (props) => {
  const {
    __scopeTooltip,
    children,
    open: openProp,
    defaultOpen = false,
    onOpenChange,
    disableHoverableContent: disableHoverableContentProp,
    delayDuration: delayDurationProp
  } = props;
  const providerContext = useTooltipProviderContext(TOOLTIP_NAME, props.__scopeTooltip);
  const popperScope = usePopperScope3(__scopeTooltip);
  const [trigger, setTrigger] = React47.useState(null);
  const contentId = useId();
  const openTimerRef = React47.useRef(0);
  const disableHoverableContent = disableHoverableContentProp ?? providerContext.disableHoverableContent;
  const delayDuration = delayDurationProp ?? providerContext.delayDuration;
  const wasOpenDelayedRef = React47.useRef(false);
  const [open = false, setOpen] = useControllableState({
    prop: openProp,
    defaultProp: defaultOpen,
    onChange: (open2) => {
      if (open2) {
        providerContext.onOpen();
        document.dispatchEvent(new CustomEvent(TOOLTIP_OPEN));
      } else {
        providerContext.onClose();
      }
      onOpenChange == null ? void 0 : onOpenChange(open2);
    }
  });
  const stateAttribute = React47.useMemo(() => {
    return open ? wasOpenDelayedRef.current ? "delayed-open" : "instant-open" : "closed";
  }, [open]);
  const handleOpen = React47.useCallback(() => {
    window.clearTimeout(openTimerRef.current);
    openTimerRef.current = 0;
    wasOpenDelayedRef.current = false;
    setOpen(true);
  }, [setOpen]);
  const handleClose = React47.useCallback(() => {
    window.clearTimeout(openTimerRef.current);
    openTimerRef.current = 0;
    setOpen(false);
  }, [setOpen]);
  const handleDelayedOpen = React47.useCallback(() => {
    window.clearTimeout(openTimerRef.current);
    openTimerRef.current = window.setTimeout(() => {
      wasOpenDelayedRef.current = true;
      setOpen(true);
      openTimerRef.current = 0;
    }, delayDuration);
  }, [delayDuration, setOpen]);
  React47.useEffect(() => {
    return () => {
      if (openTimerRef.current) {
        window.clearTimeout(openTimerRef.current);
        openTimerRef.current = 0;
      }
    };
  }, []);
  return (0, import_jsx_runtime27.jsx)(Root2, { ...popperScope, children: (0, import_jsx_runtime27.jsx)(
    TooltipContextProvider,
    {
      scope: __scopeTooltip,
      contentId,
      open,
      stateAttribute,
      trigger,
      onTriggerChange: setTrigger,
      onTriggerEnter: React47.useCallback(() => {
        if (providerContext.isOpenDelayed) handleDelayedOpen();
        else handleOpen();
      }, [providerContext.isOpenDelayed, handleDelayedOpen, handleOpen]),
      onTriggerLeave: React47.useCallback(() => {
        if (disableHoverableContent) {
          handleClose();
        } else {
          window.clearTimeout(openTimerRef.current);
          openTimerRef.current = 0;
        }
      }, [handleClose, disableHoverableContent]),
      onOpen: handleOpen,
      onClose: handleClose,
      disableHoverableContent,
      children
    }
  ) });
};
Tooltip.displayName = TOOLTIP_NAME;
var TRIGGER_NAME4 = "TooltipTrigger";
var TooltipTrigger = React47.forwardRef(
  (props, forwardedRef) => {
    const { __scopeTooltip, ...triggerProps } = props;
    const context = useTooltipContext(TRIGGER_NAME4, __scopeTooltip);
    const providerContext = useTooltipProviderContext(TRIGGER_NAME4, __scopeTooltip);
    const popperScope = usePopperScope3(__scopeTooltip);
    const ref2 = React47.useRef(null);
    const composedRefs = useComposedRefs(forwardedRef, ref2, context.onTriggerChange);
    const isPointerDownRef = React47.useRef(false);
    const hasPointerMoveOpenedRef = React47.useRef(false);
    const handlePointerUp = React47.useCallback(() => isPointerDownRef.current = false, []);
    React47.useEffect(() => {
      return () => document.removeEventListener("pointerup", handlePointerUp);
    }, [handlePointerUp]);
    return (0, import_jsx_runtime27.jsx)(Anchor, { asChild: true, ...popperScope, children: (0, import_jsx_runtime27.jsx)(
      Primitive.button,
      {
        "aria-describedby": context.open ? context.contentId : void 0,
        "data-state": context.stateAttribute,
        ...triggerProps,
        ref: composedRefs,
        onPointerMove: composeEventHandlers(props.onPointerMove, (event) => {
          if (event.pointerType === "touch") return;
          if (!hasPointerMoveOpenedRef.current && !providerContext.isPointerInTransitRef.current) {
            context.onTriggerEnter();
            hasPointerMoveOpenedRef.current = true;
          }
        }),
        onPointerLeave: composeEventHandlers(props.onPointerLeave, () => {
          context.onTriggerLeave();
          hasPointerMoveOpenedRef.current = false;
        }),
        onPointerDown: composeEventHandlers(props.onPointerDown, () => {
          isPointerDownRef.current = true;
          document.addEventListener("pointerup", handlePointerUp, { once: true });
        }),
        onFocus: composeEventHandlers(props.onFocus, () => {
          if (!isPointerDownRef.current) context.onOpen();
        }),
        onBlur: composeEventHandlers(props.onBlur, context.onClose),
        onClick: composeEventHandlers(props.onClick, context.onClose)
      }
    ) });
  }
);
TooltipTrigger.displayName = TRIGGER_NAME4;
var PORTAL_NAME5 = "TooltipPortal";
var [PortalProvider3, usePortalContext3] = createTooltipContext(PORTAL_NAME5, {
  forceMount: void 0
});
var TooltipPortal = (props) => {
  const { __scopeTooltip, forceMount, children, container } = props;
  const context = useTooltipContext(PORTAL_NAME5, __scopeTooltip);
  return (0, import_jsx_runtime27.jsx)(PortalProvider3, { scope: __scopeTooltip, forceMount, children: (0, import_jsx_runtime27.jsx)(Presence, { present: forceMount || context.open, children: (0, import_jsx_runtime27.jsx)(Portal, { asChild: true, container, children }) }) });
};
TooltipPortal.displayName = PORTAL_NAME5;
var CONTENT_NAME5 = "TooltipContent";
var TooltipContent = React47.forwardRef(
  (props, forwardedRef) => {
    const portalContext = usePortalContext3(CONTENT_NAME5, props.__scopeTooltip);
    const { forceMount = portalContext.forceMount, side = "top", ...contentProps } = props;
    const context = useTooltipContext(CONTENT_NAME5, props.__scopeTooltip);
    return (0, import_jsx_runtime27.jsx)(Presence, { present: forceMount || context.open, children: context.disableHoverableContent ? (0, import_jsx_runtime27.jsx)(TooltipContentImpl, { side, ...contentProps, ref: forwardedRef }) : (0, import_jsx_runtime27.jsx)(TooltipContentHoverable, { side, ...contentProps, ref: forwardedRef }) });
  }
);
var TooltipContentHoverable = React47.forwardRef((props, forwardedRef) => {
  const context = useTooltipContext(CONTENT_NAME5, props.__scopeTooltip);
  const providerContext = useTooltipProviderContext(CONTENT_NAME5, props.__scopeTooltip);
  const ref2 = React47.useRef(null);
  const composedRefs = useComposedRefs(forwardedRef, ref2);
  const [pointerGraceArea, setPointerGraceArea] = React47.useState(null);
  const { trigger, onClose } = context;
  const content3 = ref2.current;
  const { onPointerInTransitChange } = providerContext;
  const handleRemoveGraceArea = React47.useCallback(() => {
    setPointerGraceArea(null);
    onPointerInTransitChange(false);
  }, [onPointerInTransitChange]);
  const handleCreateGraceArea = React47.useCallback(
    (event, hoverTarget) => {
      const currentTarget = event.currentTarget;
      const exitPoint = { x: event.clientX, y: event.clientY };
      const exitSide = getExitSideFromRect(exitPoint, currentTarget.getBoundingClientRect());
      const paddedExitPoints = getPaddedExitPoints(exitPoint, exitSide);
      const hoverTargetPoints = getPointsFromRect(hoverTarget.getBoundingClientRect());
      const graceArea = getHull([...paddedExitPoints, ...hoverTargetPoints]);
      setPointerGraceArea(graceArea);
      onPointerInTransitChange(true);
    },
    [onPointerInTransitChange]
  );
  React47.useEffect(() => {
    return () => handleRemoveGraceArea();
  }, [handleRemoveGraceArea]);
  React47.useEffect(() => {
    if (trigger && content3) {
      const handleTriggerLeave = (event) => handleCreateGraceArea(event, content3);
      const handleContentLeave = (event) => handleCreateGraceArea(event, trigger);
      trigger.addEventListener("pointerleave", handleTriggerLeave);
      content3.addEventListener("pointerleave", handleContentLeave);
      return () => {
        trigger.removeEventListener("pointerleave", handleTriggerLeave);
        content3.removeEventListener("pointerleave", handleContentLeave);
      };
    }
  }, [trigger, content3, handleCreateGraceArea, handleRemoveGraceArea]);
  React47.useEffect(() => {
    if (pointerGraceArea) {
      const handleTrackPointerGrace = (event) => {
        const target = event.target;
        const pointerPosition = { x: event.clientX, y: event.clientY };
        const hasEnteredTarget = (trigger == null ? void 0 : trigger.contains(target)) || (content3 == null ? void 0 : content3.contains(target));
        const isPointerOutsideGraceArea = !isPointInPolygon(pointerPosition, pointerGraceArea);
        if (hasEnteredTarget) {
          handleRemoveGraceArea();
        } else if (isPointerOutsideGraceArea) {
          handleRemoveGraceArea();
          onClose();
        }
      };
      document.addEventListener("pointermove", handleTrackPointerGrace);
      return () => document.removeEventListener("pointermove", handleTrackPointerGrace);
    }
  }, [trigger, content3, pointerGraceArea, onClose, handleRemoveGraceArea]);
  return (0, import_jsx_runtime27.jsx)(TooltipContentImpl, { ...props, ref: composedRefs });
});
var [VisuallyHiddenContentContextProvider, useVisuallyHiddenContentContext] = createTooltipContext(TOOLTIP_NAME, { isInside: false });
var TooltipContentImpl = React47.forwardRef(
  (props, forwardedRef) => {
    const {
      __scopeTooltip,
      children,
      "aria-label": ariaLabel,
      onEscapeKeyDown,
      onPointerDownOutside,
      ...contentProps
    } = props;
    const context = useTooltipContext(CONTENT_NAME5, __scopeTooltip);
    const popperScope = usePopperScope3(__scopeTooltip);
    const { onClose } = context;
    React47.useEffect(() => {
      document.addEventListener(TOOLTIP_OPEN, onClose);
      return () => document.removeEventListener(TOOLTIP_OPEN, onClose);
    }, [onClose]);
    React47.useEffect(() => {
      if (context.trigger) {
        const handleScroll2 = (event) => {
          const target = event.target;
          if (target == null ? void 0 : target.contains(context.trigger)) onClose();
        };
        window.addEventListener("scroll", handleScroll2, { capture: true });
        return () => window.removeEventListener("scroll", handleScroll2, { capture: true });
      }
    }, [context.trigger, onClose]);
    return (0, import_jsx_runtime27.jsx)(
      DismissableLayer,
      {
        asChild: true,
        disableOutsidePointerEvents: false,
        onEscapeKeyDown,
        onPointerDownOutside,
        onFocusOutside: (event) => event.preventDefault(),
        onDismiss: onClose,
        children: (0, import_jsx_runtime27.jsxs)(
          Content,
          {
            "data-state": context.stateAttribute,
            ...popperScope,
            ...contentProps,
            ref: forwardedRef,
            style: {
              ...contentProps.style,
              // re-namespace exposed content custom properties
              ...{
                "--radix-tooltip-content-transform-origin": "var(--radix-popper-transform-origin)",
                "--radix-tooltip-content-available-width": "var(--radix-popper-available-width)",
                "--radix-tooltip-content-available-height": "var(--radix-popper-available-height)",
                "--radix-tooltip-trigger-width": "var(--radix-popper-anchor-width)",
                "--radix-tooltip-trigger-height": "var(--radix-popper-anchor-height)"
              }
            },
            children: [
              (0, import_jsx_runtime27.jsx)(Slottable, { children }),
              (0, import_jsx_runtime27.jsx)(VisuallyHiddenContentContextProvider, { scope: __scopeTooltip, isInside: true, children: (0, import_jsx_runtime27.jsx)(Root6, { id: context.contentId, role: "tooltip", children: ariaLabel || children }) })
            ]
          }
        )
      }
    );
  }
);
TooltipContent.displayName = CONTENT_NAME5;
var ARROW_NAME4 = "TooltipArrow";
var TooltipArrow = React47.forwardRef(
  (props, forwardedRef) => {
    const { __scopeTooltip, ...arrowProps } = props;
    const popperScope = usePopperScope3(__scopeTooltip);
    const visuallyHiddenContentContext = useVisuallyHiddenContentContext(
      ARROW_NAME4,
      __scopeTooltip
    );
    return visuallyHiddenContentContext.isInside ? null : (0, import_jsx_runtime27.jsx)(Arrow2, { ...popperScope, ...arrowProps, ref: forwardedRef });
  }
);
TooltipArrow.displayName = ARROW_NAME4;
function getExitSideFromRect(point3, rect) {
  const top = Math.abs(rect.top - point3.y);
  const bottom = Math.abs(rect.bottom - point3.y);
  const right = Math.abs(rect.right - point3.x);
  const left = Math.abs(rect.left - point3.x);
  switch (Math.min(top, bottom, right, left)) {
    case left:
      return "left";
    case right:
      return "right";
    case top:
      return "top";
    case bottom:
      return "bottom";
    default:
      throw new Error("unreachable");
  }
}
function getPaddedExitPoints(exitPoint, exitSide, padding = 5) {
  const paddedExitPoints = [];
  switch (exitSide) {
    case "top":
      paddedExitPoints.push(
        { x: exitPoint.x - padding, y: exitPoint.y + padding },
        { x: exitPoint.x + padding, y: exitPoint.y + padding }
      );
      break;
    case "bottom":
      paddedExitPoints.push(
        { x: exitPoint.x - padding, y: exitPoint.y - padding },
        { x: exitPoint.x + padding, y: exitPoint.y - padding }
      );
      break;
    case "left":
      paddedExitPoints.push(
        { x: exitPoint.x + padding, y: exitPoint.y - padding },
        { x: exitPoint.x + padding, y: exitPoint.y + padding }
      );
      break;
    case "right":
      paddedExitPoints.push(
        { x: exitPoint.x - padding, y: exitPoint.y - padding },
        { x: exitPoint.x - padding, y: exitPoint.y + padding }
      );
      break;
  }
  return paddedExitPoints;
}
function getPointsFromRect(rect) {
  const { top, right, bottom, left } = rect;
  return [
    { x: left, y: top },
    { x: right, y: top },
    { x: right, y: bottom },
    { x: left, y: bottom }
  ];
}
function isPointInPolygon(point3, polygon) {
  const { x: x3, y: y2 } = point3;
  let inside = false;
  for (let i3 = 0, j3 = polygon.length - 1; i3 < polygon.length; j3 = i3++) {
    const xi = polygon[i3].x;
    const yi = polygon[i3].y;
    const xj = polygon[j3].x;
    const yj = polygon[j3].y;
    const intersect = yi > y2 !== yj > y2 && x3 < (xj - xi) * (y2 - yi) / (yj - yi) + xi;
    if (intersect) inside = !inside;
  }
  return inside;
}
function getHull(points) {
  const newPoints = points.slice();
  newPoints.sort((a2, b3) => {
    if (a2.x < b3.x) return -1;
    else if (a2.x > b3.x) return 1;
    else if (a2.y < b3.y) return -1;
    else if (a2.y > b3.y) return 1;
    else return 0;
  });
  return getHullPresorted(newPoints);
}
function getHullPresorted(points) {
  if (points.length <= 1) return points.slice();
  const upperHull = [];
  for (let i3 = 0; i3 < points.length; i3++) {
    const p2 = points[i3];
    while (upperHull.length >= 2) {
      const q2 = upperHull[upperHull.length - 1];
      const r2 = upperHull[upperHull.length - 2];
      if ((q2.x - r2.x) * (p2.y - r2.y) >= (q2.y - r2.y) * (p2.x - r2.x)) upperHull.pop();
      else break;
    }
    upperHull.push(p2);
  }
  upperHull.pop();
  const lowerHull = [];
  for (let i3 = points.length - 1; i3 >= 0; i3--) {
    const p2 = points[i3];
    while (lowerHull.length >= 2) {
      const q2 = lowerHull[lowerHull.length - 1];
      const r2 = lowerHull[lowerHull.length - 2];
      if ((q2.x - r2.x) * (p2.y - r2.y) >= (q2.y - r2.y) * (p2.x - r2.x)) lowerHull.pop();
      else break;
    }
    lowerHull.push(p2);
  }
  lowerHull.pop();
  if (upperHull.length === 1 && lowerHull.length === 1 && upperHull[0].x === lowerHull[0].x && upperHull[0].y === lowerHull[0].y) {
    return upperHull;
  } else {
    return upperHull.concat(lowerHull);
  }
}
var Provider = TooltipProvider;
var Root32 = Tooltip;
var Trigger4 = TooltipTrigger;
var Portal5 = TooltipPortal;
var Content23 = TooltipContent;
var Arrow23 = TooltipArrow;

// node_modules/@mdxeditor/editor/dist/plugins/toolbar/primitives/TooltipWrap.js
var import_classnames8 = __toESM(require_classnames(), 1);
var import_react51 = __toESM(require_react(), 1);
var TooltipWrap = import_react51.default.forwardRef(({ title, children }, ref2) => {
  const editorRootElementRef = E(editorRootElementRef$);
  return import_react51.default.createElement(Provider, { delayDuration: 100 }, import_react51.default.createElement(Root32, null, import_react51.default.createElement(Trigger4, { ref: ref2, asChild: true }, import_react51.default.createElement("span", { className: styles.tooltipTrigger }, children)), import_react51.default.createElement(Portal5, { container: editorRootElementRef == null ? void 0 : editorRootElementRef.current }, import_react51.default.createElement(Content23, { className: (0, import_classnames8.default)(styles.tooltipContent), sideOffset: 10 }, title))));
});

// node_modules/@mdxeditor/editor/dist/plugins/toolbar/primitives/select.js
var SelectItem2 = import_react52.default.forwardRef(
  ({ children, className, ...props }, forwardedRef) => {
    return import_react52.default.createElement(Item3, { ...props, ref: forwardedRef, className: (0, import_classnames9.default)(className, styles.selectItem) }, import_react52.default.createElement(ItemText, null, children));
  }
);
var SelectTrigger2 = ({ title, placeholder: placeholder2, className }) => {
  const [readOnly, iconComponentFor] = X(readOnly$, iconComponentFor$);
  return import_react52.default.createElement(TooltipWrap, { title }, import_react52.default.createElement(
    Trigger3,
    {
      "aria-label": placeholder2,
      className: (0, import_classnames9.default)(styles.selectTrigger, className),
      "data-toolbar-item": true,
      disabled: readOnly
    },
    import_react52.default.createElement(Value, { placeholder: placeholder2 }),
    import_react52.default.createElement(Icon, { className: styles.selectDropdownArrow }, iconComponentFor("arrow_drop_down"))
  ));
};
var SelectContent2 = ({
  children,
  className = styles.selectContainer
}) => {
  const editorRootElementRef = E(editorRootElementRef$);
  return import_react52.default.createElement(Portal4, { container: editorRootElementRef == null ? void 0 : editorRootElementRef.current }, import_react52.default.createElement(
    Content22,
    {
      className: (0, import_classnames9.default)(className, "mdxeditor-select-content"),
      onCloseAutoFocus: (e2) => {
        e2.preventDefault();
      },
      position: "popper"
    },
    import_react52.default.createElement(Viewport, { "data-editor-dropdown": true }, children)
  ));
};
var SelectButtonTrigger = ({
  children,
  title,
  className
}) => {
  const [readOnly, iconComponentFor] = X(readOnly$, iconComponentFor$);
  return import_react52.default.createElement(TooltipWrap, { title }, import_react52.default.createElement(Trigger3, { className: (0, import_classnames9.default)(styles.toolbarButtonSelectTrigger, className), disabled: readOnly }, children, import_react52.default.createElement(Icon, { className: styles.selectDropdownArrow }, iconComponentFor("arrow_drop_down"))));
};
var Select2 = (props) => {
  return import_react52.default.createElement(Root24, { value: props.value || void 0, onValueChange: props.onChange }, import_react52.default.createElement(SelectTrigger2, { title: props.triggerTitle, placeholder: props.placeholder }), import_react52.default.createElement(SelectContent2, null, props.items.map((item, index3) => {
    if (item === "separator") {
      return import_react52.default.createElement(Separator3, { key: index3 });
    }
    return import_react52.default.createElement(SelectItem2, { key: index3, value: item.value }, item.label);
  })));
};

// node_modules/@mdxeditor/editor/dist/plugins/codemirror/CodeMirrorEditor.js
var COMMON_STATE_CONFIG_EXTENSIONS = [];
var EMPTY_VALUE = "__EMPTY_VALUE__";
var CodeMirrorEditor = ({ language: language2, nodeKey, code: code3, focusEmitter }) => {
  const t3 = useTranslation();
  const { parentEditor, lexicalNode } = useCodeBlockEditorContext();
  const [readOnly, codeMirrorExtensions, autoLoadLanguageSupport, iconComponentFor, codeBlockLanguages] = X(
    readOnly$,
    codeMirrorExtensions$,
    codeMirrorAutoLoadLanguageSupport$,
    iconComponentFor$,
    codeBlockLanguages$
  );
  const codeMirrorRef = useCodeMirrorRef(nodeKey, "codeblock", language2, focusEmitter);
  const { setCode } = useCodeBlockEditorContext();
  const editorViewRef = import_react53.default.useRef(null);
  const elRef = import_react53.default.useRef(null);
  const setCodeRef = import_react53.default.useRef(setCode);
  setCodeRef.current = setCode;
  codeMirrorRef.current = {
    getCodemirror: () => editorViewRef.current
  };
  import_react53.default.useEffect(() => {
    void (async () => {
      const extensions = [
        ...codeMirrorExtensions,
        basicSetup,
        basicLight,
        lineNumbers(),
        EditorView.lineWrapping,
        EditorView.updateListener.of(({ state }) => {
          setCodeRef.current(state.doc.toString());
        })
      ];
      if (readOnly) {
        extensions.push(EditorState.readOnly.of(true));
      }
      if (language2 !== "" && autoLoadLanguageSupport) {
        const languageData = languages.find((l3) => {
          return l3.name === language2 || l3.alias.includes(language2) || l3.extensions.includes(language2);
        });
        if (languageData) {
          try {
            const languageSupport = await languageData.load();
            extensions.push(languageSupport.extension);
          } catch (e2) {
            console.warn("failed to load language support for", language2);
          }
        }
      }
      elRef.current.innerHTML = "";
      editorViewRef.current = new EditorView({
        parent: elRef.current,
        state: EditorState.create({ doc: code3, extensions })
      });
    })();
    return () => {
      var _a2;
      (_a2 = editorViewRef.current) == null ? void 0 : _a2.destroy();
      editorViewRef.current = null;
    };
  }, [readOnly, language2]);
  return import_react53.default.createElement(
    "div",
    {
      className: styles.codeMirrorWrapper,
      onKeyDown: (e2) => {
        e2.stopPropagation();
      }
    },
    import_react53.default.createElement("div", { className: styles.codeMirrorToolbar }, import_react53.default.createElement(
      Select2,
      {
        value: language2,
        onChange: (language22) => {
          parentEditor.update(() => {
            lexicalNode.setLanguage(language22 === EMPTY_VALUE ? "" : language22);
            setTimeout(() => {
              parentEditor.update(() => {
                lexicalNode.getLatest().select();
              });
            });
          });
        },
        triggerTitle: t3("codeBlock.selectLanguage", "Select code block language"),
        placeholder: t3("codeBlock.inlineLanguage", "Language"),
        items: Object.entries(codeBlockLanguages).map(([value2, label4]) => ({ value: value2 ? value2 : EMPTY_VALUE, label: label4 }))
      }
    ), import_react53.default.createElement(
      "button",
      {
        className: styles.iconButton,
        type: "button",
        title: t3("codeblock.delete", "Delete code block"),
        onClick: (e2) => {
          e2.preventDefault();
          parentEditor.update(() => {
            lexicalNode.remove();
          });
        }
      },
      iconComponentFor("delete_small")
    )),
    import_react53.default.createElement("div", { ref: elRef })
  );
};

// node_modules/@mdxeditor/editor/dist/plugins/codemirror/index.js
var codeBlockLanguages$ = $({
  js: "JavaScript",
  ts: "TypeScript",
  tsx: "TypeScript (React)",
  jsx: "JavaScript (React)",
  css: "CSS"
});
var insertCodeMirror$ = K((r2) => {
  r2.link(
    r2.pipe(
      insertCodeMirror$,
      _(({ language: language2, code: code3 }) => {
        return {
          code: code3,
          language: language2,
          meta: ""
        };
      })
    ),
    insertCodeBlock$
  );
});
var codeMirrorExtensions$ = $([]);
var codeMirrorAutoLoadLanguageSupport$ = $(true);
var codeMirrorPlugin = realmPlugin({
  update(r2, params) {
    r2.pubIn({
      [codeBlockLanguages$]: params == null ? void 0 : params.codeBlockLanguages,
      [codeMirrorExtensions$]: (params == null ? void 0 : params.codeMirrorExtensions) ?? [],
      [codeMirrorAutoLoadLanguageSupport$]: (params == null ? void 0 : params.autoLoadLanguageSupport) ?? true
    });
  },
  init(r2, params) {
    r2.pubIn({
      [codeBlockLanguages$]: params == null ? void 0 : params.codeBlockLanguages,
      [codeMirrorExtensions$]: (params == null ? void 0 : params.codeMirrorExtensions) ?? [],
      [appendCodeBlockEditorDescriptor$]: buildCodeBlockDescriptor((params == null ? void 0 : params.codeBlockLanguages) ?? {}),
      [codeMirrorAutoLoadLanguageSupport$]: (params == null ? void 0 : params.autoLoadLanguageSupport) ?? true
    });
  }
});
function buildCodeBlockDescriptor(codeBlockLanguages) {
  return {
    match(language2, meta) {
      return Boolean(Object.hasOwn(codeBlockLanguages, language2 ?? "")) && !meta;
    },
    priority: 1,
    Editor: CodeMirrorEditor
  };
}

// node_modules/mdast-util-directive/lib/index.js
var own7 = {}.hasOwnProperty;
var emptyOptions3 = {};
var shortcut = /^[^\t\n\r "#'.<=>`}]+$/;
var unquoted = /^[^\t\n\r "'<=>`}]+$/;
function directiveFromMarkdown() {
  return {
    canContainEols: ["textDirective"],
    enter: {
      directiveContainer: enterContainer,
      directiveContainerAttributes: enterAttributes,
      directiveContainerLabel: enterContainerLabel,
      directiveLeaf: enterLeaf,
      directiveLeafAttributes: enterAttributes,
      directiveText: enterText,
      directiveTextAttributes: enterAttributes
    },
    exit: {
      directiveContainer: exit3,
      directiveContainerAttributeClassValue: exitAttributeClassValue,
      directiveContainerAttributeIdValue: exitAttributeIdValue,
      directiveContainerAttributeName: exitAttributeName,
      directiveContainerAttributeValue: exitAttributeValue,
      directiveContainerAttributes: exitAttributes,
      directiveContainerLabel: exitContainerLabel,
      directiveContainerName: exitName,
      directiveLeaf: exit3,
      directiveLeafAttributeClassValue: exitAttributeClassValue,
      directiveLeafAttributeIdValue: exitAttributeIdValue,
      directiveLeafAttributeName: exitAttributeName,
      directiveLeafAttributeValue: exitAttributeValue,
      directiveLeafAttributes: exitAttributes,
      directiveLeafName: exitName,
      directiveText: exit3,
      directiveTextAttributeClassValue: exitAttributeClassValue,
      directiveTextAttributeIdValue: exitAttributeIdValue,
      directiveTextAttributeName: exitAttributeName,
      directiveTextAttributeValue: exitAttributeValue,
      directiveTextAttributes: exitAttributes,
      directiveTextName: exitName
    }
  };
}
function directiveToMarkdown(options) {
  const settings = options || emptyOptions3;
  if (settings.quote !== '"' && settings.quote !== "'" && settings.quote !== null && settings.quote !== void 0) {
    throw new Error(
      "Invalid quote `" + settings.quote + "`, expected `'` or `\"`"
    );
  }
  handleDirective.peek = peekDirective;
  return {
    handlers: {
      containerDirective: handleDirective,
      leafDirective: handleDirective,
      textDirective: handleDirective
    },
    unsafe: [
      {
        character: "\r",
        inConstruct: ["leafDirectiveLabel", "containerDirectiveLabel"]
      },
      {
        character: "\n",
        inConstruct: ["leafDirectiveLabel", "containerDirectiveLabel"]
      },
      {
        before: "[^:]",
        character: ":",
        after: "[A-Za-z]",
        inConstruct: ["phrasing"]
      },
      { atBreak: true, character: ":", after: ":" }
    ]
  };
  function handleDirective(node2, _2, state, info) {
    const tracker = state.createTracker(info);
    const sequence = fence3(node2);
    const exit4 = state.enter(node2.type);
    let value2 = tracker.move(sequence + (node2.name || ""));
    let label4;
    if (node2.type === "containerDirective") {
      const head = (node2.children || [])[0];
      label4 = inlineDirectiveLabel(head) ? head : void 0;
    } else {
      label4 = node2;
    }
    if (label4 && label4.children && label4.children.length > 0) {
      const exit5 = state.enter("label");
      const labelType = `${node2.type}Label`;
      const subexit = state.enter(labelType);
      value2 += tracker.move("[");
      value2 += tracker.move(
        state.containerPhrasing(label4, {
          ...tracker.current(),
          before: value2,
          after: "]"
        })
      );
      value2 += tracker.move("]");
      subexit();
      exit5();
    }
    value2 += tracker.move(attributes4(node2, state));
    if (node2.type === "containerDirective") {
      const head = (node2.children || [])[0];
      let shallow = node2;
      if (inlineDirectiveLabel(head)) {
        shallow = Object.assign({}, node2, { children: node2.children.slice(1) });
      }
      if (shallow && shallow.children && shallow.children.length > 0) {
        value2 += tracker.move("\n");
        value2 += tracker.move(state.containerFlow(shallow, tracker.current()));
      }
      value2 += tracker.move("\n" + sequence);
    }
    exit4();
    return value2;
  }
  function attributes4(node2, state) {
    const attributes5 = node2.attributes || {};
    const values2 = [];
    let classesFull;
    let classes;
    let id;
    let key2;
    for (key2 in attributes5) {
      if (own7.call(attributes5, key2) && attributes5[key2] !== void 0 && attributes5[key2] !== null) {
        const value2 = String(attributes5[key2]);
        if (key2 === "id") {
          id = settings.preferShortcut !== false && shortcut.test(value2) ? "#" + value2 : quoted("id", value2, node2, state);
        } else if (key2 === "class") {
          const list4 = value2.split(/[\t\n\r ]+/g);
          const classesFullList = [];
          const classesList = [];
          let index3 = -1;
          while (++index3 < list4.length) {
            ;
            (settings.preferShortcut !== false && shortcut.test(list4[index3]) ? classesList : classesFullList).push(list4[index3]);
          }
          classesFull = classesFullList.length > 0 ? quoted("class", classesFullList.join(" "), node2, state) : "";
          classes = classesList.length > 0 ? "." + classesList.join(".") : "";
        } else {
          values2.push(quoted(key2, value2, node2, state));
        }
      }
    }
    if (classesFull) {
      values2.unshift(classesFull);
    }
    if (classes) {
      values2.unshift(classes);
    }
    if (id) {
      values2.unshift(id);
    }
    return values2.length > 0 ? "{" + values2.join(" ") + "}" : "";
  }
  function quoted(key2, value2, node2, state) {
    if (settings.collapseEmptyAttributes !== false && !value2) return key2;
    if (settings.preferUnquoted && unquoted.test(value2)) {
      return key2 + "=" + value2;
    }
    const preferred = settings.quote || state.options.quote || '"';
    const alternative = preferred === '"' ? "'" : '"';
    const appliedQuote = settings.quoteSmart && ccount(value2, preferred) > ccount(value2, alternative) ? alternative : preferred;
    const subset = node2.type === "textDirective" ? [appliedQuote] : [appliedQuote, "\n", "\r"];
    return key2 + "=" + appliedQuote + stringifyEntitiesLight(value2, { subset }) + appliedQuote;
  }
}
function enterContainer(token) {
  enter.call(this, "containerDirective", token);
}
function enterLeaf(token) {
  enter.call(this, "leafDirective", token);
}
function enterText(token) {
  enter.call(this, "textDirective", token);
}
function enter(type2, token) {
  this.enter({ type: type2, name: "", attributes: {}, children: [] }, token);
}
function exitName(token) {
  const node2 = this.stack[this.stack.length - 1];
  ok(
    node2.type === "containerDirective" || node2.type === "leafDirective" || node2.type === "textDirective"
  );
  node2.name = this.sliceSerialize(token);
}
function enterContainerLabel(token) {
  this.enter(
    { type: "paragraph", data: { directiveLabel: true }, children: [] },
    token
  );
}
function exitContainerLabel(token) {
  this.exit(token);
}
function enterAttributes() {
  this.data.directiveAttributes = [];
  this.buffer();
}
function exitAttributeIdValue(token) {
  const list4 = this.data.directiveAttributes;
  ok(list4, "expected `directiveAttributes`");
  list4.push([
    "id",
    parseEntities(this.sliceSerialize(token), { attribute: true })
  ]);
}
function exitAttributeClassValue(token) {
  const list4 = this.data.directiveAttributes;
  ok(list4, "expected `directiveAttributes`");
  list4.push([
    "class",
    parseEntities(this.sliceSerialize(token), { attribute: true })
  ]);
}
function exitAttributeValue(token) {
  const list4 = this.data.directiveAttributes;
  ok(list4, "expected `directiveAttributes`");
  list4[list4.length - 1][1] = parseEntities(this.sliceSerialize(token), {
    attribute: true
  });
}
function exitAttributeName(token) {
  const list4 = this.data.directiveAttributes;
  ok(list4, "expected `directiveAttributes`");
  list4.push([this.sliceSerialize(token), ""]);
}
function exitAttributes() {
  const list4 = this.data.directiveAttributes;
  ok(list4, "expected `directiveAttributes`");
  const cleaned = {};
  let index3 = -1;
  while (++index3 < list4.length) {
    const attribute = list4[index3];
    if (attribute[0] === "class" && cleaned.class) {
      cleaned.class += " " + attribute[1];
    } else {
      cleaned[attribute[0]] = attribute[1];
    }
  }
  this.data.directiveAttributes = void 0;
  this.resume();
  const node2 = this.stack[this.stack.length - 1];
  ok(
    node2.type === "containerDirective" || node2.type === "leafDirective" || node2.type === "textDirective"
  );
  node2.attributes = cleaned;
}
function exit3(token) {
  this.exit(token);
}
function peekDirective() {
  return ":";
}
function inlineDirectiveLabel(node2) {
  return Boolean(
    node2 && node2.type === "paragraph" && node2.data && node2.data.directiveLabel
  );
}
function fence3(node2) {
  let size4 = 0;
  if (node2.type === "containerDirective") {
    visitParents(node2, function(node3, parents) {
      if (node3.type === "containerDirective") {
        let index3 = parents.length;
        let nesting = 0;
        while (index3--) {
          if (parents[index3].type === "containerDirective") {
            nesting++;
          }
        }
        if (nesting > size4) size4 = nesting;
      }
    });
    size4 += 3;
  } else if (node2.type === "leafDirective") {
    size4 = 2;
  } else {
    size4 = 1;
  }
  return ":".repeat(size4);
}

// node_modules/micromark-extension-directive/dev/lib/factory-attributes.js
function factoryAttributes(effects, ok3, nok, attributesType, attributesMarkerType, attributeType, attributeIdType, attributeClassType, attributeNameType, attributeInitializerType, attributeValueLiteralType, attributeValueType, attributeValueMarker, attributeValueData, disallowEol) {
  let type2;
  let marker;
  return start2;
  function start2(code3) {
    ok(code3 === codes.leftCurlyBrace, "expected `{`");
    effects.enter(attributesType);
    effects.enter(attributesMarkerType);
    effects.consume(code3);
    effects.exit(attributesMarkerType);
    return between2;
  }
  function between2(code3) {
    if (code3 === codes.numberSign) {
      type2 = attributeIdType;
      return shortcutStart(code3);
    }
    if (code3 === codes.dot) {
      type2 = attributeClassType;
      return shortcutStart(code3);
    }
    if (code3 === codes.colon || code3 === codes.underscore || asciiAlpha(code3)) {
      effects.enter(attributeType);
      effects.enter(attributeNameType);
      effects.consume(code3);
      return name2;
    }
    if (disallowEol && markdownSpace(code3)) {
      return factorySpace(effects, between2, types.whitespace)(code3);
    }
    if (!disallowEol && markdownLineEndingOrSpace(code3)) {
      return factoryWhitespace(effects, between2)(code3);
    }
    return end(code3);
  }
  function shortcutStart(code3) {
    const markerType = (
      /** @type {TokenType} */
      type2 + "Marker"
    );
    effects.enter(attributeType);
    effects.enter(type2);
    effects.enter(markerType);
    effects.consume(code3);
    effects.exit(markerType);
    return shortcutStartAfter;
  }
  function shortcutStartAfter(code3) {
    if (code3 === codes.eof || code3 === codes.quotationMark || code3 === codes.numberSign || code3 === codes.apostrophe || code3 === codes.dot || code3 === codes.lessThan || code3 === codes.equalsTo || code3 === codes.greaterThan || code3 === codes.graveAccent || code3 === codes.rightCurlyBrace || markdownLineEndingOrSpace(code3)) {
      return nok(code3);
    }
    const valueType = (
      /** @type {TokenType} */
      type2 + "Value"
    );
    effects.enter(valueType);
    effects.consume(code3);
    return shortcut2;
  }
  function shortcut2(code3) {
    if (code3 === codes.eof || code3 === codes.quotationMark || code3 === codes.apostrophe || code3 === codes.lessThan || code3 === codes.equalsTo || code3 === codes.greaterThan || code3 === codes.graveAccent) {
      return nok(code3);
    }
    if (code3 === codes.numberSign || code3 === codes.dot || code3 === codes.rightCurlyBrace || markdownLineEndingOrSpace(code3)) {
      const valueType = (
        /** @type {TokenType} */
        type2 + "Value"
      );
      effects.exit(valueType);
      effects.exit(type2);
      effects.exit(attributeType);
      return between2(code3);
    }
    effects.consume(code3);
    return shortcut2;
  }
  function name2(code3) {
    if (code3 === codes.dash || code3 === codes.dot || code3 === codes.colon || code3 === codes.underscore || asciiAlphanumeric(code3)) {
      effects.consume(code3);
      return name2;
    }
    effects.exit(attributeNameType);
    if (disallowEol && markdownSpace(code3)) {
      return factorySpace(effects, nameAfter, types.whitespace)(code3);
    }
    if (!disallowEol && markdownLineEndingOrSpace(code3)) {
      return factoryWhitespace(effects, nameAfter)(code3);
    }
    return nameAfter(code3);
  }
  function nameAfter(code3) {
    if (code3 === codes.equalsTo) {
      effects.enter(attributeInitializerType);
      effects.consume(code3);
      effects.exit(attributeInitializerType);
      return valueBefore;
    }
    effects.exit(attributeType);
    return between2(code3);
  }
  function valueBefore(code3) {
    if (code3 === codes.eof || code3 === codes.lessThan || code3 === codes.equalsTo || code3 === codes.greaterThan || code3 === codes.graveAccent || code3 === codes.rightCurlyBrace || disallowEol && markdownLineEnding(code3)) {
      return nok(code3);
    }
    if (code3 === codes.quotationMark || code3 === codes.apostrophe) {
      effects.enter(attributeValueLiteralType);
      effects.enter(attributeValueMarker);
      effects.consume(code3);
      effects.exit(attributeValueMarker);
      marker = code3;
      return valueQuotedStart;
    }
    if (disallowEol && markdownSpace(code3)) {
      return factorySpace(effects, valueBefore, types.whitespace)(code3);
    }
    if (!disallowEol && markdownLineEndingOrSpace(code3)) {
      return factoryWhitespace(effects, valueBefore)(code3);
    }
    effects.enter(attributeValueType);
    effects.enter(attributeValueData);
    effects.consume(code3);
    marker = void 0;
    return valueUnquoted;
  }
  function valueUnquoted(code3) {
    if (code3 === codes.eof || code3 === codes.quotationMark || code3 === codes.apostrophe || code3 === codes.lessThan || code3 === codes.equalsTo || code3 === codes.greaterThan || code3 === codes.graveAccent) {
      return nok(code3);
    }
    if (code3 === codes.rightCurlyBrace || markdownLineEndingOrSpace(code3)) {
      effects.exit(attributeValueData);
      effects.exit(attributeValueType);
      effects.exit(attributeType);
      return between2(code3);
    }
    effects.consume(code3);
    return valueUnquoted;
  }
  function valueQuotedStart(code3) {
    if (code3 === marker) {
      effects.enter(attributeValueMarker);
      effects.consume(code3);
      effects.exit(attributeValueMarker);
      effects.exit(attributeValueLiteralType);
      effects.exit(attributeType);
      return valueQuotedAfter;
    }
    effects.enter(attributeValueType);
    return valueQuotedBetween(code3);
  }
  function valueQuotedBetween(code3) {
    if (code3 === marker) {
      effects.exit(attributeValueType);
      return valueQuotedStart(code3);
    }
    if (code3 === codes.eof) {
      return nok(code3);
    }
    if (markdownLineEnding(code3)) {
      return disallowEol ? nok(code3) : factoryWhitespace(effects, valueQuotedBetween)(code3);
    }
    effects.enter(attributeValueData);
    effects.consume(code3);
    return valueQuoted;
  }
  function valueQuoted(code3) {
    if (code3 === marker || code3 === codes.eof || markdownLineEnding(code3)) {
      effects.exit(attributeValueData);
      return valueQuotedBetween(code3);
    }
    effects.consume(code3);
    return valueQuoted;
  }
  function valueQuotedAfter(code3) {
    return code3 === codes.rightCurlyBrace || markdownLineEndingOrSpace(code3) ? between2(code3) : end(code3);
  }
  function end(code3) {
    if (code3 === codes.rightCurlyBrace) {
      effects.enter(attributesMarkerType);
      effects.consume(code3);
      effects.exit(attributesMarkerType);
      effects.exit(attributesType);
      return ok3;
    }
    return nok(code3);
  }
}

// node_modules/micromark-extension-directive/dev/lib/factory-label.js
function factoryLabel2(effects, ok3, nok, type2, markerType, stringType, disallowEol) {
  let size4 = 0;
  let balance = 0;
  let previous3;
  return start2;
  function start2(code3) {
    ok(code3 === codes.leftSquareBracket, "expected `[`");
    effects.enter(type2);
    effects.enter(markerType);
    effects.consume(code3);
    effects.exit(markerType);
    return afterStart;
  }
  function afterStart(code3) {
    if (code3 === codes.rightSquareBracket) {
      effects.enter(markerType);
      effects.consume(code3);
      effects.exit(markerType);
      effects.exit(type2);
      return ok3;
    }
    effects.enter(stringType);
    return lineStart(code3);
  }
  function lineStart(code3) {
    if (code3 === codes.rightSquareBracket && !balance) {
      return atClosingBrace(code3);
    }
    const token = effects.enter(types.chunkText, {
      contentType: constants.contentTypeText,
      previous: previous3
    });
    if (previous3) previous3.next = token;
    previous3 = token;
    return data2(code3);
  }
  function data2(code3) {
    if (code3 === codes.eof || size4 > constants.linkReferenceSizeMax) {
      return nok(code3);
    }
    if (code3 === codes.leftSquareBracket && ++balance > constants.linkResourceDestinationBalanceMax) {
      return nok(code3);
    }
    if (code3 === codes.rightSquareBracket && !balance--) {
      effects.exit(types.chunkText);
      return atClosingBrace(code3);
    }
    if (markdownLineEnding(code3)) {
      if (disallowEol) {
        return nok(code3);
      }
      effects.consume(code3);
      effects.exit(types.chunkText);
      return lineStart;
    }
    effects.consume(code3);
    return code3 === codes.backslash ? dataEscape : data2;
  }
  function dataEscape(code3) {
    if (code3 === codes.leftSquareBracket || code3 === codes.backslash || code3 === codes.rightSquareBracket) {
      effects.consume(code3);
      size4++;
      return data2;
    }
    return data2(code3);
  }
  function atClosingBrace(code3) {
    effects.exit(stringType);
    effects.enter(markerType);
    effects.consume(code3);
    effects.exit(markerType);
    effects.exit(type2);
    return ok3;
  }
}

// node_modules/micromark-extension-directive/dev/lib/factory-name.js
function factoryName(effects, ok3, nok, type2) {
  const self2 = this;
  return start2;
  function start2(code3) {
    if (asciiAlpha(code3)) {
      effects.enter(type2);
      effects.consume(code3);
      return name2;
    }
    return nok(code3);
  }
  function name2(code3) {
    if (code3 === codes.dash || code3 === codes.underscore || asciiAlphanumeric(code3)) {
      effects.consume(code3);
      return name2;
    }
    effects.exit(type2);
    return self2.previous === codes.dash || self2.previous === codes.underscore ? nok(code3) : ok3(code3);
  }
}

// node_modules/micromark-extension-directive/dev/lib/directive-container.js
var directiveContainer = {
  tokenize: tokenizeDirectiveContainer,
  concrete: true
};
var label = { tokenize: tokenizeLabel, partial: true };
var attributes = { tokenize: tokenizeAttributes, partial: true };
var nonLazyLine = { tokenize: tokenizeNonLazyLine, partial: true };
function tokenizeDirectiveContainer(effects, ok3, nok) {
  const self2 = this;
  const tail = self2.events[self2.events.length - 1];
  const initialSize = tail && tail[1].type === types.linePrefix ? tail[2].sliceSerialize(tail[1], true).length : 0;
  let sizeOpen = 0;
  let previous3;
  return start2;
  function start2(code3) {
    ok(code3 === codes.colon, "expected `:`");
    effects.enter("directiveContainer");
    effects.enter("directiveContainerFence");
    effects.enter("directiveContainerSequence");
    return sequenceOpen(code3);
  }
  function sequenceOpen(code3) {
    if (code3 === codes.colon) {
      effects.consume(code3);
      sizeOpen++;
      return sequenceOpen;
    }
    if (sizeOpen < constants.codeFencedSequenceSizeMin) {
      return nok(code3);
    }
    effects.exit("directiveContainerSequence");
    return factoryName.call(
      self2,
      effects,
      afterName,
      nok,
      "directiveContainerName"
    )(code3);
  }
  function afterName(code3) {
    return code3 === codes.leftSquareBracket ? effects.attempt(label, afterLabel, afterLabel)(code3) : afterLabel(code3);
  }
  function afterLabel(code3) {
    return code3 === codes.leftCurlyBrace ? effects.attempt(attributes, afterAttributes, afterAttributes)(code3) : afterAttributes(code3);
  }
  function afterAttributes(code3) {
    return factorySpace(effects, openAfter, types.whitespace)(code3);
  }
  function openAfter(code3) {
    effects.exit("directiveContainerFence");
    if (code3 === codes.eof) {
      return after(code3);
    }
    if (markdownLineEnding(code3)) {
      if (self2.interrupt) {
        return ok3(code3);
      }
      return effects.attempt(nonLazyLine, contentStart, after)(code3);
    }
    return nok(code3);
  }
  function contentStart(code3) {
    if (code3 === codes.eof) {
      return after(code3);
    }
    if (markdownLineEnding(code3)) {
      return effects.check(
        nonLazyLine,
        emptyContentNonLazyLineAfter,
        after
      )(code3);
    }
    effects.enter("directiveContainerContent");
    return lineStart(code3);
  }
  function lineStart(code3) {
    return effects.attempt(
      { tokenize: tokenizeClosingFence, partial: true },
      afterContent,
      initialSize ? factorySpace(effects, chunkStart, types.linePrefix, initialSize + 1) : chunkStart
    )(code3);
  }
  function chunkStart(code3) {
    if (code3 === codes.eof) {
      return afterContent(code3);
    }
    if (markdownLineEnding(code3)) {
      return effects.check(nonLazyLine, chunkNonLazyStart, afterContent)(code3);
    }
    return chunkNonLazyStart(code3);
  }
  function contentContinue(code3) {
    if (code3 === codes.eof) {
      const t3 = effects.exit(types.chunkDocument);
      self2.parser.lazy[t3.start.line] = false;
      return afterContent(code3);
    }
    if (markdownLineEnding(code3)) {
      return effects.check(nonLazyLine, nonLazyLineAfter, lineAfter)(code3);
    }
    effects.consume(code3);
    return contentContinue;
  }
  function chunkNonLazyStart(code3) {
    const token = effects.enter(types.chunkDocument, {
      contentType: constants.contentTypeDocument,
      previous: previous3
    });
    if (previous3) previous3.next = token;
    previous3 = token;
    return contentContinue(code3);
  }
  function emptyContentNonLazyLineAfter(code3) {
    effects.enter("directiveContainerContent");
    return lineStart(code3);
  }
  function nonLazyLineAfter(code3) {
    effects.consume(code3);
    const t3 = effects.exit(types.chunkDocument);
    self2.parser.lazy[t3.start.line] = false;
    return lineStart;
  }
  function lineAfter(code3) {
    const t3 = effects.exit(types.chunkDocument);
    self2.parser.lazy[t3.start.line] = false;
    return afterContent(code3);
  }
  function afterContent(code3) {
    effects.exit("directiveContainerContent");
    return after(code3);
  }
  function after(code3) {
    effects.exit("directiveContainer");
    return ok3(code3);
  }
  function tokenizeClosingFence(effects2, ok4, nok2) {
    let size4 = 0;
    ok(self2.parser.constructs.disable.null, "expected `disable.null`");
    return factorySpace(
      effects2,
      closingPrefixAfter,
      types.linePrefix,
      self2.parser.constructs.disable.null.includes("codeIndented") ? void 0 : constants.tabSize
    );
    function closingPrefixAfter(code3) {
      effects2.enter("directiveContainerFence");
      effects2.enter("directiveContainerSequence");
      return closingSequence(code3);
    }
    function closingSequence(code3) {
      if (code3 === codes.colon) {
        effects2.consume(code3);
        size4++;
        return closingSequence;
      }
      if (size4 < sizeOpen) return nok2(code3);
      effects2.exit("directiveContainerSequence");
      return factorySpace(effects2, closingSequenceEnd, types.whitespace)(code3);
    }
    function closingSequenceEnd(code3) {
      if (code3 === codes.eof || markdownLineEnding(code3)) {
        effects2.exit("directiveContainerFence");
        return ok4(code3);
      }
      return nok2(code3);
    }
  }
}
function tokenizeLabel(effects, ok3, nok) {
  return factoryLabel2(
    effects,
    ok3,
    nok,
    "directiveContainerLabel",
    "directiveContainerLabelMarker",
    "directiveContainerLabelString",
    true
  );
}
function tokenizeAttributes(effects, ok3, nok) {
  return factoryAttributes(
    effects,
    ok3,
    nok,
    "directiveContainerAttributes",
    "directiveContainerAttributesMarker",
    "directiveContainerAttribute",
    "directiveContainerAttributeId",
    "directiveContainerAttributeClass",
    "directiveContainerAttributeName",
    "directiveContainerAttributeInitializerMarker",
    "directiveContainerAttributeValueLiteral",
    "directiveContainerAttributeValue",
    "directiveContainerAttributeValueMarker",
    "directiveContainerAttributeValueData",
    true
  );
}
function tokenizeNonLazyLine(effects, ok3, nok) {
  const self2 = this;
  return start2;
  function start2(code3) {
    ok(markdownLineEnding(code3), "expected eol");
    effects.enter(types.lineEnding);
    effects.consume(code3);
    effects.exit(types.lineEnding);
    return lineStart;
  }
  function lineStart(code3) {
    return self2.parser.lazy[self2.now().line] ? nok(code3) : ok3(code3);
  }
}

// node_modules/micromark-extension-directive/dev/lib/directive-leaf.js
var directiveLeaf = { tokenize: tokenizeDirectiveLeaf };
var label2 = { tokenize: tokenizeLabel2, partial: true };
var attributes2 = { tokenize: tokenizeAttributes2, partial: true };
function tokenizeDirectiveLeaf(effects, ok3, nok) {
  const self2 = this;
  return start2;
  function start2(code3) {
    ok(code3 === codes.colon, "expected `:`");
    effects.enter("directiveLeaf");
    effects.enter("directiveLeafSequence");
    effects.consume(code3);
    return inStart;
  }
  function inStart(code3) {
    if (code3 === codes.colon) {
      effects.consume(code3);
      effects.exit("directiveLeafSequence");
      return factoryName.call(
        self2,
        effects,
        afterName,
        nok,
        "directiveLeafName"
      );
    }
    return nok(code3);
  }
  function afterName(code3) {
    return code3 === codes.leftSquareBracket ? effects.attempt(label2, afterLabel, afterLabel)(code3) : afterLabel(code3);
  }
  function afterLabel(code3) {
    return code3 === codes.leftCurlyBrace ? effects.attempt(attributes2, afterAttributes, afterAttributes)(code3) : afterAttributes(code3);
  }
  function afterAttributes(code3) {
    return factorySpace(effects, end, types.whitespace)(code3);
  }
  function end(code3) {
    if (code3 === codes.eof || markdownLineEnding(code3)) {
      effects.exit("directiveLeaf");
      return ok3(code3);
    }
    return nok(code3);
  }
}
function tokenizeLabel2(effects, ok3, nok) {
  return factoryLabel2(
    effects,
    ok3,
    nok,
    "directiveLeafLabel",
    "directiveLeafLabelMarker",
    "directiveLeafLabelString",
    true
  );
}
function tokenizeAttributes2(effects, ok3, nok) {
  return factoryAttributes(
    effects,
    ok3,
    nok,
    "directiveLeafAttributes",
    "directiveLeafAttributesMarker",
    "directiveLeafAttribute",
    "directiveLeafAttributeId",
    "directiveLeafAttributeClass",
    "directiveLeafAttributeName",
    "directiveLeafAttributeInitializerMarker",
    "directiveLeafAttributeValueLiteral",
    "directiveLeafAttributeValue",
    "directiveLeafAttributeValueMarker",
    "directiveLeafAttributeValueData",
    true
  );
}

// node_modules/micromark-extension-directive/dev/lib/directive-text.js
var directiveText = {
  tokenize: tokenizeDirectiveText,
  previous: previous2
};
var label3 = { tokenize: tokenizeLabel3, partial: true };
var attributes3 = { tokenize: tokenizeAttributes3, partial: true };
function previous2(code3) {
  return code3 !== codes.colon || this.events[this.events.length - 1][1].type === types.characterEscape;
}
function tokenizeDirectiveText(effects, ok3, nok) {
  const self2 = this;
  return start2;
  function start2(code3) {
    ok(code3 === codes.colon, "expected `:`");
    ok(previous2.call(self2, self2.previous), "expected correct previous");
    effects.enter("directiveText");
    effects.enter("directiveTextMarker");
    effects.consume(code3);
    effects.exit("directiveTextMarker");
    return factoryName.call(self2, effects, afterName, nok, "directiveTextName");
  }
  function afterName(code3) {
    return code3 === codes.colon ? nok(code3) : code3 === codes.leftSquareBracket ? effects.attempt(label3, afterLabel, afterLabel)(code3) : afterLabel(code3);
  }
  function afterLabel(code3) {
    return code3 === codes.leftCurlyBrace ? effects.attempt(attributes3, afterAttributes, afterAttributes)(code3) : afterAttributes(code3);
  }
  function afterAttributes(code3) {
    effects.exit("directiveText");
    return ok3(code3);
  }
}
function tokenizeLabel3(effects, ok3, nok) {
  return factoryLabel2(
    effects,
    ok3,
    nok,
    "directiveTextLabel",
    "directiveTextLabelMarker",
    "directiveTextLabelString"
  );
}
function tokenizeAttributes3(effects, ok3, nok) {
  return factoryAttributes(
    effects,
    ok3,
    nok,
    "directiveTextAttributes",
    "directiveTextAttributesMarker",
    "directiveTextAttribute",
    "directiveTextAttributeId",
    "directiveTextAttributeClass",
    "directiveTextAttributeName",
    "directiveTextAttributeInitializerMarker",
    "directiveTextAttributeValueLiteral",
    "directiveTextAttributeValue",
    "directiveTextAttributeValueMarker",
    "directiveTextAttributeValueData"
  );
}

// node_modules/micromark-extension-directive/dev/lib/syntax.js
function directive() {
  return {
    text: { [codes.colon]: directiveText },
    flow: { [codes.colon]: [directiveContainer, directiveLeaf] }
  };
}

// node_modules/micromark-extension-directive/dev/lib/html.js
var own8 = {}.hasOwnProperty;

// node_modules/@mdxeditor/editor/dist/plugins/directives/DirectiveNode.js
var import_react54 = __toESM(require_react(), 1);
var __defProp8 = Object.defineProperty;
var __defNormalProp8 = (obj, key2, value2) => key2 in obj ? __defProp8(obj, key2, { enumerable: true, configurable: true, writable: true, value: value2 }) : obj[key2] = value2;
var __publicField9 = (obj, key2, value2) => {
  __defNormalProp8(obj, typeof key2 !== "symbol" ? key2 + "" : key2, value2);
  return value2;
};
var DirectiveNode = class _DirectiveNode extends DecoratorNode {
  /**
   * Constructs a new {@link DirectiveNode} with the specified MDAST directive node as the object to edit.
   */
  constructor(mdastNode, key2) {
    super(key2);
    __publicField9(this, "__mdastNode");
    __publicField9(this, "__focusEmitter", voidEmitter());
    __publicField9(this, "select", () => {
      this.__focusEmitter.publish();
    });
    this.__mdastNode = mdastNode;
  }
  /** @internal */
  static getType() {
    return "directive";
  }
  /** @internal */
  static clone(node2) {
    return new _DirectiveNode(structuredClone(node2.__mdastNode), node2.__key);
  }
  /** @internal */
  static importJSON(serializedNode) {
    return $createDirectiveNode(serializedNode.mdastNode);
  }
  /**
   * Returns the MDAST node that is being edited.
   */
  getMdastNode() {
    return this.__mdastNode;
  }
  /** @internal */
  exportJSON() {
    return {
      mdastNode: structuredClone(this.__mdastNode),
      type: "directive",
      version: 1
    };
  }
  /** @internal */
  createDOM() {
    return document.createElement(this.__mdastNode.type === "textDirective" ? "span" : "div");
  }
  /** @internal */
  updateDOM() {
    return false;
  }
  /**
   * Sets a new MDAST node to edit.
   */
  setMdastNode(mdastNode) {
    this.getWritable().__mdastNode = mdastNode;
  }
  /** @internal */
  decorate(parentEditor, config) {
    return import_react54.default.createElement(
      DirectiveEditorContainer,
      {
        lexicalNode: this,
        mdastNode: this.getMdastNode(),
        parentEditor,
        config,
        focusEmitter: this.__focusEmitter
      }
    );
  }
  /** @internal */
  isInline() {
    return this.__mdastNode.type === "textDirective";
  }
  /** @internal */
  isKeyboardSelectable() {
    return true;
  }
};
var DirectiveEditorContainer = (props) => {
  const { mdastNode } = props;
  const [directiveDescriptors] = X(directiveDescriptors$);
  const descriptor = directiveDescriptors.find((descriptor2) => descriptor2.testNode(mdastNode));
  if (!descriptor) {
    throw new Error(`No descriptor found for directive ${mdastNode.name}`);
  }
  const Editor = descriptor.Editor;
  return import_react54.default.createElement(NestedEditorsContext.Provider, { value: props }, import_react54.default.createElement(Editor, { descriptor, mdastNode, lexicalNode: props.lexicalNode, parentEditor: props.parentEditor }));
};
function $createDirectiveNode(mdastNode, key2) {
  return new DirectiveNode(mdastNode, key2);
}
function $isDirectiveNode(node2) {
  return node2 instanceof DirectiveNode;
}

// node_modules/@mdxeditor/editor/dist/plugins/directives/DirectiveVisitor.js
var DirectiveVisitor = {
  testLexicalNode: $isDirectiveNode,
  visitLexicalNode({ actions, mdastParent, lexicalNode }) {
    actions.appendToParent(mdastParent, lexicalNode.getMdastNode());
  }
};

// node_modules/@mdxeditor/editor/dist/plugins/directives/MdastDirectiveVisitor.js
var DIRECTIVE_TYPES = ["leafDirective", "containerDirective", "textDirective"];
function isMdastDirectivesNode(node2) {
  return DIRECTIVE_TYPES.includes(node2.type);
}
var MdastDirectiveVisitor = {
  testNode: (node2, { directiveDescriptors }) => {
    if (isMdastDirectivesNode(node2)) {
      const descriptor = directiveDescriptors.find((descriptor2) => descriptor2.testNode(node2));
      return descriptor !== void 0;
    }
    return false;
  },
  visitNode({ lexicalParent, mdastNode }) {
    lexicalParent.append($createDirectiveNode(mdastNode));
  }
};

// node_modules/@mdxeditor/editor/dist/plugins/directives/index.js
var insertDirective$ = K((r2) => {
  r2.link(
    r2.pipe(
      insertDirective$,
      _((payload) => {
        return () => $createDirectiveNode({ children: [], ...payload });
      })
    ),
    insertDecoratorNode$
  );
});
var directivesPlugin = realmPlugin({
  update: (realm, params) => {
    realm.pub(directiveDescriptors$, (params == null ? void 0 : params.directiveDescriptors) ?? []);
  },
  init: (realm, params) => {
    realm.pubIn({
      [directiveDescriptors$]: (params == null ? void 0 : params.directiveDescriptors) ?? [],
      // import
      [addMdastExtension$]: directiveFromMarkdown(),
      [addSyntaxExtension$]: directive(),
      [addImportVisitor$]: MdastDirectiveVisitor,
      // export
      [addLexicalNode$]: DirectiveNode,
      [addExportVisitor$]: DirectiveVisitor,
      [addToMarkdownExtension$]: directiveToMarkdown()
    });
  }
});

// node_modules/@mdxeditor/editor/dist/directive-editors/AdmonitionDirectiveDescriptor.js
var import_react55 = __toESM(require_react(), 1);
var ADMONITION_TYPES = ["note", "tip", "danger", "info", "caution"];
var AdmonitionDirectiveDescriptor = {
  name: "admonition",
  attributes: [],
  hasChildren: true,
  testNode(node2) {
    return ADMONITION_TYPES.includes(node2.name);
  },
  Editor({ mdastNode }) {
    const {
      config: { theme }
    } = useNestedEditorContext();
    return import_react55.default.createElement("div", { className: theme.admonition[mdastNode.name] }, import_react55.default.createElement(
      NestedLexicalEditor,
      {
        block: true,
        getContent: (node2) => node2.children,
        getUpdatedMdastNode: (mdastNode2, children) => ({ ...mdastNode2, children })
      }
    ));
  }
};

// node_modules/@mdxeditor/editor/dist/directive-editors/GenericDirectiveEditor.js
var import_react56 = __toESM(require_react(), 1);
var GenericDirectiveEditor = ({ mdastNode, descriptor }) => {
  const updateMdastNode = useMdastNodeUpdater();
  const properties = import_react56.default.useMemo(() => {
    return descriptor.attributes.reduce((acc, attributeName) => {
      var _a2;
      acc[attributeName] = ((_a2 = mdastNode.attributes) == null ? void 0 : _a2[attributeName]) ?? "";
      return acc;
    }, {});
  }, [mdastNode, descriptor]);
  const onChange = import_react56.default.useCallback(
    (values2) => {
      updateMdastNode({ attributes: Object.fromEntries(Object.entries(values2).filter(([, value2]) => value2 !== "")) });
    },
    [updateMdastNode]
  );
  return import_react56.default.createElement("div", { className: mdastNode.type === "textDirective" ? styles.inlineEditor : styles.blockEditor }, descriptor.attributes.length == 0 && descriptor.hasChildren && mdastNode.type !== "textDirective" ? import_react56.default.createElement("span", { className: styles.genericComponentName }, mdastNode.name) : null, descriptor.attributes.length > 0 ? import_react56.default.createElement(PropertyPopover, { properties, title: mdastNode.name || "", onChange }) : null, descriptor.hasChildren ? import_react56.default.createElement(
    NestedLexicalEditor,
    {
      block: mdastNode.type === "containerDirective",
      getContent: (node2) => node2.children,
      getUpdatedMdastNode: (mdastNode2, children) => {
        return { ...mdastNode2, children };
      }
    }
  ) : import_react56.default.createElement("span", { className: styles.genericComponentName }, mdastNode.name));
};

// node_modules/@mdxeditor/editor/dist/utils/lexicalHelpers.js
function fromWithinEditorRead(editor, fn) {
  let result = null;
  editor.getEditorState().read(() => {
    result = fn();
  });
  return result;
}
function getSelectedNode(selection2) {
  try {
    const anchor = selection2.anchor;
    const focus2 = selection2.focus;
    const anchorNode = selection2.anchor.getNode();
    const focusNode = selection2.focus.getNode();
    if (anchorNode === focusNode) {
      return anchorNode;
    }
    const isBackward = selection2.isBackward();
    if (isBackward) {
      return $isAtNodeEnd(focus2) ? anchorNode : focusNode;
    } else {
      return $isAtNodeEnd(anchor) ? anchorNode : focusNode;
    }
  } catch (e2) {
    return null;
  }
}
function getSelectionRectangle(editor) {
  const selection2 = $getSelection();
  const nativeSelection = window.getSelection();
  const activeElement = document.activeElement;
  const rootElement = editor.getRootElement();
  if (selection2 !== null && nativeSelection !== null && rootElement !== null && rootElement.contains(nativeSelection.anchorNode) && editor.isEditable()) {
    const domRange = nativeSelection.getRangeAt(0);
    let rect;
    if (nativeSelection.isCollapsed) {
      let node2 = nativeSelection.anchorNode;
      if ((node2 == null ? void 0 : node2.nodeType) == 3) {
        node2 = node2.parentNode;
      }
      rect = node2.getBoundingClientRect();
      rect.width = 0;
    } else {
      if (nativeSelection.anchorNode === rootElement) {
        let inner = rootElement;
        while (inner.firstElementChild != null) {
          inner = inner.firstElementChild;
        }
        rect = inner.getBoundingClientRect();
      } else {
        rect = domRange.getBoundingClientRect();
      }
    }
    return {
      top: Math.round(rect.top),
      left: Math.round(rect.left),
      width: Math.round(rect.width),
      height: Math.round(rect.height)
    };
  } else if (!activeElement || activeElement.className !== "link-input") {
    return null;
  }
  return null;
}
function getStateAsMarkdown(editor, exportParams) {
  return tap({ markdown: "" }, (result) => {
    editor.getEditorState().read(() => {
      result.markdown = exportMarkdownFromLexical({ root: $getRoot(), ...exportParams });
    });
  }).markdown;
}

// node_modules/@mdxeditor/editor/dist/plugins/link-dialog/LinkDialog.js
var import_react57 = __toESM(require_react(), 1);
var import_classnames10 = __toESM(require_classnames(), 1);
createCommand();
function LinkEditForm({ url, title, onSubmit, onCancel, linkAutocompleteSuggestions }) {
  const {
    register,
    handleSubmit,
    control,
    setValue,
    reset: _2
  } = useForm({
    values: {
      url,
      title
    }
  });
  const t3 = useTranslation();
  return import_react57.default.createElement(
    "form",
    {
      onSubmit: (e2) => {
        void handleSubmit(onSubmit)(e2);
        e2.stopPropagation();
        e2.preventDefault();
      },
      onReset: (e2) => {
        e2.stopPropagation();
        onCancel();
      },
      className: (0, import_classnames10.default)(styles.multiFieldForm, styles.linkDialogEditForm)
    },
    import_react57.default.createElement("div", { className: styles.formField }, import_react57.default.createElement("label", { htmlFor: "link-url" }, t3("createLink.url", "URL")), import_react57.default.createElement(
      DownshiftAutoComplete,
      {
        register,
        initialInputValue: url,
        inputName: "url",
        suggestions: linkAutocompleteSuggestions,
        setValue,
        control,
        placeholder: t3("createLink.urlPlaceholder", "Select or paste an URL"),
        autofocus: true
      }
    )),
    import_react57.default.createElement("div", { className: styles.formField }, import_react57.default.createElement("label", { htmlFor: "link-title" }, t3("createLink.title", "Title")), import_react57.default.createElement("input", { id: "link-title", className: styles.textInput, size: 40, ...register("title") })),
    import_react57.default.createElement("div", { style: { display: "flex", justifyContent: "flex-end", gap: "var(--spacing-2)" } }, import_react57.default.createElement(
      "button",
      {
        type: "submit",
        title: t3("createLink.saveTooltip", "Set URL"),
        "aria-label": t3("createLink.saveTooltip", "Set URL"),
        className: (0, import_classnames10.default)(styles.primaryButton)
      },
      t3("dialogControls.save", "Save")
    ), import_react57.default.createElement(
      "button",
      {
        type: "reset",
        title: t3("createLink.cancelTooltip", "Cancel change"),
        "aria-label": t3("createLink.cancelTooltip", "Cancel change"),
        className: (0, import_classnames10.default)(styles.secondaryButton)
      },
      t3("dialogControls.cancel", "Cancel")
    ))
  );
}
var LinkDialog = () => {
  const [editorRootElementRef, activeEditor2, iconComponentFor, linkDialogState, linkAutocompleteSuggestions, onClickLinkCallback] = X(
    editorRootElementRef$,
    activeEditor$,
    iconComponentFor$,
    linkDialogState$,
    linkAutocompleteSuggestions$,
    onClickLinkCallback$
  );
  const publishWindowChange = A(onWindowChange$);
  const updateLink = A(updateLink$);
  const cancelLinkEdit = A(cancelLinkEdit$);
  const switchFromPreviewToLinkEdit = A(switchFromPreviewToLinkEdit$);
  const removeLink = A(removeLink$);
  import_react57.default.useEffect(() => {
    const update = () => {
      activeEditor2 == null ? void 0 : activeEditor2.getEditorState().read(() => {
        publishWindowChange(true);
      });
    };
    window.addEventListener("resize", update);
    window.addEventListener("scroll", update);
    return () => {
      window.removeEventListener("resize", update);
      window.removeEventListener("scroll", update);
    };
  }, [activeEditor2, publishWindowChange]);
  const [copyUrlTooltipOpen, setCopyUrlTooltipOpen] = import_react57.default.useState(false);
  const t3 = useTranslation();
  const theRect = linkDialogState.rectangle;
  const urlIsExternal = linkDialogState.type === "preview" && linkDialogState.url.startsWith("http");
  return import_react57.default.createElement(Root22, { open: linkDialogState.type !== "inactive" }, import_react57.default.createElement(
    Anchor2,
    {
      "data-visible": linkDialogState.type === "edit",
      className: styles.linkDialogAnchor,
      style: {
        top: `${(theRect == null ? void 0 : theRect.top) ?? 0}px`,
        left: `${(theRect == null ? void 0 : theRect.left) ?? 0}px`,
        width: `${(theRect == null ? void 0 : theRect.width) ?? 0}px`,
        height: `${(theRect == null ? void 0 : theRect.height) ?? 0}px`
      }
    }
  ), import_react57.default.createElement(Portal2, { container: editorRootElementRef == null ? void 0 : editorRootElementRef.current }, import_react57.default.createElement(
    Content2,
    {
      className: (0, import_classnames10.default)(styles.linkDialogPopoverContent),
      sideOffset: 5,
      onOpenAutoFocus: (e2) => {
        e2.preventDefault();
      },
      key: linkDialogState.linkNodeKey
    },
    linkDialogState.type === "edit" && import_react57.default.createElement(
      LinkEditForm,
      {
        url: linkDialogState.url,
        title: linkDialogState.title,
        onSubmit: updateLink,
        onCancel: cancelLinkEdit.bind(null),
        linkAutocompleteSuggestions
      }
    ),
    linkDialogState.type === "preview" && import_react57.default.createElement(import_react57.default.Fragment, null, import_react57.default.createElement(
      "a",
      {
        className: styles.linkDialogPreviewAnchor,
        href: linkDialogState.url,
        ...urlIsExternal ? { target: "_blank", rel: "noreferrer" } : {},
        onClick: (e2) => {
          if (onClickLinkCallback !== null) {
            e2.preventDefault();
            onClickLinkCallback(linkDialogState.url);
          }
        },
        title: urlIsExternal ? t3("linkPreview.open", `Open {{url}} in new window`, { url: linkDialogState.url }) : linkDialogState.url
      },
      import_react57.default.createElement("span", null, linkDialogState.url),
      urlIsExternal && iconComponentFor("open_in_new")
    ), import_react57.default.createElement(
      ActionButton,
      {
        onClick: () => {
          switchFromPreviewToLinkEdit();
        },
        title: t3("linkPreview.edit", "Edit link URL"),
        "aria-label": t3("linkPreview.edit", "Edit link URL")
      },
      iconComponentFor("edit")
    ), import_react57.default.createElement(Provider, null, import_react57.default.createElement(Root32, { open: copyUrlTooltipOpen }, import_react57.default.createElement(Trigger4, { asChild: true }, import_react57.default.createElement(
      ActionButton,
      {
        title: t3("linkPreview.copyToClipboard", "Copy to clipboard"),
        "aria-label": t3("linkPreview.copyToClipboard", "Copy to clipboard"),
        onClick: () => {
          void window.navigator.clipboard.writeText(linkDialogState.url).then(() => {
            setCopyUrlTooltipOpen(true);
            setTimeout(() => {
              setCopyUrlTooltipOpen(false);
            }, 1e3);
          });
        }
      },
      copyUrlTooltipOpen ? iconComponentFor("check") : iconComponentFor("content_copy")
    )), import_react57.default.createElement(Portal5, { container: editorRootElementRef == null ? void 0 : editorRootElementRef.current }, import_react57.default.createElement(Content23, { className: (0, import_classnames10.default)(styles.tooltipContent), sideOffset: 5 }, t3("linkPreview.copied", "Copied!"), import_react57.default.createElement(Arrow23, null))))), import_react57.default.createElement(
      ActionButton,
      {
        title: t3("linkPreview.remove", "Remove link"),
        "aria-label": t3("linkPreview.remove", "Remove link"),
        onClick: () => {
          removeLink();
        }
      },
      iconComponentFor("link_off")
    )),
    import_react57.default.createElement(Arrow22, { className: styles.popoverArrow })
  )));
};
var ActionButton = import_react57.default.forwardRef(({ className, ...props }, ref2) => {
  return import_react57.default.createElement("button", { className: (0, import_classnames10.default)(styles.actionButton, className), ref: ref2, ...props });
});

// node_modules/@mdxeditor/editor/dist/plugins/link-dialog/index.js
function getLinkNodeInSelection(selection2) {
  if (!selection2) {
    return null;
  }
  const node2 = getSelectedNode(selection2);
  if (node2 === null) {
    return null;
  }
  const parent = node2.getParent();
  if ($isLinkNode(parent)) {
    return parent;
  } else if ($isLinkNode(node2)) {
    return node2;
  }
  return null;
}
var onWindowChange$ = K();
var linkDialogState$ = $({ type: "inactive" }, (r2) => {
  r2.pub(createActiveEditorSubscription$, (editor) => {
    return editor.registerCommand(
      KEY_ESCAPE_COMMAND,
      () => {
        const state = r2.getValue(linkDialogState$);
        if (state.type === "preview") {
          r2.pub(linkDialogState$, { type: "inactive" });
          return true;
        }
        return false;
      },
      COMMAND_PRIORITY_LOW
    );
  });
  r2.pub(createActiveEditorSubscription$, (editor) => {
    return editor.registerCommand(
      KEY_MODIFIER_COMMAND,
      (event) => {
        if (event.key === "k" && (IS_APPLE2 ? event.metaKey : event.ctrlKey) && !r2.getValue(readOnly$)) {
          const selection2 = $getSelection();
          if ($isRangeSelection(selection2)) {
            r2.pub(openLinkEditDialog$);
            event.stopPropagation();
            event.preventDefault();
            return true;
          } else {
            return false;
          }
        }
        return false;
      },
      COMMAND_PRIORITY_HIGH
    );
  });
  r2.link(
    r2.pipe(
      switchFromPreviewToLinkEdit$,
      tt(linkDialogState$),
      _(([, state]) => {
        if (state.type === "preview") {
          return {
            type: "edit",
            initialUrl: state.url,
            url: state.url,
            title: state.title,
            linkNodeKey: state.linkNodeKey,
            rectangle: state.rectangle
          };
        } else {
          throw new Error("Cannot switch to edit mode when not in preview mode");
        }
      })
    ),
    linkDialogState$
  );
  r2.sub(r2.pipe(updateLink$, tt(activeEditor$, linkDialogState$, currentSelection$)), ([payload, editor, state, selection2]) => {
    var _a2, _b2;
    const url = ((_a2 = payload.url) == null ? void 0 : _a2.trim()) ?? "";
    const title = ((_b2 = payload.title) == null ? void 0 : _b2.trim()) ?? "";
    if (url !== "") {
      if (selection2 == null ? void 0 : selection2.isCollapsed()) {
        const linkContent = title || url;
        editor == null ? void 0 : editor.update(
          () => {
            const linkNode = getLinkNodeInSelection(selection2);
            if (!linkNode) {
              const node2 = $createLinkNode(url, { title });
              node2.append($createTextNode(linkContent));
              $insertNodes([node2]);
              node2.select();
            } else {
              linkNode.setURL(url);
              linkNode.setTitle(title);
            }
          },
          { discrete: true }
        );
      } else {
        editor == null ? void 0 : editor.dispatchCommand(TOGGLE_LINK_COMMAND, { url, title });
      }
      r2.pub(linkDialogState$, {
        type: "preview",
        linkNodeKey: state.linkNodeKey,
        rectangle: state.rectangle,
        title,
        url
      });
    } else {
      if (state.type === "edit" && state.initialUrl !== "") {
        editor == null ? void 0 : editor.dispatchCommand(TOGGLE_LINK_COMMAND, null);
      }
      r2.pub(linkDialogState$, {
        type: "inactive"
      });
    }
  });
  r2.link(
    r2.pipe(
      cancelLinkEdit$,
      tt(linkDialogState$, activeEditor$),
      _(([, state, editor]) => {
        if (state.type === "edit") {
          editor == null ? void 0 : editor.focus();
          if (state.initialUrl === "") {
            return {
              type: "inactive"
            };
          } else {
            return {
              type: "preview",
              url: state.initialUrl,
              linkNodeKey: state.linkNodeKey,
              rectangle: state.rectangle
            };
          }
        } else {
          throw new Error("Cannot cancel edit when not in edit mode");
        }
      })
    ),
    linkDialogState$
  );
  r2.link(
    r2.pipe(
      r2.combine(currentSelection$, onWindowChange$),
      tt(activeEditor$, linkDialogState$, readOnly$),
      _(([[selection2], activeEditor2, _2, readOnly]) => {
        if ($isRangeSelection(selection2) && activeEditor2 && !readOnly) {
          const node2 = getLinkNodeInSelection(selection2);
          if (node2) {
            return {
              type: "preview",
              url: node2.getURL(),
              linkNodeKey: node2.getKey(),
              title: node2.getTitle(),
              rectangle: getSelectionRectangle(activeEditor2)
            };
          } else {
            return { type: "inactive" };
          }
        } else {
          return { type: "inactive" };
        }
      })
    ),
    linkDialogState$
  );
});
var updateLink$ = K();
var cancelLinkEdit$ = q();
var applyLinkChanges$ = q();
var switchFromPreviewToLinkEdit$ = q();
var removeLink$ = q((r2) => {
  r2.sub(r2.pipe(removeLink$, tt(activeEditor$)), ([, editor]) => {
    editor == null ? void 0 : editor.dispatchCommand(TOGGLE_LINK_COMMAND, null);
  });
});
var openLinkEditDialog$ = q((r2) => {
  r2.sub(
    r2.pipe(
      openLinkEditDialog$,
      tt(currentSelection$, activeEditor$),
      nt(([, selection2]) => $isRangeSelection(selection2))
    ),
    ([, selection2, editor]) => {
      editor == null ? void 0 : editor.focus(() => {
        setTimeout(() => {
          editor.getEditorState().read(() => {
            const node2 = getLinkNodeInSelection(selection2);
            const rectangle = getSelectionRectangle(editor);
            if (node2) {
              r2.pub(linkDialogState$, {
                type: "edit",
                initialUrl: node2.getURL(),
                initialTitle: node2.getTitle() ?? "",
                url: node2.getURL(),
                title: node2.getTitle() ?? "",
                linkNodeKey: node2.getKey(),
                rectangle
              });
            } else {
              r2.pub(linkDialogState$, {
                type: "edit",
                initialUrl: "",
                initialTitle: "",
                title: "",
                url: "",
                linkNodeKey: "",
                rectangle
              });
            }
          });
        });
      });
    }
  );
});
var linkAutocompleteSuggestions$ = $([]);
var onClickLinkCallback$ = $(null);
var linkDialogPlugin = realmPlugin({
  init(r2, params) {
    r2.pub(addComposerChild$, (params == null ? void 0 : params.LinkDialog) ?? LinkDialog);
    r2.pub(onClickLinkCallback$, (params == null ? void 0 : params.onClickLinkCallback) ?? null);
  },
  update(r2, params = {}) {
    r2.pub(linkAutocompleteSuggestions$, params.linkAutocompleteSuggestions ?? []);
  }
});

// node_modules/@mdxeditor/editor/dist/plugins/toolbar/index.js
var import_react59 = __toESM(require_react(), 1);

// node_modules/@mdxeditor/editor/dist/plugins/toolbar/primitives/toolbar.js
var import_classnames11 = __toESM(require_classnames(), 1);
var import_react58 = __toESM(require_react(), 1);
function decorateWithRef(Component3, decoratedProps) {
  return import_react58.default.forwardRef((props, ref2) => {
    const className = (0, import_classnames11.default)(decoratedProps.className, props.className);
    return import_react58.default.createElement(Component3, { ...decoratedProps, ...props, className, ref: ref2 });
  });
}
function addTooltipToChildren(Component3) {
  return ({ title, children, ...props }) => {
    return import_react58.default.createElement(Component3, { ...props }, import_react58.default.createElement(TooltipWrap, { title }, children));
  };
}
var Root7 = ({ readOnly, children, className }) => {
  return import_react58.default.createElement(
    Root42,
    {
      className: (0, import_classnames11.default)("mdxeditor-toolbar", styles.toolbarRoot, { [styles.readOnlyToolbarRoot]: readOnly }, className),
      ...readOnly ? { tabIndex: -1 } : {}
    },
    children
  );
};
var Button2 = decorateWithRef(Button, { className: styles.toolbarButton, "data-toolbar-item": true });
var ButtonWithTooltip = addTooltipToChildren(Button2);
var ToolbarToggleItem2 = decorateWithRef(ToggleItem, {
  className: styles.toolbarToggleItem,
  "data-toolbar-item": true
});
var SingleToggleGroup = decorateWithRef(ToggleGroup2, {
  type: "single",
  className: styles.toolbarToggleSingleGroup
});
var ToggleSingleGroupWithItem = import_react58.default.forwardRef(({ on, title, children, disabled, ...props }, forwardedRef) => {
  return import_react58.default.createElement(
    ToggleGroup2,
    {
      type: "single",
      className: styles.toolbarToggleSingleGroup,
      ...props,
      value: on ? "on" : "off",
      ref: forwardedRef
    },
    import_react58.default.createElement(ToolbarToggleItem2, { title, value: "on", disabled }, import_react58.default.createElement(TooltipWrap, { title }, children))
  );
});
var MultipleChoiceToggleGroup = ({ items }) => {
  return import_react58.default.createElement("div", { className: styles.toolbarGroupOfGroups }, items.map((item, index3) => import_react58.default.createElement(
    ToggleSingleGroupWithItem,
    {
      key: index3,
      title: item.title,
      on: item.active,
      onValueChange: (v3) => {
        item.onChange(v3 === "on");
      },
      disabled: item.disabled
    },
    item.contents
  )));
};
var SingleChoiceToggleGroup = ({
  value: value2,
  onChange,
  className,
  items
}) => {
  const t3 = useTranslation();
  return import_react58.default.createElement("div", { className: styles.toolbarGroupOfGroups }, import_react58.default.createElement(
    ToggleGroup2,
    {
      "aria-label": t3("toolbar.toggleGroup", "toggle group"),
      type: "single",
      className: (0, import_classnames11.default)(styles.toolbarToggleSingleGroup, className),
      onValueChange: onChange,
      value: value2 || "",
      onFocus: (e2) => {
        e2.preventDefault();
      }
    },
    items.map((item, index3) => import_react58.default.createElement(ToolbarToggleItem2, { key: index3, "aria-label": item.title, value: item.value }, import_react58.default.createElement(TooltipWrap, { title: item.title }, item.contents)))
  ));
};
var ButtonOrDropdownButton = (props) => {
  const readOnly = E(readOnly$);
  return import_react58.default.createElement(import_react58.default.Fragment, null, props.items.length === 1 ? import_react58.default.createElement(
    ButtonWithTooltip,
    {
      title: props.title,
      onClick: () => {
        props.onChoose("");
      },
      disabled: readOnly
    },
    props.children
  ) : import_react58.default.createElement(Root24, { value: "", onValueChange: props.onChoose }, import_react58.default.createElement(SelectButtonTrigger, { title: props.title }, props.children), import_react58.default.createElement(SelectContent2, { className: styles.toolbarButtonDropdownContainer }, props.items.map((item, index3) => import_react58.default.createElement(SelectItem2, { key: index3, value: item.value }, item.label)))));
};
function isConditionalContentsOption(option) {
  return Object.hasOwn(option, "when");
}
var ConditionalContents = ({ options }) => {
  const editorInFocus = E(editorInFocus$);
  const contents = import_react58.default.useMemo(() => {
    const option = options.find((option2) => {
      if (isConditionalContentsOption(option2)) {
        if (option2.when(editorInFocus)) {
          return true;
        }
      } else {
        return true;
      }
    });
    return option ? isConditionalContentsOption(option) ? option.contents() : option.fallback() : null;
  }, [options, editorInFocus]);
  return import_react58.default.createElement("div", { style: { display: "flex" } }, contents);
};
var Separator4 = Separator2;

// node_modules/@mdxeditor/editor/dist/plugins/toolbar/index.js
var toolbarContents$ = $(() => null);
var toolbarClassName$ = $("");
var DEFAULT_TOOLBAR_CONTENTS = () => {
  return "This is an empty toolbar. Pass `{toolbarContents: () => { return <>toolbar components</> }}` to the toolbarPlugin to customize it.";
};
var toolbarPlugin = realmPlugin({
  init(realm, params) {
    realm.pubIn({
      [toolbarContents$]: (params == null ? void 0 : params.toolbarContents) ?? DEFAULT_TOOLBAR_CONTENTS,
      [toolbarClassName$]: (params == null ? void 0 : params.toolbarClassName) ?? "",
      [addTopAreaChild$]: () => {
        const [toolbarContents, readOnly, toolbarClassName] = X(toolbarContents$, readOnly$, toolbarClassName$);
        return import_react59.default.createElement(Root7, { className: toolbarClassName, readOnly }, toolbarContents());
      }
    });
  },
  update(realm, params) {
    realm.pub(toolbarContents$, (params == null ? void 0 : params.toolbarContents) ?? DEFAULT_TOOLBAR_CONTENTS);
    realm.pub(toolbarClassName$, (params == null ? void 0 : params.toolbarClassName) ?? "");
  }
});

// node_modules/@mdxeditor/editor/dist/plugins/diff-source/DiffSourceWrapper.js
var import_react62 = __toESM(require_react(), 1);

// node_modules/@mdxeditor/editor/dist/plugins/diff-source/DiffViewer.js
var import_react61 = __toESM(require_react(), 1);

// node_modules/@codemirror/merge/dist/index.js
var Change = class _Change {
  constructor(fromA, toA, fromB, toB) {
    this.fromA = fromA;
    this.toA = toA;
    this.fromB = fromB;
    this.toB = toB;
  }
  /**
  @internal
  */
  offset(offA, offB = offA) {
    return new _Change(this.fromA + offA, this.toA + offA, this.fromB + offB, this.toB + offB);
  }
};
function findDiff(a2, fromA, toA, b3, fromB, toB) {
  if (a2 == b3)
    return [];
  let prefix = commonPrefix(a2, fromA, toA, b3, fromB, toB);
  let suffix = commonSuffix(a2, fromA + prefix, toA, b3, fromB + prefix, toB);
  fromA += prefix;
  toA -= suffix;
  fromB += prefix;
  toB -= suffix;
  let lenA = toA - fromA, lenB = toB - fromB;
  if (!lenA || !lenB)
    return [new Change(fromA, toA, fromB, toB)];
  if (lenA > lenB) {
    let found = a2.slice(fromA, toA).indexOf(b3.slice(fromB, toB));
    if (found > -1)
      return [
        new Change(fromA, fromA + found, fromB, fromB),
        new Change(fromA + found + lenB, toA, toB, toB)
      ];
  } else if (lenB > lenA) {
    let found = b3.slice(fromB, toB).indexOf(a2.slice(fromA, toA));
    if (found > -1)
      return [
        new Change(fromA, fromA, fromB, fromB + found),
        new Change(toA, toA, fromB + found + lenA, toB)
      ];
  }
  if (lenA == 1 || lenB == 1)
    return [new Change(fromA, toA, fromB, toB)];
  let half = halfMatch(a2, fromA, toA, b3, fromB, toB);
  if (half) {
    let [sharedA, sharedB, sharedLen] = half;
    return findDiff(a2, fromA, sharedA, b3, fromB, sharedB).concat(findDiff(a2, sharedA + sharedLen, toA, b3, sharedB + sharedLen, toB));
  }
  return findSnake(a2, fromA, toA, b3, fromB, toB);
}
var scanLimit = 1e9;
function findSnake(a2, fromA, toA, b3, fromB, toB) {
  let lenA = toA - fromA, lenB = toB - fromB;
  if (scanLimit < 1e9 && Math.min(lenA, lenB) > scanLimit * 16) {
    if (Math.min(lenA, lenB) > scanLimit * 64)
      return [new Change(fromA, toA, fromB, toB)];
    return crudeMatch(a2, fromA, toA, b3, fromB, toB);
  }
  let off = Math.ceil((lenA + lenB) / 2);
  frontier1.reset(off);
  frontier2.reset(off);
  let match1 = (x3, y2) => a2.charCodeAt(fromA + x3) == b3.charCodeAt(fromB + y2);
  let match2 = (x3, y2) => a2.charCodeAt(toA - x3 - 1) == b3.charCodeAt(toB - y2 - 1);
  let test1 = (lenA - lenB) % 2 != 0 ? frontier2 : null, test2 = test1 ? null : frontier1;
  for (let depth2 = 0; depth2 < off; depth2++) {
    if (depth2 > scanLimit)
      return crudeMatch(a2, fromA, toA, b3, fromB, toB);
    let done = frontier1.advance(depth2, lenA, lenB, off, test1, false, match1) || frontier2.advance(depth2, lenA, lenB, off, test2, true, match2);
    if (done)
      return bisect(a2, fromA, toA, fromA + done[0], b3, fromB, toB, fromB + done[1]);
  }
  return [new Change(fromA, toA, fromB, toB)];
}
var Frontier = class {
  constructor() {
    this.vec = [];
  }
  reset(off) {
    this.len = off << 1;
    for (let i3 = 0; i3 < this.len; i3++)
      this.vec[i3] = -1;
    this.vec[off + 1] = 0;
    this.start = this.end = 0;
  }
  advance(depth2, lenX, lenY, vOff, other, fromBack, match) {
    for (let k3 = -depth2 + this.start; k3 <= depth2 - this.end; k3 += 2) {
      let off = vOff + k3;
      let x3 = k3 == -depth2 || k3 != depth2 && this.vec[off - 1] < this.vec[off + 1] ? this.vec[off + 1] : this.vec[off - 1] + 1;
      let y2 = x3 - k3;
      while (x3 < lenX && y2 < lenY && match(x3, y2)) {
        x3++;
        y2++;
      }
      this.vec[off] = x3;
      if (x3 > lenX) {
        this.end += 2;
      } else if (y2 > lenY) {
        this.start += 2;
      } else if (other) {
        let offOther = vOff + (lenX - lenY) - k3;
        if (offOther >= 0 && offOther < this.len && other.vec[offOther] != -1) {
          if (!fromBack) {
            let xOther = lenX - other.vec[offOther];
            if (x3 >= xOther)
              return [x3, y2];
          } else {
            let xOther = other.vec[offOther];
            if (xOther >= lenX - x3)
              return [xOther, vOff + xOther - offOther];
          }
        }
      }
    }
    return null;
  }
};
var frontier1 = new Frontier();
var frontier2 = new Frontier();
function bisect(a2, fromA, toA, splitA, b3, fromB, toB, splitB) {
  let stop = false;
  if (!validIndex(a2, splitA) && ++splitA == toA)
    stop = true;
  if (!validIndex(b3, splitB) && ++splitB == toB)
    stop = true;
  if (stop)
    return [new Change(fromA, toA, fromB, toB)];
  return findDiff(a2, fromA, splitA, b3, fromB, splitB).concat(findDiff(a2, splitA, toA, b3, splitB, toB));
}
function chunkSize(lenA, lenB) {
  let size4 = 1, max2 = Math.min(lenA, lenB);
  while (size4 < max2)
    size4 = size4 << 1;
  return size4;
}
function commonPrefix(a2, fromA, toA, b3, fromB, toB) {
  if (fromA == toA || fromA == toB || a2.charCodeAt(fromA) != b3.charCodeAt(fromB))
    return 0;
  let chunk = chunkSize(toA - fromA, toB - fromB);
  for (let pA = fromA, pB = fromB; ; ) {
    let endA = pA + chunk, endB = pB + chunk;
    if (endA > toA || endB > toB || a2.slice(pA, endA) != b3.slice(pB, endB)) {
      if (chunk == 1)
        return pA - fromA - (validIndex(a2, pA) ? 0 : 1);
      chunk = chunk >> 1;
    } else if (endA == toA || endB == toB) {
      return endA - fromA;
    } else {
      pA = endA;
      pB = endB;
    }
  }
}
function commonSuffix(a2, fromA, toA, b3, fromB, toB) {
  if (fromA == toA || fromB == toB || a2.charCodeAt(toA - 1) != b3.charCodeAt(toB - 1))
    return 0;
  let chunk = chunkSize(toA - fromA, toB - fromB);
  for (let pA = toA, pB = toB; ; ) {
    let sA = pA - chunk, sB = pB - chunk;
    if (sA < fromA || sB < fromB || a2.slice(sA, pA) != b3.slice(sB, pB)) {
      if (chunk == 1)
        return toA - pA - (validIndex(a2, pA) ? 0 : 1);
      chunk = chunk >> 1;
    } else if (sA == fromA || sB == fromB) {
      return toA - sA;
    } else {
      pA = sA;
      pB = sB;
    }
  }
}
function findMatch(a2, fromA, toA, b3, fromB, toB, size4, divideTo) {
  let rangeB = b3.slice(fromB, toB);
  let best = null;
  for (; ; ) {
    if (best || size4 < divideTo)
      return best;
    for (let start2 = fromA + size4; ; ) {
      if (!validIndex(a2, start2))
        start2++;
      let end = start2 + size4;
      if (!validIndex(a2, end))
        end += end == start2 + 1 ? 1 : -1;
      if (end >= toA)
        break;
      let seed = a2.slice(start2, end);
      let found = -1;
      while ((found = rangeB.indexOf(seed, found + 1)) != -1) {
        let prefixAfter = commonPrefix(a2, end, toA, b3, fromB + found + seed.length, toB);
        let suffixBefore = commonSuffix(a2, fromA, start2, b3, fromB, fromB + found);
        let length = seed.length + prefixAfter + suffixBefore;
        if (!best || best[2] < length)
          best = [start2 - suffixBefore, fromB + found - suffixBefore, length];
      }
      start2 = end;
    }
    if (divideTo < 0)
      return best;
    size4 = size4 >> 1;
  }
}
function halfMatch(a2, fromA, toA, b3, fromB, toB) {
  let lenA = toA - fromA, lenB = toB - fromB;
  if (lenA < lenB) {
    let result = halfMatch(b3, fromB, toB, a2, fromA, toA);
    return result && [result[1], result[0], result[2]];
  }
  if (lenA < 4 || lenB * 2 < lenA)
    return null;
  return findMatch(a2, fromA, toA, b3, fromB, toB, Math.floor(lenA / 4), -1);
}
function crudeMatch(a2, fromA, toA, b3, fromB, toB) {
  let lenA = toA - fromA, lenB = toB - fromB;
  let result;
  if (lenA < lenB) {
    let inv = findMatch(b3, fromB, toB, a2, fromA, toA, Math.floor(lenA / 6), 50);
    result = inv && [inv[1], inv[0], inv[2]];
  } else {
    result = findMatch(a2, fromA, toA, b3, fromB, toB, Math.floor(lenB / 6), 50);
  }
  if (!result)
    return [new Change(fromA, toA, fromB, toB)];
  let [sharedA, sharedB, sharedLen] = result;
  return findDiff(a2, fromA, sharedA, b3, fromB, sharedB).concat(findDiff(a2, sharedA + sharedLen, toA, b3, sharedB + sharedLen, toB));
}
function mergeAdjacent(changes, minGap) {
  for (let i3 = 1; i3 < changes.length; i3++) {
    let prev = changes[i3 - 1], cur = changes[i3];
    if (prev.toA > cur.fromA - minGap && prev.toB > cur.fromB - minGap) {
      changes[i3 - 1] = new Change(prev.fromA, cur.toA, prev.fromB, cur.toB);
      changes.splice(i3--, 1);
    }
  }
}
function normalize(a2, b3, changes) {
  for (; ; ) {
    mergeAdjacent(changes, 1);
    let moved = false;
    for (let i3 = 0; i3 < changes.length; i3++) {
      let ch = changes[i3], pre, post;
      if (pre = commonPrefix(a2, ch.fromA, ch.toA, b3, ch.fromB, ch.toB))
        ch = changes[i3] = new Change(ch.fromA + pre, ch.toA, ch.fromB + pre, ch.toB);
      if (post = commonSuffix(a2, ch.fromA, ch.toA, b3, ch.fromB, ch.toB))
        ch = changes[i3] = new Change(ch.fromA, ch.toA - post, ch.fromB, ch.toB - post);
      let lenA = ch.toA - ch.fromA, lenB = ch.toB - ch.fromB;
      if (lenA && lenB)
        continue;
      let beforeLen = ch.fromA - (i3 ? changes[i3 - 1].toA : 0);
      let afterLen = (i3 < changes.length - 1 ? changes[i3 + 1].fromA : a2.length) - ch.toA;
      if (!beforeLen || !afterLen)
        continue;
      let text4 = lenA ? a2.slice(ch.fromA, ch.toA) : b3.slice(ch.fromB, ch.toB);
      if (beforeLen <= text4.length && a2.slice(ch.fromA - beforeLen, ch.fromA) == text4.slice(text4.length - beforeLen)) {
        changes[i3] = new Change(ch.fromA - beforeLen, ch.toA - beforeLen, ch.fromB - beforeLen, ch.toB - beforeLen);
        moved = true;
      } else if (afterLen <= text4.length && a2.slice(ch.toA, ch.toA + afterLen) == text4.slice(0, afterLen)) {
        changes[i3] = new Change(ch.fromA + afterLen, ch.toA + afterLen, ch.fromB + afterLen, ch.toB + afterLen);
        moved = true;
      }
    }
    if (!moved)
      break;
  }
  return changes;
}
function makePresentable(changes, a2, b3) {
  for (let posA = 0, i3 = 0; i3 < changes.length; i3++) {
    let change = changes[i3];
    let lenA = change.toA - change.fromA, lenB = change.toB - change.fromB;
    if (lenA && lenB || lenA > 3 || lenB > 3) {
      let nextChangeA = i3 == changes.length - 1 ? a2.length : changes[i3 + 1].fromA;
      let maxScanBefore = change.fromA - posA, maxScanAfter = nextChangeA - change.toA;
      let boundBefore = findWordBoundaryBefore(a2, change.fromA, Math.min(maxScanBefore, 5));
      let boundAfter = findWordBoundaryAfter(a2, change.toA, Math.min(maxScanAfter, 5));
      let lenBefore = change.fromA - boundBefore, lenAfter = boundAfter - change.toA;
      if (!lenA || !lenB) {
        let changeLen = Math.max(lenA, lenB);
        let [changeText, changeFrom, changeTo] = lenA ? [a2, change.fromA, change.toA] : [b3, change.fromB, change.toB];
        if (lenBefore && lenAfter) {
          if (changeLen > lenBefore && a2.slice(boundBefore, change.fromA) == changeText.slice(changeTo - lenBefore, changeTo)) {
            change = changes[i3] = new Change(boundBefore, boundBefore + lenA, change.fromB - lenBefore, change.toB - lenBefore);
            boundBefore = change.fromA;
            boundAfter = findWordBoundaryAfter(a2, change.toA, Math.min(nextChangeA - change.toA, 5));
          } else if (changeLen > lenAfter && a2.slice(change.toA, boundAfter) == changeText.slice(changeFrom, changeFrom + lenAfter)) {
            change = changes[i3] = new Change(boundAfter - lenA, boundAfter, change.fromB + lenAfter, change.toB + lenAfter);
            boundAfter = change.toA;
            boundBefore = findWordBoundaryBefore(a2, change.fromA, Math.min(change.fromA - posA, 5));
          }
          lenBefore = change.fromA - boundBefore;
          lenAfter = boundAfter - change.toA;
        }
      }
      if (lenBefore || lenAfter) {
        change = changes[i3] = new Change(change.fromA - lenBefore, change.toA + lenAfter, change.fromB - lenBefore, change.toB + lenAfter);
      } else if (!lenA) {
        let first = findLineBreakAfter(b3, change.fromB, change.toB), len;
        let last = first < 0 ? -1 : findLineBreakBefore(b3, change.toB, change.fromB);
        if (first > -1 && (len = first - change.fromB) <= maxScanAfter && b3.slice(change.fromB, first) == b3.slice(change.toB, change.toB + len))
          change = changes[i3] = change.offset(len);
        else if (last > -1 && (len = change.toB - last) <= maxScanBefore && b3.slice(change.fromB - len, change.fromB) == b3.slice(last, change.toB))
          change = changes[i3] = change.offset(-len);
      } else if (!lenB) {
        let first = findLineBreakAfter(a2, change.fromA, change.toA), len;
        let last = first < 0 ? -1 : findLineBreakBefore(a2, change.toA, change.fromA);
        if (first > -1 && (len = first - change.fromA) <= maxScanAfter && a2.slice(change.fromA, first) == a2.slice(change.toA, change.toA + len))
          change = changes[i3] = change.offset(len);
        else if (last > -1 && (len = change.toA - last) <= maxScanBefore && a2.slice(change.fromA - len, change.fromA) == a2.slice(last, change.toA))
          change = changes[i3] = change.offset(-len);
      }
      posA = change.toA;
    }
  }
  mergeAdjacent(changes, 3);
  return changes;
}
var wordChar;
try {
  wordChar = new RegExp("[\\p{Alphabetic}\\p{Number}]", "u");
} catch (_2) {
}
function asciiWordChar(code3) {
  return code3 > 48 && code3 < 58 || code3 > 64 && code3 < 91 || code3 > 96 && code3 < 123;
}
function wordCharAfter(s2, pos) {
  if (pos == s2.length)
    return 0;
  let next = s2.charCodeAt(pos);
  if (next < 192)
    return asciiWordChar(next) ? 1 : 0;
  if (!wordChar)
    return 0;
  if (!isSurrogate1(next) || pos == s2.length - 1)
    return wordChar.test(String.fromCharCode(next)) ? 1 : 0;
  return wordChar.test(s2.slice(pos, pos + 2)) ? 2 : 0;
}
function wordCharBefore(s2, pos) {
  if (!pos)
    return 0;
  let prev = s2.charCodeAt(pos - 1);
  if (prev < 192)
    return asciiWordChar(prev) ? 1 : 0;
  if (!wordChar)
    return 0;
  if (!isSurrogate2(prev) || pos == 1)
    return wordChar.test(String.fromCharCode(prev)) ? 1 : 0;
  return wordChar.test(s2.slice(pos - 2, pos)) ? 2 : 0;
}
function findWordBoundaryAfter(s2, pos, max2) {
  if (pos == s2.length || !wordCharBefore(s2, pos))
    return pos;
  for (let cur = pos, end = pos + max2; ; ) {
    let size4 = wordCharAfter(s2, cur);
    if (!size4)
      return cur;
    cur += size4;
    if (cur > end)
      return pos;
  }
}
function findWordBoundaryBefore(s2, pos, max2) {
  if (!pos || !wordCharAfter(s2, pos))
    return pos;
  for (let cur = pos, end = pos - max2; ; ) {
    let size4 = wordCharBefore(s2, cur);
    if (!size4)
      return cur;
    cur -= size4;
    if (cur < end)
      return pos;
  }
}
function findLineBreakBefore(s2, pos, stop) {
  for (; pos != stop; pos--)
    if (s2.charCodeAt(pos - 1) == 10)
      return pos;
  return -1;
}
function findLineBreakAfter(s2, pos, stop) {
  for (; pos != stop; pos++)
    if (s2.charCodeAt(pos) == 10)
      return pos;
  return -1;
}
var isSurrogate1 = (code3) => code3 >= 55296 && code3 <= 56319;
var isSurrogate2 = (code3) => code3 >= 56320 && code3 <= 57343;
function validIndex(s2, index3) {
  return !index3 || index3 == s2.length || !isSurrogate1(s2.charCodeAt(index3 - 1)) || !isSurrogate2(s2.charCodeAt(index3));
}
function diff(a2, b3, config) {
  var _a2;
  scanLimit = ((_a2 = config === null || config === void 0 ? void 0 : config.scanLimit) !== null && _a2 !== void 0 ? _a2 : 1e9) >> 1;
  return normalize(a2, b3, findDiff(a2, 0, a2.length, b3, 0, b3.length));
}
function presentableDiff(a2, b3, config) {
  return makePresentable(diff(a2, b3, config), a2, b3);
}
var mergeConfig = Facet.define({
  combine: (values2) => values2[0]
});
var setChunks = StateEffect.define();
var ChunkField = StateField.define({
  create(state) {
    return null;
  },
  update(current2, tr) {
    for (let e2 of tr.effects)
      if (e2.is(setChunks))
        current2 = e2.value;
    return current2;
  }
});
var moveByChunk = (dir) => ({ state, dispatch }) => {
  let chunks = state.field(ChunkField, false), conf = state.facet(mergeConfig);
  if (!chunks || !chunks.length || !conf)
    return false;
  let { head } = state.selection.main, pos = 0;
  for (let i3 = chunks.length - 1; i3 >= 0; i3--) {
    let chunk = chunks[i3];
    let [from2, to2] = conf.side == "b" ? [chunk.fromB, chunk.toB] : [chunk.fromA, chunk.toA];
    if (to2 < head) {
      pos = i3 + 1;
      break;
    }
    if (from2 <= head) {
      if (chunks.length == 1)
        return false;
      pos = i3 + (dir < 0 ? 0 : 1);
      break;
    }
  }
  let next = chunks[(pos + (dir < 0 ? chunks.length - 1 : 0)) % chunks.length];
  let [from, to] = conf.side == "b" ? [next.fromB, next.toB] : [next.fromA, next.toA];
  dispatch(state.update({
    selection: { anchor: from },
    userEvent: "select.byChunk",
    effects: EditorView.scrollIntoView(EditorSelection.range(to, from))
  }));
  return true;
};
var goToNextChunk = moveByChunk(1);
var goToPreviousChunk = moveByChunk(-1);
var Chunk = class _Chunk {
  constructor(changes, fromA, toA, fromB, toB) {
    this.changes = changes;
    this.fromA = fromA;
    this.toA = toA;
    this.fromB = fromB;
    this.toB = toB;
  }
  /**
  @internal
  */
  offset(offA, offB) {
    return offA || offB ? new _Chunk(this.changes, this.fromA + offA, this.toA + offA, this.fromB + offB, this.toB + offB) : this;
  }
  /**
  Returns `fromA` if the chunk is empty in A, or the end of the
  last line in the chunk otherwise.
  */
  get endA() {
    return Math.max(this.fromA, this.toA - 1);
  }
  /**
  Returns `fromB` if the chunk is empty in B, or the end of the
  last line in the chunk otherwise.
  */
  get endB() {
    return Math.max(this.fromB, this.toB - 1);
  }
  /**
  Build a set of changed chunks for the given documents.
  */
  static build(a2, b3, conf) {
    return toChunks(presentableDiff(a2.toString(), b3.toString(), conf), a2, b3, 0, 0);
  }
  /**
  Update a set of chunks for changes in document A. `a` should
  hold the updated document A.
  */
  static updateA(chunks, a2, b3, changes, conf) {
    return updateChunks(findRangesForChange(chunks, changes, true, b3.length), chunks, a2, b3, conf);
  }
  /**
  Update a set of chunks for changes in document B.
  */
  static updateB(chunks, a2, b3, changes, conf) {
    return updateChunks(findRangesForChange(chunks, changes, false, a2.length), chunks, a2, b3, conf);
  }
};
function fromLine(fromA, fromB, a2, b3) {
  let lineA = a2.lineAt(fromA), lineB = b3.lineAt(fromB);
  return lineA.to == fromA && lineB.to == fromB && fromA < a2.length && fromB < b3.length ? [fromA + 1, fromB + 1] : [lineA.from, lineB.from];
}
function toLine(toA, toB, a2, b3) {
  let lineA = a2.lineAt(toA), lineB = b3.lineAt(toB);
  return lineA.from == toA && lineB.from == toB ? [toA, toB] : [lineA.to + 1, lineB.to + 1];
}
function toChunks(changes, a2, b3, offA, offB) {
  let chunks = [];
  for (let i3 = 0; i3 < changes.length; i3++) {
    let change = changes[i3];
    let [fromA, fromB] = fromLine(change.fromA + offA, change.fromB + offB, a2, b3);
    let [toA, toB] = toLine(change.toA + offA, change.toB + offB, a2, b3);
    let chunk = [change.offset(-fromA + offA, -fromB + offB)];
    while (i3 < changes.length - 1) {
      let next = changes[i3 + 1];
      let [nextA, nextB] = fromLine(next.fromA + offA, next.fromB + offB, a2, b3);
      if (nextA > toA + 1 && nextB > toB + 1)
        break;
      chunk.push(next.offset(-fromA + offA, -fromB + offB));
      [toA, toB] = toLine(next.toA + offA, next.toB + offB, a2, b3);
      i3++;
    }
    chunks.push(new Chunk(chunk, fromA, Math.max(fromA, toA), fromB, Math.max(fromB, toB)));
  }
  return chunks;
}
var updateMargin = 1e3;
function findPos(chunks, pos, isA, start2) {
  let lo = 0, hi = chunks.length;
  for (; ; ) {
    if (lo == hi) {
      let refA = 0, refB = 0;
      if (lo)
        ({ toA: refA, toB: refB } = chunks[lo - 1]);
      let off = pos - (isA ? refA : refB);
      return [refA + off, refB + off];
    }
    let mid = lo + hi >> 1, chunk = chunks[mid];
    let [from, to] = isA ? [chunk.fromA, chunk.toA] : [chunk.fromB, chunk.toB];
    if (from > pos)
      hi = mid;
    else if (to <= pos)
      lo = mid + 1;
    else
      return start2 ? [chunk.fromA, chunk.fromB] : [chunk.toA, chunk.toB];
  }
}
function findRangesForChange(chunks, changes, isA, otherLen) {
  let ranges = [];
  changes.iterChangedRanges((cFromA, cToA, cFromB, cToB) => {
    let fromA = 0, toA = isA ? changes.length : otherLen;
    let fromB = 0, toB = isA ? otherLen : changes.length;
    if (cFromA > updateMargin)
      [fromA, fromB] = findPos(chunks, cFromA - updateMargin, isA, true);
    if (cToA < changes.length - updateMargin)
      [toA, toB] = findPos(chunks, cToA + updateMargin, isA, false);
    let lenDiff = cToB - cFromB - (cToA - cFromA), last;
    let [diffA, diffB] = isA ? [lenDiff, 0] : [0, lenDiff];
    if (ranges.length && (last = ranges[ranges.length - 1]).toA >= fromA)
      ranges[ranges.length - 1] = {
        fromA: last.fromA,
        fromB: last.fromB,
        toA,
        toB,
        diffA: last.diffA + diffA,
        diffB: last.diffB + diffB
      };
    else
      ranges.push({ fromA, toA, fromB, toB, diffA, diffB });
  });
  return ranges;
}
function updateChunks(ranges, chunks, a2, b3, conf) {
  if (!ranges.length)
    return chunks;
  let result = [];
  for (let i3 = 0, offA = 0, offB = 0, chunkI = 0; ; i3++) {
    let range = i3 == ranges.length ? null : ranges[i3];
    let fromA = range ? range.fromA + offA : a2.length, fromB = range ? range.fromB + offB : b3.length;
    while (chunkI < chunks.length) {
      let next = chunks[chunkI];
      if (next.toA + offA > fromA || next.toB + offB > fromB)
        break;
      result.push(next.offset(offA, offB));
      chunkI++;
    }
    if (!range)
      break;
    let toA = range.toA + offA + range.diffA, toB = range.toB + offB + range.diffB;
    let diff2 = presentableDiff(a2.sliceString(fromA, toA), b3.sliceString(fromB, toB), conf);
    for (let chunk of toChunks(diff2, a2, b3, fromA, fromB))
      result.push(chunk);
    offA += range.diffA;
    offB += range.diffB;
    while (chunkI < chunks.length) {
      let next = chunks[chunkI];
      if (next.fromA + offA > toA && next.fromB + offB > toB)
        break;
      chunkI++;
    }
  }
  return result;
}
var defaultDiffConfig = { scanLimit: 500 };
var decorateChunks = ViewPlugin.fromClass(class {
  constructor(view) {
    ({ deco: this.deco, gutter: this.gutter } = getChunkDeco(view));
  }
  update(update) {
    if (update.docChanged || update.viewportChanged || chunksChanged(update.startState, update.state) || configChanged(update.startState, update.state))
      ({ deco: this.deco, gutter: this.gutter } = getChunkDeco(update.view));
  }
}, {
  decorations: (d3) => d3.deco
});
var changeGutter = Prec.low(gutter({
  class: "cm-changeGutter",
  markers: (view) => {
    var _a2;
    return ((_a2 = view.plugin(decorateChunks)) === null || _a2 === void 0 ? void 0 : _a2.gutter) || RangeSet.empty;
  }
}));
function chunksChanged(s1, s2) {
  return s1.field(ChunkField, false) != s2.field(ChunkField, false);
}
function configChanged(s1, s2) {
  return s1.facet(mergeConfig) != s2.facet(mergeConfig);
}
var changedLine = Decoration.line({ class: "cm-changedLine" });
var changedText = Decoration.mark({ class: "cm-changedText" });
var inserted = Decoration.mark({ tagName: "ins", class: "cm-insertedLine" });
var deleted = Decoration.mark({ tagName: "del", class: "cm-deletedLine" });
var changedLineGutterMarker = new class extends GutterMarker {
  constructor() {
    super(...arguments);
    this.elementClass = "cm-changedLineGutter";
  }
}();
function buildChunkDeco(chunk, doc, isA, highlight, builder, gutterBuilder) {
  let from = isA ? chunk.fromA : chunk.fromB, to = isA ? chunk.toA : chunk.toB;
  let changeI = 0;
  if (from != to) {
    builder.add(from, from, changedLine);
    builder.add(from, to, isA ? deleted : inserted);
    if (gutterBuilder)
      gutterBuilder.add(from, from, changedLineGutterMarker);
    for (let iter = doc.iterRange(from, to - 1), pos = from; !iter.next().done; ) {
      if (iter.lineBreak) {
        pos++;
        builder.add(pos, pos, changedLine);
        if (gutterBuilder)
          gutterBuilder.add(pos, pos, changedLineGutterMarker);
        continue;
      }
      let lineEnd = pos + iter.value.length;
      if (highlight)
        while (changeI < chunk.changes.length) {
          let nextChange = chunk.changes[changeI];
          let nextFrom = from + (isA ? nextChange.fromA : nextChange.fromB);
          let nextTo = from + (isA ? nextChange.toA : nextChange.toB);
          let chFrom = Math.max(pos, nextFrom), chTo = Math.min(lineEnd, nextTo);
          if (chFrom < chTo)
            builder.add(chFrom, chTo, changedText);
          if (nextTo < lineEnd)
            changeI++;
          else
            break;
        }
      pos = lineEnd;
    }
  }
}
function getChunkDeco(view) {
  let chunks = view.state.field(ChunkField);
  let { side, highlightChanges, markGutter } = view.state.facet(mergeConfig), isA = side == "a";
  let builder = new RangeSetBuilder();
  let gutterBuilder = markGutter ? new RangeSetBuilder() : null;
  let { from, to } = view.viewport;
  for (let chunk of chunks) {
    if ((isA ? chunk.fromA : chunk.fromB) >= to)
      break;
    if ((isA ? chunk.toA : chunk.toB) > from)
      buildChunkDeco(chunk, view.state.doc, isA, highlightChanges, builder, gutterBuilder);
  }
  return { deco: builder.finish(), gutter: gutterBuilder && gutterBuilder.finish() };
}
var Spacer = class extends WidgetType {
  constructor(height) {
    super();
    this.height = height;
  }
  eq(other) {
    return this.height == other.height;
  }
  toDOM() {
    let elt = document.createElement("div");
    elt.className = "cm-mergeSpacer";
    elt.style.height = this.height + "px";
    return elt;
  }
  updateDOM(dom) {
    dom.style.height = this.height + "px";
    return true;
  }
  get estimatedHeight() {
    return this.height;
  }
  ignoreEvent() {
    return false;
  }
};
var adjustSpacers = StateEffect.define({
  map: (value2, mapping) => value2.map(mapping)
});
var Spacers = StateField.define({
  create: () => Decoration.none,
  update: (spacers, tr) => {
    for (let e2 of tr.effects)
      if (e2.is(adjustSpacers))
        return e2.value;
    return spacers.map(tr.changes);
  },
  provide: (f3) => EditorView.decorations.from(f3)
});
var epsilon = 0.01;
function compareSpacers(a2, b3) {
  if (a2.size != b3.size)
    return false;
  let iA = a2.iter(), iB = b3.iter();
  while (iA.value) {
    if (iA.from != iB.from || Math.abs(iA.value.spec.widget.height - iB.value.spec.widget.height) > 1)
      return false;
    iA.next();
    iB.next();
  }
  return true;
}
function updateSpacers(a2, b3, chunks) {
  let buildA = new RangeSetBuilder(), buildB = new RangeSetBuilder();
  let spacersA = a2.state.field(Spacers).iter(), spacersB = b3.state.field(Spacers).iter();
  let posA = 0, posB = 0, offA = 0, offB = 0, vpA = a2.viewport, vpB = b3.viewport;
  for (let chunkI = 0; ; chunkI++) {
    let chunk = chunkI < chunks.length ? chunks[chunkI] : null;
    let endA = chunk ? chunk.fromA : a2.state.doc.length, endB = chunk ? chunk.fromB : b3.state.doc.length;
    if (posA < endA) {
      let heightA = a2.lineBlockAt(posA).top + offA;
      let heightB = b3.lineBlockAt(posB).top + offB;
      let diff2 = heightA - heightB;
      if (diff2 < -epsilon) {
        offA -= diff2;
        buildA.add(posA, posA, Decoration.widget({
          widget: new Spacer(-diff2),
          block: true,
          side: -1
        }));
      } else if (diff2 > epsilon) {
        offB += diff2;
        buildB.add(posB, posB, Decoration.widget({
          widget: new Spacer(diff2),
          block: true,
          side: -1
        }));
      }
    }
    if (endA > posA + 1e3 && posA < vpA.from && endA > vpA.from && posB < vpB.from && endB > vpB.from) {
      let off = Math.min(vpA.from - posA, vpB.from - posB);
      posA += off;
      posB += off;
      chunkI--;
    } else if (!chunk) {
      break;
    } else {
      posA = chunk.toA;
      posB = chunk.toB;
    }
    while (spacersA.value && spacersA.from < posA) {
      offA -= spacersA.value.spec.widget.height;
      spacersA.next();
    }
    while (spacersB.value && spacersB.from < posB) {
      offB -= spacersB.value.spec.widget.height;
      spacersB.next();
    }
  }
  while (spacersA.value) {
    offA -= spacersA.value.spec.widget.height;
    spacersA.next();
  }
  while (spacersB.value) {
    offB -= spacersB.value.spec.widget.height;
    spacersB.next();
  }
  let docDiff = a2.contentHeight + offA - (b3.contentHeight + offB);
  if (docDiff < epsilon) {
    buildA.add(a2.state.doc.length, a2.state.doc.length, Decoration.widget({
      widget: new Spacer(-docDiff),
      block: true,
      side: 1
    }));
  } else if (docDiff > epsilon) {
    buildB.add(b3.state.doc.length, b3.state.doc.length, Decoration.widget({
      widget: new Spacer(docDiff),
      block: true,
      side: 1
    }));
  }
  let decoA = buildA.finish(), decoB = buildB.finish();
  if (!compareSpacers(decoA, a2.state.field(Spacers)))
    a2.dispatch({ effects: adjustSpacers.of(decoA) });
  if (!compareSpacers(decoB, b3.state.field(Spacers)))
    b3.dispatch({ effects: adjustSpacers.of(decoB) });
}
var uncollapseUnchanged = StateEffect.define({
  map: (value2, change) => change.mapPos(value2)
});
var CollapseWidget = class extends WidgetType {
  constructor(lines) {
    super();
    this.lines = lines;
  }
  eq(other) {
    return this.lines == other.lines;
  }
  toDOM(view) {
    let outer = document.createElement("div");
    outer.className = "cm-collapsedLines";
    outer.textContent = view.state.phrase("$ unchanged lines", this.lines);
    outer.addEventListener("click", (e2) => {
      let pos = view.posAtDOM(e2.target);
      view.dispatch({ effects: uncollapseUnchanged.of(pos) });
      let { side, sibling: sibling2 } = view.state.facet(mergeConfig);
      if (sibling2)
        sibling2().dispatch({ effects: uncollapseUnchanged.of(mapPos(pos, view.state.field(ChunkField), side == "a")) });
    });
    return outer;
  }
  ignoreEvent(e2) {
    return e2 instanceof MouseEvent;
  }
  get estimatedHeight() {
    return 27;
  }
  get type() {
    return "collapsed-unchanged-code";
  }
};
function mapPos(pos, chunks, isA) {
  let startOur = 0, startOther = 0;
  for (let i3 = 0; ; i3++) {
    let next = i3 < chunks.length ? chunks[i3] : null;
    if (!next || (isA ? next.fromA : next.fromB) >= pos)
      return startOther + (pos - startOur);
    [startOur, startOther] = isA ? [next.toA, next.toB] : [next.toB, next.toA];
  }
}
var CollapsedRanges = StateField.define({
  create(state) {
    return Decoration.none;
  },
  update(deco, tr) {
    deco = deco.map(tr.changes);
    for (let e2 of tr.effects)
      if (e2.is(uncollapseUnchanged))
        deco = deco.update({ filter: (from) => from != e2.value });
    return deco;
  },
  provide: (f3) => EditorView.decorations.from(f3)
});
function collapseUnchanged({ margin = 3, minSize = 4 }) {
  return CollapsedRanges.init((state) => buildCollapsedRanges(state, margin, minSize));
}
function buildCollapsedRanges(state, margin, minLines) {
  let builder = new RangeSetBuilder();
  let isA = state.facet(mergeConfig).side == "a";
  let chunks = state.field(ChunkField);
  let prevLine = 1;
  for (let i3 = 0; ; i3++) {
    let chunk = i3 < chunks.length ? chunks[i3] : null;
    let collapseFrom = i3 ? prevLine + margin : 1;
    let collapseTo = chunk ? state.doc.lineAt(isA ? chunk.fromA : chunk.fromB).number - 1 - margin : state.doc.lines;
    let lines = collapseTo - collapseFrom + 1;
    if (lines >= minLines) {
      builder.add(state.doc.line(collapseFrom).from, state.doc.line(collapseTo).to, Decoration.replace({
        widget: new CollapseWidget(lines),
        block: true
      }));
    }
    if (!chunk)
      break;
    prevLine = state.doc.lineAt(Math.min(state.doc.length, isA ? chunk.toA : chunk.toB)).number;
  }
  return builder.finish();
}
var externalTheme = EditorView.styleModule.of(new StyleModule({
  ".cm-mergeView": {
    overflowY: "auto"
  },
  ".cm-mergeViewEditors": {
    display: "flex",
    alignItems: "stretch"
  },
  ".cm-mergeViewEditor": {
    flexGrow: 1,
    flexBasis: 0,
    overflow: "hidden"
  },
  ".cm-merge-revert": {
    width: "1.6em",
    flexGrow: 0,
    flexShrink: 0,
    position: "relative"
  },
  ".cm-merge-revert button": {
    position: "absolute",
    display: "block",
    width: "100%",
    boxSizing: "border-box",
    textAlign: "center",
    background: "none",
    border: "none",
    font: "inherit",
    cursor: "pointer"
  }
}));
var baseTheme3 = EditorView.baseTheme({
  ".cm-mergeView & .cm-scroller, .cm-mergeView &": {
    height: "auto !important",
    overflowY: "visible !important"
  },
  "&.cm-merge-a .cm-changedLine, .cm-deletedChunk": {
    backgroundColor: "rgba(160, 128, 100, .08)"
  },
  "&.cm-merge-b .cm-changedLine": {
    backgroundColor: "rgba(100, 160, 128, .08)"
  },
  "&light.cm-merge-a .cm-changedText, &light .cm-deletedChunk .cm-deletedText": {
    background: "linear-gradient(#ee443366, #ee443366) bottom/100% 2px no-repeat"
  },
  "&dark.cm-merge-a .cm-changedText, &dark .cm-deletedChunk .cm-deletedText": {
    background: "linear-gradient(#ffaa9966, #ffaa9966) bottom/100% 2px no-repeat"
  },
  "&light.cm-merge-b .cm-changedText": {
    background: "linear-gradient(#22bb2266, #22bb2266) bottom/100% 2px no-repeat"
  },
  "&dark.cm-merge-b .cm-changedText": {
    background: "linear-gradient(#88ff8866, #88ff8866) bottom/100% 2px no-repeat"
  },
  ".cm-insertedLine, .cm-deletedLine, .cm-deletedLine del": {
    textDecoration: "none"
  },
  ".cm-deletedChunk": {
    paddingLeft: "6px",
    "& .cm-chunkButtons": {
      position: "absolute",
      insetInlineEnd: "5px"
    },
    "& button": {
      border: "none",
      cursor: "pointer",
      color: "white",
      margin: "0 2px",
      borderRadius: "3px",
      "&[name=accept]": { background: "#2a2" },
      "&[name=reject]": { background: "#d43" }
    }
  },
  ".cm-collapsedLines": {
    padding: "5px 5px 5px 10px",
    cursor: "pointer",
    "&:before": {
      content: '"⦚"',
      marginInlineEnd: "7px"
    },
    "&:after": {
      content: '"⦚"',
      marginInlineStart: "7px"
    }
  },
  "&light .cm-collapsedLines": {
    color: "#444",
    background: "linear-gradient(to bottom, transparent 0, #f3f3f3 30%, #f3f3f3 70%, transparent 100%)"
  },
  "&dark .cm-collapsedLines": {
    color: "#ddd",
    background: "linear-gradient(to bottom, transparent 0, #222 30%, #222 70%, transparent 100%)"
  },
  ".cm-changeGutter": { width: "3px", paddingLeft: "1px" },
  "&light.cm-merge-a .cm-changedLineGutter, &light .cm-deletedLineGutter": { background: "#e43" },
  "&dark.cm-merge-a .cm-changedLineGutter, &dark .cm-deletedLineGutter": { background: "#fa9" },
  "&light.cm-merge-b .cm-changedLineGutter": { background: "#2b2" },
  "&dark.cm-merge-b .cm-changedLineGutter": { background: "#8f8" }
});
var collapseCompartment = new Compartment();
var configCompartment = new Compartment();
var MergeView = class {
  /**
  Create a new merge view.
  */
  constructor(config) {
    this.revertDOM = null;
    this.revertToA = false;
    this.revertToLeft = false;
    this.measuring = -1;
    this.diffConf = config.diffConfig || defaultDiffConfig;
    let sharedExtensions = [
      Prec.low(decorateChunks),
      baseTheme3,
      externalTheme,
      Spacers,
      EditorView.updateListener.of((update) => {
        if (this.measuring < 0 && (update.heightChanged || update.viewportChanged) && !update.transactions.some((tr) => tr.effects.some((e2) => e2.is(adjustSpacers))))
          this.measure();
      })
    ];
    let configA = [mergeConfig.of({
      side: "a",
      sibling: () => this.b,
      highlightChanges: config.highlightChanges !== false,
      markGutter: config.gutter !== false
    })];
    if (config.gutter !== false)
      configA.push(changeGutter);
    let stateA = EditorState.create({
      doc: config.a.doc,
      selection: config.a.selection,
      extensions: [
        config.a.extensions || [],
        EditorView.editorAttributes.of({ class: "cm-merge-a" }),
        configCompartment.of(configA),
        sharedExtensions
      ]
    });
    let configB = [mergeConfig.of({
      side: "b",
      sibling: () => this.a,
      highlightChanges: config.highlightChanges !== false,
      markGutter: config.gutter !== false
    })];
    if (config.gutter !== false)
      configB.push(changeGutter);
    let stateB = EditorState.create({
      doc: config.b.doc,
      selection: config.b.selection,
      extensions: [
        config.b.extensions || [],
        EditorView.editorAttributes.of({ class: "cm-merge-b" }),
        configCompartment.of(configB),
        sharedExtensions
      ]
    });
    this.chunks = Chunk.build(stateA.doc, stateB.doc, this.diffConf);
    let add2 = [
      ChunkField.init(() => this.chunks),
      collapseCompartment.of(config.collapseUnchanged ? collapseUnchanged(config.collapseUnchanged) : [])
    ];
    stateA = stateA.update({ effects: StateEffect.appendConfig.of(add2) }).state;
    stateB = stateB.update({ effects: StateEffect.appendConfig.of(add2) }).state;
    this.dom = document.createElement("div");
    this.dom.className = "cm-mergeView";
    this.editorDOM = this.dom.appendChild(document.createElement("div"));
    this.editorDOM.className = "cm-mergeViewEditors";
    let orientation = config.orientation || "a-b";
    let wrapA = document.createElement("div");
    wrapA.className = "cm-mergeViewEditor";
    let wrapB = document.createElement("div");
    wrapB.className = "cm-mergeViewEditor";
    this.editorDOM.appendChild(orientation == "a-b" ? wrapA : wrapB);
    this.editorDOM.appendChild(orientation == "a-b" ? wrapB : wrapA);
    this.a = new EditorView({
      state: stateA,
      parent: wrapA,
      root: config.root,
      dispatchTransactions: (trs) => this.dispatch(trs, this.a)
    });
    this.b = new EditorView({
      state: stateB,
      parent: wrapB,
      root: config.root,
      dispatchTransactions: (trs) => this.dispatch(trs, this.b)
    });
    this.setupRevertControls(!!config.revertControls, config.revertControls == "b-to-a", config.renderRevertControl);
    if (config.parent)
      config.parent.appendChild(this.dom);
    this.scheduleMeasure();
  }
  dispatch(trs, target) {
    if (trs.some((tr) => tr.docChanged)) {
      let last = trs[trs.length - 1];
      let changes = trs.reduce((chs, tr) => chs.compose(tr.changes), ChangeSet.empty(trs[0].startState.doc.length));
      this.chunks = target == this.a ? Chunk.updateA(this.chunks, last.newDoc, this.b.state.doc, changes, this.diffConf) : Chunk.updateB(this.chunks, this.a.state.doc, last.newDoc, changes, this.diffConf);
      target.update([...trs, last.state.update({ effects: setChunks.of(this.chunks) })]);
      let other = target == this.a ? this.b : this.a;
      other.update([other.state.update({ effects: setChunks.of(this.chunks) })]);
      this.scheduleMeasure();
    } else {
      target.update(trs);
    }
  }
  /**
  Reconfigure an existing merge view.
  */
  reconfigure(config) {
    if ("diffConfig" in config) {
      this.diffConf = config.diffConfig;
    }
    if ("orientation" in config) {
      let aB = config.orientation != "b-a";
      if (aB != (this.editorDOM.firstChild == this.a.dom.parentNode)) {
        let domA = this.a.dom.parentNode, domB = this.b.dom.parentNode;
        domA.remove();
        domB.remove();
        this.editorDOM.insertBefore(aB ? domA : domB, this.editorDOM.firstChild);
        this.editorDOM.appendChild(aB ? domB : domA);
        this.revertToLeft = !this.revertToLeft;
        if (this.revertDOM)
          this.revertDOM.textContent = "";
      }
    }
    if ("revertControls" in config || "renderRevertControl" in config) {
      let controls = !!this.revertDOM, toA = this.revertToA, render = this.renderRevert;
      if ("revertControls" in config) {
        controls = !!config.revertControls;
        toA = config.revertControls == "b-to-a";
      }
      if ("renderRevertControl" in config)
        render = config.renderRevertControl;
      this.setupRevertControls(controls, toA, render);
    }
    let highlight = "highlightChanges" in config, gutter2 = "gutter" in config, collapse = "collapseUnchanged" in config;
    if (highlight || gutter2 || collapse) {
      let effectsA = [], effectsB = [];
      if (highlight || gutter2) {
        let currentConfig = this.a.state.facet(mergeConfig);
        let markGutter = gutter2 ? config.gutter !== false : currentConfig.markGutter;
        let highlightChanges = highlight ? config.highlightChanges !== false : currentConfig.highlightChanges;
        effectsA.push(configCompartment.reconfigure([
          mergeConfig.of({ side: "a", sibling: () => this.b, highlightChanges, markGutter }),
          markGutter ? changeGutter : []
        ]));
        effectsB.push(configCompartment.reconfigure([
          mergeConfig.of({ side: "b", sibling: () => this.a, highlightChanges, markGutter }),
          markGutter ? changeGutter : []
        ]));
      }
      if (collapse) {
        let effect = collapseCompartment.reconfigure(config.collapseUnchanged ? collapseUnchanged(config.collapseUnchanged) : []);
        effectsA.push(effect);
        effectsB.push(effect);
      }
      this.a.dispatch({ effects: effectsA });
      this.b.dispatch({ effects: effectsB });
    }
    this.scheduleMeasure();
  }
  setupRevertControls(controls, toA, render) {
    this.revertToA = toA;
    this.revertToLeft = this.revertToA == (this.editorDOM.firstChild == this.a.dom.parentNode);
    this.renderRevert = render;
    if (!controls && this.revertDOM) {
      this.revertDOM.remove();
      this.revertDOM = null;
    } else if (controls && !this.revertDOM) {
      this.revertDOM = this.editorDOM.insertBefore(document.createElement("div"), this.editorDOM.firstChild.nextSibling);
      this.revertDOM.addEventListener("mousedown", (e2) => this.revertClicked(e2));
      this.revertDOM.className = "cm-merge-revert";
    } else if (this.revertDOM) {
      this.revertDOM.textContent = "";
    }
  }
  scheduleMeasure() {
    if (this.measuring < 0) {
      let win = this.dom.ownerDocument.defaultView || window;
      this.measuring = win.requestAnimationFrame(() => {
        this.measuring = -1;
        this.measure();
      });
    }
  }
  measure() {
    updateSpacers(this.a, this.b, this.chunks);
    if (this.revertDOM)
      this.updateRevertButtons();
  }
  updateRevertButtons() {
    let dom = this.revertDOM, next = dom.firstChild;
    let vpA = this.a.viewport, vpB = this.b.viewport;
    for (let i3 = 0; i3 < this.chunks.length; i3++) {
      let chunk = this.chunks[i3];
      if (chunk.fromA > vpA.to || chunk.fromB > vpB.to)
        break;
      if (chunk.fromA < vpA.from || chunk.fromB < vpB.from)
        continue;
      let top = this.a.lineBlockAt(chunk.fromA).top + "px";
      while (next && +next.dataset.chunk < i3)
        next = rm(next);
      if (next && next.dataset.chunk == String(i3)) {
        if (next.style.top != top)
          next.style.top = top;
        next = next.nextSibling;
      } else {
        dom.insertBefore(this.renderRevertButton(top, i3), next);
      }
    }
    while (next)
      next = rm(next);
  }
  renderRevertButton(top, chunk) {
    let elt;
    if (this.renderRevert) {
      elt = this.renderRevert();
    } else {
      elt = document.createElement("button");
      let text4 = this.a.state.phrase("Revert this chunk");
      elt.setAttribute("aria-label", text4);
      elt.setAttribute("title", text4);
      elt.textContent = this.revertToLeft ? "⇜" : "⇝";
    }
    elt.style.top = top;
    elt.setAttribute("data-chunk", String(chunk));
    return elt;
  }
  revertClicked(e2) {
    let target = e2.target, chunk;
    while (target && target.parentNode != this.revertDOM)
      target = target.parentNode;
    if (target && (chunk = this.chunks[target.dataset.chunk])) {
      let [source, dest, srcFrom, srcTo, destFrom, destTo] = this.revertToA ? [this.b, this.a, chunk.fromB, chunk.toB, chunk.fromA, chunk.toA] : [this.a, this.b, chunk.fromA, chunk.toA, chunk.fromB, chunk.toB];
      let insert2 = source.state.sliceDoc(srcFrom, Math.max(srcFrom, srcTo - 1));
      if (srcFrom != srcTo && destTo <= dest.state.doc.length)
        insert2 += source.state.lineBreak;
      dest.dispatch({
        changes: { from: destFrom, to: Math.min(dest.state.doc.length, destTo), insert: insert2 },
        userEvent: "revert"
      });
      e2.preventDefault();
    }
  }
  /**
  Destroy this merge view.
  */
  destroy() {
    this.a.destroy();
    this.b.destroy();
    if (this.measuring > -1)
      (this.dom.ownerDocument.defaultView || window).cancelAnimationFrame(this.measuring);
    this.dom.remove();
  }
};
function rm(elt) {
  let next = elt.nextSibling;
  elt.remove();
  return next;
}
var deletedChunkGutterMarker = new class extends GutterMarker {
  constructor() {
    super(...arguments);
    this.elementClass = "cm-deletedLineGutter";
  }
}();
var unifiedChangeGutter = Prec.low(gutter({
  class: "cm-changeGutter",
  markers: (view) => {
    var _a2;
    return ((_a2 = view.plugin(decorateChunks)) === null || _a2 === void 0 ? void 0 : _a2.gutter) || RangeSet.empty;
  },
  widgetMarker: (view, widget) => widget instanceof DeletionWidget ? deletedChunkGutterMarker : null
}));
var updateOriginalDoc = StateEffect.define();
var originalDoc = StateField.define({
  create: () => Text2.empty,
  update(doc, tr) {
    for (let e2 of tr.effects)
      if (e2.is(updateOriginalDoc))
        doc = e2.value.doc;
    return doc;
  }
});
var DeletionWidgets = /* @__PURE__ */ new WeakMap();
var DeletionWidget = class extends WidgetType {
  constructor(buildDOM) {
    super();
    this.buildDOM = buildDOM;
    this.dom = null;
  }
  eq(other) {
    return this.dom == other.dom;
  }
  toDOM(view) {
    return this.dom || (this.dom = this.buildDOM(view));
  }
};
function deletionWidget(state, chunk) {
  let known = DeletionWidgets.get(chunk.changes);
  if (known)
    return known;
  let buildDOM = (view) => {
    let { highlightChanges, syntaxHighlightDeletions, syntaxHighlightDeletionsMaxLength, mergeControls } = state.facet(mergeConfig);
    let text4 = view.state.field(originalDoc).sliceString(chunk.fromA, chunk.endA);
    let lang = syntaxHighlightDeletions && state.facet(language);
    let dom = document.createElement("div");
    dom.className = "cm-deletedChunk";
    if (mergeControls) {
      let buttons = dom.appendChild(document.createElement("div"));
      buttons.className = "cm-chunkButtons";
      let accept = buttons.appendChild(document.createElement("button"));
      accept.name = "accept";
      accept.textContent = state.phrase("Accept");
      accept.onmousedown = (e2) => {
        e2.preventDefault();
        acceptChunk(view, view.posAtDOM(dom));
      };
      let reject = buttons.appendChild(document.createElement("button"));
      reject.name = "reject";
      reject.textContent = state.phrase("Reject");
      reject.onmousedown = (e2) => {
        e2.preventDefault();
        rejectChunk(view, view.posAtDOM(dom));
      };
    }
    if (chunk.fromA >= chunk.toA)
      return dom;
    let line = makeLine();
    let changes = chunk.changes, changeI = 0, inside = false;
    function makeLine() {
      let div = dom.appendChild(document.createElement("div"));
      div.className = "cm-deletedLine";
      return div.appendChild(document.createElement("del"));
    }
    function add2(from, to, cls) {
      for (let at3 = from; at3 < to; ) {
        if (text4.charAt(at3) == "\n") {
          if (!line.firstChild)
            line.appendChild(document.createElement("br"));
          line = makeLine();
          at3++;
          continue;
        }
        let nextStop = to, nodeCls = cls + (inside ? " cm-deletedText" : ""), flip4 = false;
        let newline = text4.indexOf("\n", at3);
        if (newline > -1 && newline < to)
          nextStop = newline;
        if (highlightChanges && changeI < changes.length) {
          let nextBound = Math.max(0, inside ? changes[changeI].toA : changes[changeI].fromA);
          if (nextBound <= nextStop) {
            nextStop = nextBound;
            if (inside)
              changeI++;
            flip4 = true;
          }
        }
        if (nextStop > at3) {
          let node2 = document.createTextNode(text4.slice(at3, nextStop));
          if (nodeCls) {
            let span = line.appendChild(document.createElement("span"));
            span.className = nodeCls;
            span.appendChild(node2);
          } else {
            line.appendChild(node2);
          }
          at3 = nextStop;
        }
        if (flip4)
          inside = !inside;
      }
    }
    if (lang && chunk.toA - chunk.fromA <= syntaxHighlightDeletionsMaxLength) {
      let tree = lang.parser.parse(text4), pos = 0;
      highlightTree(tree, { style: (tags2) => highlightingFor(state, tags2) }, (from, to, cls) => {
        if (from > pos)
          add2(pos, from, "");
        add2(from, to, cls);
        pos = to;
      });
      add2(pos, text4.length, "");
    } else {
      add2(0, text4.length, "");
    }
    if (!line.firstChild)
      line.appendChild(document.createElement("br"));
    return dom;
  };
  let deco = Decoration.widget({
    block: true,
    side: -1,
    widget: new DeletionWidget(buildDOM)
  });
  DeletionWidgets.set(chunk.changes, deco);
  return deco;
}
function acceptChunk(view, pos) {
  let { state } = view, at3 = pos !== null && pos !== void 0 ? pos : state.selection.main.head;
  let chunk = view.state.field(ChunkField).find((ch) => ch.fromB <= at3 && ch.endB >= at3);
  if (!chunk)
    return false;
  let insert2 = view.state.sliceDoc(chunk.fromB, Math.max(chunk.fromB, chunk.toB - 1));
  let orig = view.state.field(originalDoc);
  if (chunk.fromB != chunk.toB && chunk.toA <= orig.length)
    insert2 += view.state.lineBreak;
  let changes = ChangeSet.of({ from: chunk.fromA, to: Math.min(orig.length, chunk.toA), insert: insert2 }, orig.length);
  view.dispatch({
    effects: updateOriginalDoc.of({ doc: changes.apply(orig), changes }),
    userEvent: "accept"
  });
  return true;
}
function rejectChunk(view, pos) {
  let { state } = view, at3 = pos !== null && pos !== void 0 ? pos : state.selection.main.head;
  let chunk = state.field(ChunkField).find((ch) => ch.fromB <= at3 && ch.endB >= at3);
  if (!chunk)
    return false;
  let orig = state.field(originalDoc);
  let insert2 = orig.sliceString(chunk.fromA, Math.max(chunk.fromA, chunk.toA - 1));
  if (chunk.fromA != chunk.toA && chunk.toB <= state.doc.length)
    insert2 += state.lineBreak;
  view.dispatch({
    changes: { from: chunk.fromB, to: Math.min(state.doc.length, chunk.toB), insert: insert2 },
    userEvent: "revert"
  });
  return true;
}
function buildDeletedChunks(state) {
  let builder = new RangeSetBuilder();
  for (let ch of state.field(ChunkField))
    builder.add(ch.fromB, ch.fromB, deletionWidget(state, ch));
  return builder.finish();
}
var deletedChunks = StateField.define({
  create: (state) => buildDeletedChunks(state),
  update(deco, tr) {
    return tr.state.field(ChunkField, false) != tr.startState.field(ChunkField, false) ? buildDeletedChunks(tr.state) : deco;
  },
  provide: (f3) => EditorView.decorations.from(f3)
});

// node_modules/@mdxeditor/editor/dist/plugins/diff-source/SourceEditor.js
var import_react60 = __toESM(require_react(), 1);
var COMMON_STATE_CONFIG_EXTENSIONS2 = [
  basicSetup,
  basicLight,
  markdown(),
  lineNumbers(),
  EditorView.lineWrapping
];
var SourceEditor = () => {
  const [markdown2, readOnly, cmExtensions] = X(markdown$, readOnly$, cmExtensions$);
  const updateMarkdown = A(markdownSourceEditorValue$);
  const triggerOnBlur = A(onBlur$);
  const editorViewRef = import_react60.default.useRef(null);
  const ref2 = import_react60.default.useCallback(
    (el) => {
      var _a2;
      if (el !== null) {
        const extensions = [
          // custom extensions should come first so that you can override the default extensions
          ...cmExtensions,
          ...COMMON_STATE_CONFIG_EXTENSIONS2,
          EditorView.updateListener.of(({ state }) => {
            updateMarkdown(state.doc.toString());
          }),
          EditorView.focusChangeEffect.of((_2, focused) => {
            if (!focused) {
              triggerOnBlur(new FocusEvent("blur"));
            }
            return null;
          })
        ];
        if (readOnly) {
          extensions.push(EditorState.readOnly.of(true));
        }
        el.innerHTML = "";
        editorViewRef.current = new EditorView({
          parent: el,
          state: EditorState.create({ doc: markdown2, extensions })
        });
      } else {
        (_a2 = editorViewRef.current) == null ? void 0 : _a2.destroy();
        editorViewRef.current = null;
      }
    },
    [markdown2, readOnly, updateMarkdown, cmExtensions, triggerOnBlur]
  );
  return import_react60.default.createElement("div", { ref: ref2, className: "cm-sourceView mdxeditor-source-editor" });
};

// node_modules/@mdxeditor/editor/dist/plugins/diff-source/DiffViewer.js
function setContent(view, content3) {
  if (view !== void 0) {
    view.dispatch({ changes: { from: 0, to: view.state.doc.length, insert: content3 } });
  }
}
var DiffViewer = () => {
  const realm = R();
  const [newMarkdown, oldMarkdown, readOnly, readOnlyDiff] = X(markdown$, diffMarkdown$, readOnly$, readOnlyDiff$);
  const onUpdate = A(markdownSourceEditorValue$);
  const elRef = import_react61.default.useRef(null);
  const cmMergeViewRef = import_react61.default.useRef(null);
  const cmExtensions = E(cmExtensions$);
  const triggerOnBlur = A(onBlur$);
  import_react61.default.useEffect(() => {
    return realm.sub(diffMarkdown$, (newDiffMarkdown) => {
      var _a2;
      setContent((_a2 = cmMergeViewRef.current) == null ? void 0 : _a2.a, newDiffMarkdown);
    });
  }, [realm]);
  import_react61.default.useEffect(() => {
    return realm.sub(markdown$, (newMarkdown2) => {
      var _a2;
      setContent((_a2 = cmMergeViewRef.current) == null ? void 0 : _a2.b, newMarkdown2);
    });
  }, [realm]);
  import_react61.default.useEffect(() => {
    const isReadOnly = readOnly || readOnlyDiff;
    const revertParams = isReadOnly ? {
      renderRevertControl: void 0,
      revertControls: void 0
    } : {
      renderRevertControl: () => {
        const el = document.createElement("button");
        el.classList.add("cm-merge-revert");
        el.appendChild(document.createTextNode("⮕"));
        return el;
      },
      revertControls: "a-to-b"
    };
    cmMergeViewRef.current = new MergeView({
      ...revertParams,
      parent: elRef.current,
      orientation: "a-b",
      gutter: true,
      a: {
        doc: oldMarkdown,
        extensions: [...cmExtensions, ...COMMON_STATE_CONFIG_EXTENSIONS2, EditorState.readOnly.of(true)]
      },
      b: {
        doc: newMarkdown,
        extensions: [
          ...cmExtensions,
          ...COMMON_STATE_CONFIG_EXTENSIONS2,
          EditorState.readOnly.of(isReadOnly),
          EditorView.updateListener.of(({ state }) => {
            const md = state.doc.toString();
            onUpdate(md);
          }),
          EditorView.focusChangeEffect.of((_2, focused) => {
            if (!focused) {
              triggerOnBlur(new FocusEvent("blur"));
            }
            return null;
          })
        ]
      }
    });
    return () => {
      var _a2;
      (_a2 = cmMergeViewRef.current) == null ? void 0 : _a2.destroy();
      cmMergeViewRef.current = null;
    };
  }, [onUpdate, cmExtensions]);
  return import_react61.default.createElement("div", { ref: elRef, className: "mdxeditor-diff-editor" });
};

// node_modules/@mdxeditor/editor/dist/plugins/diff-source/DiffSourceWrapper.js
var DiffSourceWrapper = ({ children }) => {
  const [error, viewMode] = X(markdownProcessingError$, viewMode$);
  return import_react62.default.createElement("div", { className: "mdxeditor-diff-source-wrapper" }, error ? import_react62.default.createElement("div", { className: styles.markdownParseError }, import_react62.default.createElement("p", null, error.error, "."), import_react62.default.createElement("p", null, "You can fix the errors in source mode and switch to rich text mode when you are ready.")) : null, import_react62.default.createElement("div", { className: "mdxeditor-rich-text-editor", style: { display: viewMode === "rich-text" && error == null ? "block" : "none" } }, children), viewMode === "diff" ? import_react62.default.createElement(DiffViewer, null) : null, viewMode === "source" ? import_react62.default.createElement(SourceEditor, null) : null);
};

// node_modules/@mdxeditor/editor/dist/plugins/diff-source/index.js
var diffMarkdown$ = $("");
var cmExtensions$ = $([]);
var readOnlyDiff$ = $(false);
var diffSourcePlugin = realmPlugin({
  update: (r2, params) => {
    r2.pub(diffMarkdown$, (params == null ? void 0 : params.diffMarkdown) ?? "");
  },
  init(r2, params) {
    r2.pubIn({
      [diffMarkdown$]: (params == null ? void 0 : params.diffMarkdown) ?? "",
      [cmExtensions$]: (params == null ? void 0 : params.codeMirrorExtensions) ?? [],
      [addEditorWrapper$]: DiffSourceWrapper,
      [readOnlyDiff$]: (params == null ? void 0 : params.readOnlyDiff) ?? false,
      [viewMode$]: (params == null ? void 0 : params.viewMode) ?? "rich-text"
    });
  }
});

// node_modules/@lexical/code/LexicalCode.dev.mjs
var import_prismjs = __toESM(require_prism(), 1);

// node_modules/prismjs/components/prism-clike.js
Prism.languages.clike = {
  "comment": [
    {
      pattern: /(^|[^\\])\/\*[\s\S]*?(?:\*\/|$)/,
      lookbehind: true,
      greedy: true
    },
    {
      pattern: /(^|[^\\:])\/\/.*/,
      lookbehind: true,
      greedy: true
    }
  ],
  "string": {
    pattern: /(["'])(?:\\(?:\r\n|[\s\S])|(?!\1)[^\\\r\n])*\1/,
    greedy: true
  },
  "class-name": {
    pattern: /(\b(?:class|extends|implements|instanceof|interface|new|trait)\s+|\bcatch\s+\()[\w.\\]+/i,
    lookbehind: true,
    inside: {
      "punctuation": /[.\\]/
    }
  },
  "keyword": /\b(?:break|catch|continue|do|else|finally|for|function|if|in|instanceof|new|null|return|throw|try|while)\b/,
  "boolean": /\b(?:false|true)\b/,
  "function": /\b\w+(?=\()/,
  "number": /\b0x[\da-f]+\b|(?:\b\d+(?:\.\d*)?|\B\.\d+)(?:e[+-]?\d+)?/i,
  "operator": /[<>]=?|[!=]=?=?|--?|\+\+?|&&?|\|\|?|[?*/~^%]/,
  "punctuation": /[{}[\];(),.:]/
};

// node_modules/prismjs/components/prism-javascript.js
Prism.languages.javascript = Prism.languages.extend("clike", {
  "class-name": [
    Prism.languages.clike["class-name"],
    {
      pattern: /(^|[^$\w\xA0-\uFFFF])(?!\s)[_$A-Z\xA0-\uFFFF](?:(?!\s)[$\w\xA0-\uFFFF])*(?=\.(?:constructor|prototype))/,
      lookbehind: true
    }
  ],
  "keyword": [
    {
      pattern: /((?:^|\})\s*)catch\b/,
      lookbehind: true
    },
    {
      pattern: /(^|[^.]|\.\.\.\s*)\b(?:as|assert(?=\s*\{)|async(?=\s*(?:function\b|\(|[$\w\xA0-\uFFFF]|$))|await|break|case|class|const|continue|debugger|default|delete|do|else|enum|export|extends|finally(?=\s*(?:\{|$))|for|from(?=\s*(?:['"]|$))|function|(?:get|set)(?=\s*(?:[#\[$\w\xA0-\uFFFF]|$))|if|implements|import|in|instanceof|interface|let|new|null|of|package|private|protected|public|return|static|super|switch|this|throw|try|typeof|undefined|var|void|while|with|yield)\b/,
      lookbehind: true
    }
  ],
  // Allow for all non-ASCII characters (See http://stackoverflow.com/a/2008444)
  "function": /#?(?!\s)[_$a-zA-Z\xA0-\uFFFF](?:(?!\s)[$\w\xA0-\uFFFF])*(?=\s*(?:\.\s*(?:apply|bind|call)\s*)?\()/,
  "number": {
    pattern: RegExp(
      /(^|[^\w$])/.source + "(?:" + // constant
      (/NaN|Infinity/.source + "|" + // binary integer
      /0[bB][01]+(?:_[01]+)*n?/.source + "|" + // octal integer
      /0[oO][0-7]+(?:_[0-7]+)*n?/.source + "|" + // hexadecimal integer
      /0[xX][\dA-Fa-f]+(?:_[\dA-Fa-f]+)*n?/.source + "|" + // decimal bigint
      /\d+(?:_\d+)*n/.source + "|" + // decimal number (integer or float) but no bigint
      /(?:\d+(?:_\d+)*(?:\.(?:\d+(?:_\d+)*)?)?|\.\d+(?:_\d+)*)(?:[Ee][+-]?\d+(?:_\d+)*)?/.source) + ")" + /(?![\w$])/.source
    ),
    lookbehind: true
  },
  "operator": /--|\+\+|\*\*=?|=>|&&=?|\|\|=?|[!=]==|<<=?|>>>?=?|[-+*/%&|^!=<>]=?|\.{3}|\?\?=?|\?\.?|[~:]/
});
Prism.languages.javascript["class-name"][0].pattern = /(\b(?:class|extends|implements|instanceof|interface|new)\s+)[\w.\\]+/;
Prism.languages.insertBefore("javascript", "keyword", {
  "regex": {
    pattern: RegExp(
      // lookbehind
      // eslint-disable-next-line regexp/no-dupe-characters-character-class
      /((?:^|[^$\w\xA0-\uFFFF."'\])\s]|\b(?:return|yield))\s*)/.source + // Regex pattern:
      // There are 2 regex patterns here. The RegExp set notation proposal added support for nested character
      // classes if the `v` flag is present. Unfortunately, nested CCs are both context-free and incompatible
      // with the only syntax, so we have to define 2 different regex patterns.
      /\//.source + "(?:" + /(?:\[(?:[^\]\\\r\n]|\\.)*\]|\\.|[^/\\\[\r\n])+\/[dgimyus]{0,7}/.source + "|" + // `v` flag syntax. This supports 3 levels of nested character classes.
      /(?:\[(?:[^[\]\\\r\n]|\\.|\[(?:[^[\]\\\r\n]|\\.|\[(?:[^[\]\\\r\n]|\\.)*\])*\])*\]|\\.|[^/\\\[\r\n])+\/[dgimyus]{0,7}v[dgimyus]{0,7}/.source + ")" + // lookahead
      /(?=(?:\s|\/\*(?:[^*]|\*(?!\/))*\*\/)*(?:$|[\r\n,.;:})\]]|\/\/))/.source
    ),
    lookbehind: true,
    greedy: true,
    inside: {
      "regex-source": {
        pattern: /^(\/)[\s\S]+(?=\/[a-z]*$)/,
        lookbehind: true,
        alias: "language-regex",
        inside: Prism.languages.regex
      },
      "regex-delimiter": /^\/|\/$/,
      "regex-flags": /^[a-z]+$/
    }
  },
  // This must be declared before keyword because we use "function" inside the look-forward
  "function-variable": {
    pattern: /#?(?!\s)[_$a-zA-Z\xA0-\uFFFF](?:(?!\s)[$\w\xA0-\uFFFF])*(?=\s*[=:]\s*(?:async\s*)?(?:\bfunction\b|(?:\((?:[^()]|\([^()]*\))*\)|(?!\s)[_$a-zA-Z\xA0-\uFFFF](?:(?!\s)[$\w\xA0-\uFFFF])*)\s*=>))/,
    alias: "function"
  },
  "parameter": [
    {
      pattern: /(function(?:\s+(?!\s)[_$a-zA-Z\xA0-\uFFFF](?:(?!\s)[$\w\xA0-\uFFFF])*)?\s*\(\s*)(?!\s)(?:[^()\s]|\s+(?![\s)])|\([^()]*\))+(?=\s*\))/,
      lookbehind: true,
      inside: Prism.languages.javascript
    },
    {
      pattern: /(^|[^$\w\xA0-\uFFFF])(?!\s)[_$a-z\xA0-\uFFFF](?:(?!\s)[$\w\xA0-\uFFFF])*(?=\s*=>)/i,
      lookbehind: true,
      inside: Prism.languages.javascript
    },
    {
      pattern: /(\(\s*)(?!\s)(?:[^()\s]|\s+(?![\s)])|\([^()]*\))+(?=\s*\)\s*=>)/,
      lookbehind: true,
      inside: Prism.languages.javascript
    },
    {
      pattern: /((?:\b|\s|^)(?!(?:as|async|await|break|case|catch|class|const|continue|debugger|default|delete|do|else|enum|export|extends|finally|for|from|function|get|if|implements|import|in|instanceof|interface|let|new|null|of|package|private|protected|public|return|set|static|super|switch|this|throw|try|typeof|undefined|var|void|while|with|yield)(?![$\w\xA0-\uFFFF]))(?:(?!\s)[_$a-zA-Z\xA0-\uFFFF](?:(?!\s)[$\w\xA0-\uFFFF])*\s*)\(\s*|\]\s*\(\s*)(?!\s)(?:[^()\s]|\s+(?![\s)])|\([^()]*\))+(?=\s*\)\s*\{)/,
      lookbehind: true,
      inside: Prism.languages.javascript
    }
  ],
  "constant": /\b[A-Z](?:[A-Z_]|\dx?)*\b/
});
Prism.languages.insertBefore("javascript", "string", {
  "hashbang": {
    pattern: /^#!.*/,
    greedy: true,
    alias: "comment"
  },
  "template-string": {
    pattern: /`(?:\\[\s\S]|\$\{(?:[^{}]|\{(?:[^{}]|\{[^}]*\})*\})+\}|(?!\$\{)[^\\`])*`/,
    greedy: true,
    inside: {
      "template-punctuation": {
        pattern: /^`|`$/,
        alias: "string"
      },
      "interpolation": {
        pattern: /((?:^|[^\\])(?:\\{2})*)\$\{(?:[^{}]|\{(?:[^{}]|\{[^}]*\})*\})+\}/,
        lookbehind: true,
        inside: {
          "interpolation-punctuation": {
            pattern: /^\$\{|\}$/,
            alias: "punctuation"
          },
          rest: Prism.languages.javascript
        }
      },
      "string": /[\s\S]+/
    }
  },
  "string-property": {
    pattern: /((?:^|[,{])[ \t]*)(["'])(?:\\(?:\r\n|[\s\S])|(?!\2)[^\\\r\n])*\2(?=\s*:)/m,
    lookbehind: true,
    greedy: true,
    alias: "property"
  }
});
Prism.languages.insertBefore("javascript", "operator", {
  "literal-property": {
    pattern: /((?:^|[,{])[ \t]*)(?!\s)[_$a-zA-Z\xA0-\uFFFF](?:(?!\s)[$\w\xA0-\uFFFF])*(?=\s*:)/m,
    lookbehind: true,
    alias: "property"
  }
});
if (Prism.languages.markup) {
  Prism.languages.markup.tag.addInlined("script", "javascript");
  Prism.languages.markup.tag.addAttribute(
    /on(?:abort|blur|change|click|composition(?:end|start|update)|dblclick|error|focus(?:in|out)?|key(?:down|up)|load|mouse(?:down|enter|leave|move|out|over|up)|reset|resize|scroll|select|slotchange|submit|unload|wheel)/.source,
    "javascript"
  );
}
Prism.languages.js = Prism.languages.javascript;

// node_modules/prismjs/components/prism-markup.js
Prism.languages.markup = {
  "comment": {
    pattern: /<!--(?:(?!<!--)[\s\S])*?-->/,
    greedy: true
  },
  "prolog": {
    pattern: /<\?[\s\S]+?\?>/,
    greedy: true
  },
  "doctype": {
    // https://www.w3.org/TR/xml/#NT-doctypedecl
    pattern: /<!DOCTYPE(?:[^>"'[\]]|"[^"]*"|'[^']*')+(?:\[(?:[^<"'\]]|"[^"]*"|'[^']*'|<(?!!--)|<!--(?:[^-]|-(?!->))*-->)*\]\s*)?>/i,
    greedy: true,
    inside: {
      "internal-subset": {
        pattern: /(^[^\[]*\[)[\s\S]+(?=\]>$)/,
        lookbehind: true,
        greedy: true,
        inside: null
        // see below
      },
      "string": {
        pattern: /"[^"]*"|'[^']*'/,
        greedy: true
      },
      "punctuation": /^<!|>$|[[\]]/,
      "doctype-tag": /^DOCTYPE/i,
      "name": /[^\s<>'"]+/
    }
  },
  "cdata": {
    pattern: /<!\[CDATA\[[\s\S]*?\]\]>/i,
    greedy: true
  },
  "tag": {
    pattern: /<\/?(?!\d)[^\s>\/=$<%]+(?:\s(?:\s*[^\s>\/=]+(?:\s*=\s*(?:"[^"]*"|'[^']*'|[^\s'">=]+(?=[\s>]))|(?=[\s/>])))+)?\s*\/?>/,
    greedy: true,
    inside: {
      "tag": {
        pattern: /^<\/?[^\s>\/]+/,
        inside: {
          "punctuation": /^<\/?/,
          "namespace": /^[^\s>\/:]+:/
        }
      },
      "special-attr": [],
      "attr-value": {
        pattern: /=\s*(?:"[^"]*"|'[^']*'|[^\s'">=]+)/,
        inside: {
          "punctuation": [
            {
              pattern: /^=/,
              alias: "attr-equals"
            },
            {
              pattern: /^(\s*)["']|["']$/,
              lookbehind: true
            }
          ]
        }
      },
      "punctuation": /\/?>/,
      "attr-name": {
        pattern: /[^\s>\/]+/,
        inside: {
          "namespace": /^[^\s>\/:]+:/
        }
      }
    }
  },
  "entity": [
    {
      pattern: /&[\da-z]{1,8};/i,
      alias: "named-entity"
    },
    /&#x?[\da-f]{1,8};/i
  ]
};
Prism.languages.markup["tag"].inside["attr-value"].inside["entity"] = Prism.languages.markup["entity"];
Prism.languages.markup["doctype"].inside["internal-subset"].inside = Prism.languages.markup;
Prism.hooks.add("wrap", function(env2) {
  if (env2.type === "entity") {
    env2.attributes["title"] = env2.content.replace(/&amp;/, "&");
  }
});
Object.defineProperty(Prism.languages.markup.tag, "addInlined", {
  /**
   * Adds an inlined language to markup.
   *
   * An example of an inlined language is CSS with `<style>` tags.
   *
   * @param {string} tagName The name of the tag that contains the inlined language. This name will be treated as
   * case insensitive.
   * @param {string} lang The language key.
   * @example
   * addInlined('style', 'css');
   */
  value: function addInlined(tagName, lang) {
    var includedCdataInside = {};
    includedCdataInside["language-" + lang] = {
      pattern: /(^<!\[CDATA\[)[\s\S]+?(?=\]\]>$)/i,
      lookbehind: true,
      inside: Prism.languages[lang]
    };
    includedCdataInside["cdata"] = /^<!\[CDATA\[|\]\]>$/i;
    var inside = {
      "included-cdata": {
        pattern: /<!\[CDATA\[[\s\S]*?\]\]>/i,
        inside: includedCdataInside
      }
    };
    inside["language-" + lang] = {
      pattern: /[\s\S]+/,
      inside: Prism.languages[lang]
    };
    var def = {};
    def[tagName] = {
      pattern: RegExp(/(<__[^>]*>)(?:<!\[CDATA\[(?:[^\]]|\](?!\]>))*\]\]>|(?!<!\[CDATA\[)[\s\S])*?(?=<\/__>)/.source.replace(/__/g, function() {
        return tagName;
      }), "i"),
      lookbehind: true,
      greedy: true,
      inside
    };
    Prism.languages.insertBefore("markup", "cdata", def);
  }
});
Object.defineProperty(Prism.languages.markup.tag, "addAttribute", {
  /**
   * Adds an pattern to highlight languages embedded in HTML attributes.
   *
   * An example of an inlined language is CSS with `style` attributes.
   *
   * @param {string} attrName The name of the tag that contains the inlined language. This name will be treated as
   * case insensitive.
   * @param {string} lang The language key.
   * @example
   * addAttribute('style', 'css');
   */
  value: function(attrName, lang) {
    Prism.languages.markup.tag.inside["special-attr"].push({
      pattern: RegExp(
        /(^|["'\s])/.source + "(?:" + attrName + ")" + /\s*=\s*(?:"[^"]*"|'[^']*'|[^\s'">=]+(?=[\s>]))/.source,
        "i"
      ),
      lookbehind: true,
      inside: {
        "attr-name": /^[^\s=]+/,
        "attr-value": {
          pattern: /=[\s\S]+/,
          inside: {
            "value": {
              pattern: /(^=\s*(["']|(?!["'])))\S[\s\S]*(?=\2$)/,
              lookbehind: true,
              alias: [lang, "language-" + lang],
              inside: Prism.languages[lang]
            },
            "punctuation": [
              {
                pattern: /^=/,
                alias: "attr-equals"
              },
              /"|'/
            ]
          }
        }
      }
    });
  }
});
Prism.languages.html = Prism.languages.markup;
Prism.languages.mathml = Prism.languages.markup;
Prism.languages.svg = Prism.languages.markup;
Prism.languages.xml = Prism.languages.extend("markup", {});
Prism.languages.ssml = Prism.languages.xml;
Prism.languages.atom = Prism.languages.xml;
Prism.languages.rss = Prism.languages.xml;

// node_modules/prismjs/components/prism-markdown.js
(function(Prism3) {
  var inner = /(?:\\.|[^\\\n\r]|(?:\n|\r\n?)(?![\r\n]))/.source;
  function createInline(pattern) {
    pattern = pattern.replace(/<inner>/g, function() {
      return inner;
    });
    return RegExp(/((?:^|[^\\])(?:\\{2})*)/.source + "(?:" + pattern + ")");
  }
  var tableCell = /(?:\\.|``(?:[^`\r\n]|`(?!`))+``|`[^`\r\n]+`|[^\\|\r\n`])+/.source;
  var tableRow = /\|?__(?:\|__)+\|?(?:(?:\n|\r\n?)|(?![\s\S]))/.source.replace(/__/g, function() {
    return tableCell;
  });
  var tableLine = /\|?[ \t]*:?-{3,}:?[ \t]*(?:\|[ \t]*:?-{3,}:?[ \t]*)+\|?(?:\n|\r\n?)/.source;
  Prism3.languages.markdown = Prism3.languages.extend("markup", {});
  Prism3.languages.insertBefore("markdown", "prolog", {
    "front-matter-block": {
      pattern: /(^(?:\s*[\r\n])?)---(?!.)[\s\S]*?[\r\n]---(?!.)/,
      lookbehind: true,
      greedy: true,
      inside: {
        "punctuation": /^---|---$/,
        "front-matter": {
          pattern: /\S+(?:\s+\S+)*/,
          alias: ["yaml", "language-yaml"],
          inside: Prism3.languages.yaml
        }
      }
    },
    "blockquote": {
      // > ...
      pattern: /^>(?:[\t ]*>)*/m,
      alias: "punctuation"
    },
    "table": {
      pattern: RegExp("^" + tableRow + tableLine + "(?:" + tableRow + ")*", "m"),
      inside: {
        "table-data-rows": {
          pattern: RegExp("^(" + tableRow + tableLine + ")(?:" + tableRow + ")*$"),
          lookbehind: true,
          inside: {
            "table-data": {
              pattern: RegExp(tableCell),
              inside: Prism3.languages.markdown
            },
            "punctuation": /\|/
          }
        },
        "table-line": {
          pattern: RegExp("^(" + tableRow + ")" + tableLine + "$"),
          lookbehind: true,
          inside: {
            "punctuation": /\||:?-{3,}:?/
          }
        },
        "table-header-row": {
          pattern: RegExp("^" + tableRow + "$"),
          inside: {
            "table-header": {
              pattern: RegExp(tableCell),
              alias: "important",
              inside: Prism3.languages.markdown
            },
            "punctuation": /\|/
          }
        }
      }
    },
    "code": [
      {
        // Prefixed by 4 spaces or 1 tab and preceded by an empty line
        pattern: /((?:^|\n)[ \t]*\n|(?:^|\r\n?)[ \t]*\r\n?)(?: {4}|\t).+(?:(?:\n|\r\n?)(?: {4}|\t).+)*/,
        lookbehind: true,
        alias: "keyword"
      },
      {
        // ```optional language
        // code block
        // ```
        pattern: /^```[\s\S]*?^```$/m,
        greedy: true,
        inside: {
          "code-block": {
            pattern: /^(```.*(?:\n|\r\n?))[\s\S]+?(?=(?:\n|\r\n?)^```$)/m,
            lookbehind: true
          },
          "code-language": {
            pattern: /^(```).+/,
            lookbehind: true
          },
          "punctuation": /```/
        }
      }
    ],
    "title": [
      {
        // title 1
        // =======
        // title 2
        // -------
        pattern: /\S.*(?:\n|\r\n?)(?:==+|--+)(?=[ \t]*$)/m,
        alias: "important",
        inside: {
          punctuation: /==+$|--+$/
        }
      },
      {
        // # title 1
        // ###### title 6
        pattern: /(^\s*)#.+/m,
        lookbehind: true,
        alias: "important",
        inside: {
          punctuation: /^#+|#+$/
        }
      }
    ],
    "hr": {
      // ***
      // ---
      // * * *
      // -----------
      pattern: /(^\s*)([*-])(?:[\t ]*\2){2,}(?=\s*$)/m,
      lookbehind: true,
      alias: "punctuation"
    },
    "list": {
      // * item
      // + item
      // - item
      // 1. item
      pattern: /(^\s*)(?:[*+-]|\d+\.)(?=[\t ].)/m,
      lookbehind: true,
      alias: "punctuation"
    },
    "url-reference": {
      // [id]: http://example.com "Optional title"
      // [id]: http://example.com 'Optional title'
      // [id]: http://example.com (Optional title)
      // [id]: <http://example.com> "Optional title"
      pattern: /!?\[[^\]]+\]:[\t ]+(?:\S+|<(?:\\.|[^>\\])+>)(?:[\t ]+(?:"(?:\\.|[^"\\])*"|'(?:\\.|[^'\\])*'|\((?:\\.|[^)\\])*\)))?/,
      inside: {
        "variable": {
          pattern: /^(!?\[)[^\]]+/,
          lookbehind: true
        },
        "string": /(?:"(?:\\.|[^"\\])*"|'(?:\\.|[^'\\])*'|\((?:\\.|[^)\\])*\))$/,
        "punctuation": /^[\[\]!:]|[<>]/
      },
      alias: "url"
    },
    "bold": {
      // **strong**
      // __strong__
      // allow one nested instance of italic text using the same delimiter
      pattern: createInline(/\b__(?:(?!_)<inner>|_(?:(?!_)<inner>)+_)+__\b|\*\*(?:(?!\*)<inner>|\*(?:(?!\*)<inner>)+\*)+\*\*/.source),
      lookbehind: true,
      greedy: true,
      inside: {
        "content": {
          pattern: /(^..)[\s\S]+(?=..$)/,
          lookbehind: true,
          inside: {}
          // see below
        },
        "punctuation": /\*\*|__/
      }
    },
    "italic": {
      // *em*
      // _em_
      // allow one nested instance of bold text using the same delimiter
      pattern: createInline(/\b_(?:(?!_)<inner>|__(?:(?!_)<inner>)+__)+_\b|\*(?:(?!\*)<inner>|\*\*(?:(?!\*)<inner>)+\*\*)+\*/.source),
      lookbehind: true,
      greedy: true,
      inside: {
        "content": {
          pattern: /(^.)[\s\S]+(?=.$)/,
          lookbehind: true,
          inside: {}
          // see below
        },
        "punctuation": /[*_]/
      }
    },
    "strike": {
      // ~~strike through~~
      // ~strike~
      // eslint-disable-next-line regexp/strict
      pattern: createInline(/(~~?)(?:(?!~)<inner>)+\2/.source),
      lookbehind: true,
      greedy: true,
      inside: {
        "content": {
          pattern: /(^~~?)[\s\S]+(?=\1$)/,
          lookbehind: true,
          inside: {}
          // see below
        },
        "punctuation": /~~?/
      }
    },
    "code-snippet": {
      // `code`
      // ``code``
      pattern: /(^|[^\\`])(?:``[^`\r\n]+(?:`[^`\r\n]+)*``(?!`)|`[^`\r\n]+`(?!`))/,
      lookbehind: true,
      greedy: true,
      alias: ["code", "keyword"]
    },
    "url": {
      // [example](http://example.com "Optional title")
      // [example][id]
      // [example] [id]
      pattern: createInline(/!?\[(?:(?!\])<inner>)+\](?:\([^\s)]+(?:[\t ]+"(?:\\.|[^"\\])*")?\)|[ \t]?\[(?:(?!\])<inner>)+\])/.source),
      lookbehind: true,
      greedy: true,
      inside: {
        "operator": /^!/,
        "content": {
          pattern: /(^\[)[^\]]+(?=\])/,
          lookbehind: true,
          inside: {}
          // see below
        },
        "variable": {
          pattern: /(^\][ \t]?\[)[^\]]+(?=\]$)/,
          lookbehind: true
        },
        "url": {
          pattern: /(^\]\()[^\s)]+/,
          lookbehind: true
        },
        "string": {
          pattern: /(^[ \t]+)"(?:\\.|[^"\\])*"(?=\)$)/,
          lookbehind: true
        }
      }
    }
  });
  ["url", "bold", "italic", "strike"].forEach(function(token) {
    ["url", "bold", "italic", "strike", "code-snippet"].forEach(function(inside) {
      if (token !== inside) {
        Prism3.languages.markdown[token].inside.content.inside[inside] = Prism3.languages.markdown[inside];
      }
    });
  });
  Prism3.hooks.add("after-tokenize", function(env2) {
    if (env2.language !== "markdown" && env2.language !== "md") {
      return;
    }
    function walkTokens(tokens) {
      if (!tokens || typeof tokens === "string") {
        return;
      }
      for (var i3 = 0, l3 = tokens.length; i3 < l3; i3++) {
        var token = tokens[i3];
        if (token.type !== "code") {
          walkTokens(token.content);
          continue;
        }
        var codeLang = token.content[1];
        var codeBlock = token.content[3];
        if (codeLang && codeBlock && codeLang.type === "code-language" && codeBlock.type === "code-block" && typeof codeLang.content === "string") {
          var lang = codeLang.content.replace(/\b#/g, "sharp").replace(/\b\+\+/g, "pp");
          lang = (/[a-z][\w-]*/i.exec(lang) || [""])[0].toLowerCase();
          var alias = "language-" + lang;
          if (!codeBlock.alias) {
            codeBlock.alias = [alias];
          } else if (typeof codeBlock.alias === "string") {
            codeBlock.alias = [codeBlock.alias, alias];
          } else {
            codeBlock.alias.push(alias);
          }
        }
      }
    }
    walkTokens(env2.tokens);
  });
  Prism3.hooks.add("wrap", function(env2) {
    if (env2.type !== "code-block") {
      return;
    }
    var codeLang = "";
    for (var i3 = 0, l3 = env2.classes.length; i3 < l3; i3++) {
      var cls = env2.classes[i3];
      var match = /language-(.+)/.exec(cls);
      if (match) {
        codeLang = match[1];
        break;
      }
    }
    var grammar = Prism3.languages[codeLang];
    if (!grammar) {
      if (codeLang && codeLang !== "none" && Prism3.plugins.autoloader) {
        var id = "md-" + (/* @__PURE__ */ new Date()).valueOf() + "-" + Math.floor(Math.random() * 1e16);
        env2.attributes["id"] = id;
        Prism3.plugins.autoloader.loadLanguages(codeLang, function() {
          var ele = document.getElementById(id);
          if (ele) {
            ele.innerHTML = Prism3.highlight(ele.textContent, Prism3.languages[codeLang], codeLang);
          }
        });
      }
    } else {
      env2.content = Prism3.highlight(textContent(env2.content), grammar, codeLang);
    }
  });
  var tagPattern = RegExp(Prism3.languages.markup.tag.pattern.source, "gi");
  var KNOWN_ENTITY_NAMES = {
    "amp": "&",
    "lt": "<",
    "gt": ">",
    "quot": '"'
  };
  var fromCodePoint2 = String.fromCodePoint || String.fromCharCode;
  function textContent(html3) {
    var text4 = html3.replace(tagPattern, "");
    text4 = text4.replace(/&(\w{1,8}|#x?[\da-f]{1,8});/gi, function(m2, code3) {
      code3 = code3.toLowerCase();
      if (code3[0] === "#") {
        var value2;
        if (code3[1] === "x") {
          value2 = parseInt(code3.slice(2), 16);
        } else {
          value2 = Number(code3.slice(1));
        }
        return fromCodePoint2(value2);
      } else {
        var known = KNOWN_ENTITY_NAMES[code3];
        if (known) {
          return known;
        }
        return m2;
      }
    });
    return text4;
  }
  Prism3.languages.md = Prism3.languages.markdown;
})(Prism);

// node_modules/prismjs/components/prism-c.js
Prism.languages.c = Prism.languages.extend("clike", {
  "comment": {
    pattern: /\/\/(?:[^\r\n\\]|\\(?:\r\n?|\n|(?![\r\n])))*|\/\*[\s\S]*?(?:\*\/|$)/,
    greedy: true
  },
  "string": {
    // https://en.cppreference.com/w/c/language/string_literal
    pattern: /"(?:\\(?:\r\n|[\s\S])|[^"\\\r\n])*"/,
    greedy: true
  },
  "class-name": {
    pattern: /(\b(?:enum|struct)\s+(?:__attribute__\s*\(\([\s\S]*?\)\)\s*)?)\w+|\b[a-z]\w*_t\b/,
    lookbehind: true
  },
  "keyword": /\b(?:_Alignas|_Alignof|_Atomic|_Bool|_Complex|_Generic|_Imaginary|_Noreturn|_Static_assert|_Thread_local|__attribute__|asm|auto|break|case|char|const|continue|default|do|double|else|enum|extern|float|for|goto|if|inline|int|long|register|return|short|signed|sizeof|static|struct|switch|typedef|typeof|union|unsigned|void|volatile|while)\b/,
  "function": /\b[a-z_]\w*(?=\s*\()/i,
  "number": /(?:\b0x(?:[\da-f]+(?:\.[\da-f]*)?|\.[\da-f]+)(?:p[+-]?\d+)?|(?:\b\d+(?:\.\d*)?|\B\.\d+)(?:e[+-]?\d+)?)[ful]{0,4}/i,
  "operator": />>=?|<<=?|->|([-+&|:])\1|[?:~]|[-+*/%&|^!=<>]=?/
});
Prism.languages.insertBefore("c", "string", {
  "char": {
    // https://en.cppreference.com/w/c/language/character_constant
    pattern: /'(?:\\(?:\r\n|[\s\S])|[^'\\\r\n]){0,32}'/,
    greedy: true
  }
});
Prism.languages.insertBefore("c", "string", {
  "macro": {
    // allow for multiline macro definitions
    // spaces after the # character compile fine with gcc
    pattern: /(^[\t ]*)#\s*[a-z](?:[^\r\n\\/]|\/(?!\*)|\/\*(?:[^*]|\*(?!\/))*\*\/|\\(?:\r\n|[\s\S]))*/im,
    lookbehind: true,
    greedy: true,
    alias: "property",
    inside: {
      "string": [
        {
          // highlight the path of the include statement as a string
          pattern: /^(#\s*include\s*)<[^>]+>/,
          lookbehind: true
        },
        Prism.languages.c["string"]
      ],
      "char": Prism.languages.c["char"],
      "comment": Prism.languages.c["comment"],
      "macro-name": [
        {
          pattern: /(^#\s*define\s+)\w+\b(?!\()/i,
          lookbehind: true
        },
        {
          pattern: /(^#\s*define\s+)\w+\b(?=\()/i,
          lookbehind: true,
          alias: "function"
        }
      ],
      // highlight macro directives as keywords
      "directive": {
        pattern: /^(#\s*)[a-z]+/,
        lookbehind: true,
        alias: "keyword"
      },
      "directive-hash": /^#/,
      "punctuation": /##|\\(?=[\r\n])/,
      "expression": {
        pattern: /\S[\s\S]*/,
        inside: Prism.languages.c
      }
    }
  }
});
Prism.languages.insertBefore("c", "function", {
  // highlight predefined macros as constants
  "constant": /\b(?:EOF|NULL|SEEK_CUR|SEEK_END|SEEK_SET|__DATE__|__FILE__|__LINE__|__TIMESTAMP__|__TIME__|__func__|stderr|stdin|stdout)\b/
});
delete Prism.languages.c["boolean"];

// node_modules/prismjs/components/prism-css.js
(function(Prism3) {
  var string3 = /(?:"(?:\\(?:\r\n|[\s\S])|[^"\\\r\n])*"|'(?:\\(?:\r\n|[\s\S])|[^'\\\r\n])*')/;
  Prism3.languages.css = {
    "comment": /\/\*[\s\S]*?\*\//,
    "atrule": {
      pattern: RegExp("@[\\w-](?:" + /[^;{\s"']|\s+(?!\s)/.source + "|" + string3.source + ")*?" + /(?:;|(?=\s*\{))/.source),
      inside: {
        "rule": /^@[\w-]+/,
        "selector-function-argument": {
          pattern: /(\bselector\s*\(\s*(?![\s)]))(?:[^()\s]|\s+(?![\s)])|\((?:[^()]|\([^()]*\))*\))+(?=\s*\))/,
          lookbehind: true,
          alias: "selector"
        },
        "keyword": {
          pattern: /(^|[^\w-])(?:and|not|only|or)(?![\w-])/,
          lookbehind: true
        }
        // See rest below
      }
    },
    "url": {
      // https://drafts.csswg.org/css-values-3/#urls
      pattern: RegExp("\\burl\\((?:" + string3.source + "|" + /(?:[^\\\r\n()"']|\\[\s\S])*/.source + ")\\)", "i"),
      greedy: true,
      inside: {
        "function": /^url/i,
        "punctuation": /^\(|\)$/,
        "string": {
          pattern: RegExp("^" + string3.source + "$"),
          alias: "url"
        }
      }
    },
    "selector": {
      pattern: RegExp(`(^|[{}\\s])[^{}\\s](?:[^{};"'\\s]|\\s+(?![\\s{])|` + string3.source + ")*(?=\\s*\\{)"),
      lookbehind: true
    },
    "string": {
      pattern: string3,
      greedy: true
    },
    "property": {
      pattern: /(^|[^-\w\xA0-\uFFFF])(?!\s)[-_a-z\xA0-\uFFFF](?:(?!\s)[-\w\xA0-\uFFFF])*(?=\s*:)/i,
      lookbehind: true
    },
    "important": /!important\b/i,
    "function": {
      pattern: /(^|[^-a-z0-9])[-a-z0-9]+(?=\()/i,
      lookbehind: true
    },
    "punctuation": /[(){};:,]/
  };
  Prism3.languages.css["atrule"].inside.rest = Prism3.languages.css;
  var markup = Prism3.languages.markup;
  if (markup) {
    markup.tag.addInlined("style", "css");
    markup.tag.addAttribute("style", "css");
  }
})(Prism);

// node_modules/prismjs/components/prism-objectivec.js
Prism.languages.objectivec = Prism.languages.extend("c", {
  "string": {
    pattern: /@?"(?:\\(?:\r\n|[\s\S])|[^"\\\r\n])*"/,
    greedy: true
  },
  "keyword": /\b(?:asm|auto|break|case|char|const|continue|default|do|double|else|enum|extern|float|for|goto|if|in|inline|int|long|register|return|self|short|signed|sizeof|static|struct|super|switch|typedef|typeof|union|unsigned|void|volatile|while)\b|(?:@interface|@end|@implementation|@protocol|@class|@public|@protected|@private|@property|@try|@catch|@finally|@throw|@synthesize|@dynamic|@selector)\b/,
  "operator": /-[->]?|\+\+?|!=?|<<?=?|>>?=?|==?|&&?|\|\|?|[~^%?*\/@]/
});
delete Prism.languages.objectivec["class-name"];
Prism.languages.objc = Prism.languages.objectivec;

// node_modules/prismjs/components/prism-sql.js
Prism.languages.sql = {
  "comment": {
    pattern: /(^|[^\\])(?:\/\*[\s\S]*?\*\/|(?:--|\/\/|#).*)/,
    lookbehind: true
  },
  "variable": [
    {
      pattern: /@(["'`])(?:\\[\s\S]|(?!\1)[^\\])+\1/,
      greedy: true
    },
    /@[\w.$]+/
  ],
  "string": {
    pattern: /(^|[^@\\])("|')(?:\\[\s\S]|(?!\2)[^\\]|\2\2)*\2/,
    greedy: true,
    lookbehind: true
  },
  "identifier": {
    pattern: /(^|[^@\\])`(?:\\[\s\S]|[^`\\]|``)*`/,
    greedy: true,
    lookbehind: true,
    inside: {
      "punctuation": /^`|`$/
    }
  },
  "function": /\b(?:AVG|COUNT|FIRST|FORMAT|LAST|LCASE|LEN|MAX|MID|MIN|MOD|NOW|ROUND|SUM|UCASE)(?=\s*\()/i,
  // Should we highlight user defined functions too?
  "keyword": /\b(?:ACTION|ADD|AFTER|ALGORITHM|ALL|ALTER|ANALYZE|ANY|APPLY|AS|ASC|AUTHORIZATION|AUTO_INCREMENT|BACKUP|BDB|BEGIN|BERKELEYDB|BIGINT|BINARY|BIT|BLOB|BOOL|BOOLEAN|BREAK|BROWSE|BTREE|BULK|BY|CALL|CASCADED?|CASE|CHAIN|CHAR(?:ACTER|SET)?|CHECK(?:POINT)?|CLOSE|CLUSTERED|COALESCE|COLLATE|COLUMNS?|COMMENT|COMMIT(?:TED)?|COMPUTE|CONNECT|CONSISTENT|CONSTRAINT|CONTAINS(?:TABLE)?|CONTINUE|CONVERT|CREATE|CROSS|CURRENT(?:_DATE|_TIME|_TIMESTAMP|_USER)?|CURSOR|CYCLE|DATA(?:BASES?)?|DATE(?:TIME)?|DAY|DBCC|DEALLOCATE|DEC|DECIMAL|DECLARE|DEFAULT|DEFINER|DELAYED|DELETE|DELIMITERS?|DENY|DESC|DESCRIBE|DETERMINISTIC|DISABLE|DISCARD|DISK|DISTINCT|DISTINCTROW|DISTRIBUTED|DO|DOUBLE|DROP|DUMMY|DUMP(?:FILE)?|DUPLICATE|ELSE(?:IF)?|ENABLE|ENCLOSED|END|ENGINE|ENUM|ERRLVL|ERRORS|ESCAPED?|EXCEPT|EXEC(?:UTE)?|EXISTS|EXIT|EXPLAIN|EXTENDED|FETCH|FIELDS|FILE|FILLFACTOR|FIRST|FIXED|FLOAT|FOLLOWING|FOR(?: EACH ROW)?|FORCE|FOREIGN|FREETEXT(?:TABLE)?|FROM|FULL|FUNCTION|GEOMETRY(?:COLLECTION)?|GLOBAL|GOTO|GRANT|GROUP|HANDLER|HASH|HAVING|HOLDLOCK|HOUR|IDENTITY(?:COL|_INSERT)?|IF|IGNORE|IMPORT|INDEX|INFILE|INNER|INNODB|INOUT|INSERT|INT|INTEGER|INTERSECT|INTERVAL|INTO|INVOKER|ISOLATION|ITERATE|JOIN|KEYS?|KILL|LANGUAGE|LAST|LEAVE|LEFT|LEVEL|LIMIT|LINENO|LINES|LINESTRING|LOAD|LOCAL|LOCK|LONG(?:BLOB|TEXT)|LOOP|MATCH(?:ED)?|MEDIUM(?:BLOB|INT|TEXT)|MERGE|MIDDLEINT|MINUTE|MODE|MODIFIES|MODIFY|MONTH|MULTI(?:LINESTRING|POINT|POLYGON)|NATIONAL|NATURAL|NCHAR|NEXT|NO|NONCLUSTERED|NULLIF|NUMERIC|OFF?|OFFSETS?|ON|OPEN(?:DATASOURCE|QUERY|ROWSET)?|OPTIMIZE|OPTION(?:ALLY)?|ORDER|OUT(?:ER|FILE)?|OVER|PARTIAL|PARTITION|PERCENT|PIVOT|PLAN|POINT|POLYGON|PRECEDING|PRECISION|PREPARE|PREV|PRIMARY|PRINT|PRIVILEGES|PROC(?:EDURE)?|PUBLIC|PURGE|QUICK|RAISERROR|READS?|REAL|RECONFIGURE|REFERENCES|RELEASE|RENAME|REPEAT(?:ABLE)?|REPLACE|REPLICATION|REQUIRE|RESIGNAL|RESTORE|RESTRICT|RETURN(?:ING|S)?|REVOKE|RIGHT|ROLLBACK|ROUTINE|ROW(?:COUNT|GUIDCOL|S)?|RTREE|RULE|SAVE(?:POINT)?|SCHEMA|SECOND|SELECT|SERIAL(?:IZABLE)?|SESSION(?:_USER)?|SET(?:USER)?|SHARE|SHOW|SHUTDOWN|SIMPLE|SMALLINT|SNAPSHOT|SOME|SONAME|SQL|START(?:ING)?|STATISTICS|STATUS|STRIPED|SYSTEM_USER|TABLES?|TABLESPACE|TEMP(?:ORARY|TABLE)?|TERMINATED|TEXT(?:SIZE)?|THEN|TIME(?:STAMP)?|TINY(?:BLOB|INT|TEXT)|TOP?|TRAN(?:SACTIONS?)?|TRIGGER|TRUNCATE|TSEQUAL|TYPES?|UNBOUNDED|UNCOMMITTED|UNDEFINED|UNION|UNIQUE|UNLOCK|UNPIVOT|UNSIGNED|UPDATE(?:TEXT)?|USAGE|USE|USER|USING|VALUES?|VAR(?:BINARY|CHAR|CHARACTER|YING)|VIEW|WAITFOR|WARNINGS|WHEN|WHERE|WHILE|WITH(?: ROLLUP|IN)?|WORK|WRITE(?:TEXT)?|YEAR)\b/i,
  "boolean": /\b(?:FALSE|NULL|TRUE)\b/i,
  "number": /\b0x[\da-f]+\b|\b\d+(?:\.\d*)?|\B\.\d+\b/i,
  "operator": /[-+*\/=%^~]|&&?|\|\|?|!=?|<(?:=>?|<|>)?|>[>=]?|\b(?:AND|BETWEEN|DIV|ILIKE|IN|IS|LIKE|NOT|OR|REGEXP|RLIKE|SOUNDS LIKE|XOR)\b/i,
  "punctuation": /[;[\]()`,.]/
};

// node_modules/prismjs/components/prism-powershell.js
(function(Prism3) {
  var powershell = Prism3.languages.powershell = {
    "comment": [
      {
        pattern: /(^|[^`])<#[\s\S]*?#>/,
        lookbehind: true
      },
      {
        pattern: /(^|[^`])#.*/,
        lookbehind: true
      }
    ],
    "string": [
      {
        pattern: /"(?:`[\s\S]|[^`"])*"/,
        greedy: true,
        inside: null
        // see below
      },
      {
        pattern: /'(?:[^']|'')*'/,
        greedy: true
      }
    ],
    // Matches name spaces as well as casts, attribute decorators. Force starting with letter to avoid matching array indices
    // Supports two levels of nested brackets (e.g. `[OutputType([System.Collections.Generic.List[int]])]`)
    "namespace": /\[[a-z](?:\[(?:\[[^\]]*\]|[^\[\]])*\]|[^\[\]])*\]/i,
    "boolean": /\$(?:false|true)\b/i,
    "variable": /\$\w+\b/,
    // Cmdlets and aliases. Aliases should come last, otherwise "write" gets preferred over "write-host" for example
    // Get-Command | ?{ $_.ModuleName -match "Microsoft.PowerShell.(Util|Core|Management)" }
    // Get-Alias | ?{ $_.ReferencedCommand.Module.Name -match "Microsoft.PowerShell.(Util|Core|Management)" }
    "function": [
      /\b(?:Add|Approve|Assert|Backup|Block|Checkpoint|Clear|Close|Compare|Complete|Compress|Confirm|Connect|Convert|ConvertFrom|ConvertTo|Copy|Debug|Deny|Disable|Disconnect|Dismount|Edit|Enable|Enter|Exit|Expand|Export|Find|ForEach|Format|Get|Grant|Group|Hide|Import|Initialize|Install|Invoke|Join|Limit|Lock|Measure|Merge|Move|New|Open|Optimize|Out|Ping|Pop|Protect|Publish|Push|Read|Receive|Redo|Register|Remove|Rename|Repair|Request|Reset|Resize|Resolve|Restart|Restore|Resume|Revoke|Save|Search|Select|Send|Set|Show|Skip|Sort|Split|Start|Step|Stop|Submit|Suspend|Switch|Sync|Tee|Test|Trace|Unblock|Undo|Uninstall|Unlock|Unprotect|Unpublish|Unregister|Update|Use|Wait|Watch|Where|Write)-[a-z]+\b/i,
      /\b(?:ac|cat|chdir|clc|cli|clp|clv|compare|copy|cp|cpi|cpp|cvpa|dbp|del|diff|dir|ebp|echo|epal|epcsv|epsn|erase|fc|fl|ft|fw|gal|gbp|gc|gci|gcs|gdr|gi|gl|gm|gp|gps|group|gsv|gu|gv|gwmi|iex|ii|ipal|ipcsv|ipsn|irm|iwmi|iwr|kill|lp|ls|measure|mi|mount|move|mp|mv|nal|ndr|ni|nv|ogv|popd|ps|pushd|pwd|rbp|rd|rdr|ren|ri|rm|rmdir|rni|rnp|rp|rv|rvpa|rwmi|sal|saps|sasv|sbp|sc|select|set|shcm|si|sl|sleep|sls|sort|sp|spps|spsv|start|sv|swmi|tee|trcm|type|write)\b/i
    ],
    // per http://technet.microsoft.com/en-us/library/hh847744.aspx
    "keyword": /\b(?:Begin|Break|Catch|Class|Continue|Data|Define|Do|DynamicParam|Else|ElseIf|End|Exit|Filter|Finally|For|ForEach|From|Function|If|InlineScript|Parallel|Param|Process|Return|Sequence|Switch|Throw|Trap|Try|Until|Using|Var|While|Workflow)\b/i,
    "operator": {
      pattern: /(^|\W)(?:!|-(?:b?(?:and|x?or)|as|(?:Not)?(?:Contains|In|Like|Match)|eq|ge|gt|is(?:Not)?|Join|le|lt|ne|not|Replace|sh[lr])\b|-[-=]?|\+[+=]?|[*\/%]=?)/i,
      lookbehind: true
    },
    "punctuation": /[|{}[\];(),.]/
  };
  powershell.string[0].inside = {
    "function": {
      // Allow for one level of nesting
      pattern: /(^|[^`])\$\((?:\$\([^\r\n()]*\)|(?!\$\()[^\r\n)])*\)/,
      lookbehind: true,
      inside: powershell
    },
    "boolean": powershell.boolean,
    "variable": powershell.variable
  };
})(Prism);

// node_modules/prismjs/components/prism-python.js
Prism.languages.python = {
  "comment": {
    pattern: /(^|[^\\])#.*/,
    lookbehind: true,
    greedy: true
  },
  "string-interpolation": {
    pattern: /(?:f|fr|rf)(?:("""|''')[\s\S]*?\1|("|')(?:\\.|(?!\2)[^\\\r\n])*\2)/i,
    greedy: true,
    inside: {
      "interpolation": {
        // "{" <expression> <optional "!s", "!r", or "!a"> <optional ":" format specifier> "}"
        pattern: /((?:^|[^{])(?:\{\{)*)\{(?!\{)(?:[^{}]|\{(?!\{)(?:[^{}]|\{(?!\{)(?:[^{}])+\})+\})+\}/,
        lookbehind: true,
        inside: {
          "format-spec": {
            pattern: /(:)[^:(){}]+(?=\}$)/,
            lookbehind: true
          },
          "conversion-option": {
            pattern: /![sra](?=[:}]$)/,
            alias: "punctuation"
          },
          rest: null
        }
      },
      "string": /[\s\S]+/
    }
  },
  "triple-quoted-string": {
    pattern: /(?:[rub]|br|rb)?("""|''')[\s\S]*?\1/i,
    greedy: true,
    alias: "string"
  },
  "string": {
    pattern: /(?:[rub]|br|rb)?("|')(?:\\.|(?!\1)[^\\\r\n])*\1/i,
    greedy: true
  },
  "function": {
    pattern: /((?:^|\s)def[ \t]+)[a-zA-Z_]\w*(?=\s*\()/g,
    lookbehind: true
  },
  "class-name": {
    pattern: /(\bclass\s+)\w+/i,
    lookbehind: true
  },
  "decorator": {
    pattern: /(^[\t ]*)@\w+(?:\.\w+)*/m,
    lookbehind: true,
    alias: ["annotation", "punctuation"],
    inside: {
      "punctuation": /\./
    }
  },
  "keyword": /\b(?:_(?=\s*:)|and|as|assert|async|await|break|case|class|continue|def|del|elif|else|except|exec|finally|for|from|global|if|import|in|is|lambda|match|nonlocal|not|or|pass|print|raise|return|try|while|with|yield)\b/,
  "builtin": /\b(?:__import__|abs|all|any|apply|ascii|basestring|bin|bool|buffer|bytearray|bytes|callable|chr|classmethod|cmp|coerce|compile|complex|delattr|dict|dir|divmod|enumerate|eval|execfile|file|filter|float|format|frozenset|getattr|globals|hasattr|hash|help|hex|id|input|int|intern|isinstance|issubclass|iter|len|list|locals|long|map|max|memoryview|min|next|object|oct|open|ord|pow|property|range|raw_input|reduce|reload|repr|reversed|round|set|setattr|slice|sorted|staticmethod|str|sum|super|tuple|type|unichr|unicode|vars|xrange|zip)\b/,
  "boolean": /\b(?:False|None|True)\b/,
  "number": /\b0(?:b(?:_?[01])+|o(?:_?[0-7])+|x(?:_?[a-f0-9])+)\b|(?:\b\d+(?:_\d+)*(?:\.(?:\d+(?:_\d+)*)?)?|\B\.\d+(?:_\d+)*)(?:e[+-]?\d+(?:_\d+)*)?j?(?!\w)/i,
  "operator": /[-+%=]=?|!=|:=|\*\*?=?|\/\/?=?|<[<=>]?|>[=>]?|[&|^~]/,
  "punctuation": /[{}[\];(),.:]/
};
Prism.languages.python["string-interpolation"].inside["interpolation"].inside.rest = Prism.languages.python;
Prism.languages.py = Prism.languages.python;

// node_modules/prismjs/components/prism-rust.js
(function(Prism3) {
  var multilineComment = /\/\*(?:[^*/]|\*(?!\/)|\/(?!\*)|<self>)*\*\//.source;
  for (var i3 = 0; i3 < 2; i3++) {
    multilineComment = multilineComment.replace(/<self>/g, function() {
      return multilineComment;
    });
  }
  multilineComment = multilineComment.replace(/<self>/g, function() {
    return /[^\s\S]/.source;
  });
  Prism3.languages.rust = {
    "comment": [
      {
        pattern: RegExp(/(^|[^\\])/.source + multilineComment),
        lookbehind: true,
        greedy: true
      },
      {
        pattern: /(^|[^\\:])\/\/.*/,
        lookbehind: true,
        greedy: true
      }
    ],
    "string": {
      pattern: /b?"(?:\\[\s\S]|[^\\"])*"|b?r(#*)"(?:[^"]|"(?!\1))*"\1/,
      greedy: true
    },
    "char": {
      pattern: /b?'(?:\\(?:x[0-7][\da-fA-F]|u\{(?:[\da-fA-F]_*){1,6}\}|.)|[^\\\r\n\t'])'/,
      greedy: true
    },
    "attribute": {
      pattern: /#!?\[(?:[^\[\]"]|"(?:\\[\s\S]|[^\\"])*")*\]/,
      greedy: true,
      alias: "attr-name",
      inside: {
        "string": null
        // see below
      }
    },
    // Closure params should not be confused with bitwise OR |
    "closure-params": {
      pattern: /([=(,:]\s*|\bmove\s*)\|[^|]*\||\|[^|]*\|(?=\s*(?:\{|->))/,
      lookbehind: true,
      greedy: true,
      inside: {
        "closure-punctuation": {
          pattern: /^\||\|$/,
          alias: "punctuation"
        },
        rest: null
        // see below
      }
    },
    "lifetime-annotation": {
      pattern: /'\w+/,
      alias: "symbol"
    },
    "fragment-specifier": {
      pattern: /(\$\w+:)[a-z]+/,
      lookbehind: true,
      alias: "punctuation"
    },
    "variable": /\$\w+/,
    "function-definition": {
      pattern: /(\bfn\s+)\w+/,
      lookbehind: true,
      alias: "function"
    },
    "type-definition": {
      pattern: /(\b(?:enum|struct|trait|type|union)\s+)\w+/,
      lookbehind: true,
      alias: "class-name"
    },
    "module-declaration": [
      {
        pattern: /(\b(?:crate|mod)\s+)[a-z][a-z_\d]*/,
        lookbehind: true,
        alias: "namespace"
      },
      {
        pattern: /(\b(?:crate|self|super)\s*)::\s*[a-z][a-z_\d]*\b(?:\s*::(?:\s*[a-z][a-z_\d]*\s*::)*)?/,
        lookbehind: true,
        alias: "namespace",
        inside: {
          "punctuation": /::/
        }
      }
    ],
    "keyword": [
      // https://github.com/rust-lang/reference/blob/master/src/keywords.md
      /\b(?:Self|abstract|as|async|await|become|box|break|const|continue|crate|do|dyn|else|enum|extern|final|fn|for|if|impl|in|let|loop|macro|match|mod|move|mut|override|priv|pub|ref|return|self|static|struct|super|trait|try|type|typeof|union|unsafe|unsized|use|virtual|where|while|yield)\b/,
      // primitives and str
      // https://doc.rust-lang.org/stable/rust-by-example/primitives.html
      /\b(?:bool|char|f(?:32|64)|[ui](?:8|16|32|64|128|size)|str)\b/
    ],
    // functions can technically start with an upper-case letter, but this will introduce a lot of false positives
    // and Rust's naming conventions recommend snake_case anyway.
    // https://doc.rust-lang.org/1.0.0/style/style/naming/README.html
    "function": /\b[a-z_]\w*(?=\s*(?:::\s*<|\())/,
    "macro": {
      pattern: /\b\w+!/,
      alias: "property"
    },
    "constant": /\b[A-Z_][A-Z_\d]+\b/,
    "class-name": /\b[A-Z]\w*\b/,
    "namespace": {
      pattern: /(?:\b[a-z][a-z_\d]*\s*::\s*)*\b[a-z][a-z_\d]*\s*::(?!\s*<)/,
      inside: {
        "punctuation": /::/
      }
    },
    // Hex, oct, bin, dec numbers with visual separators and type suffix
    "number": /\b(?:0x[\dA-Fa-f](?:_?[\dA-Fa-f])*|0o[0-7](?:_?[0-7])*|0b[01](?:_?[01])*|(?:(?:\d(?:_?\d)*)?\.)?\d(?:_?\d)*(?:[Ee][+-]?\d+)?)(?:_?(?:f32|f64|[iu](?:8|16|32|64|size)?))?\b/,
    "boolean": /\b(?:false|true)\b/,
    "punctuation": /->|\.\.=|\.{1,3}|::|[{}[\];(),:]/,
    "operator": /[-+*\/%!^]=?|=[=>]?|&[&=]?|\|[|=]?|<<?=?|>>?=?|[@?]/
  };
  Prism3.languages.rust["closure-params"].inside.rest = Prism3.languages.rust;
  Prism3.languages.rust["attribute"].inside["string"] = Prism3.languages.rust["string"];
})(Prism);

// node_modules/prismjs/components/prism-swift.js
Prism.languages.swift = {
  "comment": {
    // Nested comments are supported up to 2 levels
    pattern: /(^|[^\\:])(?:\/\/.*|\/\*(?:[^/*]|\/(?!\*)|\*(?!\/)|\/\*(?:[^*]|\*(?!\/))*\*\/)*\*\/)/,
    lookbehind: true,
    greedy: true
  },
  "string-literal": [
    // https://docs.swift.org/swift-book/LanguageGuide/StringsAndCharacters.html
    {
      pattern: RegExp(
        /(^|[^"#])/.source + "(?:" + /"(?:\\(?:\((?:[^()]|\([^()]*\))*\)|\r\n|[^(])|[^\\\r\n"])*"/.source + "|" + /"""(?:\\(?:\((?:[^()]|\([^()]*\))*\)|[^(])|[^\\"]|"(?!""))*"""/.source + ")" + /(?!["#])/.source
      ),
      lookbehind: true,
      greedy: true,
      inside: {
        "interpolation": {
          pattern: /(\\\()(?:[^()]|\([^()]*\))*(?=\))/,
          lookbehind: true,
          inside: null
          // see below
        },
        "interpolation-punctuation": {
          pattern: /^\)|\\\($/,
          alias: "punctuation"
        },
        "punctuation": /\\(?=[\r\n])/,
        "string": /[\s\S]+/
      }
    },
    {
      pattern: RegExp(
        /(^|[^"#])(#+)/.source + "(?:" + /"(?:\\(?:#+\((?:[^()]|\([^()]*\))*\)|\r\n|[^#])|[^\\\r\n])*?"/.source + "|" + /"""(?:\\(?:#+\((?:[^()]|\([^()]*\))*\)|[^#])|[^\\])*?"""/.source + ")\\2"
      ),
      lookbehind: true,
      greedy: true,
      inside: {
        "interpolation": {
          pattern: /(\\#+\()(?:[^()]|\([^()]*\))*(?=\))/,
          lookbehind: true,
          inside: null
          // see below
        },
        "interpolation-punctuation": {
          pattern: /^\)|\\#+\($/,
          alias: "punctuation"
        },
        "string": /[\s\S]+/
      }
    }
  ],
  "directive": {
    // directives with conditions
    pattern: RegExp(
      /#/.source + "(?:" + (/(?:elseif|if)\b/.source + "(?:[ 	]*" + /(?:![ \t]*)?(?:\b\w+\b(?:[ \t]*\((?:[^()]|\([^()]*\))*\))?|\((?:[^()]|\([^()]*\))*\))(?:[ \t]*(?:&&|\|\|))?/.source + ")+") + "|" + /(?:else|endif)\b/.source + ")"
    ),
    alias: "property",
    inside: {
      "directive-name": /^#\w+/,
      "boolean": /\b(?:false|true)\b/,
      "number": /\b\d+(?:\.\d+)*\b/,
      "operator": /!|&&|\|\||[<>]=?/,
      "punctuation": /[(),]/
    }
  },
  "literal": {
    pattern: /#(?:colorLiteral|column|dsohandle|file(?:ID|Literal|Path)?|function|imageLiteral|line)\b/,
    alias: "constant"
  },
  "other-directive": {
    pattern: /#\w+\b/,
    alias: "property"
  },
  "attribute": {
    pattern: /@\w+/,
    alias: "atrule"
  },
  "function-definition": {
    pattern: /(\bfunc\s+)\w+/,
    lookbehind: true,
    alias: "function"
  },
  "label": {
    // https://docs.swift.org/swift-book/LanguageGuide/ControlFlow.html#ID141
    pattern: /\b(break|continue)\s+\w+|\b[a-zA-Z_]\w*(?=\s*:\s*(?:for|repeat|while)\b)/,
    lookbehind: true,
    alias: "important"
  },
  "keyword": /\b(?:Any|Protocol|Self|Type|actor|as|assignment|associatedtype|associativity|async|await|break|case|catch|class|continue|convenience|default|defer|deinit|didSet|do|dynamic|else|enum|extension|fallthrough|fileprivate|final|for|func|get|guard|higherThan|if|import|in|indirect|infix|init|inout|internal|is|isolated|lazy|left|let|lowerThan|mutating|none|nonisolated|nonmutating|open|operator|optional|override|postfix|precedencegroup|prefix|private|protocol|public|repeat|required|rethrows|return|right|safe|self|set|some|static|struct|subscript|super|switch|throw|throws|try|typealias|unowned|unsafe|var|weak|where|while|willSet)\b/,
  "boolean": /\b(?:false|true)\b/,
  "nil": {
    pattern: /\bnil\b/,
    alias: "constant"
  },
  "short-argument": /\$\d+\b/,
  "omit": {
    pattern: /\b_\b/,
    alias: "keyword"
  },
  "number": /\b(?:[\d_]+(?:\.[\de_]+)?|0x[a-f0-9_]+(?:\.[a-f0-9p_]+)?|0b[01_]+|0o[0-7_]+)\b/i,
  // A class name must start with an upper-case letter and be either 1 letter long or contain a lower-case letter.
  "class-name": /\b[A-Z](?:[A-Z_\d]*[a-z]\w*)?\b/,
  "function": /\b[a-z_]\w*(?=\s*\()/i,
  "constant": /\b(?:[A-Z_]{2,}|k[A-Z][A-Za-z_]+)\b/,
  // Operators are generic in Swift. Developers can even create new operators (e.g. +++).
  // https://docs.swift.org/swift-book/ReferenceManual/zzSummaryOfTheGrammar.html#ID481
  // This regex only supports ASCII operators.
  "operator": /[-+*/%=!<>&|^~?]+|\.[.\-+*/%=!<>&|^~?]+/,
  "punctuation": /[{}[\]();,.:\\]/
};
Prism.languages.swift["string-literal"].forEach(function(rule) {
  rule.inside["interpolation"].inside = Prism.languages.swift;
});

// node_modules/prismjs/components/prism-typescript.js
(function(Prism3) {
  Prism3.languages.typescript = Prism3.languages.extend("javascript", {
    "class-name": {
      pattern: /(\b(?:class|extends|implements|instanceof|interface|new|type)\s+)(?!keyof\b)(?!\s)[_$a-zA-Z\xA0-\uFFFF](?:(?!\s)[$\w\xA0-\uFFFF])*(?:\s*<(?:[^<>]|<(?:[^<>]|<[^<>]*>)*>)*>)?/,
      lookbehind: true,
      greedy: true,
      inside: null
      // see below
    },
    "builtin": /\b(?:Array|Function|Promise|any|boolean|console|never|number|string|symbol|unknown)\b/
  });
  Prism3.languages.typescript.keyword.push(
    /\b(?:abstract|declare|is|keyof|readonly|require)\b/,
    // keywords that have to be followed by an identifier
    /\b(?:asserts|infer|interface|module|namespace|type)\b(?=\s*(?:[{_$a-zA-Z\xA0-\uFFFF]|$))/,
    // This is for `import type *, {}`
    /\btype\b(?=\s*(?:[\{*]|$))/
  );
  delete Prism3.languages.typescript["parameter"];
  delete Prism3.languages.typescript["literal-property"];
  var typeInside = Prism3.languages.extend("typescript", {});
  delete typeInside["class-name"];
  Prism3.languages.typescript["class-name"].inside = typeInside;
  Prism3.languages.insertBefore("typescript", "function", {
    "decorator": {
      pattern: /@[$\w\xA0-\uFFFF]+/,
      inside: {
        "at": {
          pattern: /^@/,
          alias: "operator"
        },
        "function": /^[\s\S]+/
      }
    },
    "generic-function": {
      // e.g. foo<T extends "bar" | "baz">( ...
      pattern: /#?(?!\s)[_$a-zA-Z\xA0-\uFFFF](?:(?!\s)[$\w\xA0-\uFFFF])*\s*<(?:[^<>]|<(?:[^<>]|<[^<>]*>)*>)*>(?=\s*\()/,
      greedy: true,
      inside: {
        "function": /^#?(?!\s)[_$a-zA-Z\xA0-\uFFFF](?:(?!\s)[$\w\xA0-\uFFFF])*/,
        "generic": {
          pattern: /<[\s\S]+/,
          // everything after the first <
          alias: "class-name",
          inside: typeInside
        }
      }
    }
  });
  Prism3.languages.ts = Prism3.languages.typescript;
})(Prism);

// node_modules/prismjs/components/prism-java.js
(function(Prism3) {
  var keywords2 = /\b(?:abstract|assert|boolean|break|byte|case|catch|char|class|const|continue|default|do|double|else|enum|exports|extends|final|finally|float|for|goto|if|implements|import|instanceof|int|interface|long|module|native|new|non-sealed|null|open|opens|package|permits|private|protected|provides|public|record(?!\s*[(){}[\]<>=%~.:,;?+\-*/&|^])|requires|return|sealed|short|static|strictfp|super|switch|synchronized|this|throw|throws|to|transient|transitive|try|uses|var|void|volatile|while|with|yield)\b/;
  var classNamePrefix = /(?:[a-z]\w*\s*\.\s*)*(?:[A-Z]\w*\s*\.\s*)*/.source;
  var className = {
    pattern: RegExp(/(^|[^\w.])/.source + classNamePrefix + /[A-Z](?:[\d_A-Z]*[a-z]\w*)?\b/.source),
    lookbehind: true,
    inside: {
      "namespace": {
        pattern: /^[a-z]\w*(?:\s*\.\s*[a-z]\w*)*(?:\s*\.)?/,
        inside: {
          "punctuation": /\./
        }
      },
      "punctuation": /\./
    }
  };
  Prism3.languages.java = Prism3.languages.extend("clike", {
    "string": {
      pattern: /(^|[^\\])"(?:\\.|[^"\\\r\n])*"/,
      lookbehind: true,
      greedy: true
    },
    "class-name": [
      className,
      {
        // variables, parameters, and constructor references
        // this to support class names (or generic parameters) which do not contain a lower case letter (also works for methods)
        pattern: RegExp(/(^|[^\w.])/.source + classNamePrefix + /[A-Z]\w*(?=\s+\w+\s*[;,=()]|\s*(?:\[[\s,]*\]\s*)?::\s*new\b)/.source),
        lookbehind: true,
        inside: className.inside
      },
      {
        // class names based on keyword
        // this to support class names (or generic parameters) which do not contain a lower case letter (also works for methods)
        pattern: RegExp(/(\b(?:class|enum|extends|implements|instanceof|interface|new|record|throws)\s+)/.source + classNamePrefix + /[A-Z]\w*\b/.source),
        lookbehind: true,
        inside: className.inside
      }
    ],
    "keyword": keywords2,
    "function": [
      Prism3.languages.clike.function,
      {
        pattern: /(::\s*)[a-z_]\w*/,
        lookbehind: true
      }
    ],
    "number": /\b0b[01][01_]*L?\b|\b0x(?:\.[\da-f_p+-]+|[\da-f_]+(?:\.[\da-f_p+-]+)?)\b|(?:\b\d[\d_]*(?:\.[\d_]*)?|\B\.\d[\d_]*)(?:e[+-]?\d[\d_]*)?[dfl]?/i,
    "operator": {
      pattern: /(^|[^.])(?:<<=?|>>>?=?|->|--|\+\+|&&|\|\||::|[?:~]|[-+*/%&|^!=<>]=?)/m,
      lookbehind: true
    },
    "constant": /\b[A-Z][A-Z_\d]+\b/
  });
  Prism3.languages.insertBefore("java", "string", {
    "triple-quoted-string": {
      // http://openjdk.java.net/jeps/355#Description
      pattern: /"""[ \t]*[\r\n](?:(?:"|"")?(?:\\.|[^"\\]))*"""/,
      greedy: true,
      alias: "string"
    },
    "char": {
      pattern: /'(?:\\.|[^'\\\r\n]){1,6}'/,
      greedy: true
    }
  });
  Prism3.languages.insertBefore("java", "class-name", {
    "annotation": {
      pattern: /(^|[^.])@\w+(?:\s*\.\s*\w+)*/,
      lookbehind: true,
      alias: "punctuation"
    },
    "generics": {
      pattern: /<(?:[\w\s,.?]|&(?!&)|<(?:[\w\s,.?]|&(?!&)|<(?:[\w\s,.?]|&(?!&)|<(?:[\w\s,.?]|&(?!&))*>)*>)*>)*>/,
      inside: {
        "class-name": className,
        "keyword": keywords2,
        "punctuation": /[<>(),.:]/,
        "operator": /[?&|]/
      }
    },
    "import": [
      {
        pattern: RegExp(/(\bimport\s+)/.source + classNamePrefix + /(?:[A-Z]\w*|\*)(?=\s*;)/.source),
        lookbehind: true,
        inside: {
          "namespace": className.inside.namespace,
          "punctuation": /\./,
          "operator": /\*/,
          "class-name": /\w+/
        }
      },
      {
        pattern: RegExp(/(\bimport\s+static\s+)/.source + classNamePrefix + /(?:\w+|\*)(?=\s*;)/.source),
        lookbehind: true,
        alias: "static",
        inside: {
          "namespace": className.inside.namespace,
          "static": /\b\w+$/,
          "punctuation": /\./,
          "operator": /\*/,
          "class-name": /\w+/
        }
      }
    ],
    "namespace": {
      pattern: RegExp(
        /(\b(?:exports|import(?:\s+static)?|module|open|opens|package|provides|requires|to|transitive|uses|with)\s+)(?!<keyword>)[a-z]\w*(?:\.[a-z]\w*)*\.?/.source.replace(/<keyword>/g, function() {
          return keywords2.source;
        })
      ),
      lookbehind: true,
      inside: {
        "punctuation": /\./
      }
    }
  });
})(Prism);

// node_modules/prismjs/components/prism-cpp.js
(function(Prism3) {
  var keyword = /\b(?:alignas|alignof|asm|auto|bool|break|case|catch|char|char16_t|char32_t|char8_t|class|co_await|co_return|co_yield|compl|concept|const|const_cast|consteval|constexpr|constinit|continue|decltype|default|delete|do|double|dynamic_cast|else|enum|explicit|export|extern|final|float|for|friend|goto|if|import|inline|int|int16_t|int32_t|int64_t|int8_t|long|module|mutable|namespace|new|noexcept|nullptr|operator|override|private|protected|public|register|reinterpret_cast|requires|return|short|signed|sizeof|static|static_assert|static_cast|struct|switch|template|this|thread_local|throw|try|typedef|typeid|typename|uint16_t|uint32_t|uint64_t|uint8_t|union|unsigned|using|virtual|void|volatile|wchar_t|while)\b/;
  var modName = /\b(?!<keyword>)\w+(?:\s*\.\s*\w+)*\b/.source.replace(/<keyword>/g, function() {
    return keyword.source;
  });
  Prism3.languages.cpp = Prism3.languages.extend("c", {
    "class-name": [
      {
        pattern: RegExp(/(\b(?:class|concept|enum|struct|typename)\s+)(?!<keyword>)\w+/.source.replace(/<keyword>/g, function() {
          return keyword.source;
        })),
        lookbehind: true
      },
      // This is intended to capture the class name of method implementations like:
      //   void foo::bar() const {}
      // However! The `foo` in the above example could also be a namespace, so we only capture the class name if
      // it starts with an uppercase letter. This approximation should give decent results.
      /\b[A-Z]\w*(?=\s*::\s*\w+\s*\()/,
      // This will capture the class name before destructors like:
      //   Foo::~Foo() {}
      /\b[A-Z_]\w*(?=\s*::\s*~\w+\s*\()/i,
      // This also intends to capture the class name of method implementations but here the class has template
      // parameters, so it can't be a namespace (until C++ adds generic namespaces).
      /\b\w+(?=\s*<(?:[^<>]|<(?:[^<>]|<[^<>]*>)*>)*>\s*::\s*\w+\s*\()/
    ],
    "keyword": keyword,
    "number": {
      pattern: /(?:\b0b[01']+|\b0x(?:[\da-f']+(?:\.[\da-f']*)?|\.[\da-f']+)(?:p[+-]?[\d']+)?|(?:\b[\d']+(?:\.[\d']*)?|\B\.[\d']+)(?:e[+-]?[\d']+)?)[ful]{0,4}/i,
      greedy: true
    },
    "operator": />>=?|<<=?|->|--|\+\+|&&|\|\||[?:~]|<=>|[-+*/%&|^!=<>]=?|\b(?:and|and_eq|bitand|bitor|not|not_eq|or|or_eq|xor|xor_eq)\b/,
    "boolean": /\b(?:false|true)\b/
  });
  Prism3.languages.insertBefore("cpp", "string", {
    "module": {
      // https://en.cppreference.com/w/cpp/language/modules
      pattern: RegExp(
        /(\b(?:import|module)\s+)/.source + "(?:" + // header-name
        /"(?:\\(?:\r\n|[\s\S])|[^"\\\r\n])*"|<[^<>\r\n]*>/.source + "|" + // module name or partition or both
        /<mod-name>(?:\s*:\s*<mod-name>)?|:\s*<mod-name>/.source.replace(/<mod-name>/g, function() {
          return modName;
        }) + ")"
      ),
      lookbehind: true,
      greedy: true,
      inside: {
        "string": /^[<"][\s\S]+/,
        "operator": /:/,
        "punctuation": /\./
      }
    },
    "raw-string": {
      pattern: /R"([^()\\ ]{0,16})\([\s\S]*?\)\1"/,
      alias: "string",
      greedy: true
    }
  });
  Prism3.languages.insertBefore("cpp", "keyword", {
    "generic-function": {
      pattern: /\b(?!operator\b)[a-z_]\w*\s*<(?:[^<>]|<[^<>]*>)*>(?=\s*\()/i,
      inside: {
        "function": /^\w+/,
        "generic": {
          pattern: /<[\s\S]+/,
          alias: "class-name",
          inside: Prism3.languages.cpp
        }
      }
    }
  });
  Prism3.languages.insertBefore("cpp", "operator", {
    "double-colon": {
      pattern: /::/,
      alias: "punctuation"
    }
  });
  Prism3.languages.insertBefore("cpp", "class-name", {
    // the base clause is an optional list of parent classes
    // https://en.cppreference.com/w/cpp/language/class
    "base-clause": {
      pattern: /(\b(?:class|struct)\s+\w+\s*:\s*)[^;{}"'\s]+(?:\s+[^;{}"'\s]+)*(?=\s*[;{])/,
      lookbehind: true,
      greedy: true,
      inside: Prism3.languages.extend("cpp", {})
    }
  });
  Prism3.languages.insertBefore("inside", "double-colon", {
    // All untokenized words that are not namespaces should be class names
    "class-name": /\b[a-z_]\w*\b(?!\s*::)/i
  }, Prism3.languages.cpp["base-clause"]);
})(Prism);

// node_modules/@lexical/code/LexicalCode.dev.mjs
var Prism2 = globalThis.Prism || window.Prism;
var isLanguageSupportedByPrism = (language2) => {
  try {
    return language2 ? Prism2.languages.hasOwnProperty(language2) : false;
  } catch (_unused) {
    return false;
  }
};
function hasChildDOMNodeTag(node2, tagName) {
  for (const child of node2.childNodes) {
    if (isHTMLElement(child) && child.tagName === tagName) {
      return true;
    }
    hasChildDOMNodeTag(child, tagName);
  }
  return false;
}
var LANGUAGE_DATA_ATTRIBUTE = "data-language";
var HIGHLIGHT_LANGUAGE_DATA_ATTRIBUTE = "data-highlight-language";
var CodeNode = class _CodeNode extends ElementNode {
  /** @internal */
  /** @internal */
  static getType() {
    return "code";
  }
  static clone(node2) {
    return new _CodeNode(node2.__language, node2.__key);
  }
  constructor(language2, key2) {
    super(key2);
    this.__language = language2 || void 0;
    this.__isSyntaxHighlightSupported = isLanguageSupportedByPrism(language2);
  }
  // View
  createDOM(config) {
    const element2 = document.createElement("code");
    addClassNamesToElement(element2, config.theme.code);
    element2.setAttribute("spellcheck", "false");
    const language2 = this.getLanguage();
    if (language2) {
      element2.setAttribute(LANGUAGE_DATA_ATTRIBUTE, language2);
      if (this.getIsSyntaxHighlightSupported()) {
        element2.setAttribute(HIGHLIGHT_LANGUAGE_DATA_ATTRIBUTE, language2);
      }
    }
    return element2;
  }
  updateDOM(prevNode, dom, config) {
    const language2 = this.__language;
    const prevLanguage = prevNode.__language;
    if (language2) {
      if (language2 !== prevLanguage) {
        dom.setAttribute(LANGUAGE_DATA_ATTRIBUTE, language2);
        if (this.__isSyntaxHighlightSupported) {
          dom.setAttribute(HIGHLIGHT_LANGUAGE_DATA_ATTRIBUTE, language2);
        }
      }
    } else if (prevLanguage) {
      dom.removeAttribute(LANGUAGE_DATA_ATTRIBUTE);
      if (prevNode.__isSyntaxHighlightSupported) {
        dom.removeAttribute(HIGHLIGHT_LANGUAGE_DATA_ATTRIBUTE);
      }
    }
    return false;
  }
  exportDOM(editor) {
    const element2 = document.createElement("pre");
    addClassNamesToElement(element2, editor._config.theme.code);
    element2.setAttribute("spellcheck", "false");
    const language2 = this.getLanguage();
    if (language2) {
      element2.setAttribute(LANGUAGE_DATA_ATTRIBUTE, language2);
      if (this.getIsSyntaxHighlightSupported()) {
        element2.setAttribute(HIGHLIGHT_LANGUAGE_DATA_ATTRIBUTE, language2);
      }
    }
    return {
      element: element2
    };
  }
  static importDOM() {
    return {
      // Typically <pre> is used for code blocks, and <code> for inline code styles
      // but if it's a multi line <code> we'll create a block. Pass through to
      // inline format handled by TextNode otherwise.
      code: (node2) => {
        const isMultiLine = node2.textContent != null && (/\r?\n/.test(node2.textContent) || hasChildDOMNodeTag(node2, "BR"));
        return isMultiLine ? {
          conversion: $convertPreElement,
          priority: 1
        } : null;
      },
      div: () => ({
        conversion: $convertDivElement,
        priority: 1
      }),
      pre: () => ({
        conversion: $convertPreElement,
        priority: 0
      }),
      table: (node2) => {
        const table = node2;
        if (isGitHubCodeTable(table)) {
          return {
            conversion: $convertTableElement,
            priority: 3
          };
        }
        return null;
      },
      td: (node2) => {
        const td = node2;
        const table = td.closest("table");
        if (isGitHubCodeCell(td) || table && isGitHubCodeTable(table)) {
          return {
            conversion: convertCodeNoop,
            priority: 3
          };
        }
        return null;
      },
      tr: (node2) => {
        const tr = node2;
        const table = tr.closest("table");
        if (table && isGitHubCodeTable(table)) {
          return {
            conversion: convertCodeNoop,
            priority: 3
          };
        }
        return null;
      }
    };
  }
  static importJSON(serializedNode) {
    return $createCodeNode().updateFromJSON(serializedNode);
  }
  updateFromJSON(serializedNode) {
    return super.updateFromJSON(serializedNode).setLanguage(serializedNode.language);
  }
  exportJSON() {
    return {
      ...super.exportJSON(),
      language: this.getLanguage()
    };
  }
  // Mutation
  insertNewAfter(selection2, restoreSelection = true) {
    const children = this.getChildren();
    const childrenLength = children.length;
    if (childrenLength >= 2 && children[childrenLength - 1].getTextContent() === "\n" && children[childrenLength - 2].getTextContent() === "\n" && selection2.isCollapsed() && selection2.anchor.key === this.__key && selection2.anchor.offset === childrenLength) {
      children[childrenLength - 1].remove();
      children[childrenLength - 2].remove();
      const newElement = $createParagraphNode();
      this.insertAfter(newElement, restoreSelection);
      return newElement;
    }
    const {
      anchor,
      focus: focus2
    } = selection2;
    const firstPoint = anchor.isBefore(focus2) ? anchor : focus2;
    const firstSelectionNode = firstPoint.getNode();
    if ($isTextNode(firstSelectionNode)) {
      let node2 = getFirstCodeNodeOfLine(firstSelectionNode);
      const insertNodes = [];
      while (true) {
        if ($isTabNode(node2)) {
          insertNodes.push($createTabNode());
          node2 = node2.getNextSibling();
        } else if ($isCodeHighlightNode(node2)) {
          let spaces = 0;
          const text4 = node2.getTextContent();
          const textSize = node2.getTextContentSize();
          while (spaces < textSize && text4[spaces] === " ") {
            spaces++;
          }
          if (spaces !== 0) {
            insertNodes.push($createCodeHighlightNode(" ".repeat(spaces)));
          }
          if (spaces !== textSize) {
            break;
          }
          node2 = node2.getNextSibling();
        } else {
          break;
        }
      }
      const split = firstSelectionNode.splitText(anchor.offset)[0];
      const x3 = anchor.offset === 0 ? 0 : 1;
      const index3 = split.getIndexWithinParent() + x3;
      const codeNode = firstSelectionNode.getParentOrThrow();
      const nodesToInsert = [$createLineBreakNode(), ...insertNodes];
      codeNode.splice(index3, 0, nodesToInsert);
      const last = insertNodes[insertNodes.length - 1];
      if (last) {
        last.select();
      } else if (anchor.offset === 0) {
        split.selectPrevious();
      } else {
        split.getNextSibling().selectNext(0, 0);
      }
    }
    if ($isCodeNode(firstSelectionNode)) {
      const {
        offset: offset5
      } = selection2.anchor;
      firstSelectionNode.splice(offset5, 0, [$createLineBreakNode()]);
      firstSelectionNode.select(offset5 + 1, offset5 + 1);
    }
    return null;
  }
  canIndent() {
    return false;
  }
  collapseAtStart() {
    const paragraph2 = $createParagraphNode();
    const children = this.getChildren();
    children.forEach((child) => paragraph2.append(child));
    this.replace(paragraph2);
    return true;
  }
  setLanguage(language2) {
    const writable = this.getWritable();
    writable.__language = language2 || void 0;
    writable.__isSyntaxHighlightSupported = isLanguageSupportedByPrism(language2);
    return writable;
  }
  getLanguage() {
    return this.getLatest().__language;
  }
  getIsSyntaxHighlightSupported() {
    return this.getLatest().__isSyntaxHighlightSupported;
  }
};
function $createCodeNode(language2) {
  return $applyNodeReplacement(new CodeNode(language2));
}
function $isCodeNode(node2) {
  return node2 instanceof CodeNode;
}
function $convertPreElement(domNode) {
  const language2 = domNode.getAttribute(LANGUAGE_DATA_ATTRIBUTE);
  return {
    node: $createCodeNode(language2)
  };
}
function $convertDivElement(domNode) {
  const div = domNode;
  const isCode = isCodeElement(div);
  if (!isCode && !isCodeChildElement(div)) {
    return {
      node: null
    };
  }
  return {
    node: isCode ? $createCodeNode() : null
  };
}
function $convertTableElement() {
  return {
    node: $createCodeNode()
  };
}
function convertCodeNoop() {
  return {
    node: null
  };
}
function isCodeElement(div) {
  return div.style.fontFamily.match("monospace") !== null;
}
function isCodeChildElement(node2) {
  let parent = node2.parentElement;
  while (parent !== null) {
    if (isCodeElement(parent)) {
      return true;
    }
    parent = parent.parentElement;
  }
  return false;
}
function isGitHubCodeCell(cell) {
  return cell.classList.contains("js-file-line");
}
function isGitHubCodeTable(table) {
  return table.classList.contains("js-file-line-container");
}
var CodeHighlightNode = class _CodeHighlightNode extends TextNode {
  /** @internal */
  constructor(text4 = "", highlightType, key2) {
    super(text4, key2);
    this.__highlightType = highlightType;
  }
  static getType() {
    return "code-highlight";
  }
  static clone(node2) {
    return new _CodeHighlightNode(node2.__text, node2.__highlightType || void 0, node2.__key);
  }
  getHighlightType() {
    const self2 = this.getLatest();
    return self2.__highlightType;
  }
  setHighlightType(highlightType) {
    const self2 = this.getWritable();
    self2.__highlightType = highlightType || void 0;
    return self2;
  }
  canHaveFormat() {
    return false;
  }
  createDOM(config) {
    const element2 = super.createDOM(config);
    const className = getHighlightThemeClass(config.theme, this.__highlightType);
    addClassNamesToElement(element2, className);
    return element2;
  }
  updateDOM(prevNode, dom, config) {
    const update = super.updateDOM(prevNode, dom, config);
    const prevClassName = getHighlightThemeClass(config.theme, prevNode.__highlightType);
    const nextClassName = getHighlightThemeClass(config.theme, this.__highlightType);
    if (prevClassName !== nextClassName) {
      if (prevClassName) {
        removeClassNamesFromElement(dom, prevClassName);
      }
      if (nextClassName) {
        addClassNamesToElement(dom, nextClassName);
      }
    }
    return update;
  }
  static importJSON(serializedNode) {
    return $createCodeHighlightNode().updateFromJSON(serializedNode);
  }
  updateFromJSON(serializedNode) {
    return super.updateFromJSON(serializedNode).setHighlightType(serializedNode.highlightType);
  }
  exportJSON() {
    return {
      ...super.exportJSON(),
      highlightType: this.getHighlightType()
    };
  }
  // Prevent formatting (bold, underline, etc)
  setFormat(format) {
    return this;
  }
  isParentRequired() {
    return true;
  }
  createParentElementNode() {
    return $createCodeNode();
  }
};
function getHighlightThemeClass(theme, highlightType) {
  return highlightType && theme && theme.codeHighlight && theme.codeHighlight[highlightType];
}
function $createCodeHighlightNode(text4 = "", highlightType) {
  return $applyNodeReplacement(new CodeHighlightNode(text4, highlightType));
}
function $isCodeHighlightNode(node2) {
  return node2 instanceof CodeHighlightNode;
}
function getFirstCodeNodeOfLine(anchor) {
  let previousNode = anchor;
  let node2 = anchor;
  while ($isCodeHighlightNode(node2) || $isTabNode(node2)) {
    previousNode = node2;
    node2 = node2.getPreviousSibling();
  }
  return previousNode;
}

// node_modules/@lexical/markdown/LexicalMarkdown.dev.mjs
function indexBy(list4, callback) {
  const index3 = {};
  for (const item of list4) {
    const key2 = callback(item);
    if (!key2) {
      continue;
    }
    if (index3[key2]) {
      index3[key2].push(item);
    } else {
      index3[key2] = [item];
    }
  }
  return index3;
}
function transformersByType(transformers2) {
  const byType = indexBy(transformers2, (t3) => t3.type);
  return {
    element: byType.element || [],
    multilineElement: byType["multiline-element"] || [],
    textFormat: byType["text-format"] || [],
    textMatch: byType["text-match"] || []
  };
}
var PUNCTUATION_OR_SPACE2 = /[!-/:-@[-`{-~\s]/;
var CAN_USE_DOM8 = typeof window !== "undefined" && typeof window.document !== "undefined" && typeof window.document.createElement !== "undefined";
var documentMode4 = CAN_USE_DOM8 && "documentMode" in document ? document.documentMode : null;
CAN_USE_DOM8 && "InputEvent" in window && !documentMode4 ? "getTargetRanges" in new window.InputEvent("input") : false;
var IS_SAFARI3 = CAN_USE_DOM8 && /Version\/[\d.]+.*Safari/.test(navigator.userAgent);
var IS_IOS3 = CAN_USE_DOM8 && /iPad|iPhone|iPod/.test(navigator.userAgent) && !window.MSStream;
var IS_CHROME3 = CAN_USE_DOM8 && /^(?=.*Chrome).*/i.test(navigator.userAgent);
var IS_APPLE_WEBKIT3 = CAN_USE_DOM8 && /AppleWebKit\/[\d.]+/.test(navigator.userAgent) && !IS_CHROME3;
function runElementTransformers(parentNode, anchorNode, anchorOffset, elementTransformers) {
  const grandParentNode = parentNode.getParent();
  if (!$isRootOrShadowRoot(grandParentNode) || parentNode.getFirstChild() !== anchorNode) {
    return false;
  }
  const textContent = anchorNode.getTextContent();
  if (textContent[anchorOffset - 1] !== " ") {
    return false;
  }
  for (const {
    regExp,
    replace: replace2
  } of elementTransformers) {
    const match = textContent.match(regExp);
    if (match && match[0].length === (match[0].endsWith(" ") ? anchorOffset : anchorOffset - 1)) {
      const nextSiblings = anchorNode.getNextSiblings();
      const [leadingNode, remainderNode] = anchorNode.splitText(anchorOffset);
      leadingNode.remove();
      const siblings = remainderNode ? [remainderNode, ...nextSiblings] : nextSiblings;
      if (replace2(parentNode, siblings, match, false) !== false) {
        return true;
      }
    }
  }
  return false;
}
function runMultilineElementTransformers(parentNode, anchorNode, anchorOffset, elementTransformers) {
  const grandParentNode = parentNode.getParent();
  if (!$isRootOrShadowRoot(grandParentNode) || parentNode.getFirstChild() !== anchorNode) {
    return false;
  }
  const textContent = anchorNode.getTextContent();
  if (textContent[anchorOffset - 1] !== " ") {
    return false;
  }
  for (const {
    regExpStart,
    replace: replace2,
    regExpEnd
  } of elementTransformers) {
    if (regExpEnd && !("optional" in regExpEnd) || regExpEnd && "optional" in regExpEnd && !regExpEnd.optional) {
      continue;
    }
    const match = textContent.match(regExpStart);
    if (match && match[0].length === (match[0].endsWith(" ") ? anchorOffset : anchorOffset - 1)) {
      const nextSiblings = anchorNode.getNextSiblings();
      const [leadingNode, remainderNode] = anchorNode.splitText(anchorOffset);
      leadingNode.remove();
      const siblings = remainderNode ? [remainderNode, ...nextSiblings] : nextSiblings;
      if (replace2(parentNode, siblings, match, null, null, false) !== false) {
        return true;
      }
    }
  }
  return false;
}
function runTextMatchTransformers(anchorNode, anchorOffset, transformersByTrigger) {
  let textContent = anchorNode.getTextContent();
  const lastChar = textContent[anchorOffset - 1];
  const transformers2 = transformersByTrigger[lastChar];
  if (transformers2 == null) {
    return false;
  }
  if (anchorOffset < textContent.length) {
    textContent = textContent.slice(0, anchorOffset);
  }
  for (const transformer of transformers2) {
    if (!transformer.replace || !transformer.regExp) {
      continue;
    }
    const match = textContent.match(transformer.regExp);
    if (match === null) {
      continue;
    }
    const startIndex = match.index || 0;
    const endIndex = startIndex + match[0].length;
    let replaceNode;
    if (startIndex === 0) {
      [replaceNode] = anchorNode.splitText(endIndex);
    } else {
      [, replaceNode] = anchorNode.splitText(startIndex, endIndex);
    }
    replaceNode.selectNext(0, 0);
    transformer.replace(replaceNode, match);
    return true;
  }
  return false;
}
function $runTextFormatTransformers(anchorNode, anchorOffset, textFormatTransformers) {
  const textContent = anchorNode.getTextContent();
  const closeTagEndIndex = anchorOffset - 1;
  const closeChar = textContent[closeTagEndIndex];
  const matchers = textFormatTransformers[closeChar];
  if (!matchers) {
    return false;
  }
  for (const matcher of matchers) {
    const {
      tag
    } = matcher;
    const tagLength = tag.length;
    const closeTagStartIndex = closeTagEndIndex - tagLength + 1;
    if (tagLength > 1) {
      if (!isEqualSubString(textContent, closeTagStartIndex, tag, 0, tagLength)) {
        continue;
      }
    }
    if (textContent[closeTagStartIndex - 1] === " ") {
      continue;
    }
    const afterCloseTagChar = textContent[closeTagEndIndex + 1];
    if (matcher.intraword === false && afterCloseTagChar && !PUNCTUATION_OR_SPACE2.test(afterCloseTagChar)) {
      continue;
    }
    const closeNode = anchorNode;
    let openNode = closeNode;
    let openTagStartIndex = getOpenTagStartIndex(textContent, closeTagStartIndex, tag);
    let sibling2 = openNode;
    while (openTagStartIndex < 0 && (sibling2 = sibling2.getPreviousSibling())) {
      if ($isLineBreakNode(sibling2)) {
        break;
      }
      if ($isTextNode(sibling2)) {
        const siblingTextContent = sibling2.getTextContent();
        openNode = sibling2;
        openTagStartIndex = getOpenTagStartIndex(siblingTextContent, siblingTextContent.length, tag);
      }
    }
    if (openTagStartIndex < 0) {
      continue;
    }
    if (openNode === closeNode && openTagStartIndex + tagLength === closeTagStartIndex) {
      continue;
    }
    const prevOpenNodeText = openNode.getTextContent();
    if (openTagStartIndex > 0 && prevOpenNodeText[openTagStartIndex - 1] === closeChar) {
      continue;
    }
    const beforeOpenTagChar = prevOpenNodeText[openTagStartIndex - 1];
    if (matcher.intraword === false && beforeOpenTagChar && !PUNCTUATION_OR_SPACE2.test(beforeOpenTagChar)) {
      continue;
    }
    const prevCloseNodeText = closeNode.getTextContent();
    const closeNodeText = prevCloseNodeText.slice(0, closeTagStartIndex) + prevCloseNodeText.slice(closeTagEndIndex + 1);
    closeNode.setTextContent(closeNodeText);
    const openNodeText = openNode === closeNode ? closeNodeText : prevOpenNodeText;
    openNode.setTextContent(openNodeText.slice(0, openTagStartIndex) + openNodeText.slice(openTagStartIndex + tagLength));
    const selection2 = $getSelection();
    const nextSelection = $createRangeSelection();
    $setSelection(nextSelection);
    const newOffset = closeTagEndIndex - tagLength * (openNode === closeNode ? 2 : 1) + 1;
    nextSelection.anchor.set(openNode.__key, openTagStartIndex, "text");
    nextSelection.focus.set(closeNode.__key, newOffset, "text");
    for (const format of matcher.format) {
      if (!nextSelection.hasFormat(format)) {
        nextSelection.formatText(format);
      }
    }
    nextSelection.anchor.set(nextSelection.focus.key, nextSelection.focus.offset, nextSelection.focus.type);
    for (const format of matcher.format) {
      if (nextSelection.hasFormat(format)) {
        nextSelection.toggleFormat(format);
      }
    }
    if ($isRangeSelection(selection2)) {
      nextSelection.format = selection2.format;
    }
    return true;
  }
  return false;
}
function getOpenTagStartIndex(string3, maxIndex, tag) {
  const tagLength = tag.length;
  for (let i3 = maxIndex; i3 >= tagLength; i3--) {
    const startIndex = i3 - tagLength;
    if (isEqualSubString(string3, startIndex, tag, 0, tagLength) && // Space after opening tag cancels transformation
    string3[startIndex + tagLength] !== " ") {
      return startIndex;
    }
  }
  return -1;
}
function isEqualSubString(stringA, aStart, stringB, bStart, length) {
  for (let i3 = 0; i3 < length; i3++) {
    if (stringA[aStart + i3] !== stringB[bStart + i3]) {
      return false;
    }
  }
  return true;
}
function registerMarkdownShortcuts(editor, transformers2 = TRANSFORMERS) {
  const byType = transformersByType(transformers2);
  const textFormatTransformersByTrigger = indexBy(byType.textFormat, ({
    tag
  }) => tag[tag.length - 1]);
  const textMatchTransformersByTrigger = indexBy(byType.textMatch, ({
    trigger
  }) => trigger);
  for (const transformer of transformers2) {
    const type2 = transformer.type;
    if (type2 === "element" || type2 === "text-match" || type2 === "multiline-element") {
      const dependencies = transformer.dependencies;
      for (const node2 of dependencies) {
        if (!editor.hasNode(node2)) {
          {
            throw Error(`MarkdownShortcuts: missing dependency ${node2.getType()} for transformer. Ensure node dependency is included in editor initial config.`);
          }
        }
      }
    }
  }
  const $transform = (parentNode, anchorNode, anchorOffset) => {
    if (runElementTransformers(parentNode, anchorNode, anchorOffset, byType.element)) {
      return;
    }
    if (runMultilineElementTransformers(parentNode, anchorNode, anchorOffset, byType.multilineElement)) {
      return;
    }
    if (runTextMatchTransformers(anchorNode, anchorOffset, textMatchTransformersByTrigger)) {
      return;
    }
    $runTextFormatTransformers(anchorNode, anchorOffset, textFormatTransformersByTrigger);
  };
  return editor.registerUpdateListener(({
    tags: tags2,
    dirtyLeaves,
    editorState,
    prevEditorState
  }) => {
    if (tags2.has("collaboration") || tags2.has("historic")) {
      return;
    }
    if (editor.isComposing()) {
      return;
    }
    const selection2 = editorState.read($getSelection);
    const prevSelection = prevEditorState.read($getSelection);
    if (!$isRangeSelection(prevSelection) || !$isRangeSelection(selection2) || !selection2.isCollapsed() || selection2.is(prevSelection)) {
      return;
    }
    const anchorKey = selection2.anchor.key;
    const anchorOffset = selection2.anchor.offset;
    const anchorNode = editorState._nodeMap.get(anchorKey);
    if (!$isTextNode(anchorNode) || !dirtyLeaves.has(anchorKey) || anchorOffset !== 1 && anchorOffset > prevSelection.anchor.offset + 1) {
      return;
    }
    editor.update(() => {
      if (anchorNode.hasFormat("code")) {
        return;
      }
      const parentNode = anchorNode.getParent();
      if (parentNode === null || $isCodeNode(parentNode)) {
        return;
      }
      $transform(parentNode, anchorNode, selection2.anchor.offset);
    });
  });
}
var ORDERED_LIST_REGEX = /^(\s*)(\d{1,})\.\s/;
var UNORDERED_LIST_REGEX = /^(\s*)[-*+]\s/;
var CHECK_LIST_REGEX = /^(\s*)(?:-\s)?\s?(\[(\s|x)?\])\s/i;
var HEADING_REGEX = /^(#{1,6})\s/;
var QUOTE_REGEX = /^>\s/;
var CODE_START_REGEX = /^[ \t]*```(\w+)?/;
var CODE_END_REGEX = /[ \t]*```$/;
var createBlockNode = (createNode) => {
  return (parentNode, children, match) => {
    const node2 = createNode(match);
    node2.append(...children);
    parentNode.replace(node2);
    node2.select(0, 0);
  };
};
var LIST_INDENT_SIZE = 4;
function getIndent(whitespaces) {
  const tabs = whitespaces.match(/\t/g);
  const spaces = whitespaces.match(/ /g);
  let indent2 = 0;
  if (tabs) {
    indent2 += tabs.length;
  }
  if (spaces) {
    indent2 += Math.floor(spaces.length / LIST_INDENT_SIZE);
  }
  return indent2;
}
var listReplace = (listType) => {
  return (parentNode, children, match) => {
    const previousNode = parentNode.getPreviousSibling();
    const nextNode = parentNode.getNextSibling();
    const listItem2 = $createListItemNode(listType === "check" ? match[3] === "x" : void 0);
    if ($isListNode(nextNode) && nextNode.getListType() === listType) {
      const firstChild = nextNode.getFirstChild();
      if (firstChild !== null) {
        firstChild.insertBefore(listItem2);
      } else {
        nextNode.append(listItem2);
      }
      parentNode.remove();
    } else if ($isListNode(previousNode) && previousNode.getListType() === listType) {
      previousNode.append(listItem2);
      parentNode.remove();
    } else {
      const list4 = $createListNode(listType, listType === "number" ? Number(match[2]) : void 0);
      list4.append(listItem2);
      parentNode.replace(list4);
    }
    listItem2.append(...children);
    listItem2.select(0, 0);
    const indent2 = getIndent(match[1]);
    if (indent2) {
      listItem2.setIndent(indent2);
    }
  };
};
var listExport = (listNode, exportChildren, depth2) => {
  const output = [];
  const children = listNode.getChildren();
  let index3 = 0;
  for (const listItemNode of children) {
    if ($isListItemNode(listItemNode)) {
      if (listItemNode.getChildrenSize() === 1) {
        const firstChild = listItemNode.getFirstChild();
        if ($isListNode(firstChild)) {
          output.push(listExport(firstChild, exportChildren, depth2 + 1));
          continue;
        }
      }
      const indent2 = " ".repeat(depth2 * LIST_INDENT_SIZE);
      const listType = listNode.getListType();
      const prefix = listType === "number" ? `${listNode.getStart() + index3}. ` : listType === "check" ? `- [${listItemNode.getChecked() ? "x" : " "}] ` : "- ";
      output.push(indent2 + prefix + exportChildren(listItemNode));
      index3++;
    }
  }
  return output.join("\n");
};
var HEADING = {
  dependencies: [HeadingNode],
  export: (node2, exportChildren) => {
    if (!$isHeadingNode(node2)) {
      return null;
    }
    const level = Number(node2.getTag().slice(1));
    return "#".repeat(level) + " " + exportChildren(node2);
  },
  regExp: HEADING_REGEX,
  replace: createBlockNode((match) => {
    const tag = "h" + match[1].length;
    return $createHeadingNode(tag);
  }),
  type: "element"
};
var QUOTE = {
  dependencies: [QuoteNode],
  export: (node2, exportChildren) => {
    if (!$isQuoteNode(node2)) {
      return null;
    }
    const lines = exportChildren(node2).split("\n");
    const output = [];
    for (const line of lines) {
      output.push("> " + line);
    }
    return output.join("\n");
  },
  regExp: QUOTE_REGEX,
  replace: (parentNode, children, _match, isImport) => {
    if (isImport) {
      const previousNode = parentNode.getPreviousSibling();
      if ($isQuoteNode(previousNode)) {
        previousNode.splice(previousNode.getChildrenSize(), 0, [$createLineBreakNode(), ...children]);
        previousNode.select(0, 0);
        parentNode.remove();
        return;
      }
    }
    const node2 = $createQuoteNode();
    node2.append(...children);
    parentNode.replace(node2);
    node2.select(0, 0);
  },
  type: "element"
};
var CODE = {
  dependencies: [CodeNode],
  export: (node2) => {
    if (!$isCodeNode(node2)) {
      return null;
    }
    const textContent = node2.getTextContent();
    return "```" + (node2.getLanguage() || "") + (textContent ? "\n" + textContent : "") + "\n```";
  },
  regExpEnd: {
    optional: true,
    regExp: CODE_END_REGEX
  },
  regExpStart: CODE_START_REGEX,
  replace: (rootNode, children, startMatch, endMatch, linesInBetween, isImport) => {
    let codeBlockNode;
    let code3;
    if (!children && linesInBetween) {
      if (linesInBetween.length === 1) {
        if (endMatch) {
          codeBlockNode = $createCodeNode();
          code3 = startMatch[1] + linesInBetween[0];
        } else {
          codeBlockNode = $createCodeNode(startMatch[1]);
          code3 = linesInBetween[0].startsWith(" ") ? linesInBetween[0].slice(1) : linesInBetween[0];
        }
      } else {
        codeBlockNode = $createCodeNode(startMatch[1]);
        if (linesInBetween[0].trim().length === 0) {
          while (linesInBetween.length > 0 && !linesInBetween[0].length) {
            linesInBetween.shift();
          }
        } else {
          linesInBetween[0] = linesInBetween[0].startsWith(" ") ? linesInBetween[0].slice(1) : linesInBetween[0];
        }
        while (linesInBetween.length > 0 && !linesInBetween[linesInBetween.length - 1].length) {
          linesInBetween.pop();
        }
        code3 = linesInBetween.join("\n");
      }
      const textNode = $createTextNode(code3);
      codeBlockNode.append(textNode);
      rootNode.append(codeBlockNode);
    } else if (children) {
      createBlockNode((match) => {
        return $createCodeNode(match ? match[1] : void 0);
      })(rootNode, children, startMatch, isImport);
    }
  },
  type: "multiline-element"
};
var UNORDERED_LIST = {
  dependencies: [ListNode, ListItemNode],
  export: (node2, exportChildren) => {
    return $isListNode(node2) ? listExport(node2, exportChildren, 0) : null;
  },
  regExp: UNORDERED_LIST_REGEX,
  replace: listReplace("bullet"),
  type: "element"
};
var CHECK_LIST = {
  dependencies: [ListNode, ListItemNode],
  export: (node2, exportChildren) => {
    return $isListNode(node2) ? listExport(node2, exportChildren, 0) : null;
  },
  regExp: CHECK_LIST_REGEX,
  replace: listReplace("check"),
  type: "element"
};
var ORDERED_LIST = {
  dependencies: [ListNode, ListItemNode],
  export: (node2, exportChildren) => {
    return $isListNode(node2) ? listExport(node2, exportChildren, 0) : null;
  },
  regExp: ORDERED_LIST_REGEX,
  replace: listReplace("number"),
  type: "element"
};
var INLINE_CODE = {
  format: ["code"],
  tag: "`",
  type: "text-format"
};
var HIGHLIGHT = {
  format: ["highlight"],
  tag: "==",
  type: "text-format"
};
var BOLD_ITALIC_STAR = {
  format: ["bold", "italic"],
  tag: "***",
  type: "text-format"
};
var BOLD_ITALIC_UNDERSCORE = {
  format: ["bold", "italic"],
  intraword: false,
  tag: "___",
  type: "text-format"
};
var BOLD_STAR = {
  format: ["bold"],
  tag: "**",
  type: "text-format"
};
var BOLD_UNDERSCORE = {
  format: ["bold"],
  intraword: false,
  tag: "__",
  type: "text-format"
};
var STRIKETHROUGH = {
  format: ["strikethrough"],
  tag: "~~",
  type: "text-format"
};
var ITALIC_STAR = {
  format: ["italic"],
  tag: "*",
  type: "text-format"
};
var ITALIC_UNDERSCORE = {
  format: ["italic"],
  intraword: false,
  tag: "_",
  type: "text-format"
};
var LINK = {
  dependencies: [LinkNode],
  export: (node2, exportChildren, exportFormat) => {
    if (!$isLinkNode(node2)) {
      return null;
    }
    const title = node2.getTitle();
    const linkContent = title ? `[${node2.getTextContent()}](${node2.getURL()} "${title}")` : `[${node2.getTextContent()}](${node2.getURL()})`;
    const firstChild = node2.getFirstChild();
    if (node2.getChildrenSize() === 1 && $isTextNode(firstChild)) {
      return exportFormat(firstChild, linkContent);
    } else {
      return linkContent;
    }
  },
  importRegExp: /(?:\[([^[]+)\])(?:\((?:([^()\s]+)(?:\s"((?:[^"]*\\")*[^"]*)"\s*)?)\))/,
  regExp: /(?:\[([^[]+)\])(?:\((?:([^()\s]+)(?:\s"((?:[^"]*\\")*[^"]*)"\s*)?)\))$/,
  replace: (textNode, match) => {
    const [, linkText, linkUrl, linkTitle] = match;
    const linkNode = $createLinkNode(linkUrl, {
      title: linkTitle
    });
    const linkTextNode = $createTextNode(linkText);
    linkTextNode.setFormat(textNode.getFormat());
    linkNode.append(linkTextNode);
    textNode.replace(linkNode);
  },
  trigger: ")",
  type: "text-match"
};
var ELEMENT_TRANSFORMERS = [HEADING, QUOTE, UNORDERED_LIST, ORDERED_LIST];
var MULTILINE_ELEMENT_TRANSFORMERS = [CODE];
var TEXT_FORMAT_TRANSFORMERS = [INLINE_CODE, BOLD_ITALIC_STAR, BOLD_ITALIC_UNDERSCORE, BOLD_STAR, BOLD_UNDERSCORE, HIGHLIGHT, ITALIC_STAR, ITALIC_UNDERSCORE, STRIKETHROUGH];
var TEXT_MATCH_TRANSFORMERS = [LINK];
var TRANSFORMERS = [...ELEMENT_TRANSFORMERS, ...MULTILINE_ELEMENT_TRANSFORMERS, ...TEXT_FORMAT_TRANSFORMERS, ...TEXT_MATCH_TRANSFORMERS];

// node_modules/@lexical/react/LexicalMarkdownShortcutPlugin.dev.mjs
var import_react63 = __toESM(require_react(), 1);
var HR = {
  dependencies: [HorizontalRuleNode],
  export: (node2) => {
    return $isHorizontalRuleNode(node2) ? "***" : null;
  },
  regExp: /^(---|\*\*\*|___)\s?$/,
  replace: (parentNode, _1, _2, isImport) => {
    const line = $createHorizontalRuleNode();
    if (isImport || parentNode.getNextSibling() != null) {
      parentNode.replace(line);
    } else {
      parentNode.insertBefore(line);
    }
    line.selectNext();
  },
  type: "element"
};
var DEFAULT_TRANSFORMERS = [HR, ...TRANSFORMERS];
function MarkdownShortcutPlugin({
  transformers: transformers2 = DEFAULT_TRANSFORMERS
}) {
  const [editor] = useLexicalComposerContext();
  (0, import_react63.useEffect)(() => {
    return registerMarkdownShortcuts(editor, transformers2);
  }, [editor, transformers2]);
  return null;
}

// node_modules/@mdxeditor/editor/dist/plugins/markdown-shortcut/index.js
var import_react64 = __toESM(require_react(), 1);
var markdownShortcutPlugin = realmPlugin({
  init(realm) {
    const pluginIds = realm.getValue(activePlugins$);
    const allowedHeadingLevels = pluginIds.includes("headings") ? realm.getValue(allowedHeadingLevels$) : [];
    const transformers2 = pickTransformersForActivePlugins(pluginIds, allowedHeadingLevels);
    realm.pubIn({
      [addComposerChild$]: () => import_react64.default.createElement(MarkdownShortcutPlugin, { transformers: transformers2 }),
      [addNestedEditorChild$]: () => import_react64.default.createElement(MarkdownShortcutPlugin, { transformers: transformers2 })
    });
  }
});
var createBlockNode2 = (createNode) => {
  return (parentNode, children, match) => {
    const node2 = createNode(match);
    node2.append(...children);
    parentNode.replace(node2);
    node2.select(0, 0);
  };
};
function pickTransformersForActivePlugins(pluginIds, allowedHeadingLevels) {
  const transformers2 = [
    BOLD_ITALIC_STAR,
    BOLD_ITALIC_UNDERSCORE,
    BOLD_STAR,
    BOLD_UNDERSCORE,
    INLINE_CODE,
    ITALIC_STAR,
    ITALIC_UNDERSCORE
    // HIGHLIGHT,
    // STRIKETHROUGH
  ];
  if (pluginIds.includes("headings")) {
    const minHeadingLevel = Math.min(...allowedHeadingLevels);
    const maxHeadingLevel = Math.max(...allowedHeadingLevels);
    const headingRegExp = new RegExp(`^(#{${minHeadingLevel},${maxHeadingLevel}})\\s`);
    const HEADING2 = {
      dependencies: [HeadingNode],
      export: (node2, exportChildren) => {
        if (!$isHeadingNode(node2)) {
          return null;
        }
        const level = Number(node2.getTag().slice(1));
        return "#".repeat(level) + " " + exportChildren(node2);
      },
      regExp: headingRegExp,
      replace: createBlockNode2((match) => {
        const tag = `h${match[1].length}`;
        return $createHeadingNode(tag);
      }),
      type: "element"
    };
    transformers2.push(HEADING2);
  }
  if (pluginIds.includes("quote")) {
    transformers2.push(QUOTE);
  }
  if (pluginIds.includes("link")) {
    transformers2.push(LINK);
  }
  if (pluginIds.includes("lists")) {
    transformers2.push(ORDERED_LIST, UNORDERED_LIST, CHECK_LIST);
  }
  if (pluginIds.includes("codeblock")) {
    const codeTransformerCopy = {
      ...CODE,
      dependencies: [CodeBlockNode],
      replace: (parentNode, _children, match) => {
        const codeBlockNode = $createCodeBlockNode({ code: "", language: match[1] ?? "", meta: "" });
        parentNode.replace(codeBlockNode);
        setTimeout(() => {
          codeBlockNode.select();
        }, 80);
      }
    };
    transformers2.push(codeTransformerCopy);
  }
  return transformers2;
}

// node_modules/@mdxeditor/editor/dist/plugins/toolbar/components/BlockTypeSelect.js
var import_react65 = __toESM(require_react(), 1);
var BlockTypeSelect = () => {
  const convertSelectionToNode = A(convertSelectionToNode$);
  const currentBlockType = E(currentBlockType$);
  const activePlugins = E(activePlugins$);
  const hasQuote = activePlugins.includes("quote");
  const hasHeadings = activePlugins.includes("headings");
  const t3 = useTranslation();
  if (!hasQuote && !hasHeadings) {
    return null;
  }
  const items = [
    { label: t3("toolbar.blockTypes.paragraph", "Paragraph"), value: "paragraph" }
  ];
  if (hasQuote) {
    items.push({ label: t3("toolbar.blockTypes.quote", "Quote"), value: "quote" });
  }
  if (hasHeadings) {
    const allowedHeadingLevels = E(allowedHeadingLevels$);
    items.push(
      ...allowedHeadingLevels.map(
        (n3) => ({ label: t3("toolbar.blockTypes.heading", "Heading {{level}}", { level: n3 }), value: `h${n3}` })
      )
    );
  }
  return import_react65.default.createElement(
    Select2,
    {
      value: currentBlockType,
      onChange: (blockType) => {
        switch (blockType) {
          case "quote":
            convertSelectionToNode(() => $createQuoteNode());
            break;
          case "paragraph":
            convertSelectionToNode(() => $createParagraphNode());
            break;
          case "":
            break;
          default:
            if (blockType.startsWith("h")) {
              convertSelectionToNode(() => $createHeadingNode(blockType));
            } else {
              throw new Error(`Unknown block type: ${blockType}`);
            }
        }
      },
      triggerTitle: t3("toolbar.blockTypeSelect.selectBlockTypeTooltip", "Select block type"),
      placeholder: t3("toolbar.blockTypeSelect.placeholder", "Block type"),
      items
    }
  );
};

// node_modules/@mdxeditor/editor/dist/plugins/toolbar/components/BoldItalicUnderlineToggles.js
var import_react66 = __toESM(require_react(), 1);
var FormatButton = ({ format, addTitle, removeTitle, icon, formatName }) => {
  const [currentFormat, iconComponentFor] = X(currentFormat$, iconComponentFor$);
  const applyFormat = A(applyFormat$);
  const active = (currentFormat & format) !== 0;
  return import_react66.default.createElement(
    ToggleSingleGroupWithItem,
    {
      title: active ? removeTitle : addTitle,
      on: active,
      onValueChange: () => {
        applyFormat(formatName);
      }
    },
    iconComponentFor(icon)
  );
};
var BoldItalicUnderlineToggles = ({ options }) => {
  const t3 = useTranslation();
  const showAllButtons = typeof options === "undefined";
  return import_react66.default.createElement("div", { className: styles.toolbarGroupOfGroups }, showAllButtons || options.includes("Bold") ? import_react66.default.createElement(
    FormatButton,
    {
      format: IS_BOLD2,
      addTitle: t3("toolbar.bold", "Bold"),
      removeTitle: t3("toolbar.removeBold", "Remove bold"),
      icon: "format_bold",
      formatName: "bold"
    }
  ) : null, showAllButtons || options.includes("Italic") ? import_react66.default.createElement(
    FormatButton,
    {
      format: IS_ITALIC2,
      addTitle: t3("toolbar.italic", "Italic"),
      removeTitle: t3("toolbar.removeItalic", "Remove italic"),
      icon: "format_italic",
      formatName: "italic"
    }
  ) : null, showAllButtons || options.includes("Underline") ? import_react66.default.createElement(
    FormatButton,
    {
      format: IS_UNDERLINE2,
      addTitle: t3("toolbar.underline", "Underline"),
      removeTitle: t3("toolbar.removeUnderline", "Remove underline"),
      icon: "format_underlined",
      formatName: "underline"
    }
  ) : null);
};
var StrikeThroughSupSubToggles = ({ options }) => {
  const t3 = useTranslation();
  const showAllButtons = typeof options === "undefined";
  return import_react66.default.createElement("div", { className: styles.toolbarGroupOfGroups }, showAllButtons || options.includes("Strikethrough") ? import_react66.default.createElement(
    FormatButton,
    {
      format: IS_STRIKETHROUGH2,
      addTitle: t3("toolbar.strikethrough", "Strikethrough"),
      removeTitle: t3("toolbar.removeStrikethrough", "Remove strikethrough"),
      icon: "strikeThrough",
      formatName: "strikethrough"
    }
  ) : null, showAllButtons || options.includes("Sup") ? import_react66.default.createElement(
    FormatButton,
    {
      format: IS_SUPERSCRIPT2,
      addTitle: t3("toolbar.superscript", "Superscript"),
      removeTitle: t3("toolbar.removeSuperscript", "Remove superscript"),
      icon: "superscript",
      formatName: "superscript"
    }
  ) : null, showAllButtons || options.includes("Sub") ? import_react66.default.createElement(
    FormatButton,
    {
      format: IS_SUBSCRIPT2,
      addTitle: t3("toolbar.subscript", "Subscript"),
      removeTitle: t3("toolbar.removeSubscript", "Remove subscript"),
      icon: "subscript",
      formatName: "subscript"
    }
  ) : null);
};

// node_modules/@mdxeditor/editor/dist/plugins/toolbar/components/ChangeAdmonitionType.js
var import_react67 = __toESM(require_react(), 1);
function admonitionLabelsMap(t3) {
  return {
    note: t3("admonitions.note", "Note"),
    tip: t3("admonitions.tip", "Tip"),
    danger: t3("admonitions.danger", "Danger"),
    info: t3("admonitions.info", "Info"),
    caution: t3("admonitions.caution", "Caution")
  };
}
var ChangeAdmonitionType = () => {
  const [editorInFocus, rootEditor] = X(editorInFocus$, rootEditor$);
  const admonitionNode = editorInFocus.rootNode;
  const t3 = useTranslation();
  const labels = admonitionLabelsMap(t3);
  return import_react67.default.createElement(
    Select2,
    {
      value: admonitionNode.getMdastNode().name,
      onChange: (name2) => {
        rootEditor == null ? void 0 : rootEditor.update(() => {
          admonitionNode.setMdastNode({ ...admonitionNode.getMdastNode(), name: name2 });
          setTimeout(() => {
            rootEditor.update(() => {
              admonitionNode.getLatest().select();
            });
          }, 80);
        });
      },
      triggerTitle: t3("admonitions.changeType", "Select admonition type"),
      placeholder: t3("admonitions.placeholder", "Admonition type"),
      items: ADMONITION_TYPES.map((type2) => ({ label: labels[type2], value: type2 }))
    }
  );
};

// node_modules/@mdxeditor/editor/dist/plugins/toolbar/components/ChangeCodeMirrorLanguage.js
var import_react68 = __toESM(require_react(), 1);
var EMPTY_VALUE2 = "__EMPTY_VALUE__";
var ChangeCodeMirrorLanguage = () => {
  const [editorInFocus, theEditor, codeBlockLanguages] = X(editorInFocus$, activeEditor$, codeBlockLanguages$);
  const codeBlockNode = editorInFocus.rootNode;
  const t3 = useTranslation();
  let currentLanguage = codeBlockNode.getLanguage();
  if (currentLanguage === "") {
    currentLanguage = EMPTY_VALUE2;
  }
  return import_react68.default.createElement("div", { className: styles.selectWithLabel }, import_react68.default.createElement("label", null, t3("codeBlock.language", "Code block language")), import_react68.default.createElement(
    Select2,
    {
      value: currentLanguage,
      onChange: (language2) => {
        theEditor == null ? void 0 : theEditor.update(() => {
          codeBlockNode.setLanguage(language2 === EMPTY_VALUE2 ? "" : language2);
          setTimeout(() => {
            theEditor.update(() => {
              codeBlockNode.getLatest().select();
            });
          });
        });
      },
      triggerTitle: t3("codeBlock.selectLanguage", "Select code block language"),
      placeholder: t3("codeBlock.language", "Code block language"),
      items: Object.entries(codeBlockLanguages).map(([value2, label4]) => ({ value: value2 ? value2 : EMPTY_VALUE2, label: label4 }))
    }
  ));
};

// node_modules/@mdxeditor/editor/dist/plugins/toolbar/components/CodeToggle.js
var import_react69 = __toESM(require_react(), 1);
var CodeToggle = () => {
  const [currentFormat, iconComponentFor] = X(currentFormat$, iconComponentFor$);
  const applyFormat = A(applyFormat$);
  const t3 = useTranslation();
  const codeIsOn = (currentFormat & IS_CODE2) !== 0;
  const title = codeIsOn ? t3("toolbar.removeInlineCode", "Remove code format") : t3("toolbar.inlineCode", "Inline code format");
  return import_react69.default.createElement(
    MultipleChoiceToggleGroup,
    {
      items: [{ title, contents: iconComponentFor("code"), active: codeIsOn, onChange: applyFormat.bind(null, "code") }]
    }
  );
};

// node_modules/@mdxeditor/editor/dist/plugins/toolbar/components/CreateLink.js
var import_react70 = __toESM(require_react(), 1);
var CreateLink = () => {
  const openLinkDialog = A(openLinkEditDialog$);
  const iconComponentFor = E(iconComponentFor$);
  const t3 = useTranslation();
  return import_react70.default.createElement(
    ButtonWithTooltip,
    {
      "aria-label": t3("toolbar.link", "Create link"),
      title: t3("toolbar.link", "Create link"),
      onClick: (_2) => {
        openLinkDialog();
      }
    },
    iconComponentFor("link")
  );
};

// node_modules/@mdxeditor/editor/dist/plugins/toolbar/components/DiffSourceToggleWrapper.js
var import_react71 = __toESM(require_react(), 1);
var DiffSourceToggleWrapper = ({
  children,
  options = ["rich-text", "diff", "source"]
}) => {
  const [viewMode, iconComponentFor] = X(viewMode$, iconComponentFor$);
  const changeViewMode = A(viewMode$);
  const t3 = useTranslation();
  const toggleGroupItems = [];
  if (options.includes("rich-text")) {
    toggleGroupItems.push({ title: t3("toolbar.richText", "Rich text"), contents: iconComponentFor("rich_text"), value: "rich-text" });
  }
  if (options.includes("diff")) {
    toggleGroupItems.push({ title: t3("toolbar.diffMode", "Diff mode"), contents: iconComponentFor("difference"), value: "diff" });
  }
  if (options.includes("source")) {
    toggleGroupItems.push({ title: t3("toolbar.source", "Source mode"), contents: iconComponentFor("markdown"), value: "source" });
  }
  return import_react71.default.createElement(import_react71.default.Fragment, null, viewMode === "rich-text" ? children : viewMode === "diff" ? import_react71.default.createElement("span", { className: styles.toolbarTitleMode }, t3("toolbar.diffMode", "Diff mode")) : import_react71.default.createElement("span", { className: styles.toolbarTitleMode }, t3("toolbar.source", "Source mode")), import_react71.default.createElement("div", { style: { marginLeft: "auto", pointerEvents: "auto", opacity: 1 } }, import_react71.default.createElement(
    SingleChoiceToggleGroup,
    {
      className: styles.diffSourceToggle,
      value: viewMode,
      items: toggleGroupItems,
      onChange: (value2) => {
        changeViewMode(value2 === "" ? "rich-text" : value2);
      }
    }
  )));
};

// node_modules/@mdxeditor/editor/dist/plugins/toolbar/components/InsertAdmonition.js
var import_react72 = __toESM(require_react(), 1);
var InsertAdmonition = () => {
  const insertDirective = A(insertDirective$);
  const iconComponentFor = E(iconComponentFor$);
  const t3 = useTranslation();
  const items = import_react72.default.useMemo(() => {
    const labels = admonitionLabelsMap(t3);
    return ADMONITION_TYPES.map((type2) => ({ value: type2, label: labels[type2] }));
  }, [t3]);
  return import_react72.default.createElement(
    ButtonOrDropdownButton,
    {
      title: t3("toolbar.admonition", "Insert Admonition"),
      onChoose: (admonitionName) => {
        insertDirective({
          type: "containerDirective",
          name: admonitionName
        });
      },
      items
    },
    iconComponentFor("admonition")
  );
};

// node_modules/@mdxeditor/editor/dist/plugins/toolbar/components/InsertCodeBlock.js
var import_react73 = __toESM(require_react(), 1);
var InsertCodeBlock = () => {
  const insertCodeBlock = A(insertCodeBlock$);
  const iconComponentFor = E(iconComponentFor$);
  const t3 = useTranslation();
  return import_react73.default.createElement(
    ButtonWithTooltip,
    {
      title: t3("toolbar.codeBlock", "Insert Code Block"),
      onClick: () => {
        insertCodeBlock({});
      }
    },
    iconComponentFor("frame_source")
  );
};

// node_modules/@mdxeditor/editor/dist/plugins/toolbar/components/InsertFrontmatter.js
var import_react74 = __toESM(require_react(), 1);
var import_classnames12 = __toESM(require_classnames(), 1);
var InsertFrontmatter = () => {
  const insertFrontmatter = A(insertFrontmatter$);
  const [hasFrontmatter, iconComponentFor] = X(hasFrontmatter$, iconComponentFor$);
  const t3 = useTranslation();
  return import_react74.default.createElement(
    ButtonWithTooltip,
    {
      title: hasFrontmatter ? t3("toolbar.editFrontmatter", "Edit frontmatter") : t3("toolbar.insertFrontmatter", "Insert frontmatter"),
      className: (0, import_classnames12.default)({
        [styles.activeToolbarButton]: hasFrontmatter
      }),
      onClick: () => {
        insertFrontmatter();
      }
    },
    iconComponentFor("frontmatter")
  );
};

// node_modules/@mdxeditor/editor/dist/plugins/toolbar/components/InsertImage.js
var import_react75 = __toESM(require_react(), 1);
var InsertImage = import_react75.default.forwardRef((_2, forwardedRef) => {
  const openNewImageDialog = A(openNewImageDialog$);
  const [readOnly, iconComponentFor] = X(readOnly$, iconComponentFor$);
  const t3 = useTranslation();
  return import_react75.default.createElement(
    Button,
    {
      className: styles.toolbarButton,
      ref: forwardedRef,
      disabled: readOnly,
      onClick: () => {
        openNewImageDialog();
      }
    },
    import_react75.default.createElement(TooltipWrap, { title: t3("toolbar.image", "Insert image") }, iconComponentFor("add_photo"))
  );
});

// node_modules/@mdxeditor/editor/dist/plugins/toolbar/components/InsertSandpack.js
var import_react76 = __toESM(require_react(), 1);
var InsertSandpack = () => {
  const [sandpackConfig, iconComponentFor] = X(sandpackConfig$, iconComponentFor$);
  const insertSandpack = A(insertSandpack$);
  const items = import_react76.default.useMemo(() => sandpackConfig.presets.map((preset) => ({ value: preset.name, label: preset.label })), [sandpackConfig]);
  const t3 = useTranslation();
  return import_react76.default.createElement(ButtonOrDropdownButton, { title: t3("toolbar.insertSandpack", "Insert Sandpack"), onChoose: insertSandpack, items }, iconComponentFor("sandpack"));
};

// node_modules/@mdxeditor/editor/dist/plugins/toolbar/components/InsertTable.js
var import_react77 = __toESM(require_react(), 1);
var disableInsertTableButton$ = $(false, (r2) => {
  r2.link(
    r2.pipe(
      activeEditor$,
      _((editor) => {
        var _a2, _b2;
        return ["td", "th"].includes(((_b2 = (_a2 = editor == null ? void 0 : editor.getRootElement()) == null ? void 0 : _a2.parentNode) == null ? void 0 : _b2.nodeName.toLowerCase()) ?? "");
      })
    ),
    disableInsertTableButton$
  );
});
var InsertTable = () => {
  const iconComponentFor = E(iconComponentFor$);
  const insertTable = A(insertTable$);
  const t3 = useTranslation();
  const isDisabled = E(disableInsertTableButton$);
  return import_react77.default.createElement(
    ButtonWithTooltip,
    {
      title: t3("toolbar.table", "Insert Table"),
      onClick: () => {
        insertTable({ rows: 3, columns: 3 });
      },
      ...isDisabled ? { "aria-disabled": true, "data-disabled": true, disabled: true } : {}
    },
    iconComponentFor("table")
  );
};

// node_modules/@mdxeditor/editor/dist/plugins/toolbar/components/InsertThematicBreak.js
var import_react78 = __toESM(require_react(), 1);
var InsertThematicBreak = () => {
  const insertThematicBreak = A(insertThematicBreak$);
  const iconComponentFor = E(iconComponentFor$);
  const t3 = useTranslation();
  return import_react78.default.createElement(
    ButtonWithTooltip,
    {
      title: t3("toolbar.thematicBreak", "Insert thematic break"),
      onClick: () => {
        insertThematicBreak();
      }
    },
    iconComponentFor("horizontal_rule")
  );
};

// node_modules/@mdxeditor/editor/dist/plugins/toolbar/components/ListsToggle.js
var import_react79 = __toESM(require_react(), 1);
var ICON_NAME_MAP = {
  bullet: "format_list_bulleted",
  number: "format_list_numbered",
  check: "format_list_checked"
};
var ListsToggle = ({ options = ["bullet", "number", "check"] }) => {
  const [currentListType, iconComponentFor] = X(currentListType$, iconComponentFor$);
  const applyListType = A(applyListType$);
  const t3 = useTranslation();
  const LIST_TITLE_MAP = {
    bullet: t3("toolbar.bulletedList", "Bulleted list"),
    number: t3("toolbar.numberedList", "Numbered list"),
    check: t3("toolbar.checkList", "Check list")
  };
  const items = options.map((type2) => ({
    value: type2,
    title: LIST_TITLE_MAP[type2],
    contents: iconComponentFor(ICON_NAME_MAP[type2])
  }));
  return import_react79.default.createElement(SingleChoiceToggleGroup, { value: currentListType || "", items, onChange: applyListType });
};

// node_modules/@mdxeditor/editor/dist/plugins/toolbar/components/ShowSandpackInfo.js
var import_react80 = __toESM(require_react(), 1);
var ShowSandpackInfo = () => {
  const [editorInFocus, theEditor, iconComponentFor, sandpackConfig] = X(
    editorInFocus$,
    activeEditor$,
    iconComponentFor$,
    sandpackConfig$
  );
  const sandpackNode = editorInFocus.rootNode;
  const t3 = useTranslation();
  const preset = sandpackConfig.presets.find((preset2) => preset2.meta === sandpackNode.getMeta());
  return import_react80.default.createElement("div", { className: styles.selectWithLabel }, import_react80.default.createElement(
    ButtonWithTooltip,
    {
      title: t3("toolbar.deleteSandpack", "Delete this code block"),
      onClick: () => {
        theEditor == null ? void 0 : theEditor.update(() => {
          if (sandpackNode.getNextSibling()) {
            sandpackNode.selectNext();
          } else {
            sandpackNode.selectPrevious();
          }
          sandpackNode.remove();
        });
      }
    },
    iconComponentFor("delete_big")
  ), import_react80.default.createElement("label", null, "Sandpack preset: ", preset.name));
};

// node_modules/@mdxeditor/editor/dist/plugins/toolbar/components/UndoRedo.js
var import_react81 = __toESM(require_react(), 1);
var UndoRedo = () => {
  const [iconComponentFor, activeEditor2] = X(iconComponentFor$, activeEditor$);
  const [canUndo, setCanUndo] = import_react81.default.useState(false);
  const [canRedo, setCanRedo] = import_react81.default.useState(false);
  const t3 = useTranslation();
  import_react81.default.useEffect(() => {
    if (activeEditor2) {
      return mergeRegister(
        activeEditor2.registerCommand(
          CAN_UNDO_COMMAND,
          (payload) => {
            setCanUndo(payload);
            return false;
          },
          COMMAND_PRIORITY_CRITICAL
        ),
        activeEditor2.registerCommand(
          CAN_REDO_COMMAND,
          (payload) => {
            setCanRedo(payload);
            return false;
          },
          COMMAND_PRIORITY_CRITICAL
        )
      );
    }
  }, [activeEditor2]);
  return import_react81.default.createElement(
    MultipleChoiceToggleGroup,
    {
      items: [
        {
          title: t3("toolbar.undo", "Undo {{shortcut}}", { shortcut: IS_APPLE2 ? "⌘Z" : "Ctrl+Z" }),
          disabled: !canUndo,
          contents: iconComponentFor("undo"),
          active: false,
          onChange: () => activeEditor2 == null ? void 0 : activeEditor2.dispatchCommand(UNDO_COMMAND, void 0)
        },
        {
          title: t3("toolbar.redo", "Redo {{shortcut}}", { shortcut: IS_APPLE2 ? "⌘Y" : "Ctrl+Y" }),
          disabled: !canRedo,
          contents: iconComponentFor("redo"),
          active: false,
          onChange: () => activeEditor2 == null ? void 0 : activeEditor2.dispatchCommand(REDO_COMMAND, void 0)
        }
      ]
    }
  );
};

// node_modules/@mdxeditor/editor/dist/plugins/toolbar/components/KitchenSinkToolbar.js
var import_react82 = __toESM(require_react(), 1);
function whenInAdmonition(editorInFocus) {
  const node2 = editorInFocus == null ? void 0 : editorInFocus.rootNode;
  if (!node2 || node2.getType() !== "directive") {
    return false;
  }
  return ["note", "tip", "danger", "info", "caution"].includes(node2.getMdastNode().name);
}
var KitchenSinkToolbar = () => {
  return import_react82.default.createElement(DiffSourceToggleWrapper, null, import_react82.default.createElement(
    ConditionalContents,
    {
      options: [
        { when: (editor) => (editor == null ? void 0 : editor.editorType) === "codeblock", contents: () => import_react82.default.createElement(ChangeCodeMirrorLanguage, null) },
        { when: (editor) => (editor == null ? void 0 : editor.editorType) === "sandpack", contents: () => import_react82.default.createElement(ShowSandpackInfo, null) },
        {
          fallback: () => import_react82.default.createElement(import_react82.default.Fragment, null, import_react82.default.createElement(UndoRedo, null), import_react82.default.createElement(Separator4, null), import_react82.default.createElement(BoldItalicUnderlineToggles, null), import_react82.default.createElement(CodeToggle, null), import_react82.default.createElement(Separator4, null), import_react82.default.createElement(StrikeThroughSupSubToggles, null), import_react82.default.createElement(Separator4, null), import_react82.default.createElement(ListsToggle, null), import_react82.default.createElement(Separator4, null), import_react82.default.createElement(
            ConditionalContents,
            {
              options: [{ when: whenInAdmonition, contents: () => import_react82.default.createElement(ChangeAdmonitionType, null) }, { fallback: () => import_react82.default.createElement(BlockTypeSelect, null) }]
            }
          ), import_react82.default.createElement(Separator4, null), import_react82.default.createElement(CreateLink, null), import_react82.default.createElement(InsertImage, null), import_react82.default.createElement(Separator4, null), import_react82.default.createElement(InsertTable, null), import_react82.default.createElement(InsertThematicBreak, null), import_react82.default.createElement(Separator4, null), import_react82.default.createElement(InsertCodeBlock, null), import_react82.default.createElement(InsertSandpack, null), import_react82.default.createElement(
            ConditionalContents,
            {
              options: [
                {
                  when: (editorInFocus) => !whenInAdmonition(editorInFocus),
                  contents: () => import_react82.default.createElement(import_react82.default.Fragment, null, import_react82.default.createElement(Separator4, null), import_react82.default.createElement(InsertAdmonition, null))
                }
              ]
            }
          ), import_react82.default.createElement(Separator4, null), import_react82.default.createElement(InsertFrontmatter, null))
        }
      ]
    }
  ));
};

// node_modules/@mdxeditor/editor/dist/plugins/toolbar/primitives/DialogButton.js
var import_react83 = __toESM(require_react(), 1);
var import_classnames13 = __toESM(require_classnames(), 1);
var MAX_SUGGESTIONS2 = 20;
var DialogButton = import_react83.default.forwardRef(({ autocompleteSuggestions = [], submitButtonTitle, dialogInputPlaceholder, onSubmit, tooltipTitle, buttonContent }, forwardedRef) => {
  const [editorRootElementRef, readOnly] = X(editorRootElementRef$, readOnly$);
  const [open, setOpen] = import_react83.default.useState(false);
  const onSubmitCallback = import_react83.default.useCallback(
    (value2) => {
      onSubmit(value2);
      setOpen(false);
    },
    [onSubmit]
  );
  return import_react83.default.createElement(Root5, { open, onOpenChange: setOpen }, import_react83.default.createElement(Trigger2, { asChild: true }, import_react83.default.createElement(Button, { className: styles.toolbarButton, ref: forwardedRef, disabled: readOnly }, import_react83.default.createElement(TooltipWrap, { title: tooltipTitle }, buttonContent))), import_react83.default.createElement(Portal3, { container: editorRootElementRef == null ? void 0 : editorRootElementRef.current }, import_react83.default.createElement(Overlay, { className: styles.dialogOverlay }), import_react83.default.createElement(Content3, { className: styles.dialogContent }, import_react83.default.createElement(
    DialogForm,
    {
      submitButtonTitle,
      autocompleteSuggestions,
      onSubmitCallback,
      dialogInputPlaceholder
    }
  ))));
});
var DialogForm = ({ autocompleteSuggestions, onSubmitCallback, dialogInputPlaceholder, submitButtonTitle }) => {
  const [items, setItems] = import_react83.default.useState(autocompleteSuggestions.slice(0, MAX_SUGGESTIONS2));
  const iconComponentFor = E(iconComponentFor$);
  const enableAutoComplete = autocompleteSuggestions.length > 0;
  const { isOpen, getToggleButtonProps, getMenuProps, getInputProps, highlightedIndex, getItemProps, selectedItem } = useCombobox({
    initialInputValue: "",
    onInputValueChange({ inputValue }) {
      inputValue = (inputValue == null ? void 0 : inputValue.toLowerCase()) ?? "";
      const matchingItems = [];
      for (const suggestion of autocompleteSuggestions) {
        if (suggestion.toLowerCase().includes(inputValue)) {
          matchingItems.push(suggestion);
          if (matchingItems.length >= MAX_SUGGESTIONS2) {
            break;
          }
        }
      }
      setItems(matchingItems);
    },
    items,
    itemToString(item) {
      return item ?? "";
    }
  });
  const onKeyDownEH = import_react83.default.useCallback(
    (e2) => {
      var _a2;
      if (e2.key === "Escape") {
        (_a2 = e2.target.form) == null ? void 0 : _a2.reset();
      } else if (e2.key === "Enter" && (!isOpen || items.length === 0)) {
        e2.preventDefault();
        onSubmitCallback(e2.target.value);
      }
    },
    [isOpen, items, onSubmitCallback]
  );
  const downshiftInputProps = getInputProps();
  const inputProps = {
    ...downshiftInputProps,
    onKeyDown: (e2) => {
      onKeyDownEH(e2);
      downshiftInputProps.onKeyDown(e2);
    }
  };
  const onSubmitEH = (e2) => {
    e2.preventDefault();
    e2.stopPropagation();
    onSubmitCallback(inputProps.value);
  };
  const dropdownIsVisible = isOpen && items.length > 0;
  return import_react83.default.createElement("form", { onSubmit: onSubmitEH, className: (0, import_classnames13.default)(styles.dialogForm) }, import_react83.default.createElement("div", { className: styles.linkDialogInputContainer }, import_react83.default.createElement("div", { "data-visible-dropdown": dropdownIsVisible, className: styles.linkDialogInputWrapper }, import_react83.default.createElement(
    "input",
    {
      placeholder: dialogInputPlaceholder,
      className: styles.linkDialogInput,
      ...inputProps,
      autoFocus: true,
      size: 30,
      "data-editor-dialog": true
    }
  ), enableAutoComplete && import_react83.default.createElement("button", { "aria-label": "toggle menu", type: "button", ...getToggleButtonProps() }, iconComponentFor("arrow_drop_down"))), import_react83.default.createElement("div", { className: styles.downshiftAutocompleteContainer }, import_react83.default.createElement("ul", { ...getMenuProps(), "data-visible": dropdownIsVisible }, items.map((item, index3) => import_react83.default.createElement(
    "li",
    {
      "data-selected": selectedItem === item,
      "data-highlighted": highlightedIndex === index3,
      key: `${item}${index3}`,
      ...getItemProps({ item, index: index3 })
    },
    item
  ))))), import_react83.default.createElement(
    "button",
    {
      type: "submit",
      title: submitButtonTitle,
      "aria-label": submitButtonTitle,
      className: (0, import_classnames13.default)(styles.actionButton, styles.primaryActionButton)
    },
    iconComponentFor("check")
  ), import_react83.default.createElement(Close, { className: styles.actionButton }, iconComponentFor("close")));
};

// node_modules/@mdxeditor/editor/dist/utils/makeHslTransparent.js
function makeHslTransparent(hsl, alpha) {
  return hsl.replace("hsl", "hsla").replace(")", `, ${alpha})`);
}
export {
  $createCodeBlockNode,
  $createDirectiveNode,
  $createFrontmatterNode,
  $createGenericHTMLNode,
  $createImageNode,
  $createTableNode,
  $isCodeBlockNode,
  $isDirectiveNode,
  $isFrontmatterNode,
  $isGenericHTMLNode,
  $isImageNode,
  $isTableNode,
  ADMONITION_TYPES,
  ALL_HEADING_LEVELS,
  q as Action,
  AdmonitionDirectiveDescriptor,
  Appender,
  BlockTypeSelect,
  BoldItalicUnderlineToggles,
  Button2 as Button,
  ButtonOrDropdownButton,
  ButtonWithTooltip,
  CAN_USE_DOM7 as CAN_USE_DOM,
  COMMON_STATE_CONFIG_EXTENSIONS,
  $ as Cell,
  ChangeAdmonitionType,
  ChangeCodeMirrorLanguage,
  CodeBlockNode,
  CodeMirrorEditor,
  CodeToggle,
  ConditionalContents,
  CreateLink,
  DEFAULT_FORMAT,
  D as DerivedCell,
  DialogButton,
  DiffSourceToggleWrapper,
  DirectiveNode,
  FrontmatterNode,
  GenericDirectiveEditor,
  GenericHTMLNode,
  GenericJsxEditor,
  INSERT_IMAGE_COMMAND,
  IS_APPLE2 as IS_APPLE,
  IS_BOLD2 as IS_BOLD,
  IS_CODE2 as IS_CODE,
  IS_HIGHLIGHT2 as IS_HIGHLIGHT,
  IS_ITALIC2 as IS_ITALIC,
  IS_STRIKETHROUGH2 as IS_STRIKETHROUGH,
  IS_SUBSCRIPT2 as IS_SUBSCRIPT,
  IS_SUPERSCRIPT2 as IS_SUPERSCRIPT,
  IS_UNDERLINE2 as IS_UNDERLINE,
  ImageNode,
  InsertAdmonition,
  InsertCodeBlock,
  InsertFrontmatter,
  InsertImage,
  InsertSandpack,
  InsertTable,
  InsertThematicBreak,
  KitchenSinkToolbar,
  ListsToggle,
  MDXEditor,
  MarkdownParseError,
  MultipleChoiceToggleGroup,
  NESTED_EDITOR_UPDATED_COMMAND,
  NestedEditorsContext,
  NestedLexicalEditor,
  PropertyPopover,
  T as Realm,
  V as RealmContext,
  U as RealmProvider,
  RealmWithPlugins,
  Root7 as Root,
  Select2 as Select,
  SelectButtonTrigger,
  SelectContent2 as SelectContent,
  SelectItem2 as SelectItem,
  SelectTrigger2 as SelectTrigger,
  Separator4 as Separator,
  ShowSandpackInfo,
  K as Signal,
  SingleChoiceToggleGroup,
  SingleToggleGroup,
  StrikeThroughSupSubToggles,
  TYPE_NAME,
  TableNode,
  ToggleSingleGroupWithItem,
  ToolbarToggleItem2 as ToolbarToggleItem,
  TooltipWrap,
  UndoRedo,
  UnrecognizedMarkdownConstructError,
  activeEditor$,
  activeEditorSubscriptions$,
  activePlugins$,
  addActivePlugin$,
  addComposerChild$,
  addEditorWrapper$,
  addExportVisitor$,
  addImportVisitor$,
  addLexicalNode$,
  addMdastExtension$,
  addNestedEditorChild$,
  addSyntaxExtension$,
  addToMarkdownExtension$,
  addTopAreaChild$,
  admonitionLabelsMap,
  allowedHeadingLevels$,
  always,
  appendCodeBlockEditorDescriptor$,
  applyBlockType$,
  applyFormat$,
  applyLinkChanges$,
  applyListType$,
  autoFocus$,
  call,
  cancelLinkEdit$,
  H as changeWith,
  closeImageDialog$,
  cmExtensions$,
  codeBlockEditorDescriptors$,
  codeBlockLanguages$,
  codeBlockPlugin,
  codeMirrorAutoLoadLanguageSupport$,
  codeMirrorExtensions$,
  codeMirrorPlugin,
  J as combine,
  compose,
  composerChildren$,
  contentEditableClassName$,
  contentEditableRef$,
  controlOrMeta2 as controlOrMeta,
  convertSelectionToNode$,
  corePlugin,
  createActiveEditorSubscription$,
  createRootEditorSubscription$,
  currentBlockType$,
  currentFormat$,
  currentListType$,
  currentSelection$,
  curry1to0,
  curry2to1,
  ot as debounceTime,
  defaultCodeBlockLanguage$,
  O as defaultComparator,
  defaultSvgIcons,
  ct as delayWithMicrotask,
  diffMarkdown$,
  diffSourcePlugin,
  directiveDescriptors$,
  directivesPlugin,
  disableAutoLink$,
  disableImageResize$,
  disableImageSettingsButton$,
  editorInFocus$,
  editorRootElementRef$,
  editorWrappers$,
  exportLexicalTreeToMdast,
  exportMarkdownFromLexical,
  exportVisitors$,
  nt as filter,
  fromWithinEditorRead,
  frontmatterDialogOpen$,
  frontmatterPlugin,
  getSelectedNode,
  getSelectionRectangle,
  getStateAsMarkdown,
  Q as getValue,
  at as handlePromise,
  hasFrontmatter$,
  headingsPlugin,
  historyState$,
  htmlTags,
  iconComponentFor$,
  imageAutocompleteSuggestions$,
  imageDialogState$,
  imagePlugin,
  imagePreviewHandler$,
  imageUploadHandler$,
  importMarkdownToLexical,
  importMdastTreeToLexical,
  importVisitors$,
  inFocus$,
  initialMarkdown$,
  insertCodeBlock$,
  insertCodeMirror$,
  insertDecoratorNode$,
  insertDirective$,
  insertFrontmatter$,
  insertImage$,
  insertJsx$,
  insertMarkdown$,
  insertSandpack$,
  insertTable$,
  insertThematicBreak$,
  isMdastHTMLNode,
  isMdastJsxNode,
  isPartOftheEditorUI,
  joinProc,
  jsxComponentDescriptors$,
  jsxIsAvailable$,
  jsxPlugin,
  lexicalTheme,
  lexicalTheme$,
  F as link,
  linkAutocompleteSuggestions$,
  linkDialogPlugin,
  linkDialogState$,
  linkPlugin,
  listsPlugin,
  makeHslTransparent,
  _ as map,
  et as mapTo,
  markdown$,
  markdownErrorSignal$,
  markdownProcessingError$,
  markdownShortcutPlugin,
  markdownSourceEditorValue$,
  maxLengthPlugin,
  mdastExtensions$,
  muteChange$,
  nestedEditorChildren$,
  noop,
  onBlur$,
  onClickLinkCallback$,
  ut as onNext,
  onWindowChange$,
  st as once,
  openEditImageDialog$,
  openLinkEditDialog$,
  openNewImageDialog$,
  G as pipe,
  placeholder$,
  prop,
  Y as pub,
  B as pubIn,
  quotePlugin,
  readOnly$,
  readOnlyDiff$,
  realmPlugin,
  removeFrontmatter$,
  removeLink$,
  rootEditor$,
  rootEditorSubscriptions$,
  sandpackConfig$,
  sandpackPlugin,
  saveImage$,
  it as scan,
  setMarkdown$,
  spellCheck$,
  z as sub,
  switchFromPreviewToLinkEdit$,
  syntaxExtensions$,
  tablePlugin,
  tap,
  thematicBreakPlugin,
  rt as throttleTime,
  thrush,
  toMarkdownExtensions$,
  toMarkdownOptions$,
  toolbarClassName$,
  toolbarContents$,
  toolbarPlugin,
  topAreaChildren$,
  translation$,
  updateLink$,
  Z as useCell,
  E as useCellValue,
  X as useCellValues,
  useCodeBlockEditorContext,
  useLexicalNodeRemove,
  useMdastNodeUpdater,
  useNestedEditorContext,
  A as usePublisher,
  R as useRealm,
  useTranslation,
  usedLexicalNodes$,
  uuidv4,
  viewMode$,
  voidEmitter,
  tt as withLatestFrom
};
/*! Bundled license information:

react/cjs/react-jsx-runtime.development.js:
  (**
   * @license React
   * react-jsx-runtime.development.js
   *
   * Copyright (c) Facebook, Inc. and its affiliates.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   *)

classnames/index.js:
  (*!
  	Copyright (c) 2018 Jed Watson.
  	Licensed under the MIT License (MIT), see
  	http://jedwatson.github.io/classnames
  *)

react-is/cjs/react-is.development.js:
  (** @license React v16.13.1
   * react-is.development.js
   *
   * Copyright (c) Facebook, Inc. and its affiliates.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   *)

object-assign/index.js:
  (*
  object-assign
  (c) Sindre Sorhus
  @license MIT
  *)

react-is/cjs/react-is.development.js:
  (** @license React v17.0.2
   * react-is.development.js
   *
   * Copyright (c) Facebook, Inc. and its affiliates.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   *)

prismjs/prism.js:
  (**
   * Prism: Lightweight, robust, elegant syntax highlighting
   *
   * @license MIT <https://opensource.org/licenses/MIT>
   * @author Lea Verou <https://lea.verou.me>
   * @namespace
   * @public
   *)

js-yaml/dist/js-yaml.mjs:
  (*! js-yaml 4.1.0 https://github.com/nodeca/js-yaml @license MIT *)
*/
//# sourceMappingURL=@mdxeditor_editor.js.map
